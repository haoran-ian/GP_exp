{"id": "5eb1a5b6-e0ac-409c-a257-52026a748080", "fitness": 0.38482636162009376, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution to balance exploration and exploitation in optimizing black-box functions.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.35.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.17054391383820366, 0.8200389795746772, 0.16842139304002302, 0.12975046621438646, 0.18479281605283826, 0.15270495278301366, 0.09658530001114507, 0.95448506300738, 0.7752016657877099, 0.8553726484723091, 0.8653112181100672, 0.1387615451304114, 0.7952417792404175, 0.7044223824483185, 0.7170942138165082]}}
{"id": "98f69797-4a55-4d43-9913-338e5f6d0856", "fitness": 0.09925721070891465, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution using adaptive inertia weight for enhanced convergence in optimizing black-box functions.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Adaptive inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.04.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.13553858894925108, 0.12167008191030948, 0.2026828864252691, 0.1374330329052642, 0.1336674122676319, 0.1226145150049448, 0.08703469798432584, 0.12613280214460842, 0.09943792403408114, 0.08333333933968523, 0.11099021123998098, 0.12097079898877583, 0.13278696883524976, 0.10365595945511152, 0.09939609981933739]}}
{"id": "2f05aaf1-cd16-482b-9987-949322f84802", "fitness": 0.32426632105219055, "name": "HybridPSO_DE", "description": "Introduce adaptive inertia weight to improve convergence speed in HybridPSO_DE.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            # Adaptive inertia weight\n            w = 0.9 - 0.8 * (self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.49521699871287983, 0.11879361873611194, 0.49604095185420805, 0.12195269847874413, 0.17472297678452298, 0.6456289881274321, 0.7061482399332413, 0.7428597342759307, 0.5509622305982953, 0.08333333933968523, 0.7263249392269786, 0.08143849371195155, 0.14145664357324916, 0.635006985560624, 0.5976406872554891]}}
{"id": "f156d3ed-65b3-43e4-bef1-726ee49d1d20", "fitness": 0.23801726600765064, "name": "HybridPSO_DE", "description": "Introducing adaptive inertia weight to enhance the exploration-exploitation balance in the hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            w = 0.9 - 0.7 * (self.evaluations / self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.12140400356132519, 0.15085004434762694, 0.1270336338602538, 0.13975849413926478, 0.1524253471960001, 0.14767749012501974, 0.46683927537193326, 0.47579540790880026, 0.17263823124251987, 0.08333333933968523, 0.7163488530057563, 0.6362886253329886, 0.7248212443584776, 0.3468863933435373, 0.1304460421453565]}}
{"id": "89572ecd-9213-4341-8731-4feb5e9cb55a", "fitness": 0.24485935656629962, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution with adaptively tuned inertia weight to enhance convergence speed and solution precision.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w_max = 0.9  # Maximum inertia weight\n        w_min = 0.4  # Minimum inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            w = w_max - ((w_max - w_min) * (self.evaluations / self.budget))  # Adaptively tuned inertia weight\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.14036987951502333, 0.3544902135465806, 0.3905051530765068, 0.5780836128892267, 0.3336636181427468, 0.2163096569521249, 0.6397387309054013, 0.3741464242294651, 0.4983582088208217, 0.08333333933968523, 0.12971913356043818, 0.0874488808631333, 0.14994134679277216, 0.126328460415416, 0.6269515774021834]}}
{"id": "b3dcbdad-1957-4e86-9e00-06672bed1bb8", "fitness": 0.19745305907821367, "name": "HybridPSO_DE", "description": "An improved hybrid algorithm with an adaptive inertia weight in PSO combined with Differential Evolution for dynamic exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w_max = 0.9  # Maximum inertia weight\n        w_min = 0.4  # Minimum inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Calculate dynamic inertia weight\n            w = w_max - ((w_max - w_min) * (self.evaluations / self.budget))\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.1284142694948872, 0.3770109925807965, 0.14488420143964176, 0.13170432523567055, 0.13884835942009643, 0.13145731826114915, 0.4707044001263775, 0.13306663660512497, 0.23825781319798678, 0.08336071801584144, 0.6880306634090526, 0.08508632407065275, 0.4043870084148208, 0.19310482805235385, 0.43294442836535496]}}
{"id": "31a640ed-33d2-42ea-a8df-03012f133a89", "fitness": 0.143450976504992, "name": "HybridPSO_DE", "description": "Slightly increased the inertia weight and cognitive component to enhance exploration in the initial stages.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.8  # Inertia weight (changed from 0.7)\n        c1 = 1.6  # Cognitive component (changed from 1.5)\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.16.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.11401246085622962, 0.1479934613627124, 0.17244979089115975, 0.13061814965682705, 0.2925250465587569, 0.15138499087848778, 0.08452439503343212, 0.7971423458055824, 0.10673978613483381, 0.0849343445242553, 0.12740784943791417, 0.12619896699502176, 0.18921557368402464, 0.09805545861587672, 0.0780180147902596]}}
{"id": "bfc2d099-a888-4bac-a528-f0c5badd606b", "fitness": 0.09925721070891465, "name": "HybridPSO_DE", "description": "A hybrid Particle Swarm Optimization combined with Differential Evolution, enhanced with dynamic inertia weight adjustment for better convergence.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.9  # Adjusted dynamic inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n        return self.global_best_position", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.04.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.13553858894925108, 0.12167008191030948, 0.2026828864252691, 0.1374330329052642, 0.1336674122676319, 0.1226145150049448, 0.08703469798432584, 0.12613280214460842, 0.09943792403408114, 0.08333333933968523, 0.11099021123998098, 0.12097079898877583, 0.13278696883524976, 0.10365595945511152, 0.09939609981933739]}}
{"id": "40c24e6c-a639-4569-bd1d-cf42b35d7627", "fitness": 0.6461264237100651, "name": "HybridPSO_DE", "description": "Introducing a decay factor to the inertia weight for better balance between exploration and exploitation over time.", "code": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20  # A reasonable size for the population\n        self.particles = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        self.velocities = np.random.uniform(\n            -1.0, 1.0, (self.population_size, self.dim)\n        )\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.evaluations = 0\n\n    def __call__(self, func):\n        w = 0.7  # Inertia weight\n        c1 = 1.5  # Cognitive component\n        c2 = 1.5  # Social component\n        F = 0.8  # Differential weight\n        CR = 0.9  # Crossover probability\n        decay_rate = 0.99  # New decay rate for inertia weight\n\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                # Evaluate current particle\n                score = func(self.particles[i])\n                self.evaluations += 1\n\n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n            # Update velocities and positions using PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.particles)\n            social_velocity = c2 * r2 * (self.global_best_position - self.particles)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.particles += self.velocities\n\n            # Ensure particles are within bounds\n            self.particles = np.clip(self.particles, self.lower_bound, self.upper_bound)\n\n            # Apply differential evolution-like mutation and crossover\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.particles[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.copy(self.particles[i])\n                \n                # Binomial crossover\n                for j in range(self.dim):\n                    if np.random.rand() < CR:\n                        trial[j] = mutant[j]\n                \n                trial_score = func(trial)\n                self.evaluations += 1\n\n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial\n\n            w *= decay_rate  # Decay the inertia weight\n        return self.global_best_position", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.37.", "error": "", "parent_ids": ["5eb1a5b6-e0ac-409c-a257-52026a748080"], "operator": null, "metadata": {"aucs": [0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.03355977897489326, 0.8402941861369297, 0.8763037290398475, 0.834518574513228, 0.3907375955483815, 0.7847512455289423, 0.9643973461770781, 0.9323157428828519, 0.9579878479912951, 0.829584676772781, 0.9129858454483634, 0.9273058614456796, 0.8507132406858546, 0.9153195389522873, 0.8567879039451668, 0.8807262442581483]}}
