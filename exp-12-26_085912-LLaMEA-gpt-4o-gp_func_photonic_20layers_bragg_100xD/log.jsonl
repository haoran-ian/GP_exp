{"id": "aa521839-c803-44f6-b305-b0c967d53561", "fitness": 0.09399713912916925, "name": "HybridPSOSA", "description": "A novel hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) to effectively explore and exploit the search space for robust black box optimization under strict evaluation budgets.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w = 0.5  # inertia weight\n        self.c1 = 1.5  # cognitive weight\n        self.c2 = 1.5  # social weight\n        self.temperature = 1.0  # initial temperature for SA\n        self.alpha = 0.99  # cooling rate\n        self.best_global_position = None\n        self.best_global_value = float('inf')\n        self.current_evals = 0\n    \n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(\n            low=func.bounds.lb, \n            high=func.bounds.ub, \n            size=(self.population_size, self.dim)\n        )\n        velocities = np.random.uniform(\n            low=-abs(func.bounds.ub - func.bounds.lb), \n            high=abs(func.bounds.ub - func.bounds.lb), \n            size=(self.population_size, self.dim)\n        )\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        while self.current_evals < self.budget:\n            # Evaluate current fitness\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                fitness_value = func(particles[i])\n                self.current_evals += 1\n\n                # Update personal best\n                if fitness_value < personal_best_values[i]:\n                    personal_best_values[i] = fitness_value\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if fitness_value < self.best_global_value:\n                    self.best_global_value = fitness_value\n                    self.best_global_position = particles[i]\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (\n                    self.w * velocities[i]\n                    + self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                    + self.c2 * r2 * (self.best_global_position - particles[i])\n                )\n                particles[i] += velocities[i]\n                # Clipping to remain within bounds\n                particles[i] = np.clip(particles[i], func.bounds.lb, func.bounds.ub)\n\n            # Apply Simulated Annealing perturbation\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_position = particles[i] + np.random.normal(0, self.temperature, self.dim)\n                candidate_position = np.clip(candidate_position, func.bounds.lb, func.bounds.ub)\n                candidate_fitness = func(candidate_position)\n                self.current_evals += 1\n                \n                if candidate_fitness < personal_best_values[i]:\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n                elif np.exp((personal_best_values[i] - candidate_fitness) / self.temperature) > np.random.rand():\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n\n            # Cool down the temperature\n            self.temperature *= self.alpha\n        \n        return self.best_global_position", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.01651.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.11389454307741842, 0.11391633432495185, 0.1139010643485644, 0.07347307682257453, 0.07348081525603267, 0.07347541217890297, 0.0946052404550376, 0.0946185287307818, 0.09460923696825907]}}
{"id": "a542be04-3c35-4dad-bcf2-52394ba86508", "fitness": 0.09400149576683416, "name": "HybridPSOSA", "description": "A refined hybrid metaheuristic integrating dynamic particle inertia and adaptive simulated annealing to enhance convergence in black box optimization under strict evaluation budgets.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w_max = 0.9  # initial inertia weight\n        self.w_min = 0.4  # final inertia weight\n        self.c1 = 1.5  # cognitive weight\n        self.c2 = 1.5  # social weight\n        self.temperature = 1.0  # initial temperature for SA\n        self.alpha = 0.97  # modified cooling rate\n        self.best_global_position = None\n        self.best_global_value = float('inf')\n        self.current_evals = 0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(\n            low=func.bounds.lb, \n            high=func.bounds.ub, \n            size=(self.population_size, self.dim)\n        )\n        velocities = np.random.uniform(\n            low=-abs(func.bounds.ub - func.bounds.lb), \n            high=abs(func.bounds.ub - func.bounds.lb), \n            size=(self.population_size, self.dim)\n        )\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        while self.current_evals < self.budget:\n            # Evaluate current fitness\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                fitness_value = func(particles[i])\n                self.current_evals += 1\n\n                # Update personal best\n                if fitness_value < personal_best_values[i]:\n                    personal_best_values[i] = fitness_value\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if fitness_value < self.best_global_value:\n                    self.best_global_value = fitness_value\n                    self.best_global_position = particles[i]\n\n            # Dynamic inertia weight\n            w = self.w_max - ((self.w_max - self.w_min) * (self.current_evals / self.budget))\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (\n                    w * velocities[i]\n                    + self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                    + self.c2 * r2 * (self.best_global_position - particles[i])\n                )\n                particles[i] += velocities[i]\n                # Clipping to remain within bounds\n                particles[i] = np.clip(particles[i], func.bounds.lb, func.bounds.ub)\n\n            # Apply Simulated Annealing perturbation\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_position = particles[i] + np.random.normal(0, self.temperature, self.dim)\n                candidate_position = np.clip(candidate_position, func.bounds.lb, func.bounds.ub)\n                candidate_fitness = func(candidate_position)\n                self.current_evals += 1\n                \n                if candidate_fitness < personal_best_values[i]:\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n                elif np.exp((personal_best_values[i] - candidate_fitness) / self.temperature) > np.random.rand():\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n\n            # Cool down the temperature\n            self.temperature *= self.alpha\n        \n        return self.best_global_position", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.01651.", "error": "", "parent_ids": ["aa521839-c803-44f6-b305-b0c967d53561"], "operator": null, "metadata": {"aucs": [0.11390548524458188, 0.11390860744428133, 0.11391775715926078, 0.0734769878855207, 0.0734780579486145, 0.07348137385753528, 0.09461193859442696, 0.09461380346636972, 0.09461945030091623]}}
{"id": "35e80deb-ced8-4cf0-b716-94e83c0d4809", "fitness": 0.09399983308160581, "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA by fine-tuning particle updating strategy and cooling schedule for improved convergence.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w_max = 0.9  # initial inertia weight\n        self.w_min = 0.4  # final inertia weight\n        self.c1 = 1.5  # cognitive weight\n        self.c2 = 1.8  # slightly increased social weight\n        self.temperature = 1.0  # initial temperature for SA\n        self.alpha = 0.95  # slightly increased cooling rate\n        self.best_global_position = None\n        self.best_global_value = float('inf')\n        self.current_evals = 0\n\n    def __call__(self, func):\n        # Initialize particles\n        particles = np.random.uniform(\n            low=func.bounds.lb, \n            high=func.bounds.ub, \n            size=(self.population_size, self.dim)\n        )\n        velocities = np.random.uniform(\n            low=-abs(func.bounds.ub - func.bounds.lb), \n            high=abs(func.bounds.ub - func.bounds.lb), \n            size=(self.population_size, self.dim)\n        )\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        while self.current_evals < self.budget:\n            # Evaluate current fitness\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                fitness_value = func(particles[i])\n                self.current_evals += 1\n\n                # Update personal best\n                if fitness_value < personal_best_values[i]:\n                    personal_best_values[i] = fitness_value\n                    personal_best_positions[i] = particles[i]\n\n                # Update global best\n                if fitness_value < self.best_global_value:\n                    self.best_global_value = fitness_value\n                    self.best_global_position = particles[i]\n\n            # Dynamic inertia weight\n            w = self.w_max - ((self.w_max - self.w_min) * (self.current_evals / self.budget))\n\n            # Update velocities and positions using PSO\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (\n                    w * velocities[i]\n                    + self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                    + self.c2 * r2 * (self.best_global_position - particles[i])\n                )\n                particles[i] += velocities[i]\n                # Clipping to remain within bounds\n                particles[i] = np.clip(particles[i], func.bounds.lb, func.bounds.ub)\n\n            # Apply Simulated Annealing perturbation\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_position = particles[i] + np.random.normal(0, self.temperature, self.dim)\n                candidate_position = np.clip(candidate_position, func.bounds.lb, func.bounds.ub)\n                candidate_fitness = func(candidate_position)\n                self.current_evals += 1\n                \n                if candidate_fitness < personal_best_values[i]:\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n                elif np.exp((personal_best_values[i] - candidate_fitness) / self.temperature) > np.random.rand():\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n\n            # Cool down the temperature\n            self.temperature *= self.alpha\n        \n        return self.best_global_position", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.01651.", "error": "", "parent_ids": ["a542be04-3c35-4dad-bcf2-52394ba86508"], "operator": null, "metadata": {"aucs": [0.1139165834498791, 0.11390562858379838, 0.11390203726668369, 0.07348095055433956, 0.07347699474489244, 0.07347576050105997, 0.0946187279413645, 0.09461198157034989, 0.09460983312208482]}}
{"id": "c68bc87c-3351-4104-93cc-573b07972216", "fitness": 0.09399882570103447, "name": "HybridPSOSA", "description": "Enhanced HybridPSOSA with adaptive learning rates and swarm diversity preservation for improved convergence under constrained evaluation budgets.", "code": "import numpy as np\n\nclass HybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w_max = 0.9  # initial inertia weight\n        self.w_min = 0.4  # final inertia weight\n        self.c1_initial = 1.5  # initial cognitive weight\n        self.c2_initial = 1.5  # initial social weight\n        self.c1_final = 0.5    # final cognitive weight\n        self.c2_final = 2.0    # final social weight\n        self.temperature = 1.0  # initial temperature for SA\n        self.alpha = 0.97  # modified cooling rate\n        self.best_global_position = None\n        self.best_global_value = float('inf')\n        self.current_evals = 0\n\n    def __call__(self, func):\n        particles = np.random.uniform(\n            low=func.bounds.lb, \n            high=func.bounds.ub, \n            size=(self.population_size, self.dim)\n        )\n        velocities = np.random.uniform(\n            low=-abs(func.bounds.ub - func.bounds.lb), \n            high=abs(func.bounds.ub - func.bounds.lb), \n            size=(self.population_size, self.dim)\n        )\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                fitness_value = func(particles[i])\n                self.current_evals += 1\n\n                if fitness_value < personal_best_values[i]:\n                    personal_best_values[i] = fitness_value\n                    personal_best_positions[i] = particles[i]\n\n                if fitness_value < self.best_global_value:\n                    self.best_global_value = fitness_value\n                    self.best_global_position = particles[i]\n\n            w = self.w_max - ((self.w_max - self.w_min) * (self.current_evals / self.budget))\n            c1 = self.c1_initial + ((self.c1_final - self.c1_initial) * (self.current_evals / self.budget))\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * (self.current_evals / self.budget))\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (\n                    w * velocities[i]\n                    + c1 * r1 * (personal_best_positions[i] - particles[i])\n                    + c2 * r2 * (self.best_global_position - particles[i])\n                )\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], func.bounds.lb, func.bounds.ub)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                candidate_position = particles[i] + np.random.normal(0, self.temperature, self.dim)\n                candidate_position = np.clip(candidate_position, func.bounds.lb, func.bounds.ub)\n                candidate_fitness = func(candidate_position)\n                self.current_evals += 1\n                \n                if candidate_fitness < personal_best_values[i]:\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n                elif np.exp((personal_best_values[i] - candidate_fitness) / self.temperature) > np.random.rand():\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n\n            self.temperature *= self.alpha\n        \n        return self.best_global_position", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.01651.", "error": "", "parent_ids": ["a542be04-3c35-4dad-bcf2-52394ba86508"], "operator": null, "metadata": {"aucs": [0.11391360240326454, 0.11391493768134897, 0.11389110110014822, 0.07347988767163838, 0.07348031700120705, 0.07347185875918305, 0.09461690584750515, 0.09461767476988803, 0.09460314607512688]}}
{"id": "7f65eff1-4c07-489d-b91b-31352f7f1654", "fitness": 0.09400231670874698, "name": "EnhancedHybridPSOSA", "description": "An enhanced hybrid metaheuristic combining adaptive neighborhood-based perturbation and dynamic convergence acceleration for improved black box optimization performance under limited evaluation budgets.", "code": "import numpy as np\n\nclass EnhancedHybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temperature = 1.0\n        self.alpha = 0.97\n        self.best_global_position = None\n        self.best_global_value = float('inf')\n        self.current_evals = 0\n        self.neighbor_radius = 0.1\n\n    def __call__(self, func):\n        particles = np.random.uniform(\n            low=func.bounds.lb,\n            high=func.bounds.ub,\n            size=(self.population_size, self.dim)\n        )\n        velocities = np.random.uniform(\n            low=-abs(func.bounds.ub - func.bounds.lb),\n            high=abs(func.bounds.ub - func.bounds.lb),\n            size=(self.population_size, self.dim)\n        )\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                fitness_value = func(particles[i])\n                self.current_evals += 1\n\n                if fitness_value < personal_best_values[i]:\n                    personal_best_values[i] = fitness_value\n                    personal_best_positions[i] = particles[i]\n\n                if fitness_value < self.best_global_value:\n                    self.best_global_value = fitness_value\n                    self.best_global_position = particles[i]\n\n            w = self.w_max - ((self.w_max - self.w_min) * (self.current_evals / self.budget))\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (\n                    w * velocities[i]\n                    + self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                    + self.c2 * r2 * (self.best_global_position - particles[i])\n                )\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], func.bounds.lb, func.bounds.ub)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                perturbation = np.random.uniform(-self.neighbor_radius, self.neighbor_radius, self.dim)\n                candidate_position = particles[i] + perturbation * (func.bounds.ub - func.bounds.lb)\n                candidate_position = np.clip(candidate_position, func.bounds.lb, func.bounds.ub)\n                candidate_fitness = func(candidate_position)\n                self.current_evals += 1\n\n                if candidate_fitness < personal_best_values[i]:\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n                elif np.exp((personal_best_values[i] - candidate_fitness) / self.temperature) > np.random.rand():\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n\n            self.temperature *= self.alpha\n            self.neighbor_radius *= 0.99  # shrink neighborhood as optimization progresses\n        \n        return self.best_global_position", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedHybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.01651.", "error": "", "parent_ids": ["a542be04-3c35-4dad-bcf2-52394ba86508"], "operator": null, "metadata": {"aucs": [0.11390703503713984, 0.11391782324313982, 0.11391074286777592, 0.07347754130077422, 0.07348134663378947, 0.07347887259943586, 0.09461288673881652, 0.09461943932301853, 0.0946151626348326]}}
{"id": "26b5456f-ae2c-45ce-8d74-b7e3b78356aa", "fitness": 0.0939984986959961, "name": "EnhancedHybridPSOSA", "description": "A refined hybrid metaheuristic introducing adaptive inertia weight updating and neighborhood search strategy to enhance convergence and exploration in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temperature = 1.0\n        self.alpha = 0.97\n        self.best_global_position = None\n        self.best_global_value = float('inf')\n        self.current_evals = 0\n        self.neighbor_radius = 0.1\n\n    def __call__(self, func):\n        particles = np.random.uniform(\n            low=func.bounds.lb,\n            high=func.bounds.ub,\n            size=(self.population_size, self.dim)\n        )\n        velocities = np.random.uniform(\n            low=-abs(func.bounds.ub - func.bounds.lb),\n            high=abs(func.bounds.ub - func.bounds.lb),\n            size=(self.population_size, self.dim)\n        )\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                fitness_value = func(particles[i])\n                self.current_evals += 1\n\n                if fitness_value < personal_best_values[i]:\n                    personal_best_values[i] = fitness_value\n                    personal_best_positions[i] = particles[i]\n\n                if fitness_value < self.best_global_value:\n                    self.best_global_value = fitness_value\n                    self.best_global_position = particles[i]\n\n            w = self.w_max - ((self.w_max - self.w_min) * (self.current_evals / self.budget)**0.5)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (\n                    w * velocities[i]\n                    + self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                    + self.c2 * r2 * (self.best_global_position - particles[i])\n                )\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], func.bounds.lb, func.bounds.ub)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                perturbation = np.random.uniform(-self.neighbor_radius, self.neighbor_radius, self.dim)\n                candidate_position = particles[i] + perturbation * np.random.rand() * (func.bounds.ub - func.bounds.lb)  # Improved neighborhood search\n                candidate_position = np.clip(candidate_position, func.bounds.lb, func.bounds.ub)\n                candidate_fitness = func(candidate_position)\n                self.current_evals += 1\n\n                if candidate_fitness < personal_best_values[i]:\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n                elif np.exp((personal_best_values[i] - candidate_fitness) / self.temperature) > np.random.rand():\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n\n            self.temperature *= self.alpha\n            self.neighbor_radius *= 0.99  # shrink neighborhood as optimization progresses\n        \n        return self.best_global_position", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedHybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.01651.", "error": "", "parent_ids": ["7f65eff1-4c07-489d-b91b-31352f7f1654"], "operator": null, "metadata": {"aucs": [0.11391592148130869, 0.11391068017818318, 0.11389154652198286, 0.07348071444730242, 0.07347879750917818, 0.07347201661618763, 0.09461832324147001, 0.09461507092792332, 0.09460341734042854]}}
{"id": "10642da7-15ae-4abe-8023-c163682f70ed", "fitness": 0.09400137886227374, "name": "EnhancedHybridPSOSA", "description": "Fine-tune inertia weight adaptation for better balance between exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSOSA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temperature = 1.0\n        self.alpha = 0.97\n        self.best_global_position = None\n        self.best_global_value = float('inf')\n        self.current_evals = 0\n        self.neighbor_radius = 0.1\n\n    def __call__(self, func):\n        particles = np.random.uniform(\n            low=func.bounds.lb,\n            high=func.bounds.ub,\n            size=(self.population_size, self.dim)\n        )\n        velocities = np.random.uniform(\n            low=-abs(func.bounds.ub - func.bounds.lb),\n            high=abs(func.bounds.ub - func.bounds.lb),\n            size=(self.population_size, self.dim)\n        )\n        personal_best_positions = np.copy(particles)\n        personal_best_values = np.full(self.population_size, float('inf'))\n        \n        while self.current_evals < self.budget:\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                fitness_value = func(particles[i])\n                self.current_evals += 1\n\n                if fitness_value < personal_best_values[i]:\n                    personal_best_values[i] = fitness_value\n                    personal_best_positions[i] = particles[i]\n\n                if fitness_value < self.best_global_value:\n                    self.best_global_value = fitness_value\n                    self.best_global_position = particles[i]\n\n            w = self.w_max - ((self.w_max - self.w_min) * ((self.current_evals + 1) / self.budget))  # Adjusted\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                velocities[i] = (\n                    w * velocities[i]\n                    + self.c1 * r1 * (personal_best_positions[i] - particles[i])\n                    + self.c2 * r2 * (self.best_global_position - particles[i])\n                )\n                particles[i] += velocities[i]\n                particles[i] = np.clip(particles[i], func.bounds.lb, func.bounds.ub)\n\n            for i in range(self.population_size):\n                if self.current_evals >= self.budget:\n                    break\n                perturbation = np.random.uniform(-self.neighbor_radius, self.neighbor_radius, self.dim)\n                candidate_position = particles[i] + perturbation * (func.bounds.ub - func.bounds.lb)\n                candidate_position = np.clip(candidate_position, func.bounds.lb, func.bounds.ub)\n                candidate_fitness = func(candidate_position)\n                self.current_evals += 1\n\n                if candidate_fitness < personal_best_values[i]:\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n                elif np.exp((personal_best_values[i] - candidate_fitness) / self.temperature) > np.random.rand():\n                    personal_best_values[i] = candidate_fitness\n                    personal_best_positions[i] = candidate_position\n\n            self.temperature *= self.alpha\n            self.neighbor_radius *= 0.99  # shrink neighborhood as optimization progresses\n        \n        return self.best_global_position", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedHybridPSOSA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09400 with standard deviation 0.01651.", "error": "", "parent_ids": ["7f65eff1-4c07-489d-b91b-31352f7f1654"], "operator": null, "metadata": {"aucs": [0.11391107891766694, 0.11391471663239328, 0.11390551999066578, 0.07347898544301767, 0.07348023781060686, 0.07347700556661807, 0.09461536085360467, 0.09461753926950434, 0.09461196527638605]}}
