{"id": "d1a840a2-233d-433b-b80e-f6f5ee802e92", "fitness": 0.984783098197812, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Stochastic Selection and Re-evaluation to balance exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.98 with standard deviation 0.01 on similar problems with similar landscape features.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.9939955635197274, 0.9883416976124062, 0.9720120334613026]}}
{"id": "b9138888-4a00-48c9-a14a-a9c26f1c5aa0", "fitness": 0.8774103630351896, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced adaptive differential evolution with dynamic mutation factor scaling to improve convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                dynamic_mutation_factor = self.mutation_factor + 0.2 * (1 - evaluations / self.budget)  # Dynamic scaling\n                mutant = np.clip(a + dynamic_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88 with standard deviation 0.09 on similar problems with similar landscape features.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.7522049274366793, 0.936863265542533, 0.9431628961263563]}}
{"id": "53e38d7f-040d-4d2c-837b-2a324437f524", "fitness": 0.7518980062736774, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic mutation factor adjustment for improved exploration-exploitation balance in black-box optimization.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Dynamic mutation factor\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.14 on similar problems with similar landscape features.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.8848901137119858, 0.8133960566684478, 0.5574078484405987]}}
{"id": "3cbbb8c1-984b-4594-afc0-0acf678b09dc", "fitness": 0.6930467912331529, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Spatially Aware Mutation to promote diversity and improve convergence in black-box optimization.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                spatial_factor = np.random.uniform(0.5, 1.0, self.dim)  # New line\n                mutant = np.clip(a + self.mutation_factor * (b - c) * spatial_factor, self.lower_bound, self.upper_bound)  # Modified line\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.15 on similar problems with similar landscape features.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.8817034629045716, 0.5278558955943472, 0.6695810152005397]}}
{"id": "98a74e29-06cd-4046-82a6-6deb8fef6c3d", "fitness": 0.9668598044822971, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Mutation Factor and Re-Evaluation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Dynamic Mutation Factor\n                self.mutation_factor = 0.5 + 0.5 * np.random.rand()\n\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.02 on similar problems with similar landscape features.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.9478970707664586, 0.9634099895504264, 0.9892723531300062]}}
{"id": "15e22c4f-4df8-4ddf-8785-b18b2856b39d", "fitness": 0.9489843904688714, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Adaptive Mutation Factor for Improved Exploration and Exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.5  # Adjusted differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = 0.5 + 0.3 * (1 - evaluations / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.95 with standard deviation 0.03 on similar problems with similar landscape features.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.9134549682198666, 0.9386730225044915, 0.9948251806822561]}}
{"id": "71b82870-ec96-46fc-ad4b-24cc4c26d42a", "fitness": 0.635828772051333, "name": "AdaptiveDifferentialEvolution", "description": "Improved mutation strategy by dynamically adjusting the mutation factor based on fitness variance to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                current_mutation_factor = self.mutation_factor * (1 + np.var(fitness) / (np.mean(fitness) + 1e-9))\n                mutant = np.clip(a + current_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.31 on similar problems with similar landscape features.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.9075960699439998, 0.7958954926907748, 0.20399475351922447]}}
{"id": "2648a70e-88ce-4be4-8a44-871b1d267513", "fitness": 0.7970704927314065, "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by incorporating population-level variance to improve exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                # Modification: Incorporate population variance into mutation\n                mutation_factor = self.mutation_factor + np.var(pop, axis=0).mean() * 0.1\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.12 on similar problems with similar landscape features.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.8006840006797705, 0.9460454092258549, 0.6444820682885941]}}
{"id": "fae09c53-8926-41dc-8a79-ac6e4d26e1cf", "fitness": 0.7833505088680622, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Mutation Factor to enhance adaptability in varying optimization landscapes.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                adaptive_mutation_factor = self.mutation_factor * (1 - evaluations / self.budget)  # Dynamically adjust mutation factor\n                mutant = np.clip(a + adaptive_mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.08 on similar problems with similar landscape features.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.8906176587366597, 0.6930541294170334, 0.7663797384504937]}}
{"id": "48cc1f2e-72b6-43e5-b9a0-00c623926e49", "fitness": 0.9846496595471773, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Modified Crossover to enhance trial vector diversity in black-box optimization.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(10 * dim, budget // 10)  # Dynamic population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.mutation_factor = 0.8  # Differential weight\n        self.recombination_rate = 0.9  # Crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.array([func(ind) for ind in pop])\n        evaluations = self.pop_size\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                # Mutation\n                idxs = [idx for idx in range(self.pop_size) if idx != i]\n                a, b, c = pop[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.recombination_rate * 1.1  # Increased crossover rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return pop[best_idx], fitness[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.98 with standard deviation 0.00 on the real problem.", "error": "", "parent_ids": ["d1a840a2-233d-433b-b80e-f6f5ee802e92"], "operator": null, "metadata": {"aucs": [0.986891521674403, 0.9797084576044438, 0.9873489993626849]}}
