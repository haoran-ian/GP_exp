{"id": "f3e957e6-8d88-44f1-8757-82c46c9fe23d", "fitness": 0.9011733333333332, "name": "ASR", "description": "Adaptive Swarm Reflex (ASR) utilizes dynamic particle memory in a swarm to explore and exploit the search space efficiently.", "code": "import numpy as np\n\nclass ASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        # Initialize swarm\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                # Update velocity\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                # Update position\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                # Evaluate fitness\n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 0, "feedback": "The algorithm ASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.02 on similar problems with similar landscape features.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.91075, 0.90025, 0.88365, 0.91075, 0.9446, 0.88365, 0.91075, 0.90025, 0.88365, 0.91075, 0.90025, 0.88365, 0.91075, 0.90025, 0.88365]}}
{"id": "80a204f4-0eed-44ce-89c6-1c0f1610ecbb", "fitness": 0.9566000000000002, "name": "DIASR", "description": "Dynamic Inertia Adaptive Swarm Reflex (DI-ASR) incorporates an adaptive inertia weight to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9  # Changed\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Added to dynamically adjust inertia weight\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 1, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00 on similar problems with similar landscape features.", "error": "", "parent_ids": ["f3e957e6-8d88-44f1-8757-82c46c9fe23d"], "operator": null, "metadata": {"aucs": [0.96155, 0.95565, 0.9526, 0.96155, 0.95565, 0.9526, 0.96155, 0.95565, 0.9526, 0.96155, 0.95565, 0.9526, 0.96155, 0.95565, 0.9526]}}
{"id": "8ee54491-de0b-4346-b30e-218482606078", "fitness": 0.1667166666666666, "name": "DIASRVE", "description": "DIASR-VE introduces velocity exploration by adapting velocity randomness based on position diversity to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DIASRVE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9  # Changed\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.velocity_randomness = 0.1  # New\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                diversity = np.std(positions, axis=0)  # New\n                velocity_randomness = self.velocity_randomness * diversity  # New\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                 velocity_randomness * np.random.uniform(-1, 1, self.dim))  # Changed\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n            \n            self.inertia_weight *= 0.99  # Added to dynamically adjust inertia weight\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 2, "feedback": "The algorithm DIASRVE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3fd82429-8e74-4f52-b8ec-ce179e65ea7e", "fitness": 0.9457666666666664, "name": "DIASR", "description": "Enhanced DIASR by including a non-linear update rule for velocities to improve convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1**2 * (personal_best_positions[i] - positions[i]) +  # Changed\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 3, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.95 with standard deviation 0.01 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.9559, 0.9307, 0.9507, 0.9559, 0.9307, 0.9507, 0.9559, 0.9307, 0.9507, 0.9559, 0.9307, 0.9507, 0.9559, 0.9307, 0.9507]}}
{"id": "a5b08248-9a38-43a5-83b8-ff4295f917ad", "fitness": 0.6111166666666665, "name": "EDIASR", "description": "Enhanced Dynamic Inertia Adaptive Swarm Reflex (E-DIASR) introduces a non-linear decay for inertia weight and adaptive social-cognitive factors to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EDIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.decay_rate = 0.9\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= self.decay_rate ** (evaluations / self.budget)  # Changed to non-linear decay\n            self.cognitive_coeff = 1.2 + 0.4 * (1 - evaluations / self.budget)  # Adaptive cognitive coefficient\n            self.social_coeff = 1.2 + 0.4 * (evaluations / self.budget)  # Adaptive social coefficient\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 4, "feedback": "The algorithm EDIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.43 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.91635, 4.999999999999449e-05, 0.91695, 0.91635, 4.999999999999449e-05, 0.91695, 0.91635, 4.999999999999449e-05, 0.91695, 0.91635, 4.999999999999449e-05, 0.91695, 0.91635, 4.999999999999449e-05, 0.91695]}}
{"id": "e2d4f253-0e36-422d-a117-e4e58c23f41a", "fitness": 0.6421833333333333, "name": "EDIASR", "description": "Enhanced Dynamic Inertia Adaptive Swarm Reflex (E-DIASR) leverages a nonlinear inertia weight decay and adaptive coefficients for improved convergence.", "code": "import numpy as np\n\nclass EDIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.98 - 0.01 * (evaluations / self.budget)  # Nonlinear decay\n            self.cognitive_coeff = 1.5 - 0.5 * (evaluations / self.budget)  # Decay cognitive\n            self.social_coeff = 1.5 + 0.5 * (evaluations / self.budget)  # Increase social\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 5, "feedback": "The algorithm EDIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.45 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.95695, 4.999999999999449e-05, 0.96955, 0.95695, 4.999999999999449e-05, 0.96955, 0.95695, 4.999999999999449e-05, 0.96955, 0.95695, 4.999999999999449e-05, 0.96955, 0.95695, 4.999999999999449e-05, 0.96955]}}
{"id": "2b5ad099-351a-447e-b11b-e1175b3e2496", "fitness": 0.4845, "name": "EDIASR", "description": "Enhanced Dynamic Inertia Adaptive Swarm Reflex (E-DIASR) with adaptive velocity bounds and diversified exploration via a chaotic map.", "code": "import numpy as np\n\nclass EDIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 12  # Changed\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.7  # Changed\n        self.social_coeff = 1.5  # Changed\n        self.velocity_bound = 0.1 * (self.upper_bound - self.lower_bound)  # Changed\n\n    def chaotic_map(self, x):  # Added\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-self.velocity_bound, self.velocity_bound, (self.swarm_size, self.dim))  # Changed\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = self.chaotic_map(np.random.random()), np.random.random()  # Changed\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 6, "feedback": "The algorithm EDIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.39 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 0.9534, 0.50005, 4.999999999999449e-05, 0.9534, 0.50005, 4.999999999999449e-05, 0.9534, 0.50005, 4.999999999999449e-05, 0.9534, 0.50005, 4.999999999999449e-05, 0.9534]}}
{"id": "20bd1a59-a003-41b6-84a7-3a62816c61c9", "fitness": 0.6378999999999999, "name": "EDIASR", "description": "Enhanced Dynamic Inertia Adaptive Swarm Reflex (E-DIASR) introduces an adaptive velocity clamping mechanism to further balance exploration and exploitation.", "code": "import numpy as np\n\nclass EDIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.velocity_clamp = (self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                velocities[i] = np.clip(velocities[i], *self.velocity_clamp)  # Added velocity clamping\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 7, "feedback": "The algorithm EDIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.45 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.96155, 4.999999999999449e-05, 0.9521, 0.96155, 4.999999999999449e-05, 0.9521, 0.96155, 4.999999999999449e-05, 0.9521, 0.96155, 4.999999999999449e-05, 0.9521, 0.96155, 4.999999999999449e-05, 0.9521]}}
{"id": "282031db-f245-4484-b1f4-4ce33ce964bb", "fitness": -Infinity, "name": "DIASR", "description": "Modified Dynamic Inertia Adaptive Swarm Reflex (M-DIASR) introduces a non-linear inertia weight adjustment and adaptive swarm size to enhance convergence speed.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.adaptive_swarm = True  # Added for adaptive swarm size\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= np.log1p(evaluations) / np.log1p(self.budget)  # Non-linear inertia adjustment\n            if self.adaptive_swarm and evaluations < self.budget * 0.5:  # Adaptive swarm size\n                self.swarm_size = min(20, self.swarm_size + 1)\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 8, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {}}
{"id": "bac72851-b775-4f27-872d-15838094af75", "fitness": 0.427402159780584, "name": "EnhancedDIASR", "description": "The Enhanced DI-ASR introduces a dynamic swarm size and adaptive coefficients for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10  # Initially set\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            # Dynamically adjust swarm size\n            if evaluations % (self.budget // 10) == 0:  \n                self.swarm_size = max(5, int(self.swarm_size * 1.1))\n                positions = np.resize(positions, (self.swarm_size, self.dim))\n                velocities = np.resize(velocities, (self.swarm_size, self.dim))\n                personal_best_positions = np.resize(personal_best_positions, (self.swarm_size, self.dim))\n                personal_best_scores = np.resize(personal_best_scores, (self.swarm_size,))\n            \n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Continue to adjust\n            self.cognitive_coeff *= 1.01  # Boost cognition over iterations\n            self.social_coeff *= 0.99  # Dampen social influence slightly\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedDIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.40 on the real problem.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.21095013400891438, 0.08179278640226273, 0.9894635589305749]}}
{"id": "4fa0c21a-b783-4f60-93a7-49d5a83efff9", "fitness": 0.9551433333333335, "name": "EDIASR", "description": "Enhanced Dynamic Inertia Adaptive Swarm Reflex (E-DIASR) introduces hybridization with local search to reinforce local optima escape strategies.", "code": "import numpy as np\n\nclass EDIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5  # Changed\n        self.social_coeff = 1.5  # Changed\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n\n                # Local search strategy added\n                if np.random.rand() < 0.2:  # Changed\n                    local_search_position = positions[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_search_position = np.clip(local_search_position, self.lower_bound, self.upper_bound)\n                    local_score = func(local_search_position)\n                    evaluations += 1\n                    if local_score < score:\n                        score = local_score\n                        positions[i] = local_search_position\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.98  # Changed to dynamically adjust inertia weight\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 10, "feedback": "The algorithm EDIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.01 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.95555, 0.9475, 0.9634, 0.95555, 0.9475, 0.9634, 0.95555, 0.9458, 0.9634, 0.95555, 0.9458, 0.9634, 0.95555, 0.9458, 0.9634]}}
{"id": "efea7a5f-04f9-4005-bc66-a2ca71bd608a", "fitness": 0.9566000000000002, "name": "DIASR", "description": "Enhancing exploration by adjusting velocity initialization range proportionally to the search space.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(self.lower_bound / 5.0, self.upper_bound / 5.0, (self.swarm_size, self.dim))  # Changed\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 11, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.00 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.96155, 0.95565, 0.9526, 0.96155, 0.95565, 0.9526, 0.96155, 0.95565, 0.9526, 0.96155, 0.95565, 0.9526, 0.96155, 0.95565, 0.9526]}}
{"id": "eb1ce895-8145-49b8-89b5-4753ddcc4903", "fitness": 0.6361666666666667, "name": "ACS_DI_ASR", "description": "Enhanced DI-ASR with Adaptive Cognitive and Social Coefficients (ACS-DIASR) adjusts cognitive and social coefficients dynamically to improve convergence.", "code": "import numpy as np\n\nclass ACS_DI_ASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9  # Changed\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.min_cognitive_coeff = 1.0  # Added\n        self.max_social_coeff = 1.8  # Added\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99  # Added to dynamically adjust inertia weight\n            # Dynamically adjust cognitive and social coefficients\n            self.cognitive_coeff = max(self.min_cognitive_coeff, self.cognitive_coeff * 0.99)\n            self.social_coeff = min(self.max_social_coeff, self.social_coeff * 1.01)\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 12, "feedback": "The algorithm ACS_DI_ASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.45 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.95275, 4.999999999999449e-05, 0.9557, 0.95275, 4.999999999999449e-05, 0.9557, 0.95275, 4.999999999999449e-05, 0.9557, 0.95275, 4.999999999999449e-05, 0.9557, 0.95275, 4.999999999999449e-05, 0.9557]}}
{"id": "2121f910-0bc1-4d6e-918f-55e492e996e5", "fitness": 0.56988, "name": "EDIASR", "description": "Enhanced Dynamic Inertia Adaptive Swarm Reflex (E-DIASR) integrates a convergence factor and adaptive coefficients for improved solution convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass EDIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.convergence_factor = 0.9  # Added\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= self.convergence_factor  # Modified\n            self.cognitive_coeff = 1.2 + 0.2 * (1 - evaluations / self.budget)  # Added\n            self.social_coeff = 1.2 + 0.2 * (evaluations / self.budget)  # Added\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 13, "feedback": "The algorithm EDIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.41 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.80165, 4.999999999999449e-05, 0.9091, 0.8002, 4.999999999999449e-05, 0.9091, 0.8002, 4.999999999999449e-05, 0.9091, 0.8002, 4.999999999999449e-05, 0.9091, 0.8002, 4.999999999999449e-05, 0.9091]}}
{"id": "f3dd3e27-b1b7-48b9-9c7a-125f9944b4cd", "fitness": 0.48538333333333333, "name": "DIASR", "description": "Enhanced DIASR using adaptive cognitive and social coefficients to improve search efficiency.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                r3 = np.random.random()  # New random factor\n                r4 = np.random.random()  # New random factor\n                self.cognitive_coeff = 1.4 + 0.6 * r3  # Adaptive adjustment\n                self.social_coeff = 1.4 + 0.6 * r4  # Adaptive adjustment\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 14, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.39 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 0.95605, 0.50005, 4.999999999999449e-05, 0.95605, 0.50005, 4.999999999999449e-05, 0.95605, 0.50005, 4.999999999999449e-05, 0.95605, 0.50005, 4.999999999999449e-05, 0.95605]}}
{"id": "f1d0c262-0165-4dd2-9cdf-30f5339d7a25", "fitness": 0.4878999999999999, "name": "DIASR", "description": "The DIASR algorithm incorporates a diversity mechanism by updating the social coefficient with a random component to enhance exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9 \n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2, r3 = np.random.random(3)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 (self.social_coeff + r3) * r2 * (global_best_position - positions[i]))  # Modified line\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99 \n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 15, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.39 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 0.9636, 0.50005, 4.999999999999449e-05, 0.9636, 0.50005, 4.999999999999449e-05, 0.9636, 0.50005, 4.999999999999449e-05, 0.9636, 0.50005, 4.999999999999449e-05, 0.9636]}}
{"id": "1a082ac7-c467-4d05-bd45-b6c7c191af16", "fitness": 0.6396666666666666, "name": "DIASR", "description": "Improved Dynamic Inertia Adaptive Swarm Reflex (DI-ASR) with an adjusted cognitive coefficient for enhanced exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5  # Changed\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 16, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.64 with standard deviation 0.45 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.9634, 4.999999999999449e-05, 0.95555, 0.9634, 4.999999999999449e-05, 0.95555, 0.9634, 4.999999999999449e-05, 0.95555, 0.9634, 4.999999999999449e-05, 0.95555, 0.9634, 4.999999999999449e-05, 0.95555]}}
{"id": "e037586e-eee7-4f07-bf5c-a60d67639a1d", "fitness": 0.7257, "name": "EDIASR", "description": "Enhanced Dynamic Inertia Adaptive Swarm Reflex (E-DIASR) with nonlinear inertia adaptation and self-adaptive coefficients for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EDIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n\n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n\n        evaluations = self.swarm_size\n\n        while evaluations < self.budget:\n            inertia_decay_factor = 0.99 + 0.01 * np.exp(-evaluations/self.budget)  # Nonlinear decay\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                adaptive_cognitive_coeff = self.cognitive_coeff * (1 + np.random.normal(0, 0.1))\n                adaptive_social_coeff = self.social_coeff * (1 + np.random.normal(0, 0.1))\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 adaptive_social_coeff * r2 * (global_best_position - positions[i]))\n\n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n                score = func(positions[i])\n                evaluations += 1\n\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= inertia_decay_factor  # Nonlinear adjustment\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 17, "feedback": "The algorithm EDIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.16 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.50005, 0.87235, 0.8047, 0.50005, 0.87235, 0.8047, 0.50005, 0.87235, 0.8047, 0.50005, 0.87235, 0.8047, 0.50005, 0.87235, 0.8047]}}
{"id": "bfe0a0e9-e387-4bee-b052-37fddfa6df39", "fitness": 0.6521833333333333, "name": "DIASR", "description": "DIASR+ introduces a dynamic swarm size to improve adaptability over the optimization process.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.swarm_size = max(5, self.swarm_size - 1)  # Dynamically adjust swarm size\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 18, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.46 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.9789, 4.999999999999449e-05, 0.9776, 0.9789, 4.999999999999449e-05, 0.9776, 0.9789, 4.999999999999449e-05, 0.9776, 0.9789, 4.999999999999449e-05, 0.9776, 0.9789, 4.999999999999449e-05, 0.9776]}}
{"id": "7413be75-e8e8-42d1-b221-0b7a4c39d579", "fitness": 0.9799747051424746, "name": "DIASR", "description": "Enhanced DIASR with Lvy flight-inspired random perturbations to improve exploration.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 19, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.98 with standard deviation 0.02 on the real problem.", "error": "", "parent_ids": ["80a204f4-0eed-44ce-89c6-1c0f1610ecbb"], "operator": null, "metadata": {"aucs": [0.9956520712454351, 0.9856093289791926, 0.9586627152027963]}}
{"id": "d8697ede-59f2-4e44-9afa-294dd6a473fa", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Refine DIASR by dynamically adjusting the cognitive coefficient to enhance solution quality.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.cognitive_coeff *= 0.99  # Changed\n\n            self.inertia_weight *= 0.99\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 20, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "c60c61bc-b626-4893-a310-496b09b6c104", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive cognitive and social coefficients for improved convergence and exploration balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (1 + 0.5 * np.sin(0.1 * evaluations)) * self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  # Modified\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 21, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "b679f691-fcbe-466f-902f-49bf9d334fd7", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced dynamic social and cognitive coefficients to improve convergence speed and solution quality in DIASR.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i])) * (1 - evaluations/self.budget) +  # Modified\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 22, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "45099192-edeb-4c5d-abaf-0675d873723c", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce adaptive cognitive and social coefficients to enhance convergence and exploration.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            # Updated line to add adaptiveness to coefficients\n            r1, r2 = np.random.random(2)\n            self.cognitive_coeff = 1.4 + (2.0 - 1.4) * evaluations / self.budget\n            self.social_coeff = 1.4 - (1.4 - 0.5) * evaluations / self.budget\n\n            for i in range(self.swarm_size):\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 23, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "af121738-3ebc-4719-9ef3-bf6f4874f376", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR using adaptive coefficients and dynamic inertia reduction for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                adaptive_cognitive_coeff = self.cognitive_coeff * (global_best_score / (personal_best_scores[i] + 1e-9))  # Modified\n                adaptive_social_coeff = self.social_coeff * (1 - global_best_score / (personal_best_scores[i] + 1e-9))  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 adaptive_cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +  # Modified\n                                 adaptive_social_coeff * r2 * (global_best_position - positions[i]))  # Modified\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.98  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 24, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "93a9d689-e839-4b2b-a7b3-29bec80a5c94", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with dynamic cognitive and social coefficients for improved solution convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.cognitive_coeff *= 0.99  # Modified to enhance convergence\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 25, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "a6c1dfbd-e521-4569-8b8f-fe5bee8bb512", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with a dynamic cognitive coefficient for improved adaptability.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.4 * np.exp(-0.001 * evaluations)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 26, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "cfe9c9a2-18a1-42db-85a5-051b3d17b710", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive cognitive coefficient scaling to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff *= 0.99  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 27, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "55380875-6113-491e-9a72-74dea232f73b", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced Gaussian mutation to enhance local exploration capabilities while maintaining diversity.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                # Introduce Gaussian mutation\n                if np.random.rand() < 0.2:  \n                    positions[i] += np.random.normal(0, 0.1, self.dim)\n\n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 28, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "11931361-6ae7-4c7a-a236-bb2916ed3d0e", "fitness": 0.9536295785329271, "name": "DIASR", "description": "Adjusted the social coefficient to enhance information sharing among particles and improve convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.6  # Changed\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 29, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.95 with standard deviation 0.04 on the real problem.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.8977909979474937, 0.9647668400665987, 0.9983308975846883]}}
{"id": "4eb0aef0-30be-4f41-9737-7e7cdaeea2b1", "fitness": 0.1667166666666666, "name": "DIASR", "description": "DIASR with adaptive inertia weight starting at 0.9 and decreasing linearly to 0.4 over the iterations to enhance convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight_start = 0.9  # Modified\n        self.inertia_weight_end = 0.4    # Added\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            # Update inertia weight linearly over iterations\n            self.inertia_weight = self.inertia_weight_start - ((self.inertia_weight_start - self.inertia_weight_end) * (evaluations / self.budget))  # Modified\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 30, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "cf055d8f-d203-48e0-85ce-890050a37357", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Slightly adjusted the cognitive coefficient to enhance exploitation capabilities.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.6  # Modified\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 31, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "6043712e-2807-4385-ad1c-a1f1f0bd744b", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Refined Enhanced DIASR by dynamically adjusting the Lvy flight exponent to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.levy_exponent = 1.5 + 0.5 * (1 - evaluations / self.budget)  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 32, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "6f336717-bdd4-4a47-9236-05f7593fd24f", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Adjusted the social coefficient dynamically based on evaluations to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.social_coeff = 1.4 * (1 - evaluations / self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 33, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "6bc9f328-bf31-4324-b705-498a9b2f93b6", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce adaptive social and cognitive coefficients for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.4 * (1 - evaluations/self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 34, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "1187111f-1fa7-413c-8bae-40510afd7902", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with adaptive coefficients to enhance convergence speed.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (self.cognitive_coeff + 0.1) * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))  # Changed here\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 35, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "0ad4c980-9049-4d60-b8cd-b3427afe62b1", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive social coefficient to enhance global exploration and convergence balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 (self.social_coeff + 0.5 * np.sin(evaluations/self.budget * np.pi)) * r2 * (global_best_position - positions[i]))  # Modified\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 36, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "b68b0473-0048-46b1-a6ca-403c676ed763", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce dynamic adjustment of swarm size based on budget utilization to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(min(self.swarm_size, self.budget - evaluations)):  # Modified\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 37, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "ee8f26d5-b326-4fd9-a231-06f9e8112d85", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with dynamic cognitive and social coefficients for adaptive convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.4 - 0.4 * (evaluations / self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 38, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "2a5185f0-09e0-4a18-8649-c222bc5a95d6", "fitness": 0.9028827491478317, "name": "DIASR", "description": "Introduced adaptive levy exponent to enhance exploration-exploitation balance dynamically.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.levy_exponent = max(1.1, self.levy_exponent * 0.995)  # Changed to be adaptive\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 39, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.90 with standard deviation 0.13 on the real problem.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.9998018367487365, 0.7211138467029997, 0.9877325639917591]}}
{"id": "8392ffb3-03d4-44f3-9d5f-3f706dc998f2", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with adaptive inertia weight to balance exploration and exploitation better.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99 + 0.1 * (global_best_score / np.mean(personal_best_scores))  # Changed\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 40, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "808e416f-6dd6-443c-b174-c6dd9a7073e0", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with dynamically adjusted cognitive coefficient for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.4 * (1 - evaluations / self.budget)  # Modified\n\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 41, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "899e134c-ee42-48b9-a7c1-42fa3d04304a", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Refinement of inertia weight decay for improved convergence stability.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.7  # Modified\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 42, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "f495960e-9225-4165-a0d1-14683d9e0ede", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce dynamic adjustment of the social coefficient based on function evaluations to enhance adaptability.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.social_coeff = 1.4 + 0.3 * (evaluations / self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 43, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "00609222-5dc3-40f9-b116-1231683feea5", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Improved inertia weight decay rate to enhance convergence speed.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.995  # Changed line\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 44, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "73297d38-a2aa-44f5-8db6-261921d4009d", "fitness": 0.1667166666666666, "name": "DIASR", "description": "DIASR with adaptive inertia weight decay for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.995  # Changed from 0.99 to 0.995 for more gradual decay\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 45, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "eb233ce4-12c9-4717-94ae-edec93231468", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Refined DIASR with adaptive inertia weight decay for enhanced convergence efficiency.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.995  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 46, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "f2e4aa5b-eb5d-49da-8002-3fd16982e925", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce a dynamic social coefficient to enhance convergence by adapting exploration and exploitation balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 (self.social_coeff * 0.5 * (1 + np.cos(np.pi * evaluations / self.budget))) * r2 * (global_best_position - positions[i]))  # Modified\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 47, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "e5084e87-05b3-41f0-b665-7b7b6326548e", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Tweaked DIASR algorithm by reducing inertia weight decay rate to improve convergence speed.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.995  # Modified Decay Rate\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 48, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3e417524-9aa2-4796-9911-defc96973fb8", "fitness": 0.917246623249247, "name": "DIASR", "description": "Introduced dynamic adjustment of cognitive and social coefficients for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.cognitive_coeff *= 0.99  # Modified\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 49, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.92 with standard deviation 0.11 on the real problem.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.9998018367487365, 0.7576243137151966, 0.994313719283808]}}
{"id": "f6b1cad2-2298-41c6-b671-9b26c4902241", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with adaptive cognitive and social coefficients for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.5 + np.random.random() * 0.5  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 50, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "c7ecafe4-95f8-49f8-82f5-e1072c17fa85", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Improved DIASR incorporating adaptive coefficients to enhance convergence speed and precision.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.cognitive_coeff = 1.0 + 0.5 * (self.budget - evaluations) / self.budget  # Modified\n            self.social_coeff = 1.0 + 0.5 * (evaluations / self.budget)  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 51, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "607d66f1-0f06-4136-8914-3c2e32795e55", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce adaptive social coefficient in DIASR to dynamically adjust exploration and exploitation balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n\n                self.social_coeff *= 0.995  # Modified\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 52, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "973919e9-e3e7-4f6a-a63e-cc174a5b46d0", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive social coefficient for improved convergence by dynamically adjusting based on iteration progress.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.social_coeff = 1.4 * (1 - evaluations / self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 53, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "2d2090cd-9ff5-4175-8836-d2548e77a431", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Incorporate adaptive cognitive and social coefficients to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.4 - (1.0 * evaluations / self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 54, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3b9f6489-4028-4b5f-a8be-1dcdcf89a506", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with dynamically adjusted social coefficient based on performance to improve group cohesion and convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.social_coeff = 1.4 if evaluations < self.budget / 2 else 1.6  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 55, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "d6ae566e-5ee6-40ee-b572-920a04933e69", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced dynamic social coefficient in DIASR for adaptive exploration-exploitation balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.social_coeff = 1.4 * (1 - evaluations / self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 56, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "45bce1a8-2270-405b-81fe-57a0d5f3a506", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Adjusted the inertia weight decrease factor for enhanced convergence dynamics.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.995  # Modified line\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 57, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "b72d9d4c-d20a-446a-9afe-6771795db846", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce adaptive inertia weight to improve convergence speed and accuracy.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight = max(0.4, self.inertia_weight * 0.99)  # Modified line\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 58, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "c1941be2-8b56-4fb7-93b9-4bf320a92e06", "fitness": 0.7299236409612835, "name": "DIASR", "description": "Introduced a dynamic cognitive coefficient to adaptively enhance the personal exploration capabilities of particles.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.4 + 0.6 * np.sin(evaluations / self.budget * np.pi)  # Modified line\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 59, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73 with standard deviation 0.36 on the real problem.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.9998018367487365, 0.22136157123862898, 0.9686075148964848]}}
{"id": "9f7648dd-998d-4f4e-b2c9-6b7962c8a70e", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive cognitive and social coefficients in DIASR to enhance convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (self.cognitive_coeff + 0.1 * np.random.random()) * r1 * \n                                 (personal_best_positions[i] - positions[i]) +\n                                 (self.social_coeff + 0.1 * np.random.random()) * r2 * \n                                 (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 60, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "d00749ea-1fa8-4c9e-ace9-a958141ede6f", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Modified DIASR incorporating dynamic swarm size and adaptive coefficients to enhance search efficiency.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        swarm_size = self.initial_swarm_size\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.cognitive_coeff *= 0.98  # Added adaptive cognitive coefficient\n            self.social_coeff *= 1.01    # Added adaptive social coefficient\n            swarm_size = max(5, swarm_size - 1)  # Added dynamic swarm size reduction\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 61, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8c89c9ba-7791-42fe-8af0-f9ef454f78a6", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced dynamic social coefficient to enhance adaptability during optimization.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.social_coeff = 0.5 + 2.5 * evaluations / self.budget  # Changed line\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 62, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "2b81bf14-25c7-469a-91aa-e4c6aa67bc31", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced dynamic adjustment of the cognitive and social coefficients based on the current evaluation ratio to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                current_ratio = evaluations / self.budget  # Changed\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 63, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "ba762348-edbc-4de6-8f79-c91ab1b75717", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive cognitive and social coefficients to improve convergence dynamics.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (self.cognitive_coeff + 0.1 * (self.budget - evaluations) / self.budget) * r1 * (personal_best_positions[i] - positions[i]) +\n                                 (self.social_coeff - 0.1 * evaluations / self.budget) * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 64, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8e3bc42c-8cd6-4a37-8d9f-bc6d1d50765a", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Modified DIASR by adjusting inertia weight decay for more adaptive exploration and exploitation balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.995  # Modified: Adjusted decay rate for inertia weight\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 65, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "586824d2-2e0a-4d0b-a2d5-35fff5808de1", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Updated the inertia weight decay rate to improve convergence speed by making the swarm more dynamic.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.985  # Slightly modified decay rate\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 66, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "add76f55-71b7-4809-9a2b-646378cb3760", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with adaptive inertia weight reduction for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.98  # Changed from 0.99 to 0.98\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 67, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "723fa42a-ae7e-4f2a-b57d-340b4c1a011e", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Improved DIASR by adjusting inertia weight decay from multiplicative to additive, enhancing convergence dynamics.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight -= 0.01  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 68, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8f6a13a3-9380-4bc0-8037-c2ec19d56348", "fitness": 0.9595923977682971, "name": "DIASR", "description": "Introduced adaptive cognitive coefficient to enhance local search by dynamically adjusting its value based on the swarm's convergence state.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.4 if evaluations < self.budget // 2 else 1.0  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 69, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.03 on the real problem.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.9998018367487365, 0.9321934793076553, 0.9467818772484993]}}
{"id": "7be049c3-a9de-4631-8de5-70119be258ae", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced a dynamic cognitive coefficient to balance exploration and exploitation adaptively.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 0.5 + 0.9 * (self.budget - evaluations) / self.budget  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 70, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "92ddb3dc-d620-47f1-9a39-cef2332fad68", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced dynamic adjustment of the social coefficient based on iteration progress for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 ((self.budget - evaluations) / self.budget) * self.social_coeff * r2 * (global_best_position - positions[i]))  # Modified\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 71, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "0306981a-d53a-425c-9de5-ebd51f6303a5", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with adaptive cognitive and social coefficients for dynamic balance between exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (self.cognitive_coeff - self.inertia_weight) * r1 * (personal_best_positions[i] - positions[i]) +  # Modified\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 72, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3b80042c-cee0-4720-be65-788fd591f1ce", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with dynamic adjustment of the Lvy flight exponent to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.levy_exponent = 1.5 + (evaluations / self.budget) * 0.5  # Change: Dynamic adjustment of Levy exponent\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 73, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3cc05efc-a873-45ac-9523-00ee56cea709", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with adaptive levy exponent based on convergence speed for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            self.levy_exponent = 1.5 + 0.5 * (global_best_score / max(personal_best_scores))  # Modified\n\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 74, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8171754d-81b8-4e79-9c4b-8fccca91b713", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive social coefficient to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 (1 - evaluations/self.budget) * self.social_coeff * r2 * (global_best_position - positions[i]))  # Modified\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 75, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "bbf614c6-64f3-4d7f-9af9-42ccd8494a75", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Incorporate adaptive velocity scaling to improve convergence speed.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                velocities[i] *= 0.9 + 0.2 * np.random.random()  # Modified line\n\n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 76, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "31b5ee1a-7e7d-4bc2-933c-eaf0f4fca2f8", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhance DIASR with adaptive coefficients and random initialization of swarm size for better convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = np.random.randint(5, 15)  # Modified\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.cognitive_coeff *= 0.99  # Modified\n            self.social_coeff *= 0.99  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 77, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "2cfc00ad-a182-4e35-b377-cadb10f208ef", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with dynamic social and cognitive coefficients to adapt exploration and exploitation balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.cognitive_coeff = max(0.5, self.cognitive_coeff * 0.99)  # Modified\n            self.social_coeff = min(2, self.social_coeff * 1.01)  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 78, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "48a6b97f-90d2-4739-9317-d41fc8c49f1d", "fitness": 0.9431267866692518, "name": "DIASR", "description": "Optimized inertia weight decay strategy for improved convergence and exploration balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.995  # Modified line\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 79, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94 with standard deviation 0.07 on the real problem.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.9998018367487365, 0.8374788449987898, 0.9920996782602289]}}
{"id": "624ea3b1-22e9-4dde-bb55-2a8bc83dbe30", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive inertia weight to DIASR for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            # Change: Made inertia_weight adaptive based on evaluations\n            self.inertia_weight = 0.4 + 0.5 * ((self.budget - evaluations) / self.budget)\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 80, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "526b3101-b3a6-45e1-acf7-dfcd82734a5e", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Refined DIASR with a dynamic cognitive coefficient for adaptive learning.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.cognitive_coeff = 1.2 + 0.4 * (global_best_score / max(personal_best_scores[i], 1e-6))  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 81, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3a479147-afb5-4c9c-bc70-1ea5b3b21997", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Improved exploration by introducing adaptive social coefficient adjustments based on convergence rate.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n\n                # Adjust social coefficient based on convergence rate\n                self.social_coeff = 1.4 + 0.2 * (1 - evaluations / self.budget)  # Added one line change\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 82, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "e0058904-4bd2-4b76-af6f-d692e6a52c31", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce dynamic levy exponent adjustment to enhance exploration-exploitation balance over iterations.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.levy_exponent = 1.5 + 0.5 * (evaluations / self.budget)  # Dynamic adjustment\n\n        return global_best_position, global_best_score", "configspace": "", "generation": 83, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "ea37870b-afd8-44e1-bf7f-41d5b25280ba", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive inertia weight decay for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99 + 0.0001 * (evaluations / self.budget)\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 84, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "f7af2290-416e-4050-8840-65681519a6b1", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced dynamic adjustment of the cognitive coefficient based on iteration count to enhance convergence speed.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                # Modified line\n                self.cognitive_coeff = 1.4 + (0.6 * (evaluations / self.budget))  # Dynamically adjust\n                \n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 85, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "d7c9ae62-3c8d-4654-9964-1c291d8ed05d", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce an adaptive social coefficient to dynamically balance exploration and exploitation in DIASR.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                self.social_coeff = 1.4 + 0.3 * np.exp(-evaluations/self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 86, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "52ee5de7-6f42-40fa-8336-47eaba8631b3", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce adaptive cognitive and social coefficients to improve convergence speed and accuracy.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                # Adaptive coefficients change\n                self.cognitive_coeff = 1.4 + 0.6 * (1 - evaluations / self.budget)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 87, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "c6b6b398-e4a3-402a-a67a-521f9a272be0", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduce adaptive inertia weight decay to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99 * (1 - evaluations / self.budget)  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 88, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "f16a3c14-a257-4fee-8c5b-e57134a74643", "fitness": 0.9648179733742149, "name": "DIASR", "description": "Enhanced DIASR with adaptive social and cognitive coefficients for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (self.cognitive_coeff * 0.9) * r1 * (personal_best_positions[i] - positions[i]) +  # Modified\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 89, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.96 with standard deviation 0.05 on the real problem.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.9998018367487365, 0.899790258497827, 0.9948618248760812]}}
{"id": "1100e5c4-caf9-45ef-bff4-d71ce263c00e", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with adaptive cognitive and social coefficients for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            self.cognitive_coeff = max(0.5, self.cognitive_coeff * 0.99)  # Modified\n            \n        return global_best_position, global_best_score", "configspace": "", "generation": 90, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "55078af3-6b2d-4ac0-851e-0686a5758ffb", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced adaptive cognitive and social coefficients to enhance convergence by dynamically optimizing exploration and exploitation phases.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 (self.cognitive_coeff * (self.budget - evaluations) / self.budget) * r1 * (personal_best_positions[i] - positions[i]) +  # Modified\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 91, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "21321f6b-f347-4abb-8c51-9cd5618b054d", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Tweaked the inertia weight decay rate to enhance convergence speed, ensuring better balance between exploration and exploitation.  ", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.985  # Changed from 0.99 to 0.985\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 92, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3b265dbe-ca51-4747-9dc9-803b32cc1efe", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Introduced a dynamic adaptive adjustment to the cognitive and social coefficients based on current progress to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            progress = evaluations / self.budget  # Dynamic adjustment\n            self.cognitive_coeff = 1.4 * (1 - progress) + 0.5\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 93, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "ec3fb2bb-25f3-4048-808c-148f39729ed7", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Improved inertia weight decay to enhance convergence stability in DIASR.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.98  # Modified\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 94, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "d49748dd-7c7e-4561-81d1-eb007e444c5d", "fitness": -Infinity, "name": "DIASR", "description": "Incorporate a dynamic swarm size reduction to enhance local exploitation in later stages of the search.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            self.swarm_size = max(1, int(self.budget / (evaluations + 1)))  # Dynamic swarm size reduction\n            \n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 95, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {}}
{"id": "a3c6e8ee-51db-4e2a-abe4-ebb6c0f16a93", "fitness": -Infinity, "name": "DIASR", "description": "Refined DIASR with dynamic swarm resizing and enhanced local search for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                    if self.swarm_size < 20:  # Change 1: Dynamic swarm resizing\n                        self.swarm_size += 1\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n            if evaluations % (self.budget // 5) == 0:  # Change 2: Enhanced local search\n                self.local_search(func, global_best_position)\n        \n        return global_best_position, global_best_score\n\n    def local_search(self, func, position):  # Change 3, 4, 5: Added local search function\n        perturb = np.random.uniform(-0.1, 0.1, self.dim)\n        new_position = np.clip(position + perturb, self.lower_bound, self.upper_bound)\n        new_score = func(new_position)\n        if new_score < func(position):\n            return new_position\n        return position", "configspace": "", "generation": 96, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {}}
{"id": "faee847b-ffa8-4114-9803-141dd9643283", "fitness": 0.49935, "name": "DIASR", "description": "Enhanced DIASR with adaptive coefficients and chaos-based random perturbations for improved exploration and optimization stability.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n        self.chaotic_sequence = self.init_chaos_sequence()  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n    \n    def init_chaos_sequence(self):  # Added\n        return np.random.rand(self.budget)\n    \n    def chaotic_update(self, index):  # Added\n        return self.lower_bound + (self.upper_bound - self.lower_bound) * np.sin(np.pi * self.chaotic_sequence[index])\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                # Adaptive coefficients\n                self.cognitive_coeff = 1.4 + 0.1 * np.cos(2 * np.pi * evaluations / self.budget)  # Modified\n                self.social_coeff = 1.4 + 0.1 * np.sin(2 * np.pi * evaluations / self.budget)  # Modified\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                # Chaotic perturbation\n                if np.random.rand() < 0.2:  # Added\n                    positions[i] += self.chaotic_update(evaluations)  # Added\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 97, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.41 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 0.99795, 0.50005, 4.999999999999449e-05, 0.99795, 0.50005, 4.999999999999449e-05, 0.99795, 0.50005, 4.999999999999449e-05, 0.99795, 0.50005, 4.999999999999449e-05, 0.99795]}}
{"id": "feedbf5d-ee21-4fe0-8d2a-3df0c0664ae2", "fitness": 0.1667166666666666, "name": "DIASR", "description": "Enhanced DIASR with adaptive coefficients and dynamic swarm size for improved convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 15  # Changed\n        self.inertia_weight = 0.7  # Changed\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.99\n        \n        return global_best_position, global_best_score", "configspace": "", "generation": 98, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "126ec8c8-6dc7-4d53-97fd-4f6a5bdbc121", "fitness": 0.7196300574071426, "name": "DIASR", "description": "DIASR refinement by adjusting inertia weight decay for better convergence.", "code": "import numpy as np\n\nclass DIASR:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm_size = 10\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.4\n        self.social_coeff = 1.4\n        self.levy_exponent = 1.5  # Added\n\n    def levy_flight(self, size):  # Added\n        return np.random.standard_normal(size) * np.random.pareto(self.levy_exponent, size)\n\n    def __call__(self, func):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_scores = np.array([func(pos) for pos in positions])\n        \n        global_best_position = personal_best_positions[np.argmin(personal_best_scores)]\n        global_best_score = min(personal_best_scores)\n        \n        evaluations = self.swarm_size\n        \n        while evaluations < self.budget:\n            for i in range(self.swarm_size):\n                r1, r2 = np.random.random(2)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]))\n                \n                positions[i] = positions[i] + velocities[i] + self.levy_flight(self.dim)  # Modified\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                score = func(positions[i])\n                evaluations += 1\n                \n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i]\n\n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i]\n                \n                if evaluations >= self.budget:\n                    break\n\n            self.inertia_weight *= 0.98  # Changed from 0.99 to 0.98\n          \n        return global_best_position, global_best_score", "configspace": "", "generation": 99, "feedback": "The algorithm DIASR got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.37 on the real problem.", "error": "", "parent_ids": ["7413be75-e8e8-42d1-b221-0b7a4c39d579"], "operator": null, "metadata": {"aucs": [0.19021916520292492, 0.9812892041274316, 0.987381802891071]}}
