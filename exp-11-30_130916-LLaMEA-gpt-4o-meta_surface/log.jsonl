{"id": "35092873-0999-4989-a619-0e266c60cb2f", "fitness": 0.6883954703099041, "name": "HybridPSODE", "description": "A hybrid particle swarm and differential evolution algorithm combines exploration and exploitation for efficient search in high-dimensional spaces.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.7\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n        \n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # DE Update\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.42 on similar problems with similar landscape features.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.9985952190489574, 0.08985406365848825, 0.9767371282222668]}}
{"id": "128dde11-7123-47bc-9eff-e520572fa0ac", "fitness": 0.4250607458868945, "name": "HybridPSODE", "description": "Enhanced hybrid PSO with adaptive inertia weight and DE mutation strategies for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.F_base = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n        \n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update with adaptive inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (eval_count / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # DE Update with adaptive factor\n            F_adaptive = self.F_base * (1 + np.random.uniform(-0.1, 0.1))\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + F_adaptive * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.40 on similar problems with similar landscape features.", "error": "", "parent_ids": ["35092873-0999-4989-a619-0e266c60cb2f"], "operator": null, "metadata": {"aucs": [0.1464953627656176, 0.13603889087673737, 0.9926479840183288]}}
{"id": "886fb7a6-53a4-43da-be5d-cbb09f025134", "fitness": 0.7041022470260332, "name": "HybridPSODE", "description": "Introducing dynamic adjustment of the inertia weight to improve the balance between exploration and exploitation over time in the HybridPSODE algorithm.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9  # Changed from 0.7 to 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n        \n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (eval_count / self.budget) * 0.4  # Dynamically adjust inertia weight\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # DE Update\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.40 on similar problems with similar landscape features.", "error": "", "parent_ids": ["35092873-0999-4989-a619-0e266c60cb2f"], "operator": null, "metadata": {"aucs": [0.9743052588264872, 0.14356624739170698, 0.9944352348599057]}}
{"id": "34abb69f-3825-47b0-974e-8d5e6ea0f549", "fitness": 0.7098818486079844, "name": "HybridPSODE", "description": "Integrate adaptive learning strategies into HybridPSODE for enhanced convergence and stability.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n        \n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update with adaptive parameters\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (eval_count / self.budget) * 0.4  # Inertia weight\n            self.c1 = 1.5 + (eval_count / self.budget) * 0.5  # Increase cognitive component\n            self.c2 = 1.5 - (eval_count / self.budget) * 0.5  # Decrease social component\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # DE Update\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.39 on similar problems with similar landscape features.", "error": "", "parent_ids": ["886fb7a6-53a4-43da-be5d-cbb09f025134"], "operator": null, "metadata": {"aucs": [0.9776143834004107, 0.16124261132395257, 0.9907885510995895]}}
{"id": "54f0998d-f889-4f0f-ba97-3834acaf1cc7", "fitness": -Infinity, "name": "HybridPSODE", "description": "Enhance HybridPSODE with dynamic population size adjustment and hybrid crossover for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.dynamic_pop_size = True  # Enable dynamic population size adjustment\n\n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n        \n        evaluate_population()\n\n        while eval_count < self.budget:\n            if self.dynamic_pop_size:\n                self.population_size = max(5, int(0.5 * self.population_size + 0.5 * budget / eval_count))\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.8 - (eval_count / self.budget) * 0.3\n            self.c1 = 1.5 + (eval_count / self.budget) * 0.4\n            self.c2 = 1.5 - (eval_count / self.budget) * 0.4\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 4, "feedback": "An exception occurred: NameError(\"name 'budget' is not defined\").", "error": "NameError(\"name 'budget' is not defined\")", "parent_ids": ["34abb69f-3825-47b0-974e-8d5e6ea0f549"], "operator": null, "metadata": {}}
{"id": "30f8f957-ed30-4775-be2f-24b21209daa8", "fitness": 0.44279600754219856, "name": "HybridPSODE", "description": "Adjust the mutation factor `F` adaptively based on evaluation progress for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n        \n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update with adaptive parameters\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (eval_count / self.budget) * 0.4  # Inertia weight\n            self.c1 = 1.5 + (eval_count / self.budget) * 0.5  # Increase cognitive component\n            self.c2 = 1.5 - (eval_count / self.budget) * 0.5  # Decrease social component\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # DE Update\n            self.F = 0.8 - (eval_count / self.budget) * 0.3  # Adaptive mutation factor\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.F * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.35 on similar problems with similar landscape features.", "error": "", "parent_ids": ["34abb69f-3825-47b0-974e-8d5e6ea0f549"], "operator": null, "metadata": {"aucs": [0.9333139875609008, 0.13312293815163534, 0.2619510969140595]}}
{"id": "fdfaf143-f70d-49cb-a8d9-94291d8c55a4", "fitness": 0.9834642033456081, "name": "HybridPSODE", "description": "Introduce dynamic population size adjustment and adaptive mutation for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.initial_population_size = self.population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n    \n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n\n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update with adaptive parameters\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (eval_count / self.budget) * 0.4  # Inertia weight\n            self.c1 = 1.5 + (eval_count / self.budget) * 0.5  # Increase cognitive component\n            self.c2 = 1.5 - (eval_count / self.budget) * 0.5  # Decrease social component\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # Dynamic population size adjustment\n            new_population_size = int(self.initial_population_size * (1 - eval_count / self.budget))\n            if new_population_size < 5:\n                new_population_size = 5\n            if new_population_size != self.population_size:\n                self.population = self.population[:new_population_size]\n                self.velocities = self.velocities[:new_population_size]\n                self.pbest_positions = self.pbest_positions[:new_population_size]\n                self.pbest_scores = self.pbest_scores[:new_population_size]\n                self.population_size = new_population_size\n\n            # DE Update with adaptive mutation\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                F_adaptive = self.F + 0.2 * np.random.rand() * (1 - eval_count / self.budget)\n                mutant = np.clip(a + F_adaptive * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.98 with standard deviation 0.01 on similar problems with similar landscape features.", "error": "", "parent_ids": ["34abb69f-3825-47b0-974e-8d5e6ea0f549"], "operator": null, "metadata": {"aucs": [0.9890354104243915, 0.9882429987170108, 0.9731142008954223]}}
{"id": "1ef5e249-eadd-4105-b275-2fd5392499bb", "fitness": 0.7384510221825593, "name": "HybridPSODE", "description": "Enhance the strategy by dynamically adapting the crossover rate based on the evaluation count.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.initial_population_size = self.population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n    \n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n\n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update with adaptive parameters\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (eval_count / self.budget) * 0.4  # Inertia weight\n            self.c1 = 1.5 + (eval_count / self.budget) * 0.5  # Increase cognitive component\n            self.c2 = 1.5 - (eval_count / self.budget) * 0.5  # Decrease social component\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # Dynamic population size adjustment\n            new_population_size = int(self.initial_population_size * (1 - eval_count / self.budget))\n            if new_population_size < 5:\n                new_population_size = 5\n            if new_population_size != self.population_size:\n                self.population = self.population[:new_population_size]\n                self.velocities = self.velocities[:new_population_size]\n                self.pbest_positions = self.pbest_positions[:new_population_size]\n                self.pbest_scores = self.pbest_scores[:new_population_size]\n                self.population_size = new_population_size\n\n            # DE Update with adaptive mutation\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                F_adaptive = self.F + 0.2 * np.random.rand() * (1 - eval_count / self.budget)\n                mutant = np.clip(a + F_adaptive * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < (self.CR * (0.5 + 0.5 * eval_count / self.budget))\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.35 on similar problems with similar landscape features.", "error": "", "parent_ids": ["fdfaf143-f70d-49cb-a8d9-94291d8c55a4"], "operator": null, "metadata": {"aucs": [0.995356770820426, 0.23717396378820665, 0.9828223319390454]}}
{"id": "1c562886-322e-49ba-91bc-233d6c7e9fb7", "fitness": 0.2803616853326463, "name": "HybridPSODE", "description": "Introduce a gradual increase in the crossover rate (CR) for enhanced exploration throughout the optimization process.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.initial_population_size = self.population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n    \n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n\n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update with adaptive parameters\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (eval_count / self.budget) * 0.4  # Inertia weight\n            self.c1 = 1.5 + (eval_count / self.budget) * 0.5  # Increase cognitive component\n            self.c2 = 1.5 - (eval_count / self.budget) * 0.5  # Decrease social component\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # Dynamic population size adjustment\n            new_population_size = int(self.initial_population_size * (1 - eval_count / self.budget))\n            if new_population_size < 5:\n                new_population_size = 5\n            if new_population_size != self.population_size:\n                self.population = self.population[:new_population_size]\n                self.velocities = self.velocities[:new_population_size]\n                self.pbest_positions = self.pbest_positions[:new_population_size]\n                self.pbest_scores = self.pbest_scores[:new_population_size]\n                self.population_size = new_population_size\n\n            # DE Update with adaptive mutation\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                F_adaptive = self.F + 0.2 * np.random.rand() * (1 - eval_count / self.budget)\n                mutant = np.clip(a + F_adaptive * (b - c), self.bounds[0], self.bounds[1])\n                cross_points = np.random.rand(self.dim) < (self.CR + (0.1 * eval_count / self.budget))\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.04 on similar problems with similar landscape features.", "error": "", "parent_ids": ["fdfaf143-f70d-49cb-a8d9-94291d8c55a4"], "operator": null, "metadata": {"aucs": [0.33734053797190144, 0.2706498112184009, 0.23309470680763666]}}
{"id": "60af39af-97e1-4849-a779-b974ad7b9128", "fitness": 0.9914676310192198, "name": "HybridPSODE", "description": "Introduce adaptive crossover rate in the DE update to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = min(30, budget)\n        self.initial_population_size = self.population_size\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.w = 0.9\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n    \n    def __call__(self, func):\n        eval_count = 0\n\n        def evaluate_population():\n            nonlocal eval_count\n            scores = np.apply_along_axis(func, 1, self.population)\n            eval_count += self.population_size\n            for i in range(self.population_size):\n                if scores[i] < self.pbest_scores[i]:\n                    self.pbest_scores[i] = scores[i]\n                    self.pbest_positions[i] = self.population[i]\n                if scores[i] < self.gbest_score:\n                    self.gbest_score = scores[i]\n                    self.gbest_position = self.population[i]\n\n        evaluate_population()\n\n        while eval_count < self.budget:\n            # PSO Update with adaptive parameters\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            self.w = 0.9 - (eval_count / self.budget) * 0.4  # Inertia weight\n            self.c1 = 1.5 + (eval_count / self.budget) * 0.5  # Increase cognitive component\n            self.c2 = 1.5 - (eval_count / self.budget) * 0.5  # Decrease social component\n            self.velocities = (\n                self.w * self.velocities +\n                self.c1 * r1 * (self.pbest_positions - self.population) +\n                self.c2 * r2 * (self.gbest_position - self.population)\n            )\n            self.population += self.velocities\n            self.population = np.clip(self.population, self.bounds[0], self.bounds[1])\n\n            # Dynamic population size adjustment\n            new_population_size = int(self.initial_population_size * (1 - eval_count / self.budget))\n            if new_population_size < 5:\n                new_population_size = 5\n            if new_population_size != self.population_size:\n                self.population = self.population[:new_population_size]\n                self.velocities = self.velocities[:new_population_size]\n                self.pbest_positions = self.pbest_positions[:new_population_size]\n                self.pbest_scores = self.pbest_scores[:new_population_size]\n                self.population_size = new_population_size\n\n            # DE Update with adaptive mutation\n            for i in range(self.population_size):\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = self.population[np.random.choice(idxs, 3, replace=False)]\n                F_adaptive = self.F + 0.2 * np.random.rand() * (1 - eval_count / self.budget)\n                mutant = np.clip(a + F_adaptive * (b - c), self.bounds[0], self.bounds[1])\n                self.CR = 0.9 - (eval_count / self.budget) * 0.4  # Adaptive crossover rate\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n                score_trial = func(trial)\n                eval_count += 1\n                if score_trial < self.pbest_scores[i]:\n                    self.population[i] = trial\n                    self.pbest_scores[i] = score_trial\n                    self.pbest_positions[i] = trial\n                    if score_trial < self.gbest_score:\n                        self.gbest_score = score_trial\n                        self.gbest_position = trial\n                if eval_count >= self.budget:\n                    break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.99 with standard deviation 0.00 on the real problem.", "error": "", "parent_ids": ["fdfaf143-f70d-49cb-a8d9-94291d8c55a4"], "operator": null, "metadata": {"aucs": [0.987369224654882, 0.99438147859161, 0.9926521898111674]}}
