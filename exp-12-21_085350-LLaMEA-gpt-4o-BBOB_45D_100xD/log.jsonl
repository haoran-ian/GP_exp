{"id": "19b0eace-4051-4f14-ac22-1a0622aae824", "fitness": 0.055540342065557025, "name": "HybridMetaheuristic", "description": "A novel hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.scaling_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Simulated Annealing Acceptance Criteria\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n# The code above defines a hybrid optimization algorithm that uses both Differential Evolution for generating\n# candidate solutions and Simulated Annealing for probabilistic acceptance, which helps to escape local optima.", "configspace": "", "generation": 0, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05554 with standard deviation 0.05338.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.12397051707635987, 0.13458133856054066, 0.12399147422268952, 0.04169299523298875, 0.0378365974511673, 0.037123489379600416, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
