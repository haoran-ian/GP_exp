{"id": "929ca93a-2c4b-48d9-b2f6-ca152f3d67e8", "fitness": 0.070544651685554, "name": "HybridDE_SA", "description": "A novel hybrid differential evolution and simulated annealing algorithm with adaptive cooling for efficient exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 0, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07054 with standard deviation 0.06313.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.14809280789938262, 0.1480376458735827, 0.16396341540395853, 0.0007067966351362864, 0.0007061430181088957, 0.0008539210968044886, 0.05724332755638595, 0.05723974695820433, 0.058058060728422234]}}
{"id": "2e0a15a0-6176-4971-96db-28eca098cc75", "fitness": 0.06888191068333775, "name": "HybridDE_SA_Refined", "description": "Introduced adaptive mutation scaling and dynamic crossover probability in the hybrid differential evolution and simulated annealing algorithm to enhance exploration and convergence in black-box optimization tasks.", "code": "import numpy as np\n\nclass HybridDE_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_F = 0.5 + 0.5 * np.random.rand()  # Adaptive mutation factor\n            dynamic_CR = 0.7 + 0.3 * np.random.rand()  # Dynamic crossover rate\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive factor\n                mutant = x1 + adaptive_F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with dynamic probability\n                crossover_mask = np.random.rand(self.dim) < dynamic_CR\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 1, "feedback": "The algorithm HybridDE_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.1482090170508482, 0.148021822370498, 0.14972952992176214, 0.0007081687373569068, 0.0007059565084356345, 0.0007257659566487495, 0.05725084552991877, 0.05723872494395088, 0.05734736513062044]}}
{"id": "4f1666c6-198e-40e9-a642-be830f03b05a", "fitness": 0.07053299076548793, "name": "EnhancedHybridDE_SA", "description": "An enhanced Hybrid Differential Evolution and Simulated Annealing algorithm with dynamic population adaptation and nonlinear cooling schedule for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.initial_temperature = 100.0\n        self.final_temperature = 1.0\n        self.alpha = 0.005  # Nonlinear cooling parameter\n\n    def nonlinear_cooling(self, iteration):\n        return self.final_temperature + (self.initial_temperature - self.final_temperature) / (1 + self.alpha * iteration**2)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            self.temperature = self.nonlinear_cooling(iteration)\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Dynamic population size adaptation\n            if iteration % 10 == 0:\n                self.population_size = max(5, int(0.9 * self.population_size))\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n\n        return best_solution", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06312.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.1480116573894812, 0.14802197571662912, 0.1639627428379521, 0.0007058354486042528, 0.0007059582819789467, 0.0008539163658554116, 0.05723806194330816, 0.057238734671666514, 0.058058034233915645]}}
{"id": "4adc11a3-4f4f-4fa4-9adc-d3ebcbf288af", "fitness": 0.06888318326636031, "name": "HybridDE_SA", "description": "Enhancing mutation with non-linear scaling and adaptive crossover for improved exploration and convergence in hybrid DE-SA.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            scaling_factor = 0.5 + 0.5 * np.tanh(iteration / self.max_iterations * np.pi)  # Non-linear scaling\n            crossover_probability = 0.9 - 0.8 * (iteration / self.max_iterations)  # Adaptive crossover\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + scaling_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < crossover_probability\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 3, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14813237011139813, 0.14810656029303204, 0.14973204535414986, 0.0007072658770884699, 0.0007069618912229902, 0.0007257943965218727, 0.057245897987646455, 0.057244232174199716, 0.057347521311983285]}}
{"id": "e0749bc8-cfc1-4728-a100-a3e310892c3c", "fitness": 0.068667528208381, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive population size for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            if iteration % (self.max_iterations // 10) == 0:\n                population_size = max(3, population_size // 2)  # Adaptive population size reduction\n\n            for i in range(population_size):\n                indices = np.random.permutation(population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 4, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06867 with standard deviation 0.06096.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14780088192055496, 0.14798918814998108, 0.14954054070687517, 0.0004834660529215995, 0.0004857013113634956, 0.0005036556785784629, 0.057027117940140926, 0.05703936179566238, 0.057137840319350874]}}
{"id": "7fc5af1b-f2ea-43b0-a85d-30d04a594c2b", "fitness": 0.0688632876525977, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm incorporating adaptive mutation scaling and dynamic population resizing for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.dynamic_population = False\n        self.dynamic_population_threshold = 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Adaptive Mutation Scaling\n                if np.random.rand() < self.dynamic_population_threshold:\n                    self.mutation_factor = 0.8 + np.random.rand() * 0.2\n                mutant = x1 + self.mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Dynamic Population Resizing\n            if self.dynamic_population and iteration > self.max_iterations * 0.5:\n                self.population_size = max(5, self.population_size // 2)\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06093.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14801551437812466, 0.14805331706230807, 0.149735860778489, 0.000705881449534429, 0.0007063307674431973, 0.0007258375300761566, 0.05723831385426437, 0.05724077486593082, 0.0573477581872085]}}
{"id": "ed20121c-c4e0-4e86-9ac3-f4d40c2e0d0f", "fitness": 0.06886932323533827, "name": "HybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with a modified mutation factor for enhanced search capability.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with modified factor\n                mutant = x1 + 0.9 * (x2 - x3)  # Changed factor from 0.8 to 0.9\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 6, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.1480914556389733, 0.14803413335522242, 0.14972952992176214, 0.0007067821560411414, 0.0007061028243392498, 0.0007257659566487495, 0.05724324778383927, 0.0572395263505977, 0.05734736513062044]}}
{"id": "4d104a3f-16a3-4c47-bc47-c4d120be91f7", "fitness": 0.06887046234145676, "name": "HybridDE_SA", "description": "A novel hybrid differential evolution and simulated annealing algorithm with adaptive cooling and enhanced crossover probability for efficient exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.95  # Change: Increased crossover probability\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 7, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14812455639337796, 0.14801055555767395, 0.14972952992176214, 0.0007071750423981449, 0.0007058224554875592, 0.0007257659566487495, 0.057245399868438795, 0.057237990746703105, 0.05734736513062044]}}
{"id": "d076ba10-fa98-45d1-bb36-be4dbd61275c", "fitness": 0.07053207862560949, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with dynamic mutation and crossover rates for improved adaptability in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            # Introduce dynamic mutation factor\n            F = 0.5 + 0.3 * np.cos(np.pi * iteration / self.max_iterations)\n            # Introduce dynamic crossover rate\n            Cr = 0.9 - 0.5 * np.sin(np.pi * iteration / self.max_iterations)\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with dynamic rate\n                crossover_mask = np.random.rand(self.dim) < Cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 8, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14802059614368934, 0.14800541469569062, 0.1639627428379521, 0.000705941877458649, 0.0007057612274181668, 0.0008539163658554116, 0.057238644823772944, 0.05723765542473258, 0.058058034233915645]}}
{"id": "ec0a6d29-7126-44a7-911f-d09a87160cf9", "fitness": 0.06895779366086803, "name": "HybridDE_SA_Enhanced", "description": "An enhanced hybrid DE-SA algorithm with dynamic population size and adaptive mutation factor for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 + dim  # Dynamic population size\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.97  # Slightly adjusted cooling rate\n        self.mutation_factor = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + self.mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Adaptive mutation factor adjustment\n            self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 9, "feedback": "The algorithm HybridDE_SA_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06896 with standard deviation 0.06104.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14812722185144456, 0.148737467829559, 0.14973085560954713, 0.0007072048917181606, 0.0007142725229938307, 0.0007257809454254138, 0.057245563898411844, 0.057284327955593906, 0.05734744744311848]}}
{"id": "60ecb4cd-5c2f-4d07-8035-e6214537efa1", "fitness": 0.06886293393227585, "name": "HybridDE_SA", "description": "Enhanced hybrid differential evolution and simulated annealing with adaptive mutation factor and dynamic cooling for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Changed cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive factor\n                F = 0.5 + 0.4 * np.random.rand()  # Adaptive mutation factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling with dynamic adjustment\n            self.temperature *= (self.cooling_rate + 0.01 * np.random.rand())  # Dynamic cooling adjustment\n\n        return best_solution", "configspace": "", "generation": 10, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06093.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14804828332009912, 0.14802390082578898, 0.14972952992176214, 0.0007062711058679616, 0.0007059811523090209, 0.0007257659566487495, 0.057240448036389946, 0.05723885994099631, 0.05734736513062044]}}
{"id": "4e90a4e5-7341-4c8d-9727-21491fec15ab", "fitness": 0.06865887268435404, "name": "ImprovedHybridDE_SA", "description": "An enhanced HybridDE_SA algorithm incorporating adaptive mutation scaling and dynamic population resizing to improve convergence and diversity in black-box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            # Dynamic adjustment of mutation factor and population size\n            mutation_factor = 0.5 + 0.5 * np.cos(np.pi * iteration / self.max_iterations)\n            population_size = int(self.initial_population_size - (self.initial_population_size * iteration / self.max_iterations))\n            population = population[:population_size]\n            fitness = fitness[:population_size]\n\n            for i in range(population_size):\n                indices = np.random.permutation(population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 11, "feedback": "The algorithm ImprovedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06866 with standard deviation 0.06095.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14791145420620944, 0.1478045736306972, 0.1495422425629218, 0.00048477989045447867, 0.0004835100161043604, 0.0005036749201691171, 0.057034314234193695, 0.05702735871138631, 0.05713794598704991]}}
{"id": "16cbefad-cd7a-4bab-a03d-4e43817b0dfd", "fitness": 0.06895888706759479, "name": "EnhancedHybridDE_SA", "description": "Enhanced HybridDE_SA: Incorporates adaptive mutation and dynamic crossover to improve exploration and convergence rates in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.98  # Slightly more aggressive cooling\n        self.cr_min = 0.5\n        self.cr_max = 0.9\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx].copy()\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.choice(np.delete(np.arange(self.population_size), i), 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Adaptive Differential Evolution Mutation\n                F = 0.5 + (0.5 * np.random.rand())  # Adaptive mutation factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover Rate\n                cr = self.cr_min + (self.cr_max - self.cr_min) * (best_fitness / (fitness[i] + 1e-8))\n                crossover_mask = np.random.rand(self.dim) < cr\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial.copy()\n                    best_fitness = trial_fitness\n\n            # Cooling\n            temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06896 with standard deviation 0.06106.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14819687697048534, 0.1487315418202403, 0.14973836970640186, 0.0007061790953367675, 0.0007058399024411077, 0.0007258658905486826, 0.057239399769572374, 0.05723799651886596, 0.057347913934460704]}}
{"id": "88a908e8-31ec-4646-9ba7-bd67b1019cee", "fitness": 0.06886019009390036, "name": "HybridDE_SA", "description": "Enhanced Hybrid Differential Evolution with Adaptive Mutation and Cooling for Improved Exploration-Exploitation Balance in Black-Box Optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Slightly increased cooling rate\n        self.mutation_factor = 0.7  # Added mutation factor for diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive factor\n                mutant = x1 + self.mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with adjusted rate\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    # Adaptive mutation factor based on success\n                    self.mutation_factor *= (1 + 0.1 * (trial_fitness < best_fitness))\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling with dynamic adjustment\n            self.temperature *= self.cooling_rate * (1 + 0.01 * (iteration / self.max_iterations))\n\n        return best_solution", "configspace": "", "generation": 13, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06093.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14799664424407444, 0.14805261236017064, 0.14972952992176214, 0.0007056568607571867, 0.0007063225805928885, 0.0007257659566487495, 0.05723708382202086, 0.05724072996845586, 0.05734736513062044]}}
{"id": "37c4cca5-73ae-44a9-a4c6-b8dde00a0c1e", "fitness": 0.07053352029580229, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with dynamic crossover rate adjustment based on iteration progress for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with dynamic rate\n                crossover_rate = 0.9 - 0.8 * (iteration / self.max_iterations)  # Changed line\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 14, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06312.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.1479997695589691, 0.14803406802238306, 0.16396708701434703, 0.0007056940699780023, 0.0007061020446023081, 0.0008539469196037208, 0.057237287605928944, 0.05723952208052585, 0.058058205345882574]}}
{"id": "befb5884-b5d2-43d1-8234-ed1b30ab0410", "fitness": 0.06886609222595368, "name": "HybridDE_SA", "description": "Refined hybrid differential evolution and simulated annealing algorithm with enhanced exploratory potential via adaptive crossover probability.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive probability\n                crossover_prob = 0.6 + (0.9 - 0.6) * (iteration / self.max_iterations) # Enhanced line\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 15, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06093.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.1480883438697682, 0.1480102695142379, 0.14972952992176214, 0.0007067410528727169, 0.0007058189826930628, 0.0007257659566487495, 0.05724302385723745, 0.05723797174774237, 0.05734736513062044]}}
{"id": "3277c546-b959-49ac-89a3-3ebf1efb37a5", "fitness": 0.06886906431173176, "name": "HybridDE_SA", "description": "A novel hybrid differential evolution and simulated annealing algorithm with dynamic scaling factor adjustment and adaptive crossover probability for efficient exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            scale_factor = 0.5 + 0.5 * (1 - iteration / self.max_iterations)  # Dynamic scaling factor\n            crossover_prob = 0.9 - 0.5 * (iteration / self.max_iterations)   # Adaptive crossover probability\n            \n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n                \n                # Differential Evolution Mutation\n                mutant = x1 + scale_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 16, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14803215577098172, 0.14809128868287402, 0.14972952992176214, 0.0007060770959400609, 0.0007067790518712203, 0.0007257659566487495, 0.057239386083940746, 0.05724323111094676, 0.05734736513062044]}}
{"id": "34d22577-bd35-432f-8c3e-2e46e236277d", "fitness": 0.07054084418736668, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with adaptive parameter control and elitism to improve exploration and solution refinement in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.99\n        \n        # Adaptive parameters\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.temperature = self.initial_temperature\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with Adaptive Control\n                mutant = x1 + self.mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with Adaptive Control\n                crossover_mask = np.random.rand(self.dim) < self.crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance with Elitism\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n                    \n            # Cooling\n            self.temperature *= self.cooling_rate\n            \n            # Adaptive control of parameters\n            self.mutation_factor = 0.5 + 0.3 * np.cos(iteration * np.pi / self.max_iterations)\n            self.crossover_rate = 0.7 + 0.2 * np.sin(iteration * np.pi / self.max_iterations)\n\n        return best_solution", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07054 with standard deviation 0.06312.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14804341754480044, 0.14805365869346998, 0.1639649951952381, 0.0007062127449197764, 0.0007063344836333307, 0.0008539322084138989, 0.05724012853623184, 0.05724079532154147, 0.05805812295805135]}}
{"id": "c17001d0-b73c-414a-b0e8-640154a1b2bf", "fitness": 0.07053038555691199, "name": "HybridDE_SA", "description": "Enhance the exploration capacity of HybridDE_SA by incorporating non-uniform mutation and adaptive crossover probability for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Non-uniform Mutation\n                tau = 0.8 * (1 - iteration / self.max_iterations)\n                mutant = x1 + tau * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                crossover_probability = 0.9 - 0.5 * (iteration / self.max_iterations)\n                crossover_mask = np.random.rand(self.dim) < crossover_probability\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 18, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14800278929560418, 0.1480090746407966, 0.1639627428379521, 0.0007057300128441302, 0.0007058046878692936, 0.0008539163658554116, 0.05723748445819388, 0.05723789347917674, 0.058058034233915645]}}
{"id": "04ef9f95-75ce-4c65-a654-a4c222469f31", "fitness": 0.06866388425624541, "name": "HybridDE_SA", "description": "Enhanced hybrid algorithm with dynamic population scaling and adaptive mutation for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adapted_population_size = max(3, self.population_size // 2)  # Dynamic population scaling\n            for i in range(adapted_population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                F = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 19, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06866 with standard deviation 0.06095.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14786660292903375, 0.14789299676715484, 0.14954054070688738, 0.00048424752497822077, 0.0004845610104231568, 0.0005036556785792401, 0.05703139813743152, 0.057033115232349774, 0.05713784031937075]}}
{"id": "22fd4215-1767-49b5-8972-066964b89fb8", "fitness": 0.06885637876749197, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with adaptive mutation scaling and dynamic cooling to improve convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.final_temperature = 1.0\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            current_temperature = self.initial_temperature * ((self.final_temperature / self.initial_temperature) ** (iteration / self.max_iterations))\n            adaptive_mutation_factor = self.mutation_factor + 0.2 * (1 - iteration / self.max_iterations)\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Differential Evolution Mutation with Adaptive Mutation Factor\n                mutant = x1 + adaptive_mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                delta_fitness = fitness[i] - trial_fitness\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp(delta_fitness / current_temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n        return best_solution", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06092.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.1479903872603694, 0.14802667257606483, 0.14972987952748107, 0.0007055823595871757, 0.0007060141215026183, 0.0007257699094855852, 0.0572366758016043, 0.057239040513507145, 0.05734738683782559]}}
{"id": "39accfe9-5e0c-4679-be3c-15c6a6dec846", "fitness": 0.0703331560837194, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with dynamic population size adjustment and adaptive mutation scaling for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.mutation_scaling_factor = 0.8\n        self.min_population_size = 4\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            for i in range(population_size):\n                indices = np.random.permutation(population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Dynamic Mutation Scaling\n                dynamic_scaling_factor = self.mutation_scaling_factor * (1 - iteration / self.max_iterations)\n                mutant = x1 + dynamic_scaling_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Dynamic Population Size Adjustment\n            population_size = max(self.min_population_size, int(self.initial_population_size * (1 - iteration / self.max_iterations)))\n            if population_size < len(population):\n                population = population[:population_size]\n                fitness = fitness[:population_size]\n\n        return best_solution", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07033 with standard deviation 0.06314.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14786169578382635, 0.14784931096300413, 0.16377729246272565, 0.0004841891421146771, 0.00048404192298101556, 0.0006318379501050186, 0.05703107837858379, 0.057030272032032814, 0.05784868611810112]}}
{"id": "1d13beb4-6a61-4809-8c64-36a301cdba5c", "fitness": 0.07056476980737351, "name": "HybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with a dynamically adjusted crossover rate for improved exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 22, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07056 with standard deviation 0.06315.", "error": "", "parent_ids": ["929ca93a-2c4b-48d9-b2f6-ca152f3d67e8"], "operator": null, "metadata": {"aucs": [0.14826114405480362, 0.14803821481078094, 0.1639627428379521, 0.0007087732726227536, 0.0007061510489914102, 0.0008539163658554116, 0.05725416106893677, 0.05723979057250295, 0.058058034233915645]}}
{"id": "e97caf56-774f-45f7-8709-d3b59c5d4719", "fitness": 0.06921175526973003, "name": "EnhancedHybridDE_SA", "description": "Enhanced HybridDE_SA with a dynamic population size adjustment and adaptive mutation strategy for improved convergence and diversity balance.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_mutation_factor = 0.5 + 0.5 * (iteration / self.max_iterations)  # Adaptive mutation strength\n            dynamic_population_factor = 1.0 - (iteration / self.max_iterations)  # Dynamic population size adjustment\n\n            # Dynamically adjust population size\n            self.population_size = int(self.initial_population_size * dynamic_population_factor) or 1\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.initial_population_size)[:3]\n                x1, x2, x3 = population[indices]\n\n                # Differential Evolution Mutation with Adaptive Mutation Factor\n                mutant = x1 + adaptive_mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06921 with standard deviation 0.06162.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.15249968684584347, 0.14786798080542451, 0.14954441365671178, 0.0005335052202806168, 0.0004842633158265164, 0.000503699465614571, 0.05730268253542048, 0.05703148480027209, 0.05713808078217619]}}
{"id": "99124220-2e66-4890-a592-0f2557680b65", "fitness": 0.07053869893792634, "name": "HybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with an optimized initial temperature for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 50.0  # Modified initial temperature for better convergence\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 24, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07054 with standard deviation 0.06312.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1480478053265455, 0.1480332987292471, 0.16396298743270932, 0.0007062643566090321, 0.0007060923115183027, 0.0008539180863090801, 0.057240411384337775, 0.05723946894483234, 0.05805804386922864]}}
{"id": "1ff12d58-6a93-4c06-b5e7-4d57682e4fe4", "fitness": 0.07032993895202161, "name": "EnhancedHybridDE_SA", "description": "A hybrid differential evolution and simulated annealing algorithm enhanced with a stochastic tunneling strategy to escape local optima and an adaptive population size to balance exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.adaptive_population_size = self.initial_population_size\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            self.adaptive_population_size = max(4, int(self.initial_population_size * (1 - iteration / self.max_iterations)))\n\n            for i in range(self.adaptive_population_size):\n                indices = np.random.permutation(self.initial_population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance with Stochastic Tunneling\n                trial_fitness = func(trial)\n                delta = fitness[i] - trial_fitness\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp(min(0, delta / self.temperature)):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07033 with standard deviation 0.06313.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14781490834831934, 0.14786657340195541, 0.16378001042363233, 0.0004836330446305048, 0.00048424704521254913, 0.0006318570672828594, 0.057028032508796955, 0.05703139554745573, 0.05784879318090885]}}
{"id": "400768a5-4e5d-4fda-8e9c-326d97490f62", "fitness": 0.06900718790571912, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm integrating adaptive mutation scaling and population diversity maintenance for superior exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            mutation_scale = 0.8 + 0.2 * (np.std(fitness) / np.mean(fitness))  # Adaptive mutation scale based on population diversity\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling\n                mutant = x1 + mutation_scale * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06901 with standard deviation 0.06112.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14921243328167277, 0.148138634685682, 0.14973225858398564, 0.0007088512104003186, 0.0007056462185988099, 0.0007257770773996253, 0.057256420403479, 0.057237243632432655, 0.05734742605782128]}}
{"id": "8e1a3987-5306-4ebf-828c-ce84f50ce9c0", "fitness": 0.07056476980737351, "name": "EnhancedHybridDE_SA", "description": "Enhanced Hybrid Differential Evolution and Simulated Annealing with Adaptive Population Reinitialization for improved exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.reinitialization_threshold = 0.1  # Fraction of max_iterations for reinitialization\n        self.stagnation_counter = 0\n        self.best_fitness_history = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        \n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            \n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Track progress and check for stagnation\n            self.best_fitness_history.append(best_fitness)\n            if len(self.best_fitness_history) > 5:\n                if np.std(self.best_fitness_history[-5:]) < 1e-5:\n                    self.stagnation_counter += 1\n                else:\n                    self.stagnation_counter = 0\n\n            # Reinitialization if stagnation is detected\n            if self.stagnation_counter > self.reinitialization_threshold * self.max_iterations:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.stagnation_counter = 0\n\n        return best_solution", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07056 with standard deviation 0.06315.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14826114405480362, 0.14803821481078094, 0.1639627428379521, 0.0007087732726227536, 0.0007061510489914102, 0.0008539163658554116, 0.05725416106893677, 0.05723979057250295, 0.058058034233915645]}}
{"id": "550e10f0-9f57-40a8-b3fc-0b59f7204ed2", "fitness": 0.07032499190112049, "name": "HybridDE_SA_v2", "description": "HybridDE_SA_v2: Enhanced hybrid differential evolution with simulated annealing, utilizing adaptive population size and multi-phase cooling for optimized search balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.min_population_size = 4 * dim  # adaptive population size\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            for i in range(population_size):\n                indices = np.random.permutation(population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            self.temperature *= self.cooling_rate\n\n            # Adaptive Population Size Reduction\n            if iteration % (self.max_iterations // 3) == 0 and population_size > self.min_population_size:\n                population_size = max(self.min_population_size, int(population_size * 0.8))\n                population, fitness = self._reduce_population(population, fitness, population_size)\n\n        return best_solution\n\n    def _reduce_population(self, population, fitness, new_size):\n        sorted_indices = np.argsort(fitness)\n        return population[sorted_indices[:new_size]], fitness[sorted_indices[:new_size]]", "configspace": "", "generation": 28, "feedback": "The algorithm HybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07032 with standard deviation 0.06313.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14781039518808603, 0.14782725953743303, 0.16378256827598348, 0.0004835793228922247, 0.0004837800228947309, 0.0006318750571311371, 0.05702773828601637, 0.05702883748893628, 0.05784889393071113]}}
{"id": "ca9cf8a0-8e79-441a-a42e-19fb57fffd92", "fitness": 0.07054040051248998, "name": "HybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with a dynamically adjusted crossover rate for improved exploration and exploitation in black-box optimization, with a stabilized adaptive crossover rate.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.4 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 29, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07054 with standard deviation 0.06312.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14809978827237957, 0.14799410855467754, 0.16396446257019393, 0.0007068808993451192, 0.0007056266734667416, 0.0008539284618990228, 0.05724378871046676, 0.05723691849396528, 0.05805810197601591]}}
{"id": "fedfca0b-aa56-477b-8fa5-a25aca218efc", "fitness": 0.06902441807784798, "name": "HybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with improved parameter adaptation for better convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.95 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 30, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06902 with standard deviation 0.06112.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1494136718724305, 0.14801055555767395, 0.14972952992176214, 0.0007220516902832763, 0.0007058224554875592, 0.0007257659566487495, 0.05732700936902213, 0.057237990746703105, 0.05734736513062044]}}
{"id": "87b8d213-8387-48c1-9870-46201822fe45", "fitness": 0.0705315287831583, "name": "HybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with a dynamically adjusted crossover and mutation rate for improved exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutation_factor = 0.8 + 0.2 * (iteration / self.max_iterations) # Adjusted mutation factor\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 31, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479997695589691, 0.14802157526047355, 0.16396281826881753, 0.0007056940699780023, 0.0007059532080709863, 0.0008539168964468713, 0.057237287605928944, 0.05723870697436462, 0.05805803720537506]}}
{"id": "f7213f95-edd4-4a8a-8867-0faafd92894a", "fitness": 0.06892061106186184, "name": "HybridDE_ALS", "description": "A novel hybrid differential evolution with adaptive local search using elite-guided perturbation and dynamically adjusted mutation rate for enhanced convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temp = 100.0\n        self.cooling_rate = 0.98\n        self.elite_ratio = 0.1\n        self.mutation_factor_base = 0.8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            temperature = self.initial_temp * (self.cooling_rate ** iteration)\n            elite_count = max(1, int(self.elite_ratio * self.population_size))\n            sorted_indices = np.argsort(fitness)\n            elite_indices = sorted_indices[:elite_count]\n            adaptive_mutation_factor = self.mutation_factor_base * (1 - iteration / self.max_iterations)\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2 = population[indices[:2]]\n\n                # Elite Guided Perturbation: Combine with elite solutions\n                elite_idx = np.random.choice(elite_indices)\n                mutant = x1 + adaptive_mutation_factor * (x2 - population[elite_idx])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < 0.9\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Adaptive Local Search Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n        return best_solution", "configspace": "", "generation": 32, "feedback": "The algorithm HybridDE_ALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06892 with standard deviation 0.06100.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.148354463867996, 0.14812342960904668, 0.14980629519613609, 0.0007098742906024302, 0.0007071621976623144, 0.0007266315835899873, 0.05726019396876092, 0.05724532935432014, 0.05735211948864205]}}
{"id": "ccf34dbf-a4d5-47b4-81b8-d82db64aaf9e", "fitness": 0.06923759713675061, "name": "HybridDE_SA_Enhanced", "description": "A dynamically balanced hybrid differential evolution and simulated annealing algorithm with adaptive scaling factors and temperature schedules for better convergence in diverse black-box optimization tasks.", "code": "import numpy as np\n\nclass HybridDE_SA_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 1.0\n        self.cooling_rate = 0.95\n        self.scaling_factor = 0.8\n        self.temperature_schedule = np.linspace(1.0, 0.01, self.max_iterations)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            self.scaling_factor = 0.8 - 0.5 * np.cos(np.pi * iteration / self.max_iterations)  # Adaptive scaling factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling factor\n                mutant = x1 + self.scaling_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature_schedule[iteration]):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n        return best_solution", "configspace": "", "generation": 33, "feedback": "The algorithm HybridDE_SA_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06924 with standard deviation 0.06138.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.15112025658199246, 0.14809596541646475, 0.14972952992176214, 0.0007405104061040113, 0.0007068359248811884, 0.0007257659566487495, 0.05742860265291261, 0.057243542239369116, 0.05734736513062044]}}
{"id": "0cae41de-e2ac-4a05-b15c-4def6b65d131", "fitness": 0.0705315287831583, "name": "HybridDE_SA", "description": "An enhanced HybridDE_SA with adaptive mutation scaling and a refined cooling schedule for improved convergence and performance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Changed cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            adaptive_mutation_scale = 0.8 + 0.2 * (iteration / self.max_iterations)  # Adaptive mutation scale\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + adaptive_mutation_scale * (x2 - x3)  # Updated line\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate  # Changed cooling rate\n\n        return best_solution", "configspace": "", "generation": 34, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479997695589691, 0.14802157526047355, 0.16396281826881753, 0.0007056940699780023, 0.0007059532080709863, 0.0008539168964468713, 0.057237287605928944, 0.05723870697436462, 0.05805803720537506]}}
{"id": "8facfadc-9526-4903-93fd-394e23ce00c6", "fitness": 0.06890120328039649, "name": "HybridDE_SA", "description": "An improved hybrid differential evolution and simulated annealing algorithm, employing an adaptive scaling factor for better exploration and exploitation balance in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                scaling_factor = 0.5 + 0.3 * (iteration / self.max_iterations)  # Adaptive scaling factor\n                mutant = x1 + scaling_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 35, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06890 with standard deviation 0.06098.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14836702202234298, 0.14802200774947094, 0.14973283645102375, 0.0007100009329634727, 0.0007059585118586176, 0.0007258033402562925, 0.05726089411196256, 0.057238735975863375, 0.057347570427826455]}}
{"id": "3235713a-1d10-4fbe-a11e-0a619f016dfd", "fitness": 0.06888005275208267, "name": "EnhancedHybridDE_SA", "description": "Enhanced hybrid differential evolution with adaptive simulated annealing integrating population diversity and elitism for robust black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.99\n        self.elitism_rate = 0.1  # Percentage of elite individuals to retain\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            num_elites = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            elites = population[elite_indices]\n\n            for i in range(self.population_size):\n                if i not in elite_indices:\n                    indices = np.random.permutation(self.population_size)\n                    x1, x2, x3 = population[indices[:3]]\n\n                    # Differential Evolution Mutation\n                    mutant = x1 + 0.8 * (x2 - x3)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    # Crossover\n                    crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                    trial = np.where(crossover_mask, mutant, population[i])\n                    \n                    # Diversity enhancement by random perturbation\n                    if np.random.rand() < 0.1:\n                        trial += np.random.normal(0, 0.1, self.dim)\n\n                    # Simulated Annealing Acceptance\n                    trial_fitness = func(trial)\n                    acceptance_prob = np.exp((fitness[i] - trial_fitness) / temperature)\n                    if trial_fitness < fitness[i] or np.random.rand() < acceptance_prob:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n\n                    # Update best solution found\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Ensure elitism by maintaining elite individuals\n            population[:num_elites] = elites\n\n            # Cooling\n            temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14820366719781652, 0.14801160016270876, 0.14972952992176214, 0.0007081132881501251, 0.0007058348778185008, 0.0007257659566487495, 0.057250539448181925, 0.05723805878503685, 0.05734736513062044]}}
{"id": "bfd9b421-a479-4672-8adb-ceb06479c4be", "fitness": 0.0697588235070113, "name": "HybridDE_SA", "description": "An enhanced hybrid differential evolution with simulated annealing incorporating dynamic scaling factors for mutation and optimized cooling rates for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with dynamic scaling factor\n                F = 0.8 + 0.2 * (best_fitness - fitness[i]) / (fitness[np.argmax(fitness)] - fitness[np.argmin(fitness)])\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 37, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06976 with standard deviation 0.06203.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14894231112297585, 0.15467625025964205, 0.14972952992176214, 0.0007055808309489597, 0.0007761474546257308, 0.0007257659566487495, 0.05723839440582257, 0.05768806648005531, 0.05734736513062044]}}
{"id": "e550430c-241b-4572-9396-a8cc64fcd24e", "fitness": 0.07053939018504621, "name": "HybridDE_SA", "description": "An improved hybrid differential evolution and simulated annealing algorithm with a refined adaptive crossover strategy for enhanced exploration in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.7 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 38, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07054 with standard deviation 0.06312.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1480093640974096, 0.14807776074789747, 0.1639627428379521, 0.0007058082516739894, 0.0007066188242381699, 0.0008539163658554116, 0.0572379129623255, 0.057242353344147956, 0.058058034233915645]}}
{"id": "e514794c-db42-449e-8f9e-dc7796a84bd6", "fitness": 0.06891032668507881, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with adaptive mutation scaling and a linear temperature reduction schedule for superior convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.final_temperature = 1.0\n        self.temperature = self.initial_temperature\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            mutation_scaling = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation scaling factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling\n                mutant = x1 + mutation_scaling * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Linear Cooling\n            self.temperature = self.initial_temperature - (self.initial_temperature - self.final_temperature) * (iteration / self.max_iterations)\n\n        return best_solution", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06891 with standard deviation 0.06099.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14818443425758632, 0.14828373648268445, 0.14972984880048223, 0.0007078844514659677, 0.0007090291839637608, 0.0007257695621800675, 0.05724928612884628, 0.057255566368213384, 0.05734738493028679]}}
{"id": "4bf3b2ec-d1a5-46eb-becd-f5f366149977", "fitness": 0.06891032668507881, "name": "HybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with an adaptive mutation factor and cooling schedule for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Modified cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            mutation_factor = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 40, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06891 with standard deviation 0.06099.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14818443425758632, 0.14828373648268445, 0.14972984880048223, 0.0007078844514659677, 0.0007090291839637608, 0.0007257695621800675, 0.05724928612884628, 0.057255566368213384, 0.05734738493028679]}}
{"id": "fcc6d859-038f-4a3c-b9eb-e44f87135bd1", "fitness": 0.06885569837776967, "name": "HybridDE_SA", "description": "Enhanced hybrid algorithm by introducing a dynamic mutation factor for improved diversity and convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            dynamic_mutation_factor = 0.5 + 0.3 * np.sin(2 * np.pi * iteration / self.max_iterations)  # Dynamic mutation factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + dynamic_mutation_factor * (x2 - x3)  # Updated mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 41, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06092.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479902588921238, 0.14800910764175634, 0.1497419281419431, 0.0007055808309489597, 0.0007058052187300934, 0.0007259061067972361, 0.05723666742958311, 0.0572378963458513, 0.05734813479219314]}}
{"id": "43089482-e30c-43c9-a61d-888884b4c580", "fitness": 0.06888440981682784, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive scaling factor for refined exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_scaling_factor = 0.6 + 0.4 * (iteration / self.max_iterations)  # New adaptive scaling factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + adaptive_scaling_factor * (x2 - x3)  # Adjusted scaling factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 42, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06096.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14799199746094538, 0.1482597367234837, 0.14972952992176214, 0.0007056015338318122, 0.000708770253933455, 0.0007257659566487495, 0.05723678081238037, 0.0572541405578445, 0.05734736513062044]}}
{"id": "17d05350-3c9f-4f9a-9193-a305df1d795b", "fitness": 0.06887284004543842, "name": "EnhancedHybridDE_SA", "description": "Enhanced hybrid differential evolution and simulated annealing with elitism and adaptable population diversity to improve convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.elitism_rate = 0.1  # Rate for elitism\n\n    def __call__(self, func):\n        # Initialize population and evaluate fitness\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            elite_count = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            new_population = population[elite_indices]  # Keep elite solutions\n\n            while len(new_population) < self.population_size:\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + np.random.uniform(0.5, 1.0) * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[indices[0]])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[indices[0]] or np.random.rand() < np.exp((fitness[indices[0]] - trial_fitness) / self.temperature):\n                    new_population = np.vstack([new_population, trial])\n                \n                # If budget allows, evaluate trial and consider for best solution\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            population = new_population\n            fitness = np.array([func(ind) for ind in population])\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14808949162306484, 0.14806488732802114, 0.14973012552874732, 0.0007067605271772193, 0.0007064675440162649, 0.0007257726907999862, 0.05724312881437821, 0.05724152424086704, 0.057347402111873724]}}
{"id": "a753a143-d158-47e4-96bf-a0333cdecc75", "fitness": 0.06885241302193781, "name": "ImprovedHybridDE_SA", "description": "A novel hybrid differential evolution and simulated annealing algorithm with adaptive mutation scale factor and temperature for enhanced convergence in black-box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.temperature = self.initial_temperature\n        self.cooling_rate = 0.98\n        self.mutation_factor = 0.8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_mutation = self.mutation_factor + 0.2 * (1 - iteration / self.max_iterations)\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive mutation factor\n                mutant = x1 + adaptive_mutation * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance with adaptive temperature\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling with an adaptive cooling schedule\n            self.temperature = self.initial_temperature * (self.cooling_rate ** (iteration / self.max_iterations))\n\n        return best_solution", "configspace": "", "generation": 44, "feedback": "The algorithm ImprovedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06885 with standard deviation 0.06092.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479902588921238, 0.14799401135550883, 0.14972952992176214, 0.0007055808309489597, 0.0007056255174894277, 0.0007257659566487495, 0.05723666742958311, 0.05723691216275484, 0.05734736513062044]}}
{"id": "b063594c-96b0-44af-9c20-e860ff96b0b5", "fitness": 0.06890120328039649, "name": "HybridDE_SA", "description": "Enhanced hybrid differential evolution with simulated annealing, incorporating adaptive mutation scaling for improved search efficiency.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive factor\n                F = 0.5 + 0.3 * (iteration / self.max_iterations)  # Adaptive mutation scaling factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 45, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06890 with standard deviation 0.06098.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14836702202234298, 0.14802200774947094, 0.14973283645102375, 0.0007100009329634727, 0.0007059585118586176, 0.0007258033402562925, 0.05726089411196256, 0.057238735975863375, 0.057347570427826455]}}
{"id": "debe7458-ed81-4045-8449-74ed6471a586", "fitness": 0.06887674090526862, "name": "EnhancedHybridDE_SA", "description": "A hybrid differential evolution and simulated annealing algorithm enhanced with opposition-based learning and adaptive mutation scaling for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def opposition_based_learning(self, population):\n        # Generate opposition-based population\n        return self.lower_bound + self.upper_bound - population\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        # Apply opposition-based learning\n        opposition_population = self.opposition_based_learning(population)\n        opposition_fitness = np.array([func(ind) for ind in opposition_population])\n        for i in range(self.population_size):\n            if opposition_fitness[i] < fitness[i]:\n                population[i] = opposition_population[i]\n                fitness[i] = opposition_fitness[i]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_mutation_factor = 0.8 * (1 - iteration / self.max_iterations)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling\n                mutant = x1 + adaptive_mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1480249126575678, 0.1481604062527735, 0.1497318243336112, 0.0007059932157422733, 0.0007075965086145164, 0.000725791897408512, 0.05723892600459857, 0.057247709689496884, 0.05734750758760432]}}
{"id": "cbcef7ac-ddfa-4c34-a928-3cbce9dd7e63", "fitness": 0.06886906431173176, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive mutation scaling for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling\n                F = 0.5 + 0.5 * (1 - iteration / self.max_iterations)\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 47, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14803215577098172, 0.14809128868287402, 0.14972952992176214, 0.0007060770959400609, 0.0007067790518712203, 0.0007257659566487495, 0.057239386083940746, 0.05724323111094676, 0.05734736513062044]}}
{"id": "d78a72aa-35d2-4a06-9e3d-3fb2de58d4bb", "fitness": 0.06886872255801256, "name": "HybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with improved mutation scaling and adaptive cooling for enhanced exploration and convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Slightly adjusted cooling rate for better convergence\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                F = 0.9  # Increased mutation scaling factor for enhanced exploration\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 48, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14802679918148787, 0.14809378204110535, 0.14972952992176214, 0.0007060157043377036, 0.000706807686263744, 0.0007257659566487495, 0.05723904916007738, 0.05724338823980968, 0.05734736513062044]}}
{"id": "df6ec061-38c2-4312-aae7-9d8af542c6c3", "fitness": 0.06889744295634101, "name": "AdvancedHybridDE_SA", "description": "A novel adaptive hybrid differential evolution algorithm with simulated annealing using a dynamically regulated mutation factor based on population diversity for enhanced convergence in black-box optimization.", "code": "import numpy as np\n\nclass AdvancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            diversity = np.std(population, axis=0).mean()\n            mutation_factor = 0.5 + diversity / 10  # Dynamically regulated mutation factor\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive mutation factor\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 49, "feedback": "The algorithm AdvancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06890 with standard deviation 0.06097.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14834628217843981, 0.1480141433547535, 0.14972977606787508, 0.0007097944595861883, 0.0007058651493987433, 0.0007257687397369539, 0.0572597516671024, 0.0572382245759826, 0.05734738041419385]}}
{"id": "b9fbdc0c-f05d-4855-ad77-1553522b6b11", "fitness": 0.07053210384407768, "name": "HybridDE_SA_Adaptive", "description": "A synergistic blend of differential evolution and simulated annealing with adaptive population resizing for enhanced convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.min_population_size = 4 * dim\n        self.max_iterations = 1000  # Set a reasonable upper limit for iterations\n        self.temperature = 100.0\n        self.cooling_rate = 0.995\n\n    def __call__(self, func):\n        remaining_budget = self.budget\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        iteration = 0\n        while remaining_budget > 0 and iteration < self.max_iterations:\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(population_size):\n                indices = np.random.permutation(population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                remaining_budget -= 1\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                if remaining_budget <= 0:\n                    break\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Adaptive Population Resizing\n            if iteration % 100 == 0 and population_size > self.min_population_size:\n                population_size = max(self.min_population_size, int(population_size * 0.9))\n                sorted_indices = np.argsort(fitness)\n                population = population[sorted_indices[:population_size]]\n                fitness = fitness[sorted_indices[:population_size]]\n\n            iteration += 1\n\n        return best_solution", "configspace": "", "generation": 50, "feedback": "The algorithm HybridDE_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479997695589691, 0.1480264521726381, 0.1639627428379521, 0.0007056940699780023, 0.0007060115155060886, 0.0008539163658554116, 0.057237287605928944, 0.05723902623595578, 0.058058034233915645]}}
{"id": "ff5f29e2-ec47-49f4-93d4-44f0996b7df9", "fitness": 0.06886003428593367, "name": "HybridDE_SA", "description": "Enhanced crossover strategy by introducing a small random perturbation to improve exploration capabilities.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with small random perturbation\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                trial = np.where(crossover_mask, mutant + perturbation, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 51, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06093.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479902588921238, 0.14803739517117787, 0.1497499148381648, 0.0007055808309489597, 0.0007061415237999968, 0.0007259939052388642, 0.05723666742958311, 0.05723973833692986, 0.05734861764543575]}}
{"id": "3d65228a-cf19-4b47-97e2-fba2f156c8fc", "fitness": 0.06886850417098715, "name": "EnhancedMemoryDE_SA", "description": "An Enhanced Memory-Informed Hybrid DE-SA using elite archiving and adaptive scaling for superior exploration-exploitation balance in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedMemoryDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.elite_size = max(1, self.population_size // 10)  # Elite archive size\n        self.elite_archive = []\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            f_scaling = 0.5 + 0.3 * (np.sin(iteration / self.max_iterations * np.pi))  # Adaptive scaling factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n                \n                # Differential Evolution Mutation with elite consideration\n                if np.random.rand() < 0.1 and self.elite_archive:\n                    x1 = self.elite_archive[np.random.randint(len(self.elite_archive))]\n                \n                mutant = x1 + f_scaling * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Update elite archive\n            elite_indices = np.argsort(fitness)[:self.elite_size]\n            self.elite_archive = [population[idx] for idx in elite_indices if fitness[idx] < best_fitness]\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedMemoryDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14801360779278627, 0.1481024490482692, 0.14973222797665342, 0.0007058574220538683, 0.0007069139936637381, 0.0007257964609151957, 0.05723818265226088, 0.05724396954310351, 0.057347532649178246]}}
{"id": "d41c12e8-f056-471b-ad76-7ed31093c8bd", "fitness": 0.06885727003396917, "name": "AHDE_SA", "description": "An enhanced Adaptive Hybrid Differential Evolution with Simulated Annealing (AHDE-SA), incorporating adaptive mutation and crossover strategies for a better balance between exploration and exploitation in black-box optimization. ", "code": "import numpy as np\n\nclass AHDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_mutation_factor = 0.5 + 0.3 * np.cos(np.pi * iteration / self.max_iterations)  # Adaptive mutation factor\n            adaptive_crossover_rate = 0.7 + 0.2 * np.sin(np.pi * iteration / self.max_iterations)  # Adaptive crossover rate\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Differential Evolution Mutation with adaptive factor\n                mutant = x1 + adaptive_mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover with adaptive rate\n                crossover_mask = np.random.rand(self.dim) < adaptive_crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 53, "feedback": "The algorithm AHDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06092.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14802811715199438, 0.14799394975201052, 0.14973232901136735, 0.0007060311434928801, 0.0007056247839996033, 0.0007257976034102942, 0.057239133790799146, 0.05723690814551752, 0.057347538923130825]}}
{"id": "383c3938-8213-428d-8972-eef8006e45cc", "fitness": 0.06890120328039649, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with an adaptive differential weight to balance exploration-exploitation trade-off effectively.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_weight = 0.5 + 0.3 * (iteration / self.max_iterations)  # Adaptive differential weight\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + adaptive_weight * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 54, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06890 with standard deviation 0.06098.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14836702202234298, 0.14802200774947094, 0.14973283645102375, 0.0007100009329634727, 0.0007059585118586176, 0.0007258033402562925, 0.05726089411196256, 0.057238735975863375, 0.057347570427826455]}}
{"id": "96ec929c-2422-44ee-bea3-8f9a3a287678", "fitness": 0.0705315287831583, "name": "HybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with a dynamically adjusted mutation factor for improved exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            mutation_factor = 0.8 + 0.2 * (iteration / self.max_iterations)  # Dynamically adjusted mutation factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 55, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479997695589691, 0.14802157526047355, 0.16396281826881753, 0.0007056940699780023, 0.0007059532080709863, 0.0008539168964468713, 0.057237287605928944, 0.05723870697436462, 0.05805803720537506]}}
{"id": "de945085-7638-42c4-b25d-c32c276bcf2c", "fitness": 0.07053617509230775, "name": "HybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with a dynamically adjusted crossover rate and an added elitism strategy for improved exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Elitism: retain the best solution in the population\n            worst_idx = np.argmax(fitness)\n            population[worst_idx] = best_solution\n            fitness[worst_idx] = best_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 56, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07054 with standard deviation 0.06312.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14800519245292743, 0.14805070709903356, 0.16396721646964418, 0.000705758619310215, 0.0007062992758378739, 0.0008539478286830882, 0.0572376411296579, 0.057240602518409456, 0.05805821043726611]}}
{"id": "1d24fabc-b75c-4e4d-b2ab-53496fa0bc04", "fitness": 0.06891032668507881, "name": "HybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with an adaptive mutation factor and enhanced cooling schedule for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Enhanced cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_mutation = 0.5 + 0.3 * np.random.rand()  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + adaptive_mutation * (x2 - x3)  # Using adaptive mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 57, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06891 with standard deviation 0.06099.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14818443425758632, 0.14828373648268445, 0.14972984880048223, 0.0007078844514659677, 0.0007090291839637608, 0.0007257695621800675, 0.05724928612884628, 0.057255566368213384, 0.05734738493028679]}}
{"id": "fb4e90da-a5af-4658-9984-6ce83b1e07a8", "fitness": 0.06885241302193781, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with nonlinear temperature cooling and adaptive mutation scaling for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.temperature = self.initial_temperature\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_mutation_scale = 0.8 + 0.2 * (1 - iteration / self.max_iterations)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + adaptive_mutation_scale * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Nonlinear Cooling: Exponential cooling\n            self.temperature = self.initial_temperature * (self.cooling_rate ** iteration)\n\n        return best_solution", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06885 with standard deviation 0.06092.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479902588921238, 0.14799401135550883, 0.14972952992176214, 0.0007055808309489597, 0.0007056255174894277, 0.0007257659566487495, 0.05723666742958311, 0.05723691216275484, 0.05734736513062044]}}
{"id": "342a8b49-e143-4237-a50f-ec4f0033bb7e", "fitness": 0.06934000668227241, "name": "HybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with adaptive scaling factor and population diversity maintenance for improved black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_scaling_factor = 0.5 + 0.5 * (iteration / self.max_iterations)  # New adaptive scaling factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + adaptive_scaling_factor * (x2 - x3)  # Modified scaling factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 59, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06934 with standard deviation 0.06151.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.15207463114695874, 0.14801195987128501, 0.14973340178514405, 0.0007486710085599091, 0.0007058390747859411, 0.0007258097314721823, 0.0574740602003696, 0.05723808179598033, 0.057347605525895906]}}
{"id": "1a8369c5-e4c7-4f6b-8ea3-71c6cd58310c", "fitness": 0.0690699097071924, "name": "AdaptiveHybridDE_SA", "description": "A novel adaptive hybrid differential evolution and simulated annealing algorithm that utilizes dynamic population scaling and adaptive mutation strategies to enhance exploration and exploitation balance in black-box optimization.", "code": "import numpy as np\n\nclass AdaptiveHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 5 * dim)  # Dynamic initial population size\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.95  # Adjusted cooling rate for longer exploration\n        self.mutation_factor = 0.8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evaluations = self.population_size\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 * (1 - (iteration / self.max_iterations)) + 0.1  # Dynamic crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Adaptive Mutation Factor\n                self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n                mutant = x1 + self.mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance with adaptive temperature impact\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n                # Early stopping criteria based on fitness evaluations\n                if evaluations >= self.budget:\n                    return best_solution\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Dynamic population scaling\n            if iteration % 10 == 0 and self.population_size < 2 * self.dim:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evaluations += 5\n                population = np.vstack((population, new_individuals))\n                fitness = np.concatenate((fitness, new_fitness))\n                self.population_size = population.shape[0]\n\n        return best_solution", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06907 with standard deviation 0.06118.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1481057374564848, 0.14867741061228312, 0.15075312663601048, 0.0007069514033949398, 0.0007136755507565207, 0.00073715019660614, 0.05724417493781986, 0.05728102513764999, 0.057409935433725745]}}
{"id": "485b1814-4422-4be3-bd69-9f7f086c68fc", "fitness": 0.06885679586416443, "name": "HybridDE_SA", "description": "A further refined hybrid algorithm integrating adaptive mutation factors and elitism to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            adaptive_mutation_factor = 0.8 + 0.4 * np.random.rand()  # new adaptive mutation factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1 = population[indices[0]]\n                x2 = population[indices[1]]\n                x3 = population[indices[2]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + adaptive_mutation_factor * (x2 - x3)  # updated mutation with adaptive factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    # Update best solution found\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Elitism strategy\n            if np.random.rand() < 0.1:  # 10% chance to replace a random individual with the best solution\n                replace_idx = np.random.randint(0, self.population_size)\n                population[replace_idx] = best_solution\n                fitness[replace_idx] = best_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 61, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06092.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479902588921238, 0.1480289610067258, 0.149731208951849, 0.0007055808309489597, 0.0007060414071201615, 0.0007257849402008132, 0.05723666742958311, 0.05723918993749799, 0.057347469381430205]}}
{"id": "c4eb6f7a-4419-40b2-85a5-a5450ab4df07", "fitness": 0.06894331833677066, "name": "EnhancedHybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with adaptive mutation scaling and stochastic multi-crossover for balanced exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.95  # Slightly faster cooling\n        self.mutation_scaling = 0.5  # Adaptive mutation scaling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            \n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling\n                F = self.mutation_scaling + 0.1 * np.random.rand()  # Stochastic and adaptive scaling\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Multi-Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                # Additional stochastic crossover\n                alt_crossover_mask = np.random.rand(self.dim) < (1 - adaptive_rate)\n                alt_trial = np.where(alt_crossover_mask, mutant, population[i])\n\n                # Evaluate both trials and select the better one\n                trial_fitness = func(trial)\n                alt_trial_fitness = func(alt_trial)\n                if trial_fitness < alt_trial_fitness:\n                    selected_trial, selected_fitness = trial, trial_fitness\n                else:\n                    selected_trial, selected_fitness = alt_trial, alt_trial_fitness\n\n                # Simulated Annealing Acceptance\n                if selected_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - selected_fitness) / self.temperature):\n                    population[i] = selected_trial\n                    fitness[i] = selected_fitness\n\n                # Update best solution found\n                if selected_fitness < best_fitness:\n                    best_solution = selected_trial\n                    best_fitness = selected_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06894 with standard deviation 0.06103.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14810260391199226, 0.1486389439482474, 0.14973235647599425, 0.0007069155067482846, 0.0007132166436567555, 0.0007257979133701298, 0.057243977927212586, 0.057278512077600485, 0.0573475406261138]}}
{"id": "fa735a55-3541-49d6-915f-c6e87f05861d", "fitness": 0.06917178765018, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive population size and self-adaptive mutation for improved exploration and convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5, 5 * dim)  # Adaptive population size change\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate for faster convergence\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive factor\n                F = np.random.rand()  # Self-adaptive mutation factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 63, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06917 with standard deviation 0.06130.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479918138082289, 0.15067371991517464, 0.14972952992176214, 0.0007055993327036436, 0.0007353311792812622, 0.0007257659566487495, 0.05723676876169137, 0.057400194845508956, 0.05734736513062044]}}
{"id": "50acef22-4531-40cf-9e4b-19663b9b10d6", "fitness": 0.06871327998758353, "name": "AdaptiveHybridDE_SA", "description": "An adaptive hybrid differential evolution and simulated annealing algorithm with dynamic population management for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.dynamic_population_size = self.initial_population_size\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.elite_portion = 0.2\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n\n            # Dynamic population resizing\n            self.dynamic_population_size = max(self.initial_population_size // 2, int(self.initial_population_size * (1 - iteration / self.max_iterations)))\n            elite_size = max(2, int(self.dynamic_population_size * self.elite_portion))\n            \n            # Select elites\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            for i in range(self.dynamic_population_size):\n                indices = np.random.permutation(elite_size)\n                x1, x2, x3 = elites[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i % self.initial_population_size])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i % self.initial_population_size] or np.random.rand() < np.exp((fitness[i % self.initial_population_size] - trial_fitness) / self.temperature):\n                    population[i % self.initial_population_size] = trial\n                    fitness[i % self.initial_population_size] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 64, "feedback": "The algorithm AdaptiveHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06871 with standard deviation 0.06101.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1482939191578334, 0.1478720117144079, 0.1495473568607535, 0.0004892670692810963, 0.0004843115248169827, 0.0005037327354322496, 0.057058908572866884, 0.057031748763051726, 0.057138263489808105]}}
{"id": "888ebe85-5251-4ee1-ae4c-f4289a4a1f2f", "fitness": 0.06885241302193781, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive mutation scaling for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                F = 0.8 + 0.2 * (1 - iteration / self.max_iterations)  # Adaptive mutation scaling factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 65, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06885 with standard deviation 0.06092.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479902588921238, 0.14799401135550883, 0.14972952992176214, 0.0007055808309489597, 0.0007056255174894277, 0.0007257659566487495, 0.05723666742958311, 0.05723691216275484, 0.05734736513062044]}}
{"id": "70f6f032-2e79-46ea-b04e-4e753c0087da", "fitness": 0.07052902053602693, "name": "HybridDE_SA", "description": "An enhanced hybrid differential evolution and simulated annealing algorithm with improved adaptive cooling for better convergence speed in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.995  # Modified cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                acceptance_probability = np.exp((fitness[i] - trial_fitness) / (self.temperature / 10))  # Adjusted acceptance probability\n                if trial_fitness < fitness[i] or np.random.rand() < acceptance_probability:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 66, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14800650758267475, 0.14799394975201052, 0.1639627428379521, 0.0007057742709819514, 0.0007056247839996033, 0.0008539163658554116, 0.05723772685133488, 0.05723690814551752, 0.058058034233915645]}}
{"id": "d564525a-29c3-4707-a822-0b573c2467dc", "fitness": 0.0688819058579828, "name": "EnhancedHybridDE_SA", "description": "An enhanced adaptive hybrid differential evolution and simulated annealing algorithm that incorporates a convergence-focused adaptive parameter control for improved performance in diverse black-box optimization tasks.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Slightly faster cooling\n        self.convergence_factor = 1.0 / dim  # Adjusted for improved convergence\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with convergence factor\n                F = 0.8 + self.convergence_factor * (best_fitness - fitness[i])\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1479907023239544, 0.14824008539521427, 0.14972952992176214, 0.0007055861111301409, 0.0007085404007846074, 0.0007257659566487495, 0.05723669634768336, 0.05725288113404714, 0.05734736513062044]}}
{"id": "43816af8-bfd2-4283-bc58-95742a3cf63c", "fitness": 0.0688766900336327, "name": "HybridDE_SA", "description": "The algorithm is enhanced by introducing adaptive scaling for differential evolution to improve convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            adaptive_scaling = 0.5 + 0.3 * np.sin(0.1 * iteration)  # Newly added adaptive scaling factor\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + adaptive_scaling * (x2 - x3)  # Using adaptive scaling factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 68, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14799832858977469, 0.14818327619531857, 0.14973515223717238, 0.0007056768964549542, 0.0007078638467602483, 0.0007258295188842245, 0.05723719355669421, 0.05724917526832041, 0.057347714193314636]}}
{"id": "267172f9-87ba-4621-9222-e5fe7f95ad39", "fitness": 0.06893766780150386, "name": "EnhancedHybridDE_SA", "description": "A refined hybrid differential evolution and simulated annealing algorithm with adaptive mutation and crossover strategies for enhanced convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def adaptive_mutation_factor(self, iteration):\n        return 0.5 + 0.3 * np.sin(np.pi * iteration / self.max_iterations)\n\n    def adaptive_crossover_rate(self, iteration):\n        return 0.9 - 0.5 * (iteration / self.max_iterations) + 0.1 * np.sin(np.pi * iteration / self.max_iterations)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            mutation_factor = self.adaptive_mutation_factor(iteration)\n            crossover_rate = self.adaptive_crossover_rate(iteration)\n            \n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06894 with standard deviation 0.06102.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14833442550378073, 0.14835950515435092, 0.14973345820235828, 0.0007095010538491486, 0.0007099435306242574, 0.0007258103691866191, 0.05725818685642903, 0.0572605705144571, 0.05734760902849867]}}
{"id": "f3cad395-d5ea-4779-b813-481a7719fc87", "fitness": 0.06886872255801256, "name": "HybridDE_SA", "description": "Enhance the HybridDE_SA algorithm by fine-tuning the mutation scale factor and introducing adaptive cooling for improved convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.97  # Adjusted cooling rate for better exploration\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.9 * (x2 - x3)  # Adjusted mutation scale factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 70, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14802679918148787, 0.14809378204110535, 0.14972952992176214, 0.0007060157043377036, 0.000706807686263744, 0.0007257659566487495, 0.05723904916007738, 0.05724338823980968, 0.05734736513062044]}}
{"id": "105de495-daf2-40e4-9855-92f0972d8086", "fitness": 0.07053349231506706, "name": "EnhancedDE_ASA", "description": "Enhanced Differential Evolution with Adaptive Simulated Annealing (EDE-ASA) utilizing a dynamic temperature schedule and elitist selection for accelerated convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedDE_ASA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.final_temperature = 1.0\n        self.cooling_rate = (self.final_temperature / self.initial_temperature) ** (1.0 / self.max_iterations)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        temperature = self.initial_temperature\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.5 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance with Elitism\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Dynamic Cooling\n            temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedDE_ASA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06312.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.1480042813627046, 0.14803354625408127, 0.1639627428379521, 0.0007057477755872954, 0.0007060952459210235, 0.0008539163658554116, 0.057237581740354315, 0.05723948501923182, 0.058058034233915645]}}
{"id": "a8ae82d5-d545-4754-a82e-05a8957b58f5", "fitness": 0.07067390753563377, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with refined adaptive rate calculation for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 72, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07067 with standard deviation 0.06327.", "error": "", "parent_ids": ["1d13beb4-6a61-4809-8c64-36a301cdba5c"], "operator": null, "metadata": {"aucs": [0.14884077090100412, 0.1483714467447539, 0.16396286951440664, 0.0007155415127649833, 0.0007100664218891994, 0.0008539172569240749, 0.05729126715412469, 0.05726124909068897, 0.05805803922414732]}}
{"id": "441c2aa0-f159-4644-8ec9-4c277b97bc83", "fitness": 0.06865207136628437, "name": "EnhancedHybridDE_SA", "description": "Enhanced HybridDE_SA with self-adaptive parameters and dynamic population resizing for robust black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.min_population_size = 4\n        self.population_size = self.initial_population_size\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        self.evaluate_budget = self.population_size\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                F = 0.5 + 0.3 * np.random.rand()  # Self-adaptive scaling factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                self.evaluate_budget += 1\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Dynamic population resizing\n            if self.population_size > self.min_population_size:\n                self.population_size = max(self.min_population_size, int(self.population_size * 0.95))\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n            if self.evaluate_budget >= self.budget:\n                break\n\n        return best_solution", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06865 with standard deviation 0.06094.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14780188895963764, 0.14785899525696566, 0.14954054070695277, 0.0004834780446657527, 0.00048415706032955974, 0.0005036556785801283, 0.05702718361495174, 0.05703090265509081, 0.05713784031938529]}}
{"id": "4c47dec4-377d-4433-85d4-aab433816c1f", "fitness": 0.0690064109326529, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive population size and improved mutation strategy for superior convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                F = 0.5 + 0.5 * (iteration / self.max_iterations)  # Improved mutation factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 74, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06901 with standard deviation 0.06110.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14799278504273206, 0.14927856898230696, 0.1497317219189941, 0.0007056109113722231, 0.0007204826284062937, 0.000725790739797727, 0.05723683217048958, 0.05731840476881589, 0.05734750123096133]}}
{"id": "801b0e22-9c95-4084-a8cc-cdc4c663428c", "fitness": 0.06891039014292294, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with optimized mutation factor for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.85 * (x2 - x3)  # Adjusted mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 75, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06891 with standard deviation 0.06099.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14847460144889646, 0.14799394975201052, 0.14973029740582144, 0.0007112416541423805, 0.0007056247839996033, 0.0007257746342780313, 0.05726770067724307, 0.05723690814551752, 0.05734741278439748]}}
{"id": "05cb744f-33e9-4ccc-99d1-45897648f2e9", "fitness": 0.06886989936326081, "name": "AdvancedDE_SA", "description": "AdvancedDE_SA employing self-adaptive mutation and dynamic cooling for enhanced exploration-exploitation balance in diverse black-box optimization.", "code": "import numpy as np\n\nclass AdvancedDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.995\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            mutation_factor = 0.5 + 0.5 * np.random.rand()  # Self-adaptive mutation\n            adaptive_rate = 0.9 - 0.6 * np.cos(np.pi * iteration / self.max_iterations)  # Cosine-based adaptive rate\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 76, "feedback": "The algorithm AdvancedDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14812329716956718, 0.14800711097193664, 0.14972952992176214, 0.0007071600401753475, 0.0007057814096214088, 0.0007257659566487495, 0.057245317708070065, 0.05723776596094532, 0.05734736513062044]}}
{"id": "37a4a833-0524-4277-8f65-35890e9f8fb1", "fitness": 0.0704359566752753, "name": "HybridDE_SA_Improved", "description": "Enhanced HybridDE_SA with dynamic population resizing for maintaining diversity and improving convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(10 * dim, budget // 10)\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.shrink_factor = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Dynamic population resizing\n            if iteration % int(self.max_iterations / 10) == 0 and iteration != 0:\n                self.population_size = int(self.population_size * self.shrink_factor)\n                chosen_indices = np.random.choice(len(population), self.population_size, replace=False)\n                population = population[chosen_indices]\n                fitness = fitness[chosen_indices]\n\n        return best_solution", "configspace": "", "generation": 77, "feedback": "The algorithm HybridDE_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07044 with standard deviation 0.06325.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14865296579872278, 0.14791797106041715, 0.16377729246276396, 0.0004934448847289108, 0.0004848571441289362, 0.0006318379501054627, 0.057081817229090226, 0.05703473742940435, 0.05784868611811589]}}
{"id": "73aa7afc-8cb7-46ae-b7d4-054596e5612c", "fitness": 0.07067390753563377, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with dynamic population size adjustment for improved convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(10 * dim, budget // 5)  # Dynamic adjustment based on budget\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 78, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07067 with standard deviation 0.06327.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14884077090100412, 0.1483714467447539, 0.16396286951440664, 0.0007155415127649833, 0.0007100664218891994, 0.0008539172569240749, 0.05729126715412469, 0.05726124909068897, 0.05805803922414732]}}
{"id": "7a513c2a-d773-4171-82f2-d13d1b6550d6", "fitness": 0.07067390753563377, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with a more aggressive cooling schedule for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.95  # Adjusted cooling rate for more aggressive cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate  # Change to a more aggressive cooling\n\n        return best_solution", "configspace": "", "generation": 79, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07067 with standard deviation 0.06327.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14884077090100412, 0.1483714467447539, 0.16396286951440664, 0.0007155415127649833, 0.0007100664218891994, 0.0008539172569240749, 0.05729126715412469, 0.05726124909068897, 0.05805803922414732]}}
{"id": "c2544328-ff70-427b-b361-058489b804db", "fitness": 0.07052926850324809, "name": "ImprovedHybridDE_SA", "description": "Improved HybridDE_SA with adaptive mutation scaling and dynamic temperature adjustment for enhanced convergence in black-box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.final_temperature = 1.0\n        self.temp_decay_power = 3.0  # Exponential decay power for temperature\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)\n            mutation_factor = 0.8 + 0.2 * (iteration / self.max_iterations)  # Adaptive mutation scaling\n            temperature = self.initial_temperature * (self.final_temperature / self.initial_temperature) ** (iteration / self.max_iterations) ** self.temp_decay_power\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n        return best_solution", "configspace": "", "generation": 80, "feedback": "The algorithm ImprovedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14799979188283063, 0.14800202700266651, 0.16396347400578715, 0.0007056943357565126, 0.0007057209384767615, 0.000853921508439548, 0.05723728906139569, 0.057237434759701666, 0.058058063034178375]}}
{"id": "2a1539c0-e2ea-4d42-8679-e71a2438fc96", "fitness": 0.06886576430392108, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with improved mutation scaling and cooling strategy for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Changed from 0.99 to 0.98\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.9 * (x2 - x3)  # Changed mutation scaling from 0.8 to 0.9\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 81, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06093.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.1480929817497273, 0.1480028610608517, 0.14972952992176214, 0.0007068014969379144, 0.0007057308750128, 0.0007257659566487495, 0.05724335336556674, 0.05723748917816196, 0.05734736513062044]}}
{"id": "7a1e5377-6b48-45e8-afb7-31cd0fef859d", "fitness": 0.06885793489901067, "name": "EnhancedHybridDE_SA", "description": "Enhanced Adaptive HybridDE_SA with multi-population strategy and dynamic parameter tuning for superior convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.num_subpopulations = 3\n\n    def __call__(self, func):\n        subpopulations = [\n            np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // self.num_subpopulations, self.dim))\n            for _ in range(self.num_subpopulations)\n        ]\n        fitness = [np.array([func(ind) for ind in subpop]) for subpop in subpopulations]\n        best_idx = [np.argmin(fit) for fit in fitness]\n        best_solutions = [subpop[i] for subpop, i in zip(subpopulations, best_idx)]\n        best_fitness = [fit[i] for fit, i in zip(fitness, best_idx)]\n        \n        global_best_fit_idx = np.argmin(best_fitness)\n        global_best_solution = best_solutions[global_best_fit_idx]\n        global_best_fitness = best_fitness[global_best_fit_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)\n            for s in range(self.num_subpopulations):\n                for i in range(len(subpopulations[s])):\n                    indices = np.random.permutation(len(subpopulations[s]))\n                    x1, x2, x3 = subpopulations[s][indices[:3]]\n\n                    # Differential Evolution Mutation\n                    mutant = x1 + 0.8 * (x2 - x3)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    # Crossover\n                    crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                    trial = np.where(crossover_mask, mutant, subpopulations[s][i])\n\n                    # Simulated Annealing Acceptance\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[s][i] or np.random.rand() < np.exp((fitness[s][i] - trial_fitness) / self.temperature):\n                        subpopulations[s][i] = trial\n                        fitness[s][i] = trial_fitness\n\n                    # Update best solution found in subpopulation\n                    if trial_fitness < best_fitness[s]:\n                        best_solutions[s] = trial\n                        best_fitness[s] = trial_fitness\n\n            # Update global best solution\n            for s in range(self.num_subpopulations):\n                if best_fitness[s] < global_best_fitness:\n                    global_best_solution = best_solutions[s]\n                    global_best_fitness = best_fitness[s]\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return global_best_solution", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06092.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14801082308650126, 0.14801441373197932, 0.1497347214675374, 0.0007058255372410782, 0.0007058683596918858, 0.0007258246482348962, 0.057238007655248446, 0.057238242160051356, 0.057347687444610385]}}
{"id": "a78dc10d-3f58-4eb0-874f-2f6424801534", "fitness": 0.07067390753563377, "name": "HybridDE_SA", "description": "Refined Adaptive Cooling Rate in HybridDE_SA for Enhanced Convergence in Black-Box Optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 83, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07067 with standard deviation 0.06327.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14884077090100412, 0.1483714467447539, 0.16396286951440664, 0.0007155415127649833, 0.0007100664218891994, 0.0008539172569240749, 0.05729126715412469, 0.05726124909068897, 0.05805803922414732]}}
{"id": "21e09fbe-d008-473f-b73e-faad269850f7", "fitness": 0.06888211200746464, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with configurable population scaling and improved mutation strategy for robust black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(10, 5 * dim)  # Line modified for configurable scaling\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Line modified for improved cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.9 * (x2 - x3)  # Line modified for enhanced mutation strategy\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 84, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14797416446266198, 0.14825837147099108, 0.14972952992176214, 0.0007053890964042742, 0.0007087538536520999, 0.0007257659566487495, 0.0572356173875338, 0.05725405078690715, 0.05734736513062044]}}
{"id": "87c1572c-24fe-4786-871b-2183da0f0c37", "fitness": 0.06907367000731675, "name": "HybridDE_SA", "description": "Enhance HybridDE_SA by refining mutation strategy and incorporating adaptive temperature for better convergence.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Slightly adjusted cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3, x4 = population[indices[:4]]  # Select four vectors for mutation\n\n                # Enhanced Differential Evolution Mutation\n                mutant = x1 + 0.5 * (x2 - x3) + 0.3 * (x4 - x1)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance with adaptive temperature\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (self.temperature * (1 + iteration/self.max_iterations))):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 85, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06907 with standard deviation 0.06118.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14810810932975427, 0.14972609326450514, 0.1497346100945285, 0.0007069782326128982, 0.0007251690477637629, 0.000725823388339597, 0.05724432228358389, 0.057344243898517666, 0.05734768052624506]}}
{"id": "34add5e8-0774-44e4-a984-53e30623645c", "fitness": 0.06888202433452784, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive multi-population strategy for robust exploration and convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.num_subpopulations = 3  # Number of subpopulations for diverse exploration\n        \n    def __call__(self, func):\n        subpopulations = [np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size // self.num_subpopulations, self.dim)) for _ in range(self.num_subpopulations)]\n        fitnesses = [np.array([func(ind) for ind in sub]) for sub in subpopulations]\n        best_overall_solution = None\n        best_overall_fitness = float('inf')\n\n        for iteration in range(self.max_iterations):\n            for k in range(self.num_subpopulations):\n                population = subpopulations[k]\n                fitness = fitnesses[k]\n                best_idx = np.argmin(fitness)\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n\n                for i in range(len(population)):\n                    indices = np.random.permutation(len(population))\n                    x1, x2, x3 = population[indices[:3]]\n\n                    # Differential Evolution Mutation\n                    F = 0.5 + np.random.rand() * 0.3  # Randomized scale factor for diversity\n                    mutant = x1 + F * (x2 - x3)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                    # Adaptive Crossover\n                    adaptive_rate = 0.8 - 0.5 * (iteration / self.max_iterations)  # Adaptation based on iteration\n                    crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                    trial = np.where(crossover_mask, mutant, population[i])\n\n                    # Simulated Annealing Acceptance\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n\n                    # Update best solution found\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n                # Update overall best solution\n                if best_fitness < best_overall_fitness:\n                    best_overall_solution = best_solution\n                    best_overall_fitness = best_fitness\n\n                # Periodic migration between subpopulations\n                if iteration % 10 == 0:\n                    migrants = [np.argmin(fitnesses[k]) for k in range(self.num_subpopulations)]\n                    for i in range(self.num_subpopulations):\n                        for j in range(self.num_subpopulations):\n                            if i != j:\n                                subpopulations[j][migrants[j]] = subpopulations[i][migrants[i]]\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_overall_solution", "configspace": "", "generation": 86, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14820914775893268, 0.14802260010280943, 0.14972952992176214, 0.0007081775793897904, 0.0007059656549859294, 0.0007257659566487495, 0.0572508918349518, 0.05723877507064956, 0.05734736513062044]}}
{"id": "1c424298-0d29-40ab-9e3a-cd4298e48064", "fitness": 0.06887249172127646, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with further improved adaptive mutation factor for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + (0.7 + 0.3 * np.random.rand()) * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 87, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14807077926852708, 0.14807886613901533, 0.1497319488266673, 0.0007065383019669857, 0.0007066344669086622, 0.0007257933044737541, 0.05724191158276215, 0.057242438286077446, 0.057347515315089415]}}
{"id": "5204d3c8-5dc8-4d28-9034-f9b70a53fce1", "fitness": 0.07054752571294168, "name": "HybridDE_SA", "description": "Enhanced HybridDE_SA with dynamically adjusted mutation scaling factor for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            mutation_factor = 0.5 + 0.3 * (1 - iteration / self.max_iterations)  # Newly added line\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 88, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07055 with standard deviation 0.06313.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14800656155799863, 0.14814655950429034, 0.1639647961293479, 0.0007057748729890623, 0.0007074356651776137, 0.0008539308053463479, 0.057237730159525047, 0.05724682762110711, 0.05805811510069303]}}
{"id": "a3e2a79b-c099-440f-a91e-0f448d16c015", "fitness": 0.06896737695084472, "name": "EnhancedHybridDE_SA", "description": "Enhanced HybridDE_SA with adaptive learning of mutation factor and simulated annealing temperature for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.initial_temperature = 100.0\n        self.min_temperature = 1e-3\n        self.cooling_rate = 0.97\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        temperature = self.initial_temperature\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)\n            mutation_factor = 0.5 + 0.5 * np.random.rand()  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive mutation factor\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance with adaptive temperature\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling with lower bound on temperature\n            temperature = max(self.min_temperature, temperature * self.cooling_rate)\n\n        return best_solution", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06897 with standard deviation 0.06106.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14842035527153996, 0.14812489977645416, 0.15013102560174074, 0.0007106611717786482, 0.0007071743257143215, 0.0007302694591110326, 0.057264502832699016, 0.057245397346908145, 0.057372106771656495]}}
{"id": "8f8f4638-75a2-4c9f-9780-c3c811a0573a", "fitness": 0.06886136231495972, "name": "EnhancedHybridDE_SA", "description": "Incorporate a dynamic population size and adaptive mutation scaling to improve convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, 10 * dim)  # Initial population size\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.dynamic_scaling_factor = 0.8\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)\n            scaling_factor = self.dynamic_scaling_factor * (1 - iteration / self.max_iterations)\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling\n                mutant = x1 + scaling_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Dynamic population size adjustment\n            if iteration % 10 == 0 and self.population_size < 200:\n                additional_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (10, self.dim))\n                additional_fitness = np.array([func(ind) for ind in additional_individuals])\n                population = np.vstack((population, additional_individuals))\n                fitness = np.concatenate((fitness, additional_fitness))\n                self.population_size += 10\n\n        return best_solution", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06093.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14802732933045593, 0.14800834586782663, 0.14975299026670275, 0.000706021520489486, 0.0007057957428029393, 0.0007260311075040216, 0.05723908115968457, 0.05723784456808201, 0.0573488212710892]}}
{"id": "2d991fb2-3879-4237-9f62-d7c03d1a5255", "fitness": 0.06887668683072427, "name": "AugmentedHybridDE_SA", "description": "Augmented HybridDE_SA with dynamic population scaling and adaptive mutation strategies for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass AugmentedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.population_growth_factor = 1.1  # Factor to increase population size\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(population_size):\n                indices = np.random.permutation(population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Dynamic scaling of differential weight\n                F = 0.5 + 0.5 * np.random.rand()\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Dynamic population scaling\n            if iteration % 10 == 0 and iteration > 0:  # Increase population size every 10 iterations\n                population_size = min(int(population_size * self.population_growth_factor), int(self.budget / self.max_iterations))\n                additional_population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size - len(population), self.dim))\n                population = np.vstack((population, additional_population))\n                additional_fitness = np.array([func(ind) for ind in additional_population])\n                fitness = np.hstack((fitness, additional_fitness))\n                \n        return best_solution", "configspace": "", "generation": 91, "feedback": "The algorithm AugmentedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06888 with standard deviation 0.06095.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.1481748150966643, 0.14800739402397145, 0.1497344710881422, 0.0007077714177624594, 0.000705784826457001, 0.0007258218188526122, 0.05724866663837669, 0.057237784659491364, 0.057347671906800346]}}
{"id": "57582ee3-c04d-4c7f-8882-d4fe23f5894a", "fitness": 0.06873557246991446, "name": "HybridDE_SA_TD", "description": "HybridDE_SA_TD integrates time-varying scaling factor and dynamic population size adjustment for enhanced convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA_TD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            scaling_factor = 0.5 + 0.4 * (iteration / self.max_iterations)  # Scaling factor changes over time\n            population_size = self.initial_population_size - int(iteration * (self.initial_population_size / self.max_iterations))  # Dynamic population size\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(population_size):\n                indices = np.random.permutation(population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with time-varying scaling factor\n                mutant = x1 + scaling_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 92, "feedback": "The algorithm HybridDE_SA_TD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06874 with standard deviation 0.06104.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14855473836565458, 0.1478045736306972, 0.14954054070689826, 0.0004923153200939723, 0.0004835100161043604, 0.0005036556785794621, 0.05707561948044293, 0.05702735871138631, 0.05713784031937308]}}
{"id": "d54b016d-aba3-44c3-ac4b-6191e08906e7", "fitness": 0.06887201418012528, "name": "EnhancedHybridDE_SA", "description": "Introducing adaptive mutation scaling and dynamic crossover to enhance convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            mutation_factor = 0.8 + 0.2 * np.cos(np.pi * iteration / self.max_iterations)  # Adaptive mutation scaling\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive mutation factor\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover\n                crossover_prob = adaptive_rate * (1.5 - (fitness[i] / max(fitness.max(), 1e-8)))  # Enhanced crossover logic\n                crossover_mask = np.random.rand(self.dim) < crossover_prob\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedHybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06094.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14806221155865773, 0.14809208204570212, 0.14973169489494542, 0.0007098076754529226, 0.0007056247839996033, 0.0007257659566487495, 0.05723666742958311, 0.05723690814551752, 0.05734736513062044]}}
{"id": "4c4945f4-3731-4a3c-ab06-69381af3971b", "fitness": 0.06876862702907865, "name": "HybridDE_SA_v2", "description": "HybridDE_SA_v2 with adaptive mutation scaling and dynamic population for enhanced exploration and convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)\n            dynamic_population_size = max(4, int(self.population_size * (1 - iteration / self.max_iterations)))\n            for i in range(dynamic_population_size):\n                indices = np.random.permutation(dynamic_population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Adaptive Mutation Scaling\n                F = 0.5 + 0.3 * np.random.rand()\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 94, "feedback": "The algorithm HybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06877 with standard deviation 0.06108.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.1482100507629286, 0.14790660117934107, 0.15006111051386029, 0.0004882914917434533, 0.00048472220378126263, 0.00050947797193579, 0.057053558968389595, 0.0570339982728979, 0.05716983189682989]}}
{"id": "1d4e17bb-86de-415b-9dc2-81dcffd077b4", "fitness": 0.06893941354525128, "name": "AdaptiveDE_SA", "description": "AdaptiveDE_SA with a novel adaptive mutation strategy and non-linear cooling schedule for enhanced exploitation and exploration balance.", "code": "import numpy as np\n\nclass AdaptiveDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            mutation_factor = 0.5 + 0.5 * np.cos(np.pi * iteration / self.max_iterations)  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive mutation factor\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Non-linear Cooling\n            self.temperature *= self.cooling_rate ** ((iteration + 1) / self.max_iterations)\n\n        return best_solution", "configspace": "", "generation": 95, "feedback": "The algorithm AdaptiveDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06894 with standard deviation 0.06102.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.1482566217110225, 0.14845507895368049, 0.14972952992176214, 0.0007087242364394175, 0.0007110589588135152, 0.0007257659566487495, 0.05725389111431689, 0.05726668592395734, 0.05734736513062044]}}
{"id": "fcf9adcd-93b2-404b-bc62-efc3364797fc", "fitness": 0.07052926583156956, "name": "HybridDE_SA", "description": "Adaptive mutation factor adjustment enhances convergence by optimizing exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutation_factor = 0.8 + 0.2 * (iteration / self.max_iterations)  # Adaptive mutation factor\n                mutant = x1 + mutation_factor * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 96, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07053 with standard deviation 0.06311.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.1479997695589691, 0.14800202700266651, 0.16396347400578715, 0.0007056940699780023, 0.0007057209384767615, 0.000853921508439548, 0.057237287605928944, 0.057237434759701666, 0.058058063034178375]}}
{"id": "27e897ec-0d7e-4020-bec7-92833061adf2", "fitness": 0.07067390753563377, "name": "HybridDE_SA", "description": "Improved HybridDE_SA with dynamic temperature scaling for accelerated convergence in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Changed from 0.99 to 0.98 for faster cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                mutant = x1 + 0.8 * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (self.temperature + 1e-10)):  # Added small constant to avoid division by zero\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 97, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07067 with standard deviation 0.06327.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14884077090100412, 0.1483714467447539, 0.16396286951440664, 0.0007155415127649833, 0.0007100664218891994, 0.0008539172569240749, 0.05729126715412469, 0.05726124909068897, 0.05805803922414732]}}
{"id": "55804255-6af1-4d31-8804-b62d756c1b2f", "fitness": 0.0688655710918708, "name": "HybridDE_SA", "description": "Refined HybridDE_SA with an enhanced mutation strategy to improve search space exploration and convergence speed in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_iterations = budget // self.population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)  # Dynamically adjusted crossover rate\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation\n                F = 0.5 + np.random.rand() * 0.3  # Adaptive mutation factor\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n        return best_solution", "configspace": "", "generation": 98, "feedback": "The algorithm HybridDE_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06093.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14801409428619505, 0.14807870930331213, 0.14973095711991635, 0.0007058645482662662, 0.0007066320792059599, 0.0007257820930177683, 0.05723822128884204, 0.05724242536243396, 0.05734745374564776]}}
{"id": "17a3657e-f964-4bed-833c-92a456cd3fc1", "fitness": 0.06868354769822961, "name": "HybridDE_SA_v2", "description": "HybridDE_SA_v2 incorporates adaptive mutation scaling and dynamic population resizing for enhanced exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass HybridDE_SA_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_iterations = budget // self.initial_population_size\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        for iteration in range(self.max_iterations):\n            mutation_scaling = 0.6 + 0.3 * (np.cos(np.pi * iteration / self.max_iterations))  # Adaptive mutation scaling\n            adaptive_rate = 0.9 - 0.6 * (iteration / self.max_iterations)\n\n            for i in range(self.population_size):\n                indices = np.random.permutation(self.population_size)\n                x1, x2, x3 = population[indices[:3]]\n\n                # Differential Evolution Mutation with adaptive scaling\n                mutant = x1 + mutation_scaling * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover_mask = np.random.rand(self.dim) < adaptive_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n\n                # Simulated Annealing Acceptance\n                trial_fitness = func(trial)\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temperature):\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                # Update best solution found\n                if trial_fitness < best_fitness:\n                    best_solution = trial\n                    best_fitness = trial_fitness\n\n            # Cooling\n            self.temperature *= self.cooling_rate\n\n            # Dynamic population resizing\n            if iteration % (self.max_iterations // 5) == 0 and self.population_size > self.initial_population_size // 2:\n                self.population_size = max(self.population_size // 2, self.initial_population_size // 2)\n                new_population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_population])\n                combined_population = np.vstack((population, new_population))\n                combined_fitness = np.hstack((fitness, new_fitness))\n                sorted_indices = np.argsort(combined_fitness)[:self.population_size]\n                population = combined_population[sorted_indices]\n                fitness = combined_fitness[sorted_indices]\n\n        return best_solution", "configspace": "", "generation": 99, "feedback": "The algorithm HybridDE_SA_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06868 with standard deviation 0.06098.", "error": "", "parent_ids": ["a8ae82d5-d545-4754-a82e-05a8957b58f5"], "operator": null, "metadata": {"aucs": [0.14791346392700222, 0.1480105427555488, 0.14954054070690936, 0.000484803979625803, 0.00048594359544062993, 0.0005036556785794621, 0.057034446115969306, 0.05704069220561536, 0.05713784031937552]}}
