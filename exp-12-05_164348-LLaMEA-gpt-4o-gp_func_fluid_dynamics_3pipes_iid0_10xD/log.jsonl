{"id": "3f4a81a0-17c8-48cb-babf-ad92956c5939", "fitness": 0.056343232218820684, "name": "HPSO_ADE", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (HPSO-ADE) to dynamically balance exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 0, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.06401285279319202, 0.0488352308244111, 0.057513772447530864, 0.05567290710452988, 0.04599656270889585, 0.054029669325498686, 0.06507312163836942, 0.05277196554982855, 0.0631830075771298]}}
{"id": "31582ab0-87f3-4c6f-a721-e741264e1efb", "fitness": 0.05478263985221156, "name": "HPSO_ADE", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (HPSO-ADE+) using adaptive inertia weight and crossover probability to improve convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for eval_num in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.inertia = 0.9 - 0.5 * (eval_num / self.budget)  # Adaptive inertia\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                self.cr = 0.9 - 0.4 * (eval_num / self.budget)  # Adaptive crossover probability\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 1, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05958037423250029, 0.047010074436151905, 0.05708179881213826, 0.05464669414316292, 0.044327607340603814, 0.053537105419457554, 0.06374661127061543, 0.05062824378809572, 0.06248524922717813]}}
{"id": "560549d9-8ae1-4722-a816-221b453bc1ce", "fitness": 0.05478263985221156, "name": "HPSO_ADE", "description": "Enhanced HPSO-ADE with dynamic inertia factor adjustment for improved convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Initial inertia\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Dynamic inertia adjustment\n            self.inertia = 0.4 + 0.5 * (1 - iteration / self.budget)\n            \n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 2, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05958037423250029, 0.047010074436151905, 0.05708179881213826, 0.05464669414316292, 0.044327607340603814, 0.053537105419457554, 0.06374661127061543, 0.05062824378809572, 0.06248524922717813]}}
{"id": "399a188b-c946-463b-9e49-b01ae2428f2e", "fitness": 0.05461134231191797, "name": "HPSO_ADE", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (HPSO-ADE) by improving inertia and adaptive social parameters for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Adjusted inertia\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 3, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05842309746484908, 0.046939214179209765, 0.057083254157677565, 0.05457514916734851, 0.0442629262224814, 0.05353849959763368, 0.06364876192877444, 0.05054438459840094, 0.06248679349088637]}}
{"id": "1e93200d-8952-4989-acf7-7993906a087d", "fitness": 0.05613331147682093, "name": "HPSO_ADE", "description": "Improved HPSO-ADE by adjusting inertia and introducing a mutation factor for enhanced dynamic adaptation.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Adjusted inertia for improved exploration\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.1  # New mutation factor for dynamic adaptation\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i]) + self.mutation_factor * np.random.normal(size=self.dim)\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 4, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.056685665315999056, 0.04723082202751372, 0.06309800999020032, 0.052764725370454735, 0.044542147085145256, 0.05894555180649064, 0.06125173847612975, 0.05086838536717031, 0.06981275785228458]}}
{"id": "5f28430e-852d-49c4-832c-13781ac04f18", "fitness": 0.053416680516596905, "name": "HPSO_ADE", "description": "Refined HPSO-ADE with adaptive inertia and dynamic crossover to enhance exploration-exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Changed from 0.7 to 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):  # Changed _ to iteration\n            scores = np.array([func(ind) for ind in self.population])\n\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Adjusting inertia dynamically\n            self.inertia = 0.9 - 0.5 * (iteration / self.budget)  # Changed inertia adjustment\n\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Adaptive crossover probability\n            self.cr = 0.5 + 0.4 * np.sin(np.pi * iteration / self.budget)  # Changed crossover adjustment\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 5, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.055004719637982036, 0.05122049487154334, 0.05451186357896087, 0.05184381882219713, 0.045470280356106896, 0.05119236563065743, 0.06004996151626962, 0.052048033415279193, 0.05940858682037564]}}
{"id": "1c635124-ce3d-4409-a499-d806978f559b", "fitness": 0.055601150310699135, "name": "HPSO_ADE", "description": "Improved Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (HPSO-ADE) using adaptive learning factors for enhanced convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.7\n        self.cognitive = 2.0  # Changed from 1.5 \n        self.social = 2.5  # Changed from 1.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 6, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.0605229498453731, 0.05085384887041422, 0.054295138769217655, 0.05668398694614407, 0.047132919177861, 0.05103201577631655, 0.06645009209017139, 0.05413525030201771, 0.05930415101877651]}}
{"id": "8c9033df-d9af-4ad3-91d9-8bff8f2369ef", "fitness": 0.05633285416929986, "name": "HPSO_ADE", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (HPSO-ADE) by dynamically adjusting cognitive and social coefficients for improved black box optimization.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Dynamically adjust cognitive and social coefficients\n            self.cognitive *= 0.99\n            self.social *= 1.01\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 7, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.06076386178572646, 0.049885480729613185, 0.05668716140627683, 0.056638346707371556, 0.0469125846343017, 0.05328966711235672, 0.06679005519975412, 0.05385956629353683, 0.06216896365476132]}}
{"id": "b8543b49-0e93-48b0-a804-3210d089c1e3", "fitness": 0.055401851664938224, "name": "HPSO_ADE", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Evolution (Enhanced HPSO-ADE) using dynamic parameter adjustment for better convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Dynamic adjustment of parameters based on iteration\n            self.inertia = 0.9 - 0.4 * (_ / self.budget)  # Change 1\n            self.cognitive = 2.5 - 1.5 * (_ / self.budget)  # Change 2\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 8, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05595911811147769, 0.05136113693519129, 0.05725263734091168, 0.0532732792330074, 0.04826841115281788, 0.05298152929143085, 0.061910559232397855, 0.05587676968578337, 0.061733224001426]}}
{"id": "172134ad-18ba-4050-b446-53ac9546c11a", "fitness": 0.05447104194371382, "name": "HPSO_ADE", "description": "Enhanced HPSO-ADE with adaptive parameters for inertia and cognitive weights to improve convergence speed.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia_initial = 0.9\n        self.inertia_final = 0.4\n        self.cognitive_initial = 2.0\n        self.cognitive_final = 1.0\n        self.social = 1.5\n\n    def __call__(self, func):\n        for t in range(self.budget):\n            inertia = self.inertia_initial - t * (self.inertia_initial - self.inertia_final) / self.budget\n            cognitive = self.cognitive_initial - t * (self.cognitive_initial - self.cognitive_final) / self.budget\n            \n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (inertia * self.velocities +\n                               cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 9, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05676708918261786, 0.0475578680907941, 0.05646862400456909, 0.05324516009437441, 0.044830001978138134, 0.05446643745639668, 0.061873262299146914, 0.0512623853688331, 0.06376854901855411]}}
{"id": "36cc4555-1472-4000-bf43-5b4746792f10", "fitness": 0.05478263985221156, "name": "HPSO_ADE", "description": "Enhanced HPSO-ADE with adaptive inertia and tailored mutation to improve convergence in black box optimization.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Adaptive inertia\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            scores = np.array([func(ind) for ind in self.population])\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n            \n            self.inertia = 0.9 - 0.5 * (i / self.budget)  # Adaptive inertia adjustment\n\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 10, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05958037423250029, 0.047010074436151905, 0.05708179881213826, 0.05464669414316292, 0.044327607340603814, 0.053537105419457554, 0.06374661127061543, 0.05062824378809572, 0.06248524922717813]}}
{"id": "2429504a-dc14-48e4-af7e-82655b2165b9", "fitness": 0.05478263985221156, "name": "HPSO_ADE", "description": "Enhanced HPSO-ADE with adaptive inertia weight and dynamic selection for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Adaptive inertia weight\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for t in range(self.budget):\n            # Adaptive inertia weight\n            self.inertia = 0.9 - (0.5 * (t / self.budget))  \n            \n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 11, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05958037423250029, 0.047010074436151905, 0.05708179881213826, 0.05464669414316292, 0.044327607340603814, 0.053537105419457554, 0.06374661127061543, 0.05062824378809572, 0.06248524922717813]}}
{"id": "40c8ed0b-b0ac-47e5-a25b-85f0350d111c", "fitness": 0.05509477754765768, "name": "HPSO_ADE", "description": "Improved HPSO_ADE by adjusting adaptive parameters and introducing dynamic weights for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Changed inertia to 0.9\n        self.cognitive = 1.7  # Changed cognitive parameter to 1.7\n        self.social = 1.3  # Changed social parameter to 1.3\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 12, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.06002380129297158, 0.050146536624075644, 0.05352355007505616, 0.0562385494098655, 0.04723280228005888, 0.05032353686407087, 0.06583232532093464, 0.05425117979807459, 0.05828071626381126]}}
{"id": "cad07924-c4b3-4cd3-a0ef-f8e83689be5b", "fitness": 0.05509477754765768, "name": "HPSO_ADE", "description": "Enhanced HPSO_ADE with dynamic parameter tuning to improve convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Updated Inertia\n        self.cognitive = 1.7  # Updated cognitive\n        self.social = 1.3  # Updated social\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 13, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.06002380129297158, 0.050146536624075644, 0.05352355007505616, 0.0562385494098655, 0.04723280228005888, 0.05032353686407087, 0.06583232532093464, 0.05425117979807459, 0.05828071626381126]}}
{"id": "9a2f5051-a451-4c1d-b4d2-4b08ca00032c", "fitness": 0.05478263985221156, "name": "HPSO_ADE", "description": "Enhanced HPSO-ADE with adaptive inertia weight to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9  # Initial inertia\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for t in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Adaptive inertia weight\n            self.inertia = 0.9 - 0.5 * (t / self.budget)\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 14, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05958037423250029, 0.047010074436151905, 0.05708179881213826, 0.05464669414316292, 0.044327607340603814, 0.053537105419457554, 0.06374661127061543, 0.05062824378809572, 0.06248524922717813]}}
{"id": "1689c1c7-567e-42c3-bf30-cb4f86d1b905", "fitness": 0.05478263985221156, "name": "HPSO_ADE", "description": "Enhanced HPSO-ADE with dynamic adjustment of inertia weight to improve convergence performance.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia_initial = 0.9\n        self.inertia_final = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for i in range(self.budget):\n            # Dynamic inertia adjustment\n            self.inertia = self.inertia_initial - i * (self.inertia_initial - self.inertia_final) / self.budget\n            \n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 15, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.05958037423250029, 0.047010074436151905, 0.05708179881213826, 0.05464669414316292, 0.044327607340603814, 0.053537105419457554, 0.06374661127061543, 0.05062824378809572, 0.06248524922717813]}}
{"id": "5cec2848-ddca-4bf8-9cfb-a68590cd3136", "fitness": 0.054981654486239234, "name": "HPSO_ADE", "description": "Enhanced HPSO-ADE with dynamic parameters to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5  # Differential weight\n        self.cr = 0.9  # Crossover probability\n        self.inertia = 0.9 - 0.5 * (budget / 1000)  # Dynamic inertia\n        self.cognitive = 2.0 - 0.5 * (budget / 1000)  # Dynamic cognitive\n        self.social = 1.5 + 0.5 * (budget / 1000)  # Dynamic social\n\n    def __call__(self, func):\n        for _ in range(self.budget):\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 16, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.057742275122840914, 0.04992754752762796, 0.05803445860227219, 0.054191877984239745, 0.043932769396892724, 0.05417554700251914, 0.06311806037217571, 0.05024940222847918, 0.06346295213910558]}}
{"id": "193e9aed-6d77-49a3-8a2a-9b3a53745f73", "fitness": 0.056505594691074745, "name": "HPSO_ADE", "description": "Enhanced Hybrid Particle Swarm Optimization with Adaptive Differential Evolution using dynamic parameter tuning to improve convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 17, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3f4a81a0-17c8-48cb-babf-ad92956c5939"], "operator": null, "metadata": {"aucs": [0.06590605361638302, 0.04890119497493639, 0.057229707064067714, 0.05567290710452988, 0.04605516972138557, 0.05388162760600146, 0.06507312163836942, 0.05285112606735276, 0.06297944442664649]}}
{"id": "b1836ec7-14ec-4ebd-9101-f5017c87f081", "fitness": 0.05499380952848625, "name": "HPSO_ADE", "description": "A refined HPSO_ADE algorithm with dynamic parameter adjustment and elitism to enhance convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            self.inertia = 0.9 - 0.7 * (iteration / self.budget)  # Adjusted dynamic inertia\n            scores = np.array([func(ind) for ind in self.population])\n\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n            \n            elite_index = np.argmin(self.pbest_scores)  # Elitism: retain the best individual\n            self.population[0] = self.pbest_positions[elite_index]\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 18, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["193e9aed-6d77-49a3-8a2a-9b3a53745f73"], "operator": null, "metadata": {"aucs": [0.06040963073904204, 0.04702944890514382, 0.05708355528794806, 0.0546857191977026, 0.04434535597537648, 0.05445133290769544, 0.06380068957619944, 0.05065099987019683, 0.06248755329707156]}}
{"id": "f8433207-f47c-42fc-9b05-f484a5550320", "fitness": 0.05473459378628071, "name": "HPSO_ADE", "description": "Refined HPSO-ADE with adaptive mutation factor and exploration-exploitation balance for improved convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.8 - 0.6 * (iteration / self.budget)\n            \n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                self.f = 0.4 + 0.3 * np.random.rand()  # Adaptive mutation factor\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 19, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["193e9aed-6d77-49a3-8a2a-9b3a53745f73"], "operator": null, "metadata": {"aucs": [0.057378449858803804, 0.049502810152012744, 0.05575888981936494, 0.053839149117346885, 0.046623623289719474, 0.05237962613062541, 0.0626900279132977, 0.05354254500719102, 0.06089622278816442]}}
{"id": "8635937d-ec6c-4e89-b151-6f259bfb1f4b", "fitness": 0.0565600052639539, "name": "HPSO_ADE", "description": "Enhanced HPSO_ADE with adjusted cognitive and social coefficients for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 20, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["193e9aed-6d77-49a3-8a2a-9b3a53745f73"], "operator": null, "metadata": {"aucs": [0.06401285279319202, 0.04826617105922559, 0.05890691124663239, 0.05567290710452988, 0.04548174748211087, 0.05498509346657121, 0.06507312163836942, 0.05209953740586881, 0.06454170517908486]}}
{"id": "e5cb8bf4-3b41-4d04-8bc9-a707ddc44f91", "fitness": 0.056544727749015325, "name": "HPSO_ADE", "description": "Improve exploration by adjusting the variation of PSO velocity factors dynamically with each iteration.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.cognitive = 1.7 - 0.3 * (iteration / self.budget)  # Dynamic cognitive adjustment\n            self.social = 1.5 + 0.3 * (iteration / self.budget)     # Dynamic social adjustment\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 21, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["8635937d-ec6c-4e89-b151-6f259bfb1f4b"], "operator": null, "metadata": {"aucs": [0.06401285279319202, 0.04824656147983808, 0.05883282714846749, 0.05567290710452988, 0.04546389707311782, 0.05498398490622869, 0.06507312163836942, 0.05207628357721361, 0.0645401140201809]}}
{"id": "e0b210a8-91af-4594-830f-76797bc111ed", "fitness": 0.0565600052639539, "name": "HPSO_ADE", "description": "Introduced adaptive parameters for DE crossover rate and inertia to enhance optimization adaptability.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)  # Adapt DE crossover rate\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 22, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["8635937d-ec6c-4e89-b151-6f259bfb1f4b"], "operator": null, "metadata": {"aucs": [0.06401285279319202, 0.04826617105922559, 0.05890691124663239, 0.05567290710452988, 0.04548174748211087, 0.05498509346657121, 0.06507312163836942, 0.05209953740586881, 0.06454170517908486]}}
{"id": "2ce7ca75-96e4-4fcf-b3b8-e3eac7e42f05", "fitness": 0.05356478244032809, "name": "HPSO_ADE", "description": "Improved exploration by introducing random perturbations for global best updates.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best with perturbation\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx] + np.random.uniform(-0.1, 0.1, self.dim)\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 23, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["8635937d-ec6c-4e89-b151-6f259bfb1f4b"], "operator": null, "metadata": {"aucs": [0.05736447766210617, 0.049659160556424164, 0.0527741602704106, 0.053831441068618924, 0.0467654727287663, 0.04891868022378287, 0.06269151975639198, 0.053682911158226765, 0.056395218538225045]}}
{"id": "5e7eb35a-31eb-4ef7-8ef9-0e8628710090", "fitness": 0.05658555618912765, "name": "HPSO_ADE", "description": "Improved HPSO_ADE by dynamically adapting the social coefficient for enhanced convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 24, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["8635937d-ec6c-4e89-b151-6f259bfb1f4b"], "operator": null, "metadata": {"aucs": [0.06401285279319202, 0.04827463892098682, 0.05897269491362478, 0.05567290710452988, 0.04548945852057107, 0.05504171539369063, 0.06507312163836942, 0.05210958160630763, 0.06462303481087661]}}
{"id": "1b987370-8d86-4c79-8640-b1704cdee028", "fitness": 0.05552755770781173, "name": "HPSO_ADE", "description": "Enhanced HPSO_ADE by incorporating adaptive mutation factor and elite retention for improved convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        elite_size = 5  # Added for elite retention\n        for iteration in range(self.budget):\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n            scores = np.array([func(ind) for ind in self.population])\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n            self.f = 0.5 + 0.2 * (iteration / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                if i < elite_size:  # Preserve elite individuals\n                    continue\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 25, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["5e7eb35a-31eb-4ef7-8ef9-0e8628710090"], "operator": null, "metadata": {"aucs": [0.055724005895678386, 0.054907975762022554, 0.05439219579079424, 0.05235362948700695, 0.05146632290946207, 0.05108036063920607, 0.060706849332056056, 0.05988574553895709, 0.05923093401512214]}}
{"id": "7367ba59-adf8-4841-9988-a8a71afa151c", "fitness": 0.05320656135337368, "name": "HPSO_ADE", "description": "Enhanced HPSO_ADE by incorporating adaptive cognitive coefficient and damping factor in velocities for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7\n        self.social = 1.5\n\n    def __call__(self, func):\n        damping_factor = 0.99  # New damping factor for velocities\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive cognitive coefficient\n            self.cognitive = 1.5 + 0.2 * np.sin(iteration / self.budget * np.pi) \n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = damping_factor * (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 26, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["5e7eb35a-31eb-4ef7-8ef9-0e8628710090"], "operator": null, "metadata": {"aucs": [0.056462394399469096, 0.04907362754151956, 0.05377792129979486, 0.05301398092521725, 0.04547146994228779, 0.04979987124366214, 0.06156653161786074, 0.05208421298217136, 0.05760904222838026]}}
{"id": "ec3c1ff4-6883-4c9d-8f39-972eca69b69a", "fitness": 0.05604079995772401, "name": "HPSO_ADE", "description": "Enhanced HPSO_ADE by adjusting the DE mutation factor and introducing a diversity measure to maintain exploration.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.8  # Adjusted DE mutation factor\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            scores = np.array([func(ind) for ind in self.population])\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            for i in range(self.population_size):\n                diversity = np.mean(np.std(self.population, axis=0))  # Diversity measure\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 27, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["5e7eb35a-31eb-4ef7-8ef9-0e8628710090"], "operator": null, "metadata": {"aucs": [0.05780453608506009, 0.051646409884330224, 0.05636056932800526, 0.05424724592755781, 0.048299518996925306, 0.05394434833930839, 0.06319754191487204, 0.055741763974033964, 0.06312526516942307]}}
{"id": "6e5a9355-eafd-4dc9-8788-b9d129615d10", "fitness": 0.056658928059111845, "name": "HPSO_ADE", "description": "Refinement of HPSO_ADE by incorporating adaptive mutation factor and crossover rate to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                trial_score = func(trial_vector)\n                if trial_score < self.pbest_scores[i]:\n                    self.population[i] = trial_vector\n                    self.pbest_scores[i] = trial_score\n                    if trial_score < self.gbest_score:\n                        self.gbest_score = trial_score\n                        self.gbest_position = trial_vector\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 28, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["5e7eb35a-31eb-4ef7-8ef9-0e8628710090"], "operator": null, "metadata": {"aucs": [0.06401285279319202, 0.04824948462374068, 0.05923357503005788, 0.05567290710452988, 0.045466555083844895, 0.055237194390613586, 0.06507312163836942, 0.05207974097745183, 0.06490492089020639]}}
{"id": "12e8c842-ba81-4946-8e4b-e992f64bfeac", "fitness": 0.05892321244592907, "name": "HPSO_ADE", "description": "Enhancement of HPSO_ADE by integrating an elite preservation strategy and adjusted velocity update to refine global exploration and convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        elite_size = 3  # Preserving top 3 elites\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 29, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["6e5a9355-eafd-4dc9-8788-b9d129615d10"], "operator": null, "metadata": {"aucs": [0.06064735931736431, 0.05449928747539534, 0.05965732216115094, 0.05682288069797936, 0.051212120613718826, 0.05586486430664239, 0.06663483201814469, 0.059419602810754535, 0.06555064261221122]}}
{"id": "1cefa673-1718-49b9-800e-5c18325bde14", "fitness": 0.058862083517949824, "name": "HPSO_ADE", "description": "Enhancing HPSO_ADE by fine-tuning the cognitive coefficient to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.9  # Adjusted cognitive coefficient (Change made here)\n        self.social = 1.5\n\n    def __call__(self, func):\n        elite_size = 3  # Preserving top 3 elites\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 30, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["12e8c842-ba81-4946-8e4b-e992f64bfeac"], "operator": null, "metadata": {"aucs": [0.06046994298403485, 0.05449928747539534, 0.05965732216115094, 0.05666578268646172, 0.051212120613718826, 0.05586486430664239, 0.06641918601117858, 0.059419602810754535, 0.06555064261221122]}}
{"id": "8a1765e7-f09b-4aea-9fe2-56425784e2fb", "fitness": 0.05924819457308486, "name": "HPSO_ADE", "description": "Enhancement of HPSO_ADE by refining the elite preservation strategy to dynamically adjust elite size based on convergence progress.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia\n            self.inertia = 0.7 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 31, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["12e8c842-ba81-4946-8e4b-e992f64bfeac"], "operator": null, "metadata": {"aucs": [0.060511240127436694, 0.05402231799507207, 0.06252732845888354, 0.05669979226378974, 0.0507637720057289, 0.05669076751140989, 0.06646040194577807, 0.058869796318544054, 0.06668833453112077]}}
{"id": "a695d0a5-593a-449d-908e-7551f2a388e6", "fitness": 0.059730385433120085, "name": "HPSO_ADE", "description": "Enhanced HPSO_ADE by slightly refining the adaptive inertia weight strategy for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 32, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["8a1765e7-f09b-4aea-9fe2-56425784e2fb"], "operator": null, "metadata": {"aucs": [0.05972492547022734, 0.05279545091041504, 0.06352374841168973, 0.057426659374170796, 0.049649804186770785, 0.05931241207245097, 0.06746341600997463, 0.05736957426039091, 0.07030747820199057]}}
{"id": "8fbcfd97-7800-4f18-9418-0c02ad413789", "fitness": 0.057707868773590985, "name": "HPSO_ADE", "description": "Improved the algorithm by adjusting the inertia weight to enhance exploration in early iterations.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.9 - 0.6 * (iteration / self.budget)  # Changed from previous 0.8 and 0.5\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 33, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["a695d0a5-593a-449d-908e-7551f2a388e6"], "operator": null, "metadata": {"aucs": [0.0600863443409283, 0.052883785531801175, 0.057572185802194475, 0.0563162868998105, 0.049717993518485715, 0.05498275779927597, 0.06594846735612325, 0.05750380420526091, 0.06435919350843855]}}
{"id": "793d00d1-1d2a-4923-99a5-3057df32e832", "fitness": 0.05591474757708242, "name": "HPSO_ADE", "description": "Enhanced exploration phase by introducing a small random noise to the velocities to diversify search paths.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population) +\n                               0.01 * np.random.randn(self.population_size, self.dim))  # Added random noise\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 34, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["a695d0a5-593a-449d-908e-7551f2a388e6"], "operator": null, "metadata": {"aucs": [0.058694243804020885, 0.051590053496425536, 0.05025354699670159, 0.054072606245702426, 0.04854262416245725, 0.05566922939702379, 0.06295203551979289, 0.05594818460958906, 0.06551020396202833]}}
{"id": "d54263bf-a63a-4890-8d5e-958a91bdd8c6", "fitness": 0.05742515293395177, "name": "HPSO_ADE_Refined", "description": "Further refines adaptive strategies and introduces chaotic map for enhancing convergence and diversity.", "code": "import numpy as np\n\nclass HPSO_ADE_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7\n        self.social = 1.5\n        self.chaos = np.random.rand()  # Introduce chaotic variable\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            self.inertia = 0.9 - 0.6 * (iteration / self.budget)  # Change 1: Slightly refined adaptive inertia\n            self.social = 1.6 + 0.4 * (iteration / self.budget)    # Change 2: Slightly refined adaptive social factor\n            self.f = 0.6 + 0.2 * np.sin(0.6 * np.pi * iteration / self.budget)  # Change 3\n            self.cr = 0.85 - 0.35 * (iteration / self.budget)  # Change 4\n\n            scores = np.array([func(ind) for ind in self.population])\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            for i in range(self.population_size):\n                if i not in elite_indices:\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            self.population[elite_indices] = elite_population\n            self.chaos = 4 * self.chaos * (1 - self.chaos)  # Change 5: Chaotic map for enhancing diversity\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 35, "feedback": "The algorithm HPSO_ADE_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["a695d0a5-593a-449d-908e-7551f2a388e6"], "operator": null, "metadata": {"aucs": [0.06345006595559244, 0.04991877777526743, 0.05623325892547981, 0.0580221602703308, 0.047019106891939444, 0.05435172044796499, 0.0682856882210201, 0.05397384354029855, 0.06557175437767238]}}
{"id": "e85460da-b3ce-4da9-8f65-3b32758e80e2", "fitness": 0.05964068252353748, "name": "HPSO_ADE", "description": "Enhanced HPSO_ADE by dynamically adjusting the cognitive coefficient for improved exploration.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of cognitive coefficient\n            self.cognitive = 1.7 + 0.3 * (iteration / self.budget)\n\n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 36, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["a695d0a5-593a-449d-908e-7551f2a388e6"], "operator": null, "metadata": {"aucs": [0.05972492547022734, 0.05278334038625976, 0.06352374841168973, 0.057103274913794855, 0.049638784262307944, 0.05931241207245097, 0.06701698995193783, 0.05735518904117831, 0.07030747820199057]}}
{"id": "6f084e86-09a6-4689-9fb0-eb33a8dc74eb", "fitness": 0.05972028206872065, "name": "HPSO_ADE", "description": "Enhanced the cognitive coefficient adjustment to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(0.5 * np.pi * iteration / self.budget)\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               (self.cognitive + 0.1 * (iteration / self.budget)) * r1 * (self.pbest_positions - self.population) +  # <--- Changed line\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 37, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["a695d0a5-593a-449d-908e-7551f2a388e6"], "operator": null, "metadata": {"aucs": [0.05972492547022734, 0.05279146264444379, 0.06352374841168973, 0.057393715683783486, 0.04964617517791248, 0.05931241207245097, 0.06741778430202194, 0.05736483665396552, 0.07030747820199057]}}
{"id": "a9d34747-6d3d-4ec8-8cee-f3de46dde7c9", "fitness": 0.059785392965352555, "name": "HPSO_ADE", "description": "Improved exploration by adjusting the mutation factor's periodicity in the adaptive strategy.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 38, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["a695d0a5-593a-449d-908e-7551f2a388e6"], "operator": null, "metadata": {"aucs": [0.05972492547022734, 0.052808153334347296, 0.06352374841168973, 0.05761747401229089, 0.04966132677857382, 0.05931241207245097, 0.06772842836348969, 0.05738459004311269, 0.07030747820199057]}}
{"id": "5536f230-3638-4dac-9c4d-10189e2c7970", "fitness": 0.057697754049833204, "name": "HPSO_ADE", "description": "Enhanced exploration by modifying the inertia weight decay to improve convergence rate.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.9 - 0.6 * (iteration / self.budget)  # Modified inertia decay\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 39, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["a9d34747-6d3d-4ec8-8cee-f3de46dde7c9"], "operator": null, "metadata": {"aucs": [0.0600863443409283, 0.05289011307791769, 0.05746539165116227, 0.0563162868998105, 0.04972195626295539, 0.05498275779927597, 0.06594846735612325, 0.057509275551886896, 0.06435919350843855]}}
{"id": "7b4a6f04-aafa-4b6b-a902-b70153ec9bb8", "fitness": 0.05920676031232291, "name": "HPSO_ADE", "description": "Introduced a dynamic cognitive coefficient for improved exploration and convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Dynamic adjustment of cognitive coefficient\n            self.cognitive = 1.7 + 0.3 * np.cos(np.pi * iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 40, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["a9d34747-6d3d-4ec8-8cee-f3de46dde7c9"], "operator": null, "metadata": {"aucs": [0.05972492547022734, 0.052365933770684436, 0.06352374841168973, 0.0559924476771001, 0.0492611496840798, 0.05931241207245097, 0.06550771639510777, 0.05686503112757546, 0.07030747820199057]}}
{"id": "394ee0bc-12d6-4003-9962-22eda56690fb", "fitness": 0.055454216364873896, "name": "HPSO_ADE", "description": "Enhancing the adaptive strategy by refining the mutation factor's adjustment formula for improved convergence.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.cos(np.pi * iteration / self.budget)  # Refined periodicity adjustment\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 41, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["a9d34747-6d3d-4ec8-8cee-f3de46dde7c9"], "operator": null, "metadata": {"aucs": [0.06050839600863467, 0.055153396068697624, 0.05120076600069934, 0.05275286680710889, 0.05179699313642927, 0.0493194896229282, 0.06122577937070495, 0.06017881423864746, 0.056951446030014674]}}
{"id": "becc8ff7-4ca7-4b1c-975c-24002471bc3a", "fitness": 0.059731583938698915, "name": "HPSO_ADE", "description": "Improved exploitation by refining the inertia scaling for better local search capability.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.3 * (iteration / self.budget)  # More gradual scaling\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            self.population += self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 42, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["a9d34747-6d3d-4ec8-8cee-f3de46dde7c9"], "operator": null, "metadata": {"aucs": [0.05972492547022734, 0.05283634550040017, 0.06352374841168973, 0.05738765585390715, 0.04968696432489783, 0.05930295918946371, 0.0674093879764216, 0.057418093905594825, 0.0702941748156879]}}
{"id": "3707c02d-209e-493a-9a66-2e779f5da468", "fitness": 0.0869863464980606, "name": "HPSO_ADE", "description": "Enhanced diversity by introducing an adaptive velocity scaling factor in the PSO component.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            velocity_scaling = 0.9 + 0.1 * np.sin(2 * np.pi * iteration / self.budget)  # New line\n            self.population += velocity_scaling * self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 43, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.05.", "error": "", "parent_ids": ["a9d34747-6d3d-4ec8-8cee-f3de46dde7c9"], "operator": null, "metadata": {"aucs": [0.11759265509437222, 0.05253547877622844, 0.06289738512713383, 0.1016137058355161, 0.049409180670619945, 0.05873867278469325, 0.21344683153537647, 0.05706383207471877, 0.06957937658388635]}}
{"id": "91217692-8d42-4d76-9ce4-a9cba994b3ed", "fitness": 0.05980843968930533, "name": "HPSO_ADE", "description": "Improved exploration by modifying the velocity scaling factor to enhance dynamic adaptations.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            velocity_scaling = 0.9 + 0.1 * np.cos(2 * np.pi * iteration / self.budget)  # Adjusted line\n            self.population += velocity_scaling * self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 44, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3707c02d-209e-493a-9a66-2e779f5da468"], "operator": null, "metadata": {"aucs": [0.05972492547022734, 0.05280765531374998, 0.06352374841168973, 0.05770322645686343, 0.0496608733886148, 0.05931395645589421, 0.06784791822368008, 0.057383997437468914, 0.0703096560455595]}}
{"id": "6afb93fb-024f-428f-a2e4-d0183b2de6cb", "fitness": 0.08698612401803273, "name": "HPSO_ADE", "description": "Enhanced diversity by introducing adaptive inertia and velocity scaling adjustments in the PSO component.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            velocity_scaling = 0.9 + 0.2 * np.sin(2 * np.pi * iteration / self.budget)  # Modified scaling\n            self.population += velocity_scaling * self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 45, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.05.", "error": "", "parent_ids": ["3707c02d-209e-493a-9a66-2e779f5da468"], "operator": null, "metadata": {"aucs": [0.11759265509437222, 0.05253484228434102, 0.06289738512713383, 0.1016137058355161, 0.04940859397870001, 0.05873867278469325, 0.21344683153537647, 0.057063052938275294, 0.06957937658388635]}}
{"id": "91552344-3c1c-4397-8f6a-5188f92b85f6", "fitness": 0.08698612424260693, "name": "HPSO_ADE", "description": "Enhanced exploration by adjusting the velocity scaling factor's periodicity in PSO.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            velocity_scaling = 0.9 + 0.1 * np.sin(4 * np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.population += velocity_scaling * self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 46, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.05.", "error": "", "parent_ids": ["3707c02d-209e-493a-9a66-2e779f5da468"], "operator": null, "metadata": {"aucs": [0.11759265509437222, 0.052534842929479186, 0.06289738512713383, 0.1016137058355161, 0.04940859457180746, 0.05873867278469325, 0.21344683153537647, 0.057063053721197465, 0.06957937658388635]}}
{"id": "07851b58-cd8e-461f-87f9-c621a7ff3555", "fitness": 0.05769025767070051, "name": "HPSO_ADE", "description": "Enhanced exploration via adaptive mutation scale factor in DE component.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.6 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            velocity_scaling = 0.9 + 0.1 * np.sin(2 * np.pi * iteration / self.budget)  # New line\n            self.population += velocity_scaling * self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 47, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3707c02d-209e-493a-9a66-2e779f5da468"], "operator": null, "metadata": {"aucs": [0.06405466651339675, 0.05227617344503854, 0.05490220036331417, 0.059872523122611265, 0.04917828806047686, 0.05152203809595557, 0.0708245918282927, 0.05676256040895211, 0.05981927719826663]}}
{"id": "5264d31d-8586-40d9-aab7-70b75faff573", "fitness": 0.08698640913177902, "name": "HPSO_ADE", "description": "Introduced a non-linear scaling factor in the velocity update for enhanced exploration.", "code": "import numpy as np\n\nclass HPSO_ADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.population = np.random.uniform(-5, 5, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.pbest_positions = np.copy(self.population)\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.f = 0.5\n        self.cr = 0.9\n        self.inertia = 0.7\n        self.cognitive = 1.7  # Adjusted cognitive coefficient\n        self.social = 1.5\n\n    def __call__(self, func):\n        for iteration in range(self.budget):\n            # Dynamic adjustment of inertia (slightly refined)\n            self.inertia = 0.8 - 0.5 * (iteration / self.budget)\n            \n            # Dynamic adjustment of social coefficient\n            self.social = 1.5 + 0.5 * (iteration / self.budget)\n\n            # Adaptive mutation factor and crossover rate\n            self.f = 0.5 + 0.3 * np.sin(np.pi * iteration / self.budget)  # Adjusted periodicity\n            self.cr = 0.9 - 0.4 * (iteration / self.budget)\n\n            # Evaluate the current population\n            scores = np.array([func(ind) for ind in self.population])\n\n            # Update personal bests\n            better_indices = scores < self.pbest_scores\n            self.pbest_positions[better_indices] = self.population[better_indices]\n            self.pbest_scores[better_indices] = scores[better_indices]\n\n            # Update global best\n            min_score_idx = np.argmin(scores)\n            if scores[min_score_idx] < self.gbest_score:\n                self.gbest_score = scores[min_score_idx]\n                self.gbest_position = self.population[min_score_idx]\n\n            # Elite preservation with dynamic elite size\n            elite_size = max(1, int(5 * (1 - iteration / self.budget)))  # Adjust elite size dynamically\n            elite_indices = np.argsort(scores)[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            # Update velocities and positions (PSO)\n            r1, r2 = np.random.rand(2, self.population_size, self.dim)\n            self.velocities = (self.inertia * self.velocities +\n                               self.cognitive * r1 * (self.pbest_positions - self.population) +\n                               self.social * r2 * (self.gbest_position - self.population))\n            velocity_scaling = 0.9 + 0.1 * np.sin(2 * np.pi * iteration**2 / self.budget**2)  # Modified line\n            self.population += velocity_scaling * self.velocities\n            self.population = np.clip(self.population, -5, 5)\n\n            # Apply Differential Evolution (DE) crossover and mutation\n            for i in range(self.population_size):\n                if i not in elite_indices:  # Skip elites during mutation\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n                    mutant_vector = np.clip(a + self.f * (b - c), -5, 5)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.cr, mutant_vector, self.population[i])\n                    trial_score = func(trial_vector)\n                    if trial_score < self.pbest_scores[i]:\n                        self.population[i] = trial_vector\n                        self.pbest_scores[i] = trial_score\n                        if trial_score < self.gbest_score:\n                            self.gbest_score = trial_score\n                            self.gbest_position = trial_vector\n\n            # Reinstate elites\n            self.population[elite_indices] = elite_population\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 48, "feedback": "The algorithm HPSO_ADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.05.", "error": "", "parent_ids": ["3707c02d-209e-493a-9a66-2e779f5da468"], "operator": null, "metadata": {"aucs": [0.11759265509437222, 0.0525356517340535, 0.06289738512713383, 0.1016137058355161, 0.049409342527508504, 0.05873867278469325, 0.21344683153537647, 0.05706406096347094, 0.06957937658388635]}}
