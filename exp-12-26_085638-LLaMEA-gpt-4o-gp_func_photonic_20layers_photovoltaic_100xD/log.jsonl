{"id": "99fd1779-cc8f-4347-baf5-acd77bbcd3ef", "fitness": 0.07920711428406003, "name": "DEALS", "description": "A Hybrid Differential Evolution with Adaptive Local Search (DEALS) that combines global exploration with localized exploitation for efficient optimization.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07921 with standard deviation 0.04269.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.05224536589685991, 0.05306250977290894, 0.05596506012306646, 0.13564416445922634, 0.14217663530157132, 0.14005890795935405, 0.044358845531195956, 0.04458564861477654, 0.04476689089758079]}}
{"id": "75892b91-3eb3-47ff-bb17-21e99dec40b1", "fitness": 0.08076314335288896, "name": "DEALS", "description": "Enhanced DEALS with stochastic adaptive crossover probability for improved diversity and convergence.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08076 with standard deviation 0.04254.", "error": "", "parent_ids": ["99fd1779-cc8f-4347-baf5-acd77bbcd3ef"], "operator": null, "metadata": {"aucs": [0.0582527917338761, 0.052788721878513134, 0.05468371635202962, 0.14204067357682515, 0.14047651480244117, 0.13948376181590083, 0.0458075328457892, 0.04618940080411693, 0.0471451763665085]}}
{"id": "02ee4ca3-901a-4529-ae07-6f72e472cee2", "fitness": 0.0805309546026787, "name": "DEALS", "description": "Enhanced DEALS with adaptive differential weight and crossover probability for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.5 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08053 with standard deviation 0.04093.", "error": "", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {"aucs": [0.05278329189330433, 0.058274291697557934, 0.05408642120011076, 0.13658344170014192, 0.13880799394769183, 0.13929285729505736, 0.047907679358894506, 0.05095224761713424, 0.0460903667142154]}}
{"id": "4d6acf79-d5b7-4336-8ef5-4e31a5a0939a", "fitness": -Infinity, "name": "EnhancedDEALS", "description": "Enhanced DEALS with adaptive population size and dynamic F adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Initial population size\n        self.min_population_size = 5 * dim  # Minimum population size allowed\n        self.max_population_size = 15 * dim  # Maximum population size allowed\n        self.F = 0.8  # Initial differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _dynamic_population_size(self):\n        # Dynamically adjust population size based on convergence\n        if self.scores.std() < 0.01:  # If convergence is detected\n            self.population_size = max(self.min_population_size, self.population_size - self.dim)\n        else:\n            self.population_size = min(self.max_population_size, self.population_size + self.dim)\n\n    def _adjust_F(self):\n        # Dynamically adjust F based on performance\n        self.F = np.clip(0.5 + 0.5 * (1 - np.mean(self.scores) / (np.std(self.scores) + 1e-8)), 0.4, 0.9)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            self._dynamic_population_size()\n            self._adjust_F()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 3, "feedback": "An exception occurred: IndexError('index 218 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 218 is out of bounds for axis 0 with size 200')", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {}}
{"id": "8863c3ca-77ed-4a82-bcc9-514b7b5cb300", "fitness": -Infinity, "name": "EnhancedDEALS", "description": "Enhanced DEALS with dynamic population adaptation and multi-trial selection for improved efficiency and robustness.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _dynamic_population_adaptation(self):\n        # Reduce population size dynamically as evaluations increase\n        reduction_factor = 1 - (self.evaluations / self.budget)\n        new_population_size = max(5, int(self.population_size * reduction_factor))\n        if new_population_size < len(self.population):\n            self.population = self.population[:new_population_size]\n            self.scores = self.scores[:new_population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            self._dynamic_population_adaptation()  # Adapt population size\n            \n            for i in range(len(self.population)):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                # Multi-trial selection approach\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                local_candidate = self._local_search(trial)\n                if self.evaluations < self.budget:\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                best_candidate, best_score = (trial, trial_score) if trial_score < local_score else (local_candidate, local_score)\n\n                if best_score < self.scores[i]:\n                    self.population[i] = best_candidate\n                    self.scores[i] = best_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 4, "feedback": "An exception occurred: IndexError('index 163 is out of bounds for axis 0 with size 160').", "error": "IndexError('index 163 is out of bounds for axis 0 with size 160')", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {}}
{"id": "ee44ee91-8fbe-4a0e-905c-595dc6de6798", "fitness": 0.08585894895917145, "name": "DEALSPlusPlus", "description": "DEALS++ enhances adaptive crossover with elitist selection and dynamic population resizing for improved exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  # Percentage of elitist individuals\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.9\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08586 with standard deviation 0.04285.", "error": "", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {"aucs": [0.060072071721516185, 0.06243027711492799, 0.060775155998561536, 0.14654224364081225, 0.1448996483420586, 0.146808617105875, 0.04712235093976869, 0.04980167716184414, 0.054278498607178705]}}
{"id": "b6c619cc-560b-45d5-82c5-d51ed796a4d5", "fitness": 0.08946332273279334, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces adaptive local search radius and mutation strategies, enhancing solution diversity and convergence speed.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.04220.", "error": "", "parent_ids": ["ee44ee91-8fbe-4a0e-905c-595dc6de6798"], "operator": null, "metadata": {"aucs": [0.059309851799742574, 0.0792279498442856, 0.058217093319019475, 0.152098780103891, 0.1422208076640008, 0.15014252401458572, 0.05641745847251112, 0.05574549882219948, 0.05178994055490427]}}
{"id": "b4daa51f-f81a-48c6-94dc-9daaec7f5bd4", "fitness": 0.0892053189262822, "name": "DEALSPlusPlus", "description": "Implemented adaptive crossover rate adjustment to further enhance solution diversity and exploration.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = self.CR * 0.9 + 0.1 * np.random.rand()  # Adaptive crossover rate adjustment\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08921 with standard deviation 0.04064.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06585802141577479, 0.06543008828377606, 0.065183591980294, 0.14929908922968205, 0.14691692760479247, 0.14278583736933248, 0.05452957540496062, 0.05878598393499579, 0.05405875511293157]}}
{"id": "2d454bff-53ba-419c-b935-7c38804dffa9", "fitness": 0.08740618347614938, "name": "DEALSPlusPlusPlus", "description": "DEALS++++ incorporates a dynamic elitism rate and adaptive crossover probability, enhancing solution exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = 0.9 * (1 - self.evaluations / self.budget) + 0.1\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self.elitism_rate = 0.1 + 0.4 * (1 - self.evaluations / self.budget)\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm DEALSPlusPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08741 with standard deviation 0.04248.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.05636781232735, 0.061863855453694105, 0.06240257794968862, 0.14090983406072222, 0.14833304251626356, 0.15243126074383118, 0.05609766485074652, 0.053789379373231694, 0.05446022400981654]}}
{"id": "296c5270-6626-4ca4-aac3-778e32f39590", "fitness": 0.08631500331175833, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces adaptive local search radius and mutation strategies, enhancing solution diversity and convergence speed while refining crossover strategy.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.4 + 0.6  # Modified crossover rate\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08632 with standard deviation 0.04069.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06197963074514712, 0.0649987749896852, 0.06370544623280816, 0.146400009339253, 0.1429864559206614, 0.14086941952555987, 0.05433754191987117, 0.05093963036377003, 0.05061812076906902]}}
{"id": "4f2bd4a8-c92f-43fa-b223-a7d6b5ea6c8a", "fitness": 0.08697462801895597, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces stochastic elitism to increase exploration by probabilistically selecting elite individuals.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return np.random.choice(elite_indices, len(elite_indices) // 2, replace=False)  # Stochastic elitism\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08697 with standard deviation 0.04096.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06734815122283544, 0.059440374852599454, 0.05976727412287974, 0.14495326163451727, 0.1407276842050028, 0.14782922058650327, 0.05987371796849539, 0.051790659443332276, 0.05104130813443808]}}
{"id": "10d4bf37-5bc2-46d0-9a5a-0d1f020219d7", "fitness": -Infinity, "name": "DEALSEnhanced", "description": "DEALS+++Enhanced incorporates adaptive differential grouping and feedback-controlled local search to improve convergence efficiency and solution quality.", "code": "import numpy as np\n\nclass DEALSEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n        self.feedback_threshold = 0.05  # For adaptive local search\n        \n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx, change_group):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  \n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        if change_group:\n            dims = np.random.choice(self.dim, size=np.random.randint(1, self.dim), replace=False)\n            mutant[dims] = a[dims] + adaptive_F * (b[dims] - c[dims])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, score):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        new_score = func(neighbors)\n        if new_score < score - self.feedback_threshold:\n            return neighbors, new_score\n        return individual, score\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutate_group = (i % 2 == 0)\n                mutant = self._mutate(target_idx, mutate_group)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate, local_score = self._local_search(self.population[target_idx], self.scores[target_idx])\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 11, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {}}
{"id": "10229eb6-2911-496f-b86b-20550a0d36a3", "fitness": 0.08631500331175833, "name": "DEALSPlusPlus", "description": "Improved population resizing and adaptive crossover strategy for enhanced convergence.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.4 + 0.6  # Adjusted crossover rate range\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.80  # Further increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08632 with standard deviation 0.04069.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06197963074514712, 0.0649987749896852, 0.06370544623280816, 0.146400009339253, 0.1429864559206614, 0.14086941952555987, 0.05433754191987117, 0.05093963036377003, 0.05061812076906902]}}
{"id": "acbd539a-fd8f-48e5-ab4d-5d7c0a2e18db", "fitness": 0.08946332273279334, "name": "DEALSPlusPlusDFS", "description": "DEALS+++ with Dynamic Fitness Sharing leverages adaptive mutation, crossover, and a novel fitness sharing mechanism to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusDFS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n        self.sigma_share = 0.1  # Fitness sharing parameter\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def _fitness_sharing(self):\n        distances = np.linalg.norm(self.population[:, np.newaxis] - self.population, axis=2)\n        sharing_values = np.exp(-distances**2 / (2 * self.sigma_share**2))\n        sharing_sum = np.sum(sharing_values, axis=1)\n        shared_scores = self.scores * sharing_sum\n        return shared_scores\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            self.scores = self._fitness_sharing()\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm DEALSPlusPlusDFS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.04220.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.059309851799742574, 0.0792279498442856, 0.058217093319019475, 0.152098780103891, 0.1422208076640008, 0.15014252401458572, 0.05641745847251112, 0.05574549882219948, 0.05178994055490427]}}
{"id": "a02b4747-0432-4b0d-b332-d912e019e35a", "fitness": 0.0911216245933329, "name": "DEALSPlusPlusRefined", "description": "DEALS+++Refined integrates dynamic population control and an adaptive crossover strategy, enhancing both exploitation and exploration capabilities.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5  # Introduced to dynamically adjust mutation factor\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._dynamic_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm DEALSPlusPlusRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09112 with standard deviation 0.04317.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06147542483072577, 0.06881379020040101, 0.0736611117339292, 0.14863641983834164, 0.1476383699021524, 0.1578378460255484, 0.05166484366656121, 0.05484683845625615, 0.05551997668608022]}}
{"id": "ef3e53e5-3fe8-4c3d-9d1a-46889f95d6a0", "fitness": 0.0855011149147309, "name": "DEALSPlusPlusRefinedHyperMutation", "description": "DEALS+++RefinedHyperMutation incorporates hypermutation strategies and dynamic crowding distance to enhance diversity and convergence speed.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefinedHyperMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n        self.hypermutation_factor = 0.5  # To adjust hypermutation influence\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _hypermutate(self, target, iteration):\n        hypermutation_prob = self.hypermutation_factor * (self.budget - self.evaluations) / self.budget\n        if np.random.rand() < hypermutation_prob:\n            perturbation = np.random.uniform(-0.5, 0.5, self.dim) * (self.ub - self.lb)\n            target = np.clip(target + perturbation, self.lb, self.ub)\n        return target\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _crowding_distance(self):\n        distances = np.zeros(self.population_size)\n        for i in range(self.dim):\n            sorted_indices = np.argsort(self.population[:, i])\n            sorted_pop = self.population[sorted_indices]\n            max_dist = np.max(sorted_pop[:, i]) - np.min(sorted_pop[:, i])\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            for j in range(1, self.population_size - 1):\n                distances[sorted_indices[j]] += (sorted_pop[j + 1, i] - sorted_pop[j - 1, i]) / max_dist\n        return distances\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            crowding_distances = self._crowding_distance()\n            elite_indices = np.argsort(crowding_distances)[:int(self.elitism_rate * self.population_size)]\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._dynamic_crossover(target, mutant, iteration)\n\n                trial = self._hypermutate(trial, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm DEALSPlusPlusRefinedHyperMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08550 with standard deviation 0.04363.", "error": "", "parent_ids": ["a02b4747-0432-4b0d-b332-d912e019e35a"], "operator": null, "metadata": {"aucs": [0.06101291642413653, 0.057155103033459276, 0.0556758396882534, 0.14603034816398308, 0.14939398728280706, 0.14554254315652448, 0.05399361793100377, 0.05365132011477225, 0.04705435843763828]}}
{"id": "14bff040-5f7d-4587-9be9-7ad120b66e46", "fitness": 0.09445784543721052, "name": "DEALSPlusPlusRefined2", "description": "DEALS+++Refined2 enhances adaptive control via a novel dual-phase mutation and elite-focused local search, optimizing convergence and solution quality.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm DEALSPlusPlusRefined2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09446 with standard deviation 0.04359.", "error": "", "parent_ids": ["a02b4747-0432-4b0d-b332-d912e019e35a"], "operator": null, "metadata": {"aucs": [0.07303685320198883, 0.07166553118178332, 0.06583541736765652, 0.16047768026279086, 0.15426095580701715, 0.15181892535833985, 0.060904320673306866, 0.0574365709444451, 0.054684354137566116]}}
{"id": "4103cccd-1248-4e8f-b251-2de6f8752a9b", "fitness": -Infinity, "name": "DEALSPlusPlusRefined3", "description": "DEALS+++Refined3 introduces stochastic re-evaluation of solutions for dynamic adaptability and competitive balance, enhancing both exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def _stochastic_re_evaluation(self):\n        re_eval_indices = np.random.choice(self.population_size, int(0.05 * self.population_size), replace=False)\n        for idx in re_eval_indices:\n            if self.evaluations >= self.budget:\n                break\n            new_score = func(self.population[idx])\n            self.evaluations += 1\n            self.scores[idx] = min(self.scores[idx], new_score)\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            self._stochastic_re_evaluation()\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 17, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {}}
{"id": "d4c433d0-6055-47f1-a0f3-5782ab4ea218", "fitness": 0.0922358899881831, "name": "DEALSPlusPlusRefined3", "description": "DEALS+++Refined3 improves on adaptive control and diversity maintenance through a triphase mutation strategy and dynamic elite rotation, further optimizing exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _triphase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * np.random.rand()\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (b - d), self.lb, self.ub)\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._triphase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score3 = func(trial3)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx] or trial_score3 < self.scores[target_idx]:\n                    better_trial, better_score = min(\n                        [(trial1, trial_score1), (trial2, trial_score2), (trial3, trial_score3)], \n                        key=lambda x: x[1]\n                    )\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09224 with standard deviation 0.04481.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.07411317754174462, 0.06253270745672546, 0.06085572501435832, 0.1506096352758749, 0.15731160983361647, 0.15727948987364482, 0.05886034278507146, 0.05290929653376486, 0.055651025578847046]}}
{"id": "ffb3c45e-dd9e-495e-9bb5-633cddb36e92", "fitness": 0.08675409047176773, "name": "DEALSPlusPlusRefined3", "description": "DEALS+++Refined3 introduces adaptive scaling of mutation and crossover rates based on population diversity, enhancing exploitation while preserving exploration for improved convergence.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _calculate_diversity(self):\n        centroid = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - centroid, axis=1))\n        return diversity\n\n    def _adaptive_mutation_scaling(self, idx, diversity):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2) * (diversity / self.dim)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration, diversity):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5 + 0.1 * (diversity / self.dim)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n            diversity = self._calculate_diversity()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation_scaling(target_idx, diversity)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration, diversity)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration, diversity)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 19, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08675 with standard deviation 0.04049.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.06214480863607874, 0.06996266571869247, 0.060006466149638005, 0.14273073820736215, 0.14647092429854902, 0.14122274507936572, 0.05346351720047904, 0.05520204177996013, 0.049582907175784285]}}
{"id": "7d84dfbd-aa09-4b67-bd26-d74a20f187ef", "fitness": 0.08804803605355034, "name": "DEALSPlusPlusImproved", "description": "DEALS+++Improved leverages adaptive learning rates and probabilistic mutation strategies for enhanced exploration and exploitation balance in optimization.", "code": "import numpy as np\n\nclass DEALSPlusPlusImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        probability = np.random.rand()\n        if probability < 0.5:\n            mutant = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant\n\n    def _probabilistic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._adaptive_mutation(target_idx)\n                trial = self._probabilistic_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 20, "feedback": "The algorithm DEALSPlusPlusImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08805 with standard deviation 0.04325.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.0666536393876681, 0.0592357609980102, 0.06229939198782153, 0.15553040194485224, 0.14650660736612564, 0.14421161030078766, 0.053819895151558494, 0.052185595511724636, 0.0519894218334046]}}
{"id": "ee5d8e32-ebb8-42f2-9c59-e133edd09c2c", "fitness": 0.09052403407418834, "name": "DEALSPlusPlusRefined2", "description": "Improved DEALS+++Refined2 by enhancing elitism and introducing a dynamic population size.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Changed from 0.1 to 0.15 to enhance elitism\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.90  # Changed from 0.85 to 0.90 to allow a slower reduction\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 21, "feedback": "The algorithm DEALSPlusPlusRefined2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09052 with standard deviation 0.04180.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.07035253171159062, 0.06310458619699277, 0.06435597191651221, 0.15163157109572012, 0.14602942201967906, 0.15011923535546046, 0.059122735813129546, 0.05597657432515846, 0.05402367823345178]}}
{"id": "e917c69c-d5a8-417c-8c86-f7ca30793c7e", "fitness": 0.09057438646523813, "name": "EnhancedDEALSPlusPlusRefined2", "description": "Enhanced DEALS+++Refined2 with triple-phase mutation and adaptive local search to improve convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedDEALSPlusPlusRefined2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.adaptive_perturbation = 0.05  # Added line\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _triple_phase_mutation(self, idx):  # Modified function\n        indices = np.random.choice(self.population_size, 7, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 7, replace=False)\n        a, b, c, d, e, f, g = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * np.sin(self.evaluations / self.budget * np.pi)  # New mutation factor\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - f), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (f - g), self.lb, self.ub)  # Additional mutation\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _adaptive_local_search(self, elite):  # Modified function\n        perturbation_size = self.adaptive_perturbation * (self.ub - self.lb) * (1 - self.evaluations / self.budget)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._triple_phase_mutation(target_idx)  # Adjusted\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)  # Added\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score3 = func(trial3)  # New evaluation\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2, trial_score3) < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else (trial2 if trial_score2 < trial_score3 else trial3)\n                    better_score = min(trial_score1, trial_score2, trial_score3)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._adaptive_local_search(self.population[target_idx])  # Adjusted\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedDEALSPlusPlusRefined2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09057 with standard deviation 0.04102.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.060818732902922945, 0.07278562867076221, 0.06205203462744757, 0.14782083132335277, 0.15272113001986642, 0.14388532189536818, 0.0588355198414342, 0.06222700221074973, 0.05402327669523921]}}
{"id": "a2fc4aed-c292-4c09-be9b-8bdb4294a3ad", "fitness": 0.0932308645191551, "name": "DEALSPlusPlusRefined3", "description": "DEALS++Refined3 introduces adaptive population resizing and stochastic ranking-based selection, improving diversity and convergence speed for black-box optimization.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _stochastic_ranking_selection(self):\n        ranks = np.argsort(self.scores)\n        probabilities = np.random.rand(self.population_size)\n        for i in range(self.population_size):\n            if i < len(ranks) - 1 and probabilities[i] < 0.45:\n                if self.scores[ranks[i]] > self.scores[ranks[i + 1]]:\n                    ranks[i], ranks[i + 1] = ranks[i + 1], ranks[i]\n        elite_size = int(self.elitism_rate * self.population_size)\n        return ranks[:elite_size]\n\n    def _adaptive_population_resizing(self, iteration):\n        trend_factor = self.evaluations / self.budget\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            scale_factor = 0.85 + 0.15 * (1 - trend_factor)\n            self.population_size = max(int(self.initial_population_size * scale_factor), 5)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._adaptive_population_resizing(iteration)\n            elite_indices = self._stochastic_ranking_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09323 with standard deviation 0.04420.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.07166554927394697, 0.06696160811815655, 0.06569683673731364, 0.16107418380840866, 0.15049485291102904, 0.15386146540850665, 0.06174193735139688, 0.05597874048670359, 0.05160260657693394]}}
{"id": "eba95a6f-8241-4e65-9b36-e7b2b7feb531", "fitness": 0.09439943701809654, "name": "DEALSRefined3", "description": "DEALSRefined3 introduces a diversity-oriented strategy with adaptive perturbation and modified selection pressure to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.diversity_factor = 0.6\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _diversity_oriented_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        F1 = np.random.uniform(self.F - 0.2, self.F + 0.2)\n        F2 = self.F * (1.0 + np.sin(2 * np.pi * (self.evaluations / self.budget)))\n        mutant1 = np.clip(a + F1 * (b - c + self.diversity_factor * (d - e)), self.lb, self.ub)\n        mutant2 = np.clip(d + F2 * (e - a + self.diversity_factor * (b - c)), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        adaptive_CR = (0.5 + 0.5 * np.sin(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, candidate):\n        perturbation_size = 0.01 * (self.ub - self.lb)\n        neighbor = candidate + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        neighbor = np.clip(neighbor, self.lb, self.ub)\n        return neighbor\n\n    def _selection_pressure(self, iteration):\n        return max(0.1, 1.0 - iteration / self.budget)\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            elite_size = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.scores)[:elite_size]\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._diversity_oriented_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 24, "feedback": "The algorithm DEALSRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09440 with standard deviation 0.04077.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.06700625633724477, 0.07829706538393943, 0.07241349887499215, 0.15087611589465844, 0.15070040458646516, 0.15259121805491316, 0.05668925625717203, 0.06089162297026596, 0.06012949480321772]}}
{"id": "951ca8ab-1a9c-4757-9b10-6549d517612d", "fitness": 0.10048127147898599, "name": "DEALSPlusPlusRefined3", "description": "DEALS+++Refined3 integrates adaptive differential evolution with an improved elite selection and dynamic population resizing strategy, enhancing convergence speed and solution quality further.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10048 with standard deviation 0.04310.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.07873275262377966, 0.07280979434634627, 0.07287653632584512, 0.16348449812024513, 0.1609248528375532, 0.15895783129778762, 0.06698988359035163, 0.06654383683655307, 0.0630114573324122]}}
{"id": "5989e62c-7acb-4273-b20f-96bc1af30c7d", "fitness": 0.10048127147898599, "name": "DEALSPlusPlusRefined3", "description": "DEALS++++Refined4 enhances convergence and solution quality by integrating a noise-reduction mechanism and utilizing adaptive differential evolution.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                # Noise reduction by averaging scores\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 26, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10048 with standard deviation 0.04310.", "error": "", "parent_ids": ["951ca8ab-1a9c-4757-9b10-6549d517612d"], "operator": null, "metadata": {"aucs": [0.07873275262377966, 0.07280979434634627, 0.07287653632584512, 0.16348449812024513, 0.1609248528375532, 0.15895783129778762, 0.06698988359035163, 0.06654383683655307, 0.0630114573324122]}}
{"id": "cdfdd641-6171-4104-9e79-cbeb53f464b3", "fitness": 0.10634883082136909, "name": "DEALSPlusPlusRefined4", "description": "DEALS+++Refined4 introduces a mutation diversity boost by adding Gaussian perturbations and enhances elitism by prioritizing recent improvements.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Increased elitism rate\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Added Gaussian perturbation\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10635 with standard deviation 0.04062.", "error": "", "parent_ids": ["951ca8ab-1a9c-4757-9b10-6549d517612d"], "operator": null, "metadata": {"aucs": [0.08286523645391686, 0.09350982503696892, 0.07875837256453255, 0.16743290715934622, 0.1672542287347295, 0.1535925328970552, 0.07220644294242651, 0.06997808932851968, 0.0715418422748263]}}
{"id": "2d5ae0c1-2b70-4483-8c23-816f1d2fa15e", "fitness": 0.09850821346209662, "name": "DEALSPlusPlusRefined4", "description": "Enhanced mutation diversity by adjusting adaptive mutation factor to improve exploration in early stages.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Increased elitism rate\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.3, 0.3)  # Adjusted for enhanced diversity\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Added Gaussian perturbation\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09851 with standard deviation 0.04214.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.06410497491835387, 0.0800714481212137, 0.08203634622517508, 0.1594136105568742, 0.16196649210659786, 0.14896519579200496, 0.05532545258752675, 0.07429809518402042, 0.06039230566710274]}}
{"id": "2d94e42e-0348-4193-9b56-0f38df7f03b8", "fitness": 0.08766102808834202, "name": "DEALSPlusPlusRefined5", "description": "DEALS+++Refined5 enhances diversity by incorporating Cauchy mutations and custom crossover for improved convergence.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Increased elitism rate\n        self.resizing_factor = 0.85\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1.0 + np.random.uniform(-0.1, 0.1))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.standard_cauchy(self.dim), self.lb, self.ub)  # Cauchy mutation\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _custom_crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.CR\n        if not np.any(mask):\n            mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.01 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._custom_crossover(target, mutant1)\n                trial2 = self._custom_crossover(target, mutant2)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08766 with standard deviation 0.04087.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.06596572542065704, 0.0679549380404122, 0.05703097586793049, 0.1477584889202198, 0.1471505013126797, 0.1399688501326911, 0.05320483388367814, 0.058556420790664365, 0.05135851842614525]}}
{"id": "b21615f0-1e04-49f7-9048-14517bbd6d9a", "fitness": 0.08346430206324379, "name": "DEALSPlusPlusRefined5", "description": "DEALS+++Refined5 enhances adaptive mutation with cosine perturbations and dynamic crossover tuning, while introducing a fitness diversity maintenance mechanism for improved exploration.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.diversity_threshold = 0.1  # New parameter for diversity maintenance\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.cos(self.evaluations / self.budget * np.pi)\n        adaptive_F2 = self.F * (1 - np.sin(self.evaluations / self.budget * np.pi))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = (np.cos(iteration / self.budget * np.pi) * 0.5) + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _fitness_diversity_maintenance(self):\n        if np.std(self.scores) < self.diversity_threshold:\n            self.population += np.random.uniform(-0.05, 0.05, self.population.shape)\n            self.population = np.clip(self.population, self.lb, self.ub)\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            self._fitness_diversity_maintenance()\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08346 with standard deviation 0.04216.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.06318532064613125, 0.05809871727425897, 0.05267706248914905, 0.14665988433068133, 0.14193257629810485, 0.13934829225578127, 0.054830589904426574, 0.04987411094755467, 0.044572164423106186]}}
{"id": "aec001b2-13ae-4dba-86f3-128905094414", "fitness": 0.09519682598938364, "name": "DEALSPlusPlusRefined5", "description": "DEALS++++Refined5 boosts convergence by dynamically adjusting population size and scaling factors, with intensified local search around top solutions.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.2  # Further increased elitism rate\n        self.resizing_factor = 0.85\n        self.dynamic_F_factor = 0.3\n        self.local_search_intensity = 0.05  # Increased local search perturbation\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-self.dynamic_F_factor, self.dynamic_F_factor)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = self.local_search_intensity * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            new_population_size = int(self.population_size * self.resizing_factor)\n            if new_population_size < 5:\n                new_population_size = 5  # Ensure a minimum size\n            self.population_size = new_population_size\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n        self.population_size = self.initial_population_size\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 31, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09520 with standard deviation 0.04411.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.07687684282538443, 0.06801375233699303, 0.06816632093308539, 0.16172998963306118, 0.15613050770852555, 0.15285480134136886, 0.05968372591280546, 0.05433024083852189, 0.058985252374706976]}}
{"id": "ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56", "fitness": 0.11412335773533903, "name": "DEALSPlusPlusRefined4", "description": "Enhanced DEALSPlusPlusRefined4 by adjusting the Gaussian perturbation scale to improve exploration.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Increased elitism rate\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)  # Adjusted Gaussian perturbation scale\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11412 with standard deviation 0.04361.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.07702511348496921, 0.09649488534991502, 0.08116254717270144, 0.1888828558064194, 0.1635020590695171, 0.16541409424298736, 0.08232556813437775, 0.10971390903119715, 0.06258918732596697]}}
{"id": "cec87a52-5d27-4a2c-89a5-df08522a64ab", "fitness": 0.09114054546565156, "name": "DEALSPlusPlusRefined5", "description": "Introducing adaptive population resizing and dynamic elitism to enhance exploration and exploitation balance based on iteration progress.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.initial_elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.lb = None\n        self.ub = None\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self, iteration):\n        dynamic_elitism_rate = self.initial_elitism_rate + 0.1 * (iteration / self.budget)\n        elite_size = int(dynamic_elitism_rate * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = max(2, int(self.population_size * self.resizing_factor))\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection(iteration)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 33, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09114 with standard deviation 0.04148.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.0686590178995643, 0.06764253861366076, 0.06122507515565878, 0.14782454872609807, 0.15641622379511488, 0.1439857256469973, 0.05929187694928739, 0.059078875521007435, 0.05614102688347511]}}
{"id": "8801007d-0125-446d-95af-f6bdfab0106d", "fitness": -Infinity, "name": "AdaptiveDEALSPlusRefined", "description": "Introduce adaptive population resizing and a synergy-based mutation strategy for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDEALSPlusRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.expansion_factor = 1.2\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _synergy_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 4, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 4, replace=False)\n        a, b, c, d = self.population[indices]\n        F_dynamic = self.F * np.random.uniform(0.5, 1.5)\n        mutant = np.clip(a + F_dynamic * (b - c) + F_dynamic * (d - a), self.lb, self.ub)\n        return mutant\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _adaptive_population_resizing(self, iteration):\n        resize_interval = self.budget // 10\n        if iteration > 0 and iteration % resize_interval == 0:\n            improvement_ratio = np.mean(self.scores) / np.min(self.scores)\n            if improvement_ratio > 1.0:\n                self.population_size = int(self.population_size * self.expansion_factor)\n            else:\n                self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._adaptive_population_resizing(iteration)\n\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._synergy_mutation(target_idx)\n                trial = self._dynamic_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 34, "feedback": "An exception occurred: AttributeError(\"'AdaptiveDEALSPlusRefined' object has no attribute '_elitist_selection'\").", "error": "AttributeError(\"'AdaptiveDEALSPlusRefined' object has no attribute '_elitist_selection'\")", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {}}
{"id": "600ac39d-f55b-4591-b3e2-fdac14f87b75", "fitness": 0.084980751049718, "name": "EnhancedDEALSPlusPlusRefined5", "description": "Introduced dynamic population resizing and adaptive crossover in Enhanced DEALSPlusPlusRefined4 to improve convergence speed and balance exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedDEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n        self.dynamic_resizing = True  # Enable dynamic population resizing\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.cos(np.pi * iteration / self.budget) * 0.5 + 0.5  # Adjusted dynamic crossover\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if self.dynamic_resizing and iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = max(int(self.population_size * self.resizing_factor), 5)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedDEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08498 with standard deviation 0.04027.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.06299633710590125, 0.06188376717117994, 0.06002839280399053, 0.13780181928710422, 0.1421751398688712, 0.14476093987664662, 0.052920722931594555, 0.05242357677289955, 0.049836063629274174]}}
{"id": "2ea75062-85c0-46ed-9cd9-814ff2cbdd89", "fitness": 0.0868829255943057, "name": "DEALSPlusPlusRefined5", "description": "Introduced an adaptive elitism and mutation strategy in DEALSPlusPlusRefined5 for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Base elitism rate\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        perturbation_scale = 0.05 + 0.1 * (1 - self.evaluations / self.budget)  # Dynamic perturbation scale\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, perturbation_scale, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _adaptive_elitist_selection(self):\n        elitism_rate = self.elitism_rate + 0.1 * (self.evaluations / self.budget)  # Adaptive elitism rate\n        elite_size = int(elitism_rate * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._adaptive_elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08688 with standard deviation 0.04186.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.06118139376667642, 0.060353107551118224, 0.06521141041863343, 0.14687475807990258, 0.14368603099689303, 0.14675141786067947, 0.053923457323252766, 0.05251491563365118, 0.051449838717944174]}}
{"id": "3f97e5de-a83e-4fa4-a4c9-786ec792a0ef", "fitness": 0.10226190678747489, "name": "DEALSPlusPlusRefined4", "description": "Improved adaptive parameter adjustment and diversified mutation strategy for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + 0.3 * np.random.uniform(-1, 1)  # Modified line\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Modified line\n        mutant2 = np.clip(d + adaptive_F2 * (e - a) + 0.1 * (self.population[np.random.randint(self.population_size)] - a), self.lb, self.ub)  # Modified line\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10226 with standard deviation 0.03909.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.09025193821814048, 0.06683099992981612, 0.08488820370718975, 0.15935016540274116, 0.1584409849613222, 0.1512914865000996, 0.07589386478133953, 0.0647946712232228, 0.06861484636340243]}}
{"id": "0cd8e224-8830-4d5d-be4b-602fe520582b", "fitness": 0.10714128417949764, "name": "DEALSPlusPlusRefined4", "description": "Enhanced exploration by integrating Lvy flights into the mutation process.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _levy_flight(self, size, lb, ub):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(size) * sigma\n        v = np.random.randn(size)\n        step = u / np.abs(v) ** (1 / beta)\n        return np.clip(step, lb, ub)\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        levy_step = self._levy_flight(self.dim, self.lb, self.ub)  # Lvy flight integration\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + levy_step, self.lb, self.ub)  # Enhanced mutation\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 38, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10714 with standard deviation 0.04240.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.07379065523664163, 0.1128926428268221, 0.07281187680397694, 0.17435353137505183, 0.15967562095239862, 0.15734558491361983, 0.06826962721145768, 0.0813045794153816, 0.06382743888012854]}}
{"id": "19c0bf81-616f-41ee-9c32-5f3534dff9f0", "fitness": 0.13285971824429174, "name": "DEALSPlusPlusRefined4", "description": "Introduced adaptive resizing in crossover and dynamic mutation adjustment to enhance convergence speed.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * (1 - self.evaluations / self.budget)  # New adaptive factor\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (a - b), self.lb, self.ub)  # New mutant strategy\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        dynamic_CR *= (1 - self.evaluations / self.budget)  # Adaptive resizing in crossover\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._dual_phase_mutation(target_idx)  # Updated number of mutants\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)  # New trial\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                trial_score3 = func(trial3)  # Evaluate new trial\n                self.evaluations += 1\n\n                # Update selection process to include new trial\n                if min(trial_score1, trial_score2, trial_score3) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), (trial3, trial_score3), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13286 with standard deviation 0.04247.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.11212727932107547, 0.13725881199840728, 0.12631117741177245, 0.17923019420783648, 0.19269958739394621, 0.18955601997567917, 0.07330733047141014, 0.09017608621553264, 0.09507097720296576]}}
{"id": "21af1bfb-8a8c-48f0-af50-e7610329b613", "fitness": 0.1288104761728349, "name": "DEALSPlusPlusRefined4", "description": "Enhanced mutation diversity by introducing perturbation in the adaptive factor and improved local search with directional adjustment.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2) * np.random.rand()  # Added random factor\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * (1 - self.evaluations / self.budget)\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (a - b), self.lb, self.ub)\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        dynamic_CR *= (1 - self.evaluations / self.budget)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        step_direction = np.random.uniform(-1, 1, self.dim)  # Directional adjustment\n        candidate = elite + step_direction * perturbation_size\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                trial_score3 = func(trial3)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2, trial_score3) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), (trial3, trial_score3), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 40, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12881 with standard deviation 0.03809.", "error": "", "parent_ids": ["19c0bf81-616f-41ee-9c32-5f3534dff9f0"], "operator": null, "metadata": {"aucs": [0.12954730994914754, 0.11171451668777677, 0.09664461864127072, 0.1765532215916089, 0.18320437857076077, 0.17575939032357613, 0.08148357879613788, 0.11995927586281463, 0.08442799513242072]}}
{"id": "0164741a-7cbf-472c-bcf5-3079ad0608e7", "fitness": 0.07752076700600344, "name": "EnhancedDEALS", "description": "Introduced multi-rate mutation strategies with feedback-driven learning to enhance convergence and robustness in diverse problem spaces.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.adaptive_F = [0.5, 0.7, 0.9]  # Different mutation strategies\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _multi_rate_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        mutants = []\n        for F in self.adaptive_F:\n            mutants.append(np.clip(a + F * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub))\n            mutants.append(np.clip(d + F * (e - a), self.lb, self.ub))\n        return mutants\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.cos(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutants = self._multi_rate_mutation(target_idx)\n                trials = [self._dynamic_crossover(target, mutant, iteration) for mutant in mutants]\n\n                trial_scores = [func(trial) for trial in trials]\n                self.evaluations += len(trials)\n\n                best_trial_index = np.argmin(trial_scores)\n                best_trial = trials[best_trial_index]\n                best_score = trial_scores[best_trial_index]\n\n                if best_score < self.scores[target_idx]:\n                    self.population[target_idx] = best_trial\n                    self.scores[target_idx] = best_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07752 with standard deviation 0.04233.", "error": "", "parent_ids": ["19c0bf81-616f-41ee-9c32-5f3534dff9f0"], "operator": null, "metadata": {"aucs": [0.048789096886795225, 0.05228091224671849, 0.05274403498362179, 0.13609802871568344, 0.13944588689530502, 0.13607509823438524, 0.04364156454239976, 0.04490009798014405, 0.04371218256897791]}}
