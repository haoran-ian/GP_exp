{"id": "99fd1779-cc8f-4347-baf5-acd77bbcd3ef", "fitness": 0.07920711428406003, "name": "DEALS", "description": "A Hybrid Differential Evolution with Adaptive Local Search (DEALS) that combines global exploration with localized exploitation for efficient optimization.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07921 with standard deviation 0.04269.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.05224536589685991, 0.05306250977290894, 0.05596506012306646, 0.13564416445922634, 0.14217663530157132, 0.14005890795935405, 0.044358845531195956, 0.04458564861477654, 0.04476689089758079]}}
{"id": "75892b91-3eb3-47ff-bb17-21e99dec40b1", "fitness": 0.08076314335288896, "name": "DEALS", "description": "Enhanced DEALS with stochastic adaptive crossover probability for improved diversity and convergence.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08076 with standard deviation 0.04254.", "error": "", "parent_ids": ["99fd1779-cc8f-4347-baf5-acd77bbcd3ef"], "operator": null, "metadata": {"aucs": [0.0582527917338761, 0.052788721878513134, 0.05468371635202962, 0.14204067357682515, 0.14047651480244117, 0.13948376181590083, 0.0458075328457892, 0.04618940080411693, 0.0471451763665085]}}
{"id": "02ee4ca3-901a-4529-ae07-6f72e472cee2", "fitness": 0.0805309546026787, "name": "DEALS", "description": "Enhanced DEALS with adaptive differential weight and crossover probability for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.5 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08053 with standard deviation 0.04093.", "error": "", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {"aucs": [0.05278329189330433, 0.058274291697557934, 0.05408642120011076, 0.13658344170014192, 0.13880799394769183, 0.13929285729505736, 0.047907679358894506, 0.05095224761713424, 0.0460903667142154]}}
{"id": "4d6acf79-d5b7-4336-8ef5-4e31a5a0939a", "fitness": -Infinity, "name": "EnhancedDEALS", "description": "Enhanced DEALS with adaptive population size and dynamic F adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Initial population size\n        self.min_population_size = 5 * dim  # Minimum population size allowed\n        self.max_population_size = 15 * dim  # Maximum population size allowed\n        self.F = 0.8  # Initial differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _dynamic_population_size(self):\n        # Dynamically adjust population size based on convergence\n        if self.scores.std() < 0.01:  # If convergence is detected\n            self.population_size = max(self.min_population_size, self.population_size - self.dim)\n        else:\n            self.population_size = min(self.max_population_size, self.population_size + self.dim)\n\n    def _adjust_F(self):\n        # Dynamically adjust F based on performance\n        self.F = np.clip(0.5 + 0.5 * (1 - np.mean(self.scores) / (np.std(self.scores) + 1e-8)), 0.4, 0.9)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            self._dynamic_population_size()\n            self._adjust_F()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 3, "feedback": "An exception occurred: IndexError('index 218 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 218 is out of bounds for axis 0 with size 200')", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {}}
{"id": "8863c3ca-77ed-4a82-bcc9-514b7b5cb300", "fitness": -Infinity, "name": "EnhancedDEALS", "description": "Enhanced DEALS with dynamic population adaptation and multi-trial selection for improved efficiency and robustness.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _dynamic_population_adaptation(self):\n        # Reduce population size dynamically as evaluations increase\n        reduction_factor = 1 - (self.evaluations / self.budget)\n        new_population_size = max(5, int(self.population_size * reduction_factor))\n        if new_population_size < len(self.population):\n            self.population = self.population[:new_population_size]\n            self.scores = self.scores[:new_population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            self._dynamic_population_adaptation()  # Adapt population size\n            \n            for i in range(len(self.population)):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                # Multi-trial selection approach\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                local_candidate = self._local_search(trial)\n                if self.evaluations < self.budget:\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                best_candidate, best_score = (trial, trial_score) if trial_score < local_score else (local_candidate, local_score)\n\n                if best_score < self.scores[i]:\n                    self.population[i] = best_candidate\n                    self.scores[i] = best_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 4, "feedback": "An exception occurred: IndexError('index 163 is out of bounds for axis 0 with size 160').", "error": "IndexError('index 163 is out of bounds for axis 0 with size 160')", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {}}
{"id": "ee44ee91-8fbe-4a0e-905c-595dc6de6798", "fitness": 0.08585894895917145, "name": "DEALSPlusPlus", "description": "DEALS++ enhances adaptive crossover with elitist selection and dynamic population resizing for improved exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  # Percentage of elitist individuals\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.9\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08586 with standard deviation 0.04285.", "error": "", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {"aucs": [0.060072071721516185, 0.06243027711492799, 0.060775155998561536, 0.14654224364081225, 0.1448996483420586, 0.146808617105875, 0.04712235093976869, 0.04980167716184414, 0.054278498607178705]}}
{"id": "b6c619cc-560b-45d5-82c5-d51ed796a4d5", "fitness": 0.08946332273279334, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces adaptive local search radius and mutation strategies, enhancing solution diversity and convergence speed.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.04220.", "error": "", "parent_ids": ["ee44ee91-8fbe-4a0e-905c-595dc6de6798"], "operator": null, "metadata": {"aucs": [0.059309851799742574, 0.0792279498442856, 0.058217093319019475, 0.152098780103891, 0.1422208076640008, 0.15014252401458572, 0.05641745847251112, 0.05574549882219948, 0.05178994055490427]}}
{"id": "b4daa51f-f81a-48c6-94dc-9daaec7f5bd4", "fitness": 0.0892053189262822, "name": "DEALSPlusPlus", "description": "Implemented adaptive crossover rate adjustment to further enhance solution diversity and exploration.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = self.CR * 0.9 + 0.1 * np.random.rand()  # Adaptive crossover rate adjustment\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08921 with standard deviation 0.04064.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06585802141577479, 0.06543008828377606, 0.065183591980294, 0.14929908922968205, 0.14691692760479247, 0.14278583736933248, 0.05452957540496062, 0.05878598393499579, 0.05405875511293157]}}
{"id": "2d454bff-53ba-419c-b935-7c38804dffa9", "fitness": 0.08740618347614938, "name": "DEALSPlusPlusPlus", "description": "DEALS++++ incorporates a dynamic elitism rate and adaptive crossover probability, enhancing solution exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = 0.9 * (1 - self.evaluations / self.budget) + 0.1\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self.elitism_rate = 0.1 + 0.4 * (1 - self.evaluations / self.budget)\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm DEALSPlusPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08741 with standard deviation 0.04248.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.05636781232735, 0.061863855453694105, 0.06240257794968862, 0.14090983406072222, 0.14833304251626356, 0.15243126074383118, 0.05609766485074652, 0.053789379373231694, 0.05446022400981654]}}
{"id": "296c5270-6626-4ca4-aac3-778e32f39590", "fitness": 0.08631500331175833, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces adaptive local search radius and mutation strategies, enhancing solution diversity and convergence speed while refining crossover strategy.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.4 + 0.6  # Modified crossover rate\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08632 with standard deviation 0.04069.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06197963074514712, 0.0649987749896852, 0.06370544623280816, 0.146400009339253, 0.1429864559206614, 0.14086941952555987, 0.05433754191987117, 0.05093963036377003, 0.05061812076906902]}}
{"id": "4f2bd4a8-c92f-43fa-b223-a7d6b5ea6c8a", "fitness": 0.08697462801895597, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces stochastic elitism to increase exploration by probabilistically selecting elite individuals.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return np.random.choice(elite_indices, len(elite_indices) // 2, replace=False)  # Stochastic elitism\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08697 with standard deviation 0.04096.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06734815122283544, 0.059440374852599454, 0.05976727412287974, 0.14495326163451727, 0.1407276842050028, 0.14782922058650327, 0.05987371796849539, 0.051790659443332276, 0.05104130813443808]}}
{"id": "10d4bf37-5bc2-46d0-9a5a-0d1f020219d7", "fitness": -Infinity, "name": "DEALSEnhanced", "description": "DEALS+++Enhanced incorporates adaptive differential grouping and feedback-controlled local search to improve convergence efficiency and solution quality.", "code": "import numpy as np\n\nclass DEALSEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n        self.feedback_threshold = 0.05  # For adaptive local search\n        \n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx, change_group):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  \n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        if change_group:\n            dims = np.random.choice(self.dim, size=np.random.randint(1, self.dim), replace=False)\n            mutant[dims] = a[dims] + adaptive_F * (b[dims] - c[dims])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, score):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        new_score = func(neighbors)\n        if new_score < score - self.feedback_threshold:\n            return neighbors, new_score\n        return individual, score\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutate_group = (i % 2 == 0)\n                mutant = self._mutate(target_idx, mutate_group)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate, local_score = self._local_search(self.population[target_idx], self.scores[target_idx])\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 11, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {}}
{"id": "10229eb6-2911-496f-b86b-20550a0d36a3", "fitness": 0.08631500331175833, "name": "DEALSPlusPlus", "description": "Improved population resizing and adaptive crossover strategy for enhanced convergence.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.4 + 0.6  # Adjusted crossover rate range\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.80  # Further increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08632 with standard deviation 0.04069.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06197963074514712, 0.0649987749896852, 0.06370544623280816, 0.146400009339253, 0.1429864559206614, 0.14086941952555987, 0.05433754191987117, 0.05093963036377003, 0.05061812076906902]}}
{"id": "acbd539a-fd8f-48e5-ab4d-5d7c0a2e18db", "fitness": 0.08946332273279334, "name": "DEALSPlusPlusDFS", "description": "DEALS+++ with Dynamic Fitness Sharing leverages adaptive mutation, crossover, and a novel fitness sharing mechanism to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusDFS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n        self.sigma_share = 0.1  # Fitness sharing parameter\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def _fitness_sharing(self):\n        distances = np.linalg.norm(self.population[:, np.newaxis] - self.population, axis=2)\n        sharing_values = np.exp(-distances**2 / (2 * self.sigma_share**2))\n        sharing_sum = np.sum(sharing_values, axis=1)\n        shared_scores = self.scores * sharing_sum\n        return shared_scores\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            self.scores = self._fitness_sharing()\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm DEALSPlusPlusDFS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.04220.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.059309851799742574, 0.0792279498442856, 0.058217093319019475, 0.152098780103891, 0.1422208076640008, 0.15014252401458572, 0.05641745847251112, 0.05574549882219948, 0.05178994055490427]}}
{"id": "a02b4747-0432-4b0d-b332-d912e019e35a", "fitness": 0.0911216245933329, "name": "DEALSPlusPlusRefined", "description": "DEALS+++Refined integrates dynamic population control and an adaptive crossover strategy, enhancing both exploitation and exploration capabilities.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5  # Introduced to dynamically adjust mutation factor\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._dynamic_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm DEALSPlusPlusRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09112 with standard deviation 0.04317.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06147542483072577, 0.06881379020040101, 0.0736611117339292, 0.14863641983834164, 0.1476383699021524, 0.1578378460255484, 0.05166484366656121, 0.05484683845625615, 0.05551997668608022]}}
