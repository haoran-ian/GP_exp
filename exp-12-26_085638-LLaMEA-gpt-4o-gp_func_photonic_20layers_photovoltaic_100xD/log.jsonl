{"id": "99fd1779-cc8f-4347-baf5-acd77bbcd3ef", "fitness": 0.07920711428406003, "name": "DEALS", "description": "A Hybrid Differential Evolution with Adaptive Local Search (DEALS) that combines global exploration with localized exploitation for efficient optimization.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07921 with standard deviation 0.04269.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.05224536589685991, 0.05306250977290894, 0.05596506012306646, 0.13564416445922634, 0.14217663530157132, 0.14005890795935405, 0.044358845531195956, 0.04458564861477654, 0.04476689089758079]}}
{"id": "75892b91-3eb3-47ff-bb17-21e99dec40b1", "fitness": 0.08076314335288896, "name": "DEALS", "description": "Enhanced DEALS with stochastic adaptive crossover probability for improved diversity and convergence.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08076 with standard deviation 0.04254.", "error": "", "parent_ids": ["99fd1779-cc8f-4347-baf5-acd77bbcd3ef"], "operator": null, "metadata": {"aucs": [0.0582527917338761, 0.052788721878513134, 0.05468371635202962, 0.14204067357682515, 0.14047651480244117, 0.13948376181590083, 0.0458075328457892, 0.04618940080411693, 0.0471451763665085]}}
{"id": "02ee4ca3-901a-4529-ae07-6f72e472cee2", "fitness": 0.0805309546026787, "name": "DEALS", "description": "Enhanced DEALS with adaptive differential weight and crossover probability for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass DEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.5 + np.random.rand() * 0.3  # Adaptive differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm DEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08053 with standard deviation 0.04093.", "error": "", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {"aucs": [0.05278329189330433, 0.058274291697557934, 0.05408642120011076, 0.13658344170014192, 0.13880799394769183, 0.13929285729505736, 0.047907679358894506, 0.05095224761713424, 0.0460903667142154]}}
{"id": "4d6acf79-d5b7-4336-8ef5-4e31a5a0939a", "fitness": -Infinity, "name": "EnhancedDEALS", "description": "Enhanced DEALS with adaptive population size and dynamic F adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Initial population size\n        self.min_population_size = 5 * dim  # Minimum population size allowed\n        self.max_population_size = 15 * dim  # Maximum population size allowed\n        self.F = 0.8  # Initial differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _dynamic_population_size(self):\n        # Dynamically adjust population size based on convergence\n        if self.scores.std() < 0.01:  # If convergence is detected\n            self.population_size = max(self.min_population_size, self.population_size - self.dim)\n        else:\n            self.population_size = min(self.max_population_size, self.population_size + self.dim)\n\n    def _adjust_F(self):\n        # Dynamically adjust F based on performance\n        self.F = np.clip(0.5 + 0.5 * (1 - np.mean(self.scores) / (np.std(self.scores) + 1e-8)), 0.4, 0.9)\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            self._dynamic_population_size()\n            self._adjust_F()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[i]:\n                    self.population[i] = trial\n                    self.scores[i] = trial_score\n\n                # Perform adaptive local search\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[i])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[i]:\n                        self.population[i] = local_candidate\n                        self.scores[i] = local_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 3, "feedback": "An exception occurred: IndexError('index 218 is out of bounds for axis 0 with size 200').", "error": "IndexError('index 218 is out of bounds for axis 0 with size 200')", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {}}
{"id": "8863c3ca-77ed-4a82-bcc9-514b7b5cb300", "fitness": -Infinity, "name": "EnhancedDEALS", "description": "Enhanced DEALS with dynamic population adaptation and multi-trial selection for improved efficiency and robustness.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Population size scales with dimensionality\n        self.F = 0.8  # Differential weight\n        self.CR = 0.9  # Initial crossover probability\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5  # Stochastic adaptive CR\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _dynamic_population_adaptation(self):\n        # Reduce population size dynamically as evaluations increase\n        reduction_factor = 1 - (self.evaluations / self.budget)\n        new_population_size = max(5, int(self.population_size * reduction_factor))\n        if new_population_size < len(self.population):\n            self.population = self.population[:new_population_size]\n            self.scores = self.scores[:new_population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n        \n        while self.evaluations < self.budget:\n            self._dynamic_population_adaptation()  # Adapt population size\n            \n            for i in range(len(self.population)):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant = self._mutate(i)\n                trial = self._crossover(target, mutant)\n\n                # Multi-trial selection approach\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                local_candidate = self._local_search(trial)\n                if self.evaluations < self.budget:\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                best_candidate, best_score = (trial, trial_score) if trial_score < local_score else (local_candidate, local_score)\n\n                if best_score < self.scores[i]:\n                    self.population[i] = best_candidate\n                    self.scores[i] = best_score\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 4, "feedback": "An exception occurred: IndexError('index 163 is out of bounds for axis 0 with size 160').", "error": "IndexError('index 163 is out of bounds for axis 0 with size 160')", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {}}
{"id": "ee44ee91-8fbe-4a0e-905c-595dc6de6798", "fitness": 0.08585894895917145, "name": "DEALSPlusPlus", "description": "DEALS++ enhances adaptive crossover with elitist selection and dynamic population resizing for improved exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  # Percentage of elitist individuals\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        mutant = np.clip(a + self.F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.1 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.9\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08586 with standard deviation 0.04285.", "error": "", "parent_ids": ["75892b91-3eb3-47ff-bb17-21e99dec40b1"], "operator": null, "metadata": {"aucs": [0.060072071721516185, 0.06243027711492799, 0.060775155998561536, 0.14654224364081225, 0.1448996483420586, 0.146808617105875, 0.04712235093976869, 0.04980167716184414, 0.054278498607178705]}}
{"id": "b6c619cc-560b-45d5-82c5-d51ed796a4d5", "fitness": 0.08946332273279334, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces adaptive local search radius and mutation strategies, enhancing solution diversity and convergence speed.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.04220.", "error": "", "parent_ids": ["ee44ee91-8fbe-4a0e-905c-595dc6de6798"], "operator": null, "metadata": {"aucs": [0.059309851799742574, 0.0792279498442856, 0.058217093319019475, 0.152098780103891, 0.1422208076640008, 0.15014252401458572, 0.05641745847251112, 0.05574549882219948, 0.05178994055490427]}}
{"id": "b4daa51f-f81a-48c6-94dc-9daaec7f5bd4", "fitness": 0.0892053189262822, "name": "DEALSPlusPlus", "description": "Implemented adaptive crossover rate adjustment to further enhance solution diversity and exploration.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = self.CR * 0.9 + 0.1 * np.random.rand()  # Adaptive crossover rate adjustment\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08921 with standard deviation 0.04064.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06585802141577479, 0.06543008828377606, 0.065183591980294, 0.14929908922968205, 0.14691692760479247, 0.14278583736933248, 0.05452957540496062, 0.05878598393499579, 0.05405875511293157]}}
{"id": "2d454bff-53ba-419c-b935-7c38804dffa9", "fitness": 0.08740618347614938, "name": "DEALSPlusPlusPlus", "description": "DEALS++++ incorporates a dynamic elitism rate and adaptive crossover probability, enhancing solution exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = 0.9 * (1 - self.evaluations / self.budget) + 0.1\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self.elitism_rate = 0.1 + 0.4 * (1 - self.evaluations / self.budget)\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm DEALSPlusPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08741 with standard deviation 0.04248.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.05636781232735, 0.061863855453694105, 0.06240257794968862, 0.14090983406072222, 0.14833304251626356, 0.15243126074383118, 0.05609766485074652, 0.053789379373231694, 0.05446022400981654]}}
{"id": "296c5270-6626-4ca4-aac3-778e32f39590", "fitness": 0.08631500331175833, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces adaptive local search radius and mutation strategies, enhancing solution diversity and convergence speed while refining crossover strategy.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.4 + 0.6  # Modified crossover rate\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08632 with standard deviation 0.04069.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06197963074514712, 0.0649987749896852, 0.06370544623280816, 0.146400009339253, 0.1429864559206614, 0.14086941952555987, 0.05433754191987117, 0.05093963036377003, 0.05061812076906902]}}
{"id": "4f2bd4a8-c92f-43fa-b223-a7d6b5ea6c8a", "fitness": 0.08697462801895597, "name": "DEALSPlusPlus", "description": "DEALS+++ introduces stochastic elitism to increase exploration by probabilistically selecting elite individuals.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return np.random.choice(elite_indices, len(elite_indices) // 2, replace=False)  # Stochastic elitism\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85  # Increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08697 with standard deviation 0.04096.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06734815122283544, 0.059440374852599454, 0.05976727412287974, 0.14495326163451727, 0.1407276842050028, 0.14782922058650327, 0.05987371796849539, 0.051790659443332276, 0.05104130813443808]}}
{"id": "10d4bf37-5bc2-46d0-9a5a-0d1f020219d7", "fitness": -Infinity, "name": "DEALSEnhanced", "description": "DEALS+++Enhanced incorporates adaptive differential grouping and feedback-controlled local search to improve convergence efficiency and solution quality.", "code": "import numpy as np\n\nclass DEALSEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n        self.feedback_threshold = 0.05  # For adaptive local search\n        \n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx, change_group):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  \n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        if change_group:\n            dims = np.random.choice(self.dim, size=np.random.randint(1, self.dim), replace=False)\n            mutant[dims] = a[dims] + adaptive_F * (b[dims] - c[dims])\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual, score):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        new_score = func(neighbors)\n        if new_score < score - self.feedback_threshold:\n            return neighbors, new_score\n        return individual, score\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutate_group = (i % 2 == 0)\n                mutant = self._mutate(target_idx, mutate_group)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate, local_score = self._local_search(self.population[target_idx], self.scores[target_idx])\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 11, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {}}
{"id": "10229eb6-2911-496f-b86b-20550a0d36a3", "fitness": 0.08631500331175833, "name": "DEALSPlusPlus", "description": "Improved population resizing and adaptive crossover strategy for enhanced convergence.", "code": "import numpy as np\n\nclass DEALSPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)  # Added adaptive_F\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.4 + 0.6  # Adjusted crossover rate range\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)  # Reduced step size for finer search\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.80  # Further increased reduction for faster resizing\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm DEALSPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08632 with standard deviation 0.04069.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06197963074514712, 0.0649987749896852, 0.06370544623280816, 0.146400009339253, 0.1429864559206614, 0.14086941952555987, 0.05433754191987117, 0.05093963036377003, 0.05061812076906902]}}
{"id": "acbd539a-fd8f-48e5-ab4d-5d7c0a2e18db", "fitness": 0.08946332273279334, "name": "DEALSPlusPlusDFS", "description": "DEALS+++ with Dynamic Fitness Sharing leverages adaptive mutation, crossover, and a novel fitness sharing mechanism to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusDFS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1  \n        self.sigma_share = 0.1  # Fitness sharing parameter\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)  # Adaptive mutation factor\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _crossover(self, target, mutant):\n        self.CR = np.random.rand() * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def _fitness_sharing(self):\n        distances = np.linalg.norm(self.population[:, np.newaxis] - self.population, axis=2)\n        sharing_values = np.exp(-distances**2 / (2 * self.sigma_share**2))\n        sharing_sum = np.sum(sharing_values, axis=1)\n        shared_scores = self.scores * sharing_sum\n        return shared_scores\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._crossover(target, mutant)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            self.scores = self._fitness_sharing()\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm DEALSPlusPlusDFS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.04220.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.059309851799742574, 0.0792279498442856, 0.058217093319019475, 0.152098780103891, 0.1422208076640008, 0.15014252401458572, 0.05641745847251112, 0.05574549882219948, 0.05178994055490427]}}
{"id": "a02b4747-0432-4b0d-b332-d912e019e35a", "fitness": 0.0911216245933329, "name": "DEALSPlusPlusRefined", "description": "DEALS+++Refined integrates dynamic population control and an adaptive crossover strategy, enhancing both exploitation and exploration capabilities.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5  # Introduced to dynamically adjust mutation factor\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._dynamic_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm DEALSPlusPlusRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09112 with standard deviation 0.04317.", "error": "", "parent_ids": ["b6c619cc-560b-45d5-82c5-d51ed796a4d5"], "operator": null, "metadata": {"aucs": [0.06147542483072577, 0.06881379020040101, 0.0736611117339292, 0.14863641983834164, 0.1476383699021524, 0.1578378460255484, 0.05166484366656121, 0.05484683845625615, 0.05551997668608022]}}
{"id": "ef3e53e5-3fe8-4c3d-9d1a-46889f95d6a0", "fitness": 0.0855011149147309, "name": "DEALSPlusPlusRefinedHyperMutation", "description": "DEALS+++RefinedHyperMutation incorporates hypermutation strategies and dynamic crowding distance to enhance diversity and convergence speed.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefinedHyperMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n        self.hypermutation_factor = 0.5  # To adjust hypermutation influence\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def _mutate(self, idx):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 3, replace=False)\n        a, b, c = self.population[indices]\n        adaptive_F = self.F + np.random.uniform(-0.2, 0.2)\n        mutant = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        return mutant\n\n    def _hypermutate(self, target, iteration):\n        hypermutation_prob = self.hypermutation_factor * (self.budget - self.evaluations) / self.budget\n        if np.random.rand() < hypermutation_prob:\n            perturbation = np.random.uniform(-0.5, 0.5, self.dim) * (self.ub - self.lb)\n            target = np.clip(target + perturbation, self.lb, self.ub)\n        return target\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, individual):\n        step_size = 0.05 * (self.ub - self.lb)\n        neighbors = individual + np.random.uniform(-step_size, step_size, self.dim)\n        neighbors = np.clip(neighbors, self.lb, self.ub)\n        return neighbors\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _crowding_distance(self):\n        distances = np.zeros(self.population_size)\n        for i in range(self.dim):\n            sorted_indices = np.argsort(self.population[:, i])\n            sorted_pop = self.population[sorted_indices]\n            max_dist = np.max(sorted_pop[:, i]) - np.min(sorted_pop[:, i])\n            distances[sorted_indices[0]] = distances[sorted_indices[-1]] = np.inf\n            for j in range(1, self.population_size - 1):\n                distances[sorted_indices[j]] += (sorted_pop[j + 1, i] - sorted_pop[j - 1, i]) / max_dist\n        return distances\n\n    def __call__(self, func):\n        self.lb, self.ub = func.bounds.lb, func.bounds.ub\n        self._initialize_population(self.lb, self.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            crowding_distances = self._crowding_distance()\n            elite_indices = np.argsort(crowding_distances)[:int(self.elitism_rate * self.population_size)]\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._mutate(target_idx)\n                trial = self._dynamic_crossover(target, mutant, iteration)\n\n                trial = self._hypermutate(trial, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm DEALSPlusPlusRefinedHyperMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08550 with standard deviation 0.04363.", "error": "", "parent_ids": ["a02b4747-0432-4b0d-b332-d912e019e35a"], "operator": null, "metadata": {"aucs": [0.06101291642413653, 0.057155103033459276, 0.0556758396882534, 0.14603034816398308, 0.14939398728280706, 0.14554254315652448, 0.05399361793100377, 0.05365132011477225, 0.04705435843763828]}}
{"id": "14bff040-5f7d-4587-9be9-7ad120b66e46", "fitness": 0.09445784543721052, "name": "DEALSPlusPlusRefined2", "description": "DEALS+++Refined2 enhances adaptive control via a novel dual-phase mutation and elite-focused local search, optimizing convergence and solution quality.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm DEALSPlusPlusRefined2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09446 with standard deviation 0.04359.", "error": "", "parent_ids": ["a02b4747-0432-4b0d-b332-d912e019e35a"], "operator": null, "metadata": {"aucs": [0.07303685320198883, 0.07166553118178332, 0.06583541736765652, 0.16047768026279086, 0.15426095580701715, 0.15181892535833985, 0.060904320673306866, 0.0574365709444451, 0.054684354137566116]}}
{"id": "4103cccd-1248-4e8f-b251-2de6f8752a9b", "fitness": -Infinity, "name": "DEALSPlusPlusRefined3", "description": "DEALS+++Refined3 introduces stochastic re-evaluation of solutions for dynamic adaptability and competitive balance, enhancing both exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def _stochastic_re_evaluation(self):\n        re_eval_indices = np.random.choice(self.population_size, int(0.05 * self.population_size), replace=False)\n        for idx in re_eval_indices:\n            if self.evaluations >= self.budget:\n                break\n            new_score = func(self.population[idx])\n            self.evaluations += 1\n            self.scores[idx] = min(self.scores[idx], new_score)\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            self._stochastic_re_evaluation()\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 17, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {}}
{"id": "d4c433d0-6055-47f1-a0f3-5782ab4ea218", "fitness": 0.0922358899881831, "name": "DEALSPlusPlusRefined3", "description": "DEALS+++Refined3 improves on adaptive control and diversity maintenance through a triphase mutation strategy and dynamic elite rotation, further optimizing exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _triphase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * np.random.rand()\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (b - d), self.lb, self.ub)\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._triphase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score3 = func(trial3)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx] or trial_score3 < self.scores[target_idx]:\n                    better_trial, better_score = min(\n                        [(trial1, trial_score1), (trial2, trial_score2), (trial3, trial_score3)], \n                        key=lambda x: x[1]\n                    )\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09224 with standard deviation 0.04481.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.07411317754174462, 0.06253270745672546, 0.06085572501435832, 0.1506096352758749, 0.15731160983361647, 0.15727948987364482, 0.05886034278507146, 0.05290929653376486, 0.055651025578847046]}}
{"id": "ffb3c45e-dd9e-495e-9bb5-633cddb36e92", "fitness": 0.08675409047176773, "name": "DEALSPlusPlusRefined3", "description": "DEALS+++Refined3 introduces adaptive scaling of mutation and crossover rates based on population diversity, enhancing exploitation while preserving exploration for improved convergence.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _calculate_diversity(self):\n        centroid = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - centroid, axis=1))\n        return diversity\n\n    def _adaptive_mutation_scaling(self, idx, diversity):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2) * (diversity / self.dim)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration, diversity):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5 + 0.1 * (diversity / self.dim)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n            diversity = self._calculate_diversity()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation_scaling(target_idx, diversity)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration, diversity)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration, diversity)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 19, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08675 with standard deviation 0.04049.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.06214480863607874, 0.06996266571869247, 0.060006466149638005, 0.14273073820736215, 0.14647092429854902, 0.14122274507936572, 0.05346351720047904, 0.05520204177996013, 0.049582907175784285]}}
{"id": "7d84dfbd-aa09-4b67-bd26-d74a20f187ef", "fitness": 0.08804803605355034, "name": "DEALSPlusPlusImproved", "description": "DEALS+++Improved leverages adaptive learning rates and probabilistic mutation strategies for enhanced exploration and exploitation balance in optimization.", "code": "import numpy as np\n\nclass DEALSPlusPlusImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        probability = np.random.rand()\n        if probability < 0.5:\n            mutant = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        else:\n            mutant = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant\n\n    def _probabilistic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._adaptive_mutation(target_idx)\n                trial = self._probabilistic_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 20, "feedback": "The algorithm DEALSPlusPlusImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08805 with standard deviation 0.04325.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.0666536393876681, 0.0592357609980102, 0.06229939198782153, 0.15553040194485224, 0.14650660736612564, 0.14421161030078766, 0.053819895151558494, 0.052185595511724636, 0.0519894218334046]}}
{"id": "ee5d8e32-ebb8-42f2-9c59-e133edd09c2c", "fitness": 0.09052403407418834, "name": "DEALSPlusPlusRefined2", "description": "Improved DEALS+++Refined2 by enhancing elitism and introducing a dynamic population size.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Changed from 0.1 to 0.15 to enhance elitism\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.90  # Changed from 0.85 to 0.90 to allow a slower reduction\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 21, "feedback": "The algorithm DEALSPlusPlusRefined2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09052 with standard deviation 0.04180.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.07035253171159062, 0.06310458619699277, 0.06435597191651221, 0.15163157109572012, 0.14602942201967906, 0.15011923535546046, 0.059122735813129546, 0.05597657432515846, 0.05402367823345178]}}
{"id": "e917c69c-d5a8-417c-8c86-f7ca30793c7e", "fitness": 0.09057438646523813, "name": "EnhancedDEALSPlusPlusRefined2", "description": "Enhanced DEALS+++Refined2 with triple-phase mutation and adaptive local search to improve convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedDEALSPlusPlusRefined2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.adaptive_perturbation = 0.05  # Added line\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _triple_phase_mutation(self, idx):  # Modified function\n        indices = np.random.choice(self.population_size, 7, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 7, replace=False)\n        a, b, c, d, e, f, g = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * np.sin(self.evaluations / self.budget * np.pi)  # New mutation factor\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - f), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (f - g), self.lb, self.ub)  # Additional mutation\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _adaptive_local_search(self, elite):  # Modified function\n        perturbation_size = self.adaptive_perturbation * (self.ub - self.lb) * (1 - self.evaluations / self.budget)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            reduction_factor = 0.85\n            self.population_size = int(self.population_size * reduction_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._triple_phase_mutation(target_idx)  # Adjusted\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)  # Added\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score3 = func(trial3)  # New evaluation\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2, trial_score3) < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else (trial2 if trial_score2 < trial_score3 else trial3)\n                    better_score = min(trial_score1, trial_score2, trial_score3)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._adaptive_local_search(self.population[target_idx])  # Adjusted\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedDEALSPlusPlusRefined2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09057 with standard deviation 0.04102.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.060818732902922945, 0.07278562867076221, 0.06205203462744757, 0.14782083132335277, 0.15272113001986642, 0.14388532189536818, 0.0588355198414342, 0.06222700221074973, 0.05402327669523921]}}
{"id": "a2fc4aed-c292-4c09-be9b-8bdb4294a3ad", "fitness": 0.0932308645191551, "name": "DEALSPlusPlusRefined3", "description": "DEALS++Refined3 introduces adaptive population resizing and stochastic ranking-based selection, improving diversity and convergence speed for black-box optimization.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _stochastic_ranking_selection(self):\n        ranks = np.argsort(self.scores)\n        probabilities = np.random.rand(self.population_size)\n        for i in range(self.population_size):\n            if i < len(ranks) - 1 and probabilities[i] < 0.45:\n                if self.scores[ranks[i]] > self.scores[ranks[i + 1]]:\n                    ranks[i], ranks[i + 1] = ranks[i + 1], ranks[i]\n        elite_size = int(self.elitism_rate * self.population_size)\n        return ranks[:elite_size]\n\n    def _adaptive_population_resizing(self, iteration):\n        trend_factor = self.evaluations / self.budget\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            scale_factor = 0.85 + 0.15 * (1 - trend_factor)\n            self.population_size = max(int(self.initial_population_size * scale_factor), 5)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._adaptive_population_resizing(iteration)\n            elite_indices = self._stochastic_ranking_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09323 with standard deviation 0.04420.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.07166554927394697, 0.06696160811815655, 0.06569683673731364, 0.16107418380840866, 0.15049485291102904, 0.15386146540850665, 0.06174193735139688, 0.05597874048670359, 0.05160260657693394]}}
{"id": "eba95a6f-8241-4e65-9b36-e7b2b7feb531", "fitness": 0.09439943701809654, "name": "DEALSRefined3", "description": "DEALSRefined3 introduces a diversity-oriented strategy with adaptive perturbation and modified selection pressure to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.diversity_factor = 0.6\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _diversity_oriented_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        F1 = np.random.uniform(self.F - 0.2, self.F + 0.2)\n        F2 = self.F * (1.0 + np.sin(2 * np.pi * (self.evaluations / self.budget)))\n        mutant1 = np.clip(a + F1 * (b - c + self.diversity_factor * (d - e)), self.lb, self.ub)\n        mutant2 = np.clip(d + F2 * (e - a + self.diversity_factor * (b - c)), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        adaptive_CR = (0.5 + 0.5 * np.sin(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < adaptive_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _local_search(self, candidate):\n        perturbation_size = 0.01 * (self.ub - self.lb)\n        neighbor = candidate + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        neighbor = np.clip(neighbor, self.lb, self.ub)\n        return neighbor\n\n    def _selection_pressure(self, iteration):\n        return max(0.1, 1.0 - iteration / self.budget)\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            elite_size = int(self.elitism_rate * self.population_size)\n            elite_indices = np.argsort(self.scores)[:elite_size]\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._diversity_oriented_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 24, "feedback": "The algorithm DEALSRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09440 with standard deviation 0.04077.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.06700625633724477, 0.07829706538393943, 0.07241349887499215, 0.15087611589465844, 0.15070040458646516, 0.15259121805491316, 0.05668925625717203, 0.06089162297026596, 0.06012949480321772]}}
{"id": "951ca8ab-1a9c-4757-9b10-6549d517612d", "fitness": 0.10048127147898599, "name": "DEALSPlusPlusRefined3", "description": "DEALS+++Refined3 integrates adaptive differential evolution with an improved elite selection and dynamic population resizing strategy, enhancing convergence speed and solution quality further.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10048 with standard deviation 0.04310.", "error": "", "parent_ids": ["14bff040-5f7d-4587-9be9-7ad120b66e46"], "operator": null, "metadata": {"aucs": [0.07873275262377966, 0.07280979434634627, 0.07287653632584512, 0.16348449812024513, 0.1609248528375532, 0.15895783129778762, 0.06698988359035163, 0.06654383683655307, 0.0630114573324122]}}
{"id": "5989e62c-7acb-4273-b20f-96bc1af30c7d", "fitness": 0.10048127147898599, "name": "DEALSPlusPlusRefined3", "description": "DEALS++++Refined4 enhances convergence and solution quality by integrating a noise-reduction mechanism and utilizing adaptive differential evolution.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                # Noise reduction by averaging scores\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 26, "feedback": "The algorithm DEALSPlusPlusRefined3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10048 with standard deviation 0.04310.", "error": "", "parent_ids": ["951ca8ab-1a9c-4757-9b10-6549d517612d"], "operator": null, "metadata": {"aucs": [0.07873275262377966, 0.07280979434634627, 0.07287653632584512, 0.16348449812024513, 0.1609248528375532, 0.15895783129778762, 0.06698988359035163, 0.06654383683655307, 0.0630114573324122]}}
{"id": "cdfdd641-6171-4104-9e79-cbeb53f464b3", "fitness": 0.10634883082136909, "name": "DEALSPlusPlusRefined4", "description": "DEALS+++Refined4 introduces a mutation diversity boost by adding Gaussian perturbations and enhances elitism by prioritizing recent improvements.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Increased elitism rate\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Added Gaussian perturbation\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10635 with standard deviation 0.04062.", "error": "", "parent_ids": ["951ca8ab-1a9c-4757-9b10-6549d517612d"], "operator": null, "metadata": {"aucs": [0.08286523645391686, 0.09350982503696892, 0.07875837256453255, 0.16743290715934622, 0.1672542287347295, 0.1535925328970552, 0.07220644294242651, 0.06997808932851968, 0.0715418422748263]}}
{"id": "2d5ae0c1-2b70-4483-8c23-816f1d2fa15e", "fitness": 0.09850821346209662, "name": "DEALSPlusPlusRefined4", "description": "Enhanced mutation diversity by adjusting adaptive mutation factor to improve exploration in early stages.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Increased elitism rate\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.3, 0.3)  # Adjusted for enhanced diversity\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Added Gaussian perturbation\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09851 with standard deviation 0.04214.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.06410497491835387, 0.0800714481212137, 0.08203634622517508, 0.1594136105568742, 0.16196649210659786, 0.14896519579200496, 0.05532545258752675, 0.07429809518402042, 0.06039230566710274]}}
{"id": "2d94e42e-0348-4193-9b56-0f38df7f03b8", "fitness": 0.08766102808834202, "name": "DEALSPlusPlusRefined5", "description": "DEALS+++Refined5 enhances diversity by incorporating Cauchy mutations and custom crossover for improved convergence.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Increased elitism rate\n        self.resizing_factor = 0.85\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1.0 + np.random.uniform(-0.1, 0.1))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.standard_cauchy(self.dim), self.lb, self.ub)  # Cauchy mutation\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _custom_crossover(self, target, mutant):\n        mask = np.random.rand(self.dim) < self.CR\n        if not np.any(mask):\n            mask[np.random.randint(0, self.dim)] = True\n        trial = np.where(mask, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.01 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._custom_crossover(target, mutant1)\n                trial2 = self._custom_crossover(target, mutant2)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08766 with standard deviation 0.04087.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.06596572542065704, 0.0679549380404122, 0.05703097586793049, 0.1477584889202198, 0.1471505013126797, 0.1399688501326911, 0.05320483388367814, 0.058556420790664365, 0.05135851842614525]}}
{"id": "b21615f0-1e04-49f7-9048-14517bbd6d9a", "fitness": 0.08346430206324379, "name": "DEALSPlusPlusRefined5", "description": "DEALS+++Refined5 enhances adaptive mutation with cosine perturbations and dynamic crossover tuning, while introducing a fitness diversity maintenance mechanism for improved exploration.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.diversity_threshold = 0.1  # New parameter for diversity maintenance\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.cos(self.evaluations / self.budget * np.pi)\n        adaptive_F2 = self.F * (1 - np.sin(self.evaluations / self.budget * np.pi))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = (np.cos(iteration / self.budget * np.pi) * 0.5) + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _fitness_diversity_maintenance(self):\n        if np.std(self.scores) < self.diversity_threshold:\n            self.population += np.random.uniform(-0.05, 0.05, self.population.shape)\n            self.population = np.clip(self.population, self.lb, self.ub)\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            self._fitness_diversity_maintenance()\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08346 with standard deviation 0.04216.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.06318532064613125, 0.05809871727425897, 0.05267706248914905, 0.14665988433068133, 0.14193257629810485, 0.13934829225578127, 0.054830589904426574, 0.04987411094755467, 0.044572164423106186]}}
{"id": "aec001b2-13ae-4dba-86f3-128905094414", "fitness": 0.09519682598938364, "name": "DEALSPlusPlusRefined5", "description": "DEALS++++Refined5 boosts convergence by dynamically adjusting population size and scaling factors, with intensified local search around top solutions.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.2  # Further increased elitism rate\n        self.resizing_factor = 0.85\n        self.dynamic_F_factor = 0.3\n        self.local_search_intensity = 0.05  # Increased local search perturbation\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-self.dynamic_F_factor, self.dynamic_F_factor)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = self.local_search_intensity * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            new_population_size = int(self.population_size * self.resizing_factor)\n            if new_population_size < 5:\n                new_population_size = 5  # Ensure a minimum size\n            self.population_size = new_population_size\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n        self.population_size = self.initial_population_size\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 31, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09520 with standard deviation 0.04411.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.07687684282538443, 0.06801375233699303, 0.06816632093308539, 0.16172998963306118, 0.15613050770852555, 0.15285480134136886, 0.05968372591280546, 0.05433024083852189, 0.058985252374706976]}}
{"id": "ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56", "fitness": 0.11412335773533903, "name": "DEALSPlusPlusRefined4", "description": "Enhanced DEALSPlusPlusRefined4 by adjusting the Gaussian perturbation scale to improve exploration.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Increased elitism rate\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)  # Adjusted Gaussian perturbation scale\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11412 with standard deviation 0.04361.", "error": "", "parent_ids": ["cdfdd641-6171-4104-9e79-cbeb53f464b3"], "operator": null, "metadata": {"aucs": [0.07702511348496921, 0.09649488534991502, 0.08116254717270144, 0.1888828558064194, 0.1635020590695171, 0.16541409424298736, 0.08232556813437775, 0.10971390903119715, 0.06258918732596697]}}
{"id": "cec87a52-5d27-4a2c-89a5-df08522a64ab", "fitness": 0.09114054546565156, "name": "DEALSPlusPlusRefined5", "description": "Introducing adaptive population resizing and dynamic elitism to enhance exploration and exploitation balance based on iteration progress.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.initial_elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.lb = None\n        self.ub = None\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self, iteration):\n        dynamic_elitism_rate = self.initial_elitism_rate + 0.1 * (iteration / self.budget)\n        elite_size = int(dynamic_elitism_rate * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = max(2, int(self.population_size * self.resizing_factor))\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection(iteration)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 33, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09114 with standard deviation 0.04148.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.0686590178995643, 0.06764253861366076, 0.06122507515565878, 0.14782454872609807, 0.15641622379511488, 0.1439857256469973, 0.05929187694928739, 0.059078875521007435, 0.05614102688347511]}}
{"id": "8801007d-0125-446d-95af-f6bdfab0106d", "fitness": -Infinity, "name": "AdaptiveDEALSPlusRefined", "description": "Introduce adaptive population resizing and a synergy-based mutation strategy for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDEALSPlusRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.expansion_factor = 1.2\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _synergy_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 4, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 4, replace=False)\n        a, b, c, d = self.population[indices]\n        F_dynamic = self.F * np.random.uniform(0.5, 1.5)\n        mutant = np.clip(a + F_dynamic * (b - c) + F_dynamic * (d - a), self.lb, self.ub)\n        return mutant\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _adaptive_population_resizing(self, iteration):\n        resize_interval = self.budget // 10\n        if iteration > 0 and iteration % resize_interval == 0:\n            improvement_ratio = np.mean(self.scores) / np.min(self.scores)\n            if improvement_ratio > 1.0:\n                self.population_size = int(self.population_size * self.expansion_factor)\n            else:\n                self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._adaptive_population_resizing(iteration)\n\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant = self._synergy_mutation(target_idx)\n                trial = self._dynamic_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 34, "feedback": "An exception occurred: AttributeError(\"'AdaptiveDEALSPlusRefined' object has no attribute '_elitist_selection'\").", "error": "AttributeError(\"'AdaptiveDEALSPlusRefined' object has no attribute '_elitist_selection'\")", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {}}
{"id": "600ac39d-f55b-4591-b3e2-fdac14f87b75", "fitness": 0.084980751049718, "name": "EnhancedDEALSPlusPlusRefined5", "description": "Introduced dynamic population resizing and adaptive crossover in Enhanced DEALSPlusPlusRefined4 to improve convergence speed and balance exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedDEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n        self.dynamic_resizing = True  # Enable dynamic population resizing\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.cos(np.pi * iteration / self.budget) * 0.5 + 0.5  # Adjusted dynamic crossover\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if self.dynamic_resizing and iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = max(int(self.population_size * self.resizing_factor), 5)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedDEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08498 with standard deviation 0.04027.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.06299633710590125, 0.06188376717117994, 0.06002839280399053, 0.13780181928710422, 0.1421751398688712, 0.14476093987664662, 0.052920722931594555, 0.05242357677289955, 0.049836063629274174]}}
{"id": "2ea75062-85c0-46ed-9cd9-814ff2cbdd89", "fitness": 0.0868829255943057, "name": "DEALSPlusPlusRefined5", "description": "Introduced an adaptive elitism and mutation strategy in DEALSPlusPlusRefined5 for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15  # Base elitism rate\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        perturbation_scale = 0.05 + 0.1 * (1 - self.evaluations / self.budget)  # Dynamic perturbation scale\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, perturbation_scale, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _adaptive_elitist_selection(self):\n        elitism_rate = self.elitism_rate + 0.1 * (self.evaluations / self.budget)  # Adaptive elitism rate\n        elite_size = int(elitism_rate * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._adaptive_elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08688 with standard deviation 0.04186.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.06118139376667642, 0.060353107551118224, 0.06521141041863343, 0.14687475807990258, 0.14368603099689303, 0.14675141786067947, 0.053923457323252766, 0.05251491563365118, 0.051449838717944174]}}
{"id": "3f97e5de-a83e-4fa4-a4c9-786ec792a0ef", "fitness": 0.10226190678747489, "name": "DEALSPlusPlusRefined4", "description": "Improved adaptive parameter adjustment and diversified mutation strategy for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + 0.3 * np.random.uniform(-1, 1)  # Modified line\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Modified line\n        mutant2 = np.clip(d + adaptive_F2 * (e - a) + 0.1 * (self.population[np.random.randint(self.population_size)] - a), self.lb, self.ub)  # Modified line\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10226 with standard deviation 0.03909.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.09025193821814048, 0.06683099992981612, 0.08488820370718975, 0.15935016540274116, 0.1584409849613222, 0.1512914865000996, 0.07589386478133953, 0.0647946712232228, 0.06861484636340243]}}
{"id": "0cd8e224-8830-4d5d-be4b-602fe520582b", "fitness": 0.10714128417949764, "name": "DEALSPlusPlusRefined4", "description": "Enhanced exploration by integrating Lvy flights into the mutation process.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _levy_flight(self, size, lb, ub):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(size) * sigma\n        v = np.random.randn(size)\n        step = u / np.abs(v) ** (1 / beta)\n        return np.clip(step, lb, ub)\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        levy_step = self._levy_flight(self.dim, self.lb, self.ub)  # Lvy flight integration\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + levy_step, self.lb, self.ub)  # Enhanced mutation\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if trial_score1 < self.scores[target_idx] or trial_score2 < self.scores[target_idx]:\n                    better_trial = trial1 if trial_score1 < trial_score2 else trial2\n                    better_score = min(trial_score1, trial_score2)\n                    self.population[target_idx] = better_trial\n                    self.scores[target_idx] = better_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 38, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10714 with standard deviation 0.04240.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.07379065523664163, 0.1128926428268221, 0.07281187680397694, 0.17435353137505183, 0.15967562095239862, 0.15734558491361983, 0.06826962721145768, 0.0813045794153816, 0.06382743888012854]}}
{"id": "19c0bf81-616f-41ee-9c32-5f3534dff9f0", "fitness": 0.13285971824429174, "name": "DEALSPlusPlusRefined4", "description": "Introduced adaptive resizing in crossover and dynamic mutation adjustment to enhance convergence speed.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * (1 - self.evaluations / self.budget)  # New adaptive factor\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (a - b), self.lb, self.ub)  # New mutant strategy\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        dynamic_CR *= (1 - self.evaluations / self.budget)  # Adaptive resizing in crossover\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._dual_phase_mutation(target_idx)  # Updated number of mutants\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)  # New trial\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                trial_score3 = func(trial3)  # Evaluate new trial\n                self.evaluations += 1\n\n                # Update selection process to include new trial\n                if min(trial_score1, trial_score2, trial_score3) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), (trial3, trial_score3), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13286 with standard deviation 0.04247.", "error": "", "parent_ids": ["ee39a719-e6aa-4b3a-8e0e-5d91f47ddc56"], "operator": null, "metadata": {"aucs": [0.11212727932107547, 0.13725881199840728, 0.12631117741177245, 0.17923019420783648, 0.19269958739394621, 0.18955601997567917, 0.07330733047141014, 0.09017608621553264, 0.09507097720296576]}}
{"id": "21af1bfb-8a8c-48f0-af50-e7610329b613", "fitness": 0.1288104761728349, "name": "DEALSPlusPlusRefined4", "description": "Enhanced mutation diversity by introducing perturbation in the adaptive factor and improved local search with directional adjustment.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined4:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dual_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2) * np.random.rand()  # Added random factor\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * (1 - self.evaluations / self.budget)\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (a - b), self.lb, self.ub)\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        dynamic_CR *= (1 - self.evaluations / self.budget)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        step_direction = np.random.uniform(-1, 1, self.dim)  # Directional adjustment\n        candidate = elite + step_direction * perturbation_size\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._dual_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                trial_score3 = func(trial3)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2, trial_score3) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), (trial3, trial_score3), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 40, "feedback": "The algorithm DEALSPlusPlusRefined4 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12881 with standard deviation 0.03809.", "error": "", "parent_ids": ["19c0bf81-616f-41ee-9c32-5f3534dff9f0"], "operator": null, "metadata": {"aucs": [0.12954730994914754, 0.11171451668777677, 0.09664461864127072, 0.1765532215916089, 0.18320437857076077, 0.17575939032357613, 0.08148357879613788, 0.11995927586281463, 0.08442799513242072]}}
{"id": "0164741a-7cbf-472c-bcf5-3079ad0608e7", "fitness": 0.07752076700600344, "name": "EnhancedDEALS", "description": "Introduced multi-rate mutation strategies with feedback-driven learning to enhance convergence and robustness in diverse problem spaces.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.adaptive_F = [0.5, 0.7, 0.9]  # Different mutation strategies\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _multi_rate_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        mutants = []\n        for F in self.adaptive_F:\n            mutants.append(np.clip(a + F * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub))\n            mutants.append(np.clip(d + F * (e - a), self.lb, self.ub))\n        return mutants\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.cos(iteration / self.budget * np.pi) * 0.5 + 0.5\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutants = self._multi_rate_mutation(target_idx)\n                trials = [self._dynamic_crossover(target, mutant, iteration) for mutant in mutants]\n\n                trial_scores = [func(trial) for trial in trials]\n                self.evaluations += len(trials)\n\n                best_trial_index = np.argmin(trial_scores)\n                best_trial = trials[best_trial_index]\n                best_score = trial_scores[best_trial_index]\n\n                if best_score < self.scores[target_idx]:\n                    self.population[target_idx] = best_trial\n                    self.scores[target_idx] = best_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07752 with standard deviation 0.04233.", "error": "", "parent_ids": ["19c0bf81-616f-41ee-9c32-5f3534dff9f0"], "operator": null, "metadata": {"aucs": [0.048789096886795225, 0.05228091224671849, 0.05274403498362179, 0.13609802871568344, 0.13944588689530502, 0.13607509823438524, 0.04364156454239976, 0.04490009798014405, 0.04371218256897791]}}
{"id": "2809c11f-5b3d-4734-a457-5cba15f2fc1b", "fitness": 0.07096766496862889, "name": "DEALSPlusPlusRefined5", "description": "Enhanced DEALSPlusPlusRefined5 by incorporating multi-strategy mutation and adaptive crossover weights to improve convergence and solution diversity.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _multi_strategy_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * (1 - self.evaluations / self.budget)\n        mutant1 = np.clip(a + adaptive_F1 * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (a - b), self.lb, self.ub)\n        mutant4 = np.clip(a - adaptive_F1 * (b + c), self.lb, self.ub)  # New strategy\n        return mutant1, mutant2, mutant3, mutant4\n\n    def _adaptive_crossover(self, target, mutants, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        dynamic_CR *= (1 - self.evaluations / self.budget)\n        crossover_weights = np.random.dirichlet(np.ones(len(mutants)))\n        trial = np.zeros(self.dim)\n        for i, mutant in enumerate(mutants):\n            cross_points = np.random.rand(self.dim) < dynamic_CR\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial += crossover_weights[i] * np.where(cross_points, mutant, target)\n        return np.clip(trial, self.lb, self.ub)\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutants = self._multi_strategy_mutation(target_idx)\n                trial = self._adaptive_crossover(target, mutants, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 42, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07097 with standard deviation 0.04183.", "error": "", "parent_ids": ["19c0bf81-616f-41ee-9c32-5f3534dff9f0"], "operator": null, "metadata": {"aucs": [0.044092444733664915, 0.0427325581207878, 0.05171985806616275, 0.13353903064353434, 0.1275787329763104, 0.12802209878715232, 0.037230751884360536, 0.03330784405707088, 0.04048566544861609]}}
{"id": "7d501979-0f94-4173-8828-04c107c0b504", "fitness": 0.09858665621707853, "name": "DEALSPlusPlusOptimized", "description": "Enhanced multi-phase mutation with adaptive feedback loop to optimize exploration-exploitation balance and improve convergence efficiency.", "code": "import numpy as np\n\nclass DEALSPlusPlusOptimized:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation_strategy(self, idx, iteration):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (0.5 + np.sin(iteration / self.budget * np.pi))\n        mutant1 = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = 0.5 + 0.5 * np.sin(iteration / self.budget * np.pi)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation_strategy(target_idx, iteration)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 43, "feedback": "The algorithm DEALSPlusPlusOptimized got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09859 with standard deviation 0.04167.", "error": "", "parent_ids": ["19c0bf81-616f-41ee-9c32-5f3534dff9f0"], "operator": null, "metadata": {"aucs": [0.06529439437571793, 0.09648249487647009, 0.07870130335229875, 0.15273591462889746, 0.15571119162188396, 0.15758395821712146, 0.055880179413604236, 0.06044292126412942, 0.06444754820358345]}}
{"id": "d5ebd41b-f0f9-4ceb-8aed-5f9dc8c99717", "fitness": 0.10392243077830066, "name": "DEALSPlusPlusRefined5", "description": "Introduced adaptive mutation strategies combined with a rotating crossover mechanism to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.rotating_factor = 0.3\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F * np.tanh(self.evaluations / self.budget)\n        adaptive_F2 = self.F * np.cos(np.pi * self.evaluations / (2 * self.budget))\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _rotating_crossover(self, target, mutant, iteration):\n        rotation_angle = (iteration / self.budget * 2 * np.pi * self.rotating_factor) % (2 * np.pi)\n        sinusoidal_CR = 0.5 * (1 + np.sin(rotation_angle))\n        cross_points = np.random.rand(self.dim) < sinusoidal_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._rotating_crossover(target, mutant1, iteration)\n                trial2 = self._rotating_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 44, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10392 with standard deviation 0.04210.", "error": "", "parent_ids": ["19c0bf81-616f-41ee-9c32-5f3534dff9f0"], "operator": null, "metadata": {"aucs": [0.09565600339053615, 0.07326669992805335, 0.07778056952373613, 0.1683612824448818, 0.16658612410240137, 0.15091168991396198, 0.06966339417562084, 0.06534673910745326, 0.06772937441806104]}}
{"id": "82e21231-2be5-4845-a733-d4b25cea1b84", "fitness": 0.14469392569670067, "name": "DEALSPlusPlusRefined5", "description": "Enhanced mutation strategies and refined adaptive mechanisms to boost exploration and exploitation balance for improved convergence.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _triple_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * (1 - self.evaluations / self.budget)\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (a - b) + adaptive_F1 * (c - d), self.lb, self.ub)\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        dynamic_CR *= (1 - self.evaluations / self.budget)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._triple_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                trial_score3 = func(trial3)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2, trial_score3) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), (trial3, trial_score3), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 45, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14469 with standard deviation 0.08749.", "error": "", "parent_ids": ["19c0bf81-616f-41ee-9c32-5f3534dff9f0"], "operator": null, "metadata": {"aucs": [0.12621186932058504, 0.09495003854924589, 0.092387693327174, 0.17913967160625766, 0.36541874546313635, 0.19173202325776983, 0.07556853106117012, 0.09590644878180576, 0.08093030990316141]}}
{"id": "6bddcb6c-d911-49a5-8d51-a46bab22d51f", "fitness": 0.08284151195453894, "name": "DEALSPlusPlusEnhanced", "description": "Introduce adaptive population sizing and inertia-enhanced exploration to improve both convergence speed and solution diversity in high-dimensional spaces.", "code": "import numpy as np\n\nclass DEALSPlusPlusEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.inertia_weight = 0.7\n        self.dynamic_CR = 0.5\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 + 0.5 * (1 - self.evaluations / self.budget))\n        mutant = np.clip(a + adaptive_F * (b - c) + self.inertia_weight * (d - e), self.lb, self.ub)\n        return mutant\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        self.dynamic_CR = 0.5 + 0.5 * np.cos((iteration / self.budget) * np.pi)\n        cross_points = np.random.rand(self.dim) < self.dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            current_size = len(self.population)\n            new_size = max(int(current_size * self.resizing_factor), 5)\n            self.population = self.population[:new_size]\n            self.scores = self.scores[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = i\n                target = self.population[target_idx]\n                mutant = self._adaptive_mutation(target_idx)\n                trial = self._adaptive_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 46, "feedback": "The algorithm DEALSPlusPlusEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08284 with standard deviation 0.04121.", "error": "", "parent_ids": ["82e21231-2be5-4845-a733-d4b25cea1b84"], "operator": null, "metadata": {"aucs": [0.05402057968967655, 0.05523035671581944, 0.059178953490884534, 0.143192325645351, 0.138472634930912, 0.14121166428991228, 0.055079887893934476, 0.04816701045336802, 0.051020194480992154]}}
{"id": "18a0f48b-bb10-4379-b166-f1b266b6e1ea", "fitness": 0.14469392569670067, "name": "DEALSPlusPlusRefined5", "description": "Introduced an adaptive speedup mechanism during resizing to enhance convergence efficiency.", "code": "import numpy as np\n\nclass DEALSPlusPlusRefined5:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.dynamic_F = 0.5\n        self.resizing_factor = 0.85\n        self.speedup_factor = 1.5\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _triple_phase_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F1 = self.F + np.random.uniform(-0.2, 0.2)\n        adaptive_F2 = self.F / (1 + np.exp(-0.05 * (self.evaluations - 0.5 * self.budget)))\n        adaptive_F3 = self.F * (1 - self.evaluations / self.budget)\n        mutant1 = np.clip(a + adaptive_F1 * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F2 * (e - a), self.lb, self.ub)\n        mutant3 = np.clip(e + adaptive_F3 * (a - b) + adaptive_F1 * (c - d), self.lb, self.ub)\n        return mutant1, mutant2, mutant3\n\n    def _dynamic_crossover(self, target, mutant, iteration):\n        dynamic_CR = np.sin(iteration / self.budget * np.pi) * 0.5 + 0.5\n        dynamic_CR *= (1 - self.evaluations / self.budget)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elite_focused_local_search(self, elite):\n        perturbation_size = 0.02 * (self.ub - self.lb)\n        candidate = elite + np.random.uniform(-perturbation_size, perturbation_size, self.dim)\n        candidate = np.clip(candidate, self.lb, self.ub)\n        return candidate\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n            self.speedup_factor *= 1.01  # Adaptive speedup mechanism\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2, mutant3 = self._triple_phase_mutation(target_idx)\n                trial1 = self._dynamic_crossover(target, mutant1, iteration)\n                trial2 = self._dynamic_crossover(target, mutant2, iteration)\n                trial3 = self._dynamic_crossover(target, mutant3, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                trial_score3 = func(trial3)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2, trial_score3) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), (trial3, trial_score3), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                if self.evaluations < self.budget:\n                    local_candidate = self._elite_focused_local_search(self.population[target_idx])\n                    local_score = func(local_candidate)\n                    self.evaluations += 1\n\n                    if local_score < self.scores[target_idx]:\n                        self.population[target_idx] = local_candidate\n                        self.scores[target_idx] = local_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 47, "feedback": "The algorithm DEALSPlusPlusRefined5 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14469 with standard deviation 0.08749.", "error": "", "parent_ids": ["82e21231-2be5-4845-a733-d4b25cea1b84"], "operator": null, "metadata": {"aucs": [0.12621186932058504, 0.09495003854924589, 0.092387693327174, 0.17913967160625766, 0.36541874546313635, 0.19173202325776983, 0.07556853106117012, 0.09590644878180576, 0.08093030990316141]}}
{"id": "94946dd0-ad4f-4e2c-b56f-a1a05d90578c", "fitness": 0.8419284775611416, "name": "DEALSAdaptiveRefined", "description": "Introduced adaptive population resizing based on convergence rates and a dynamic learning component to enhance adaptive crossover and mutation rates for more efficient exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 48, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84193 with standard deviation 0.05334.", "error": "", "parent_ids": ["82e21231-2be5-4845-a733-d4b25cea1b84"], "operator": null, "metadata": {"aucs": [0.8963603754374345, 0.751698460012372, 0.8605280563811657, 0.8930364445745123, 0.8566040827192688, 0.8754960926299553, 0.8543982101363758, 0.7418249502723839, 0.8474096258868073]}}
{"id": "bb61598e-2553-479b-89ee-3bcfa61263af", "fitness": 0.7795634166481746, "name": "DEALSAdaptiveRefined", "description": "Enhanced mutation strategy by introducing a Gaussian noise component for finer exploration.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        # Enhanced mutation with Gaussian noise\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 49, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77956 with standard deviation 0.08010.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.8469445922037938, 0.776955902203077, 0.7916094741174923, 0.8632810323866724, 0.8445302518321377, 0.8462402479983133, 0.6789256544043657, 0.6170443173990684, 0.750539277288651]}}
{"id": "2fd1baf5-8900-4d0a-b5bf-2542bcf62c2b", "fitness": 0.7641567346436443, "name": "DEALSAdaptiveRefined", "description": "Enhanced population diversity with Gaussian perturbation in mutation and improved elitist selection for better convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub) # Changed line 1\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub) # Changed line 2\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 3) # Changed line 3\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 50, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.76416 with standard deviation 0.08002.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.7525376011551851, 0.7296309662364586, 0.8459760961048244, 0.827130127984874, 0.7754466421256734, 0.8437577282093055, 0.6020442868216676, 0.671319066099136, 0.8295680970556734]}}
{"id": "ea06d893-816f-486e-8977-c0c6b768d4d2", "fitness": 0.8223572548933382, "name": "DEALSAdaptiveRefined", "description": "Enhanced adaptive mutation and synergy-driven crossover with chaotic sequences for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _chaotic_sequence(self, seed, length):\n        x = seed\n        sequence = []\n        for _ in range(length):\n            x = 4 * x * (1 - x)  # Logistic map\n            sequence.append(x)\n        return np.array(sequence)\n\n    def _adaptive_mutation(self, idx, chaos_seq):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        chaotic_factor = chaos_seq[self.evaluations % len(chaos_seq)]\n        mutant1 = np.clip(a + adaptive_F * (b - c) + chaotic_factor * np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _synergy_driven_crossover(self, target, mutant, iteration, chaos_seq):\n        chaotic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi)) * chaos_seq[iteration % len(chaos_seq)]\n        cross_points = np.random.rand(self.dim) < chaotic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n        chaos_seq = self._chaotic_sequence(seed=0.5, length=self.budget)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx, chaos_seq)\n                trial1 = self._synergy_driven_crossover(target, mutant1, iteration, chaos_seq)\n                trial2 = self._synergy_driven_crossover(target, mutant2, iteration, chaos_seq)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 51, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82236 with standard deviation 0.06301.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.8954488154310001, 0.7756556447864342, 0.8376711146358711, 0.9058717220011901, 0.8498498040362176, 0.8515038739880301, 0.8280671669536385, 0.6988343639084447, 0.7583127882992178]}}
{"id": "8b31e723-1041-40d9-bd8d-0f5a0165feb9", "fitness": 0.8419284775611416, "name": "DEALSAdaptiveNiching", "description": "Introduced adaptive niching strategy by dynamically adjusting niche sizes to preserve diversity and enhance exploration in the solution space.", "code": "import numpy as np\n\nclass DEALSAdaptiveNiching:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.niche_size = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def _niche_adjustment(self):\n        distances = np.linalg.norm(self.population[:, np.newaxis] - self.population[np.newaxis, :], axis=2)\n        niche_count = np.sum(distances < self.niche_size, axis=1)\n        for i in range(self.population_size):\n            if niche_count[i] > 1:\n                self.population[i] += np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n            self._niche_adjustment()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 52, "feedback": "The algorithm DEALSAdaptiveNiching got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84193 with standard deviation 0.05334.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.8963603754374345, 0.751698460012372, 0.8605280563811657, 0.8930364445745123, 0.8566040827192688, 0.8754960926299553, 0.8543982101363758, 0.7418249502723839, 0.8474096258868073]}}
{"id": "7b793839-b61d-4388-a648-9fd171c32900", "fitness": 0.8419284775611416, "name": "EnhancedDEALS", "description": "Introduced a multi-phase adaptive strategy integrating elite rotation and diversity preservation techniques to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDEALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.05\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def _calculate_diversity(self):\n        mean_individual = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_individual, axis=1))\n        return diversity\n\n    def _maintain_diversity(self, func):\n        if self._calculate_diversity() < self.diversity_threshold:\n            extra_population = np.random.uniform(self.lb, self.ub, (self.population_size // 2, self.dim))\n            extra_scores = np.array([func(ind) for ind in extra_population])\n            combined_population = np.vstack((self.population, extra_population))\n            combined_scores = np.hstack((self.scores, extra_scores))\n            best_indices = np.argsort(combined_scores)[:self.population_size]\n            self.population = combined_population[best_indices]\n            self.scores = combined_scores[best_indices]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n            self._maintain_diversity(func)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedDEALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84193 with standard deviation 0.05334.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.8963603754374345, 0.751698460012372, 0.8605280563811657, 0.8930364445745123, 0.8566040827192688, 0.8754960926299553, 0.8543982101363758, 0.7418249502723839, 0.8474096258868073]}}
{"id": "a54d7e53-6649-4add-ae12-5e347e9aa7f7", "fitness": 0.7265905048056688, "name": "DEALSAdaptiveLevy", "description": "Enhanced adaptive mutation with Lvy flight for better exploration and diversity in the search space.", "code": "import numpy as np\nfrom scipy.stats import levy\n\nclass DEALSAdaptiveLevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _levy_flight(self, scale=0.01):\n        return levy.rvs(size=self.dim, scale=scale)\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        levy_mutation = self._levy_flight()\n        mutant1 = np.clip(a + adaptive_F * (b - c) + levy_mutation, self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + levy_mutation, self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 54, "feedback": "The algorithm DEALSAdaptiveLevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72659 with standard deviation 0.18402.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.8855316214750353, 0.8348415124118731, 0.6664375368432018, 0.8948606180796678, 0.8512263920666026, 0.7026954995667889, 0.8712757470052835, 0.4717094716562198, 0.36073614414634636]}}
{"id": "d8c47d73-862f-42d4-a3ab-5efc1e5c6a6b", "fitness": 0.8419284775611416, "name": "DEALSAdaptiveEnhanced", "description": "Enhanced dynamic adaptation of mutation and crossover rates with a diversity maintenance mechanism to balance exploration and exploitation in the optimization process.", "code": "import numpy as np\n\nclass DEALSAdaptiveEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.2\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _calculate_diversity(self):\n        centroid = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - centroid, axis=1))\n        return diversity\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.05, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            diversity = self._calculate_diversity()\n            if diversity < self.diversity_threshold:\n                self.F *= 1.1\n            else:\n                self.F = 0.8\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 55, "feedback": "The algorithm DEALSAdaptiveEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84193 with standard deviation 0.05334.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.8963603754374345, 0.751698460012372, 0.8605280563811657, 0.8930364445745123, 0.8566040827192688, 0.8754960926299553, 0.8543982101363758, 0.7418249502723839, 0.8474096258868073]}}
{"id": "3bbe8703-8b3d-41ca-952c-45a566a435ef", "fitness": 0.8417258572419057, "name": "DEALSAdaptiveRefined", "description": "Enhanced mutation strategy by incorporating a Gaussian noise factor proportional to the current iteration, optimizing exploration in early stages and exploitation in later stages.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutation_factor = np.random.normal(0, 0.05 * (1 - self.evaluations / self.budget), self.dim)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + mutation_factor, self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 56, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84173 with standard deviation 0.05326.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.8963482575392387, 0.7515138127549232, 0.8603807267975938, 0.8928671795975757, 0.8565536348109829, 0.8741076716636312, 0.8546497646908556, 0.7418274304323424, 0.8472842368900071]}}
{"id": "927add55-067b-409f-89ba-6035a6308a7a", "fitness": 0.8590433620087288, "name": "DEALSAdaptiveRefined", "description": "Enhanced mutation strategy by introducing an additional Gaussian perturbation to improve exploration capabilities.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Adjusted perturbation\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Adjusted perturbation\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 57, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85904 with standard deviation 0.02726.", "error": "", "parent_ids": ["94946dd0-ad4f-4e2c-b56f-a1a05d90578c"], "operator": null, "metadata": {"aucs": [0.8654301010558728, 0.8667226365945129, 0.8858425319073221, 0.8786283025663594, 0.9013939353035645, 0.8519699414877192, 0.8420033250414076, 0.8083294161417103, 0.8310700679800892]}}
{"id": "7cc0a5e3-f1e7-4f5b-bdf6-7a74bb4e7f9a", "fitness": 0.7351956629794877, "name": "EnhancedDEALSAdaptiveRefined", "description": "Introduced a dynamic mutation factor based on a sinusoidal decay to enhance exploitation in later stages of optimization.", "code": "import numpy as np\n\nclass EnhancedDEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dynamic_mutation_factor(self, iteration):\n        return self.F * (np.sin(iteration / self.budget * np.pi) + 0.5)\n\n    def _adaptive_mutation(self, idx, iteration):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        dynamic_F = self._dynamic_mutation_factor(iteration)\n        mutant1 = np.clip(a + dynamic_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + dynamic_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx, iteration)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedDEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.73520 with standard deviation 0.16566.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.7543007759089383, 0.5490077975911222, 0.8958265390844915, 0.8656203073440438, 0.743165703348766, 0.9037046936665833, 0.6770942483738077, 0.38169840278931955, 0.8463424987083163]}}
{"id": "ae5f1542-0ad1-4ffc-9118-57f57b39e470", "fitness": 0.12857527260811066, "name": "EnhancedDEALSAdaptive", "description": "Introduce a dynamic mutation scaling factor driven by population diversity to improve convergence speed and robustness.", "code": "import numpy as np\n\nclass EnhancedDEALSAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.diversity_factor = 0.0\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _update_diversity_factor(self):\n        if self.evaluations == 0:\n            return\n        distances = np.linalg.norm(self.population - np.mean(self.population, axis=0), axis=1)\n        self.diversity_factor = np.std(distances)\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget))) * (1 + self.diversity_factor)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                self._update_diversity_factor()\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedDEALSAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12858 with standard deviation 0.03257.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.1318830617748341, 0.1252907969222572, 0.1050759223388027, 0.17611426984662015, 0.16187748152471937, 0.17330080544413773, 0.09667238323004668, 0.08558474612926281, 0.1013779862623152]}}
{"id": "513fc90e-40d2-4365-b4d4-a5e0fad63156", "fitness": 0.8017070898315333, "name": "EnhancedDifferentialEvolution", "description": "Introduce a dynamic learning rate and perturbation scaling to further enhance exploration and exploitation balance in adaptive differential evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.initial_learning_rate = 0.1\n        self.learning_rate = self.initial_learning_rate\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        perturbation_scale = np.random.normal(0, 0.1 * (1 - self.evaluations / self.budget), self.dim)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + perturbation_scale, self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + perturbation_scale, self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n            self.learning_rate = self.initial_learning_rate * (1 - self.evaluations / self.budget)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80171 with standard deviation 0.10128.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8961557156998277, 0.701934819987829, 0.8599979324000904, 0.9050055588545625, 0.7887837519611143, 0.8332164322556566, 0.8660125890573165, 0.5692655315489031, 0.7949914767184992]}}
{"id": "d7055fbc-34d5-4702-96b5-c04b83171ee4", "fitness": 0.0730818165161681, "name": "DEALSAdaptiveEliteGuided", "description": "Introduces dynamic population resizing and an elite-guided mutation strategy to enhance convergence and exploration capabilities simultaneously.", "code": "import numpy as np\n\nclass DEALSAdaptiveEliteGuided:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.initial_population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.initial_population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _elite_guided_mutation(self, idx, elite_indices):\n        indices = np.random.choice(elite_indices, 2, replace=False)\n        while idx in indices:\n            indices = np.random.choice(elite_indices, 2, replace=False)\n        a, b = self.population[indices]\n        target = self.population[idx]\n        mutant = np.clip(target + self.F * (a - b) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n        else:\n            self.population_size = self.initial_population_size\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n        self.population_size = self.initial_population_size\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = i\n                target = self.population[target_idx]\n                mutant = self._elite_guided_mutation(target_idx, elite_indices)\n                trial = self._adaptive_crossover(target, mutant, iteration)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm DEALSAdaptiveEliteGuided got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07308 with standard deviation 0.04372.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.044440656761893016, 0.04917260775781551, 0.041626773562227215, 0.1300376776440605, 0.14268397287001466, 0.13078081963741783, 0.04457802046847803, 0.04032509609152335, 0.03409072385208278]}}
{"id": "2849aacd-7491-4eb5-8ab9-bb7a056919c7", "fitness": 0.8405961517533407, "name": "DEALSAdaptiveRefined", "description": "Enhanced mutation and crossover strategy by introducing an oscillatory factor in mutation step size for more effective exploration.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        # Change: Introduced oscillatory factor in mutation step size\n        oscillatory_F = adaptive_F * (1 + 0.1 * np.sin(2 * np.pi * self.evaluations / self.budget))\n        mutant1 = np.clip(a + oscillatory_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + oscillatory_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.84060 with standard deviation 0.03936.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8667406229538253, 0.801463573259796, 0.8765923716078919, 0.8949834413188278, 0.8199176276131999, 0.8670749413155745, 0.8359922140446179, 0.7610578551780499, 0.8415427184882823]}}
{"id": "7c3ab058-3145-47bd-bda2-f5311989a00a", "fitness": 0.8590433620087288, "name": "DEALSAdaptiveRefinedDynamic", "description": "Introduce a dynamic population size with periodic contraction and expansion to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefinedDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.contraction_factor = 0.7\n        self.expansion_factor = 1.2\n        self.learning_rate = 0.1\n        self.phase_length = budget // 20\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % self.phase_length == 0:\n            phase = (iteration // self.phase_length) % 2\n            if phase == 0:\n                self.population_size = max(int(self.population_size * self.contraction_factor), 5)\n            else:\n                self.population_size = min(int(self.population_size * self.expansion_factor), self.initial_population_size)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm DEALSAdaptiveRefinedDynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85904 with standard deviation 0.02726.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8654301010558728, 0.8667226365945129, 0.8858425319073221, 0.8786283025663594, 0.9013939353035645, 0.8519699414877192, 0.8420033250414076, 0.8083294161417103, 0.8310700679800892]}}
{"id": "2c60b559-188e-4ce7-911a-34ab6aa5b1d9", "fitness": 0.6347500941675981, "name": "StochasticGreedyDE", "description": "Introduce a stochastic greedy selection mechanism with adaptive learning to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass StochasticGreedyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.stochastic_prob = 0.3\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if np.random.rand() < self.stochastic_prob:\n                    selected_trial, selected_score = (trial1, trial_score1) if trial_score1 < trial_score2 else (trial2, trial_score2)\n                else:\n                    selected_trial, selected_score = (trial1, trial_score1) if trial_score1 < self.scores[target_idx] else (trial2, trial_score2)\n\n                if selected_score < self.scores[target_idx]:\n                    self.population[target_idx] = selected_trial\n                    self.scores[target_idx] = selected_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 64, "feedback": "The algorithm StochasticGreedyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63475 with standard deviation 0.18462.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8290207662513853, 0.6225815340116703, 0.6447618852583896, 0.8520951209655541, 0.6957468704728572, 0.6838986570066725, 0.6881683922392308, 0.192707450562295, 0.5037701707403293]}}
{"id": "3afb0726-c411-43e2-8c3e-29e1ec56248d", "fitness": 0.857475305162606, "name": "DEALSAdaptiveRefinedEnhanced", "description": "Introduced a dynamic population resizing and adaptive elitism strategy to enhance the balance between exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefinedEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.min_population_size = max(5, int(self.population_size * 0.2))\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _adaptive_elitist_selection(self):\n        current_elitism_rate = self.elitism_rate * (1 - np.exp(-self.evaluations / self.budget))\n        elite_size = int(current_elitism_rate * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            new_size = max(self.min_population_size, int(self.population_size * self.resizing_factor))\n            if new_size < self.population_size:\n                elite_indices = np.argsort(self.scores)[:new_size]\n                self.population = self.population[elite_indices]\n                self.scores = self.scores[elite_indices]\n                self.population_size = new_size\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._adaptive_elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 65, "feedback": "The algorithm DEALSAdaptiveRefinedEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85748 with standard deviation 0.03037.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8654301010558728, 0.8667226365945129, 0.8858425319073221, 0.8786283025663594, 0.9013939353035645, 0.8519699414877192, 0.8420033250414076, 0.7942169045266063, 0.8310700679800892]}}
{"id": "f357aa41-9591-4d44-895e-538da6a27065", "fitness": 0.8590433620087288, "name": "DEALSAdaptiveRefined", "description": "Enhanced elitist selection strategy by dynamically adjusting elitism rate for improved convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (1 + 0.1 * np.sin(np.pi * self.evaluations / self.budget)) * (self.evaluations / self.budget) * self.population_size)  # Adjusted elitism rate\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85904 with standard deviation 0.02726.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8654301010558728, 0.8667226365945129, 0.8858425319073221, 0.8786283025663594, 0.9013939353035645, 0.8519699414877192, 0.8420033250414076, 0.8083294161417103, 0.8310700679800892]}}
{"id": "554d7ebb-dafd-429c-af81-5292c3c7af9d", "fitness": 0.8525299354970962, "name": "DEALSAdaptiveRefined", "description": "Enhanced mutation strategy by refining adaptive mutation with variable Gaussian perturbation for improved adaptability.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        sigma = np.exp(-self.evaluations / self.budget) * 0.1  # Adjusted perturbation variability\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, sigma, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, sigma, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85253 with standard deviation 0.02641.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8542322493072276, 0.8672687624456191, 0.8445159265956355, 0.8790745071968283, 0.9043798669184069, 0.8505905508346485, 0.8138665024897691, 0.8333671052665441, 0.8254739484191869]}}
{"id": "18d0d2b0-120c-4411-b6ba-deaaa893f25c", "fitness": 0.6743355392488065, "name": "DEALSAdaptiveRefined", "description": "Improved exploration by dynamically adjusting perturbation based on current diversity.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        diversity = np.std(self.population, axis=0).mean()  # Calculate population diversity\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        perturbation = np.random.normal(0, 0.1 + 0.1 * diversity, self.dim)  # Dynamically adjust perturbation\n        mutant1 = np.clip(a + adaptive_F * (b - c) + perturbation, self.lb, self.ub)\n        mutant2 = np.clip(d + adaptive_F * (e - a) + perturbation, self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67434 with standard deviation 0.20421.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8387851482393583, 0.6978236393085917, 0.8222686737193096, 0.852293291268841, 0.7368834500704363, 0.7360363592206071, 0.5317008784407634, 0.6943612244669766, 0.15886718850437465]}}
{"id": "93e8daaa-3466-43b0-9540-538c1832126e", "fitness": 0.8086480691310206, "name": "DEALSAdaptiveRefined", "description": "Enhanced selection mechanism by incorporating weighted average for trial selection to improve convergence speed.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Adjusted perturbation\n        mutant2 = np.clip(d + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)  # Adjusted perturbation\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                # Change made here: apply weighted average for better selection\n                weighted_trial = (trial1 * (1 - self.learning_rate) + trial2 * self.learning_rate)\n                weighted_score = func(weighted_trial)\n\n                if min(trial_score1, trial_score2, weighted_score) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), (weighted_trial, weighted_score), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 69, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80865 with standard deviation 0.02904.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8282024194961715, 0.8210585451251484, 0.8310174967833571, 0.8153887474249273, 0.8272074557634959, 0.8143671657669903, 0.825085170515915, 0.7393273831446433, 0.7761782381585373]}}
{"id": "041cf206-3d3a-46c6-9e86-a4d9f0ee29ef", "fitness": 0.8669790966726985, "name": "DEALSAdaptiveRefined", "description": "Introduce an additional mutation strategy by incorporating weighted averages of elite solutions to enhance diversity and convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 70, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86698 with standard deviation 0.02495.", "error": "", "parent_ids": ["927add55-067b-409f-89ba-6035a6308a7a"], "operator": null, "metadata": {"aucs": [0.8785942990365397, 0.86576035749553, 0.8860475765034419, 0.9045851667986785, 0.880409336299296, 0.872827546861678, 0.8637005918651645, 0.8227919122652888, 0.8280950829286697]}}
{"id": "78f22d95-4e51-4a60-8672-7975a0ed15c3", "fitness": 0.8669790966726985, "name": "DEALSAdaptiveMemory", "description": "Enhance convergence by employing a dynamic population resizing strategy and integrating a memory-based learning mechanism for adaptive parameter control.", "code": "import numpy as np\n\nclass DEALSAdaptiveMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.memory_size = 5\n        self.memory = []\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if self.evaluations > 0 and self.evaluations % (self.budget // 10) == 0:\n            self.population_size = max(int(self.population_size * self.resizing_factor), 4)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def _update_memory(self, value):\n        if len(self.memory) >= self.memory_size:\n            self.memory.pop(0)\n        self.memory.append(value)\n\n    def _learned_parameter(self):\n        if not self.memory:\n            return 0.1\n        return np.mean(self.memory)\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n                    self._update_memory(best_trial[1])\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 71, "feedback": "The algorithm DEALSAdaptiveMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86698 with standard deviation 0.02495.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8785942990365397, 0.86576035749553, 0.8860475765034419, 0.9045851667986785, 0.880409336299296, 0.872827546861678, 0.8637005918651645, 0.8227919122652888, 0.8280950829286697]}}
{"id": "072ab593-70b1-4334-81e8-c3cc03b887bc", "fitness": 0.809069880986629, "name": "DEALSAdaptiveRefined", "description": "Slightly adjust the adaptive mutation scaling factor to improve exploration capabilities.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.85  # Changed from 0.8 to 0.85 for better exploration\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80907 with standard deviation 0.08550.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8737170089053617, 0.7275987510438783, 0.8849842692061197, 0.8663051614892611, 0.8175093919897152, 0.8951169842090363, 0.8263772778375578, 0.6170991032226271, 0.772920980976104]}}
{"id": "a7c4e20e-511e-4580-b462-235719318163", "fitness": 0.6070500878845537, "name": "DEALSAdaptiveRefined", "description": "Enhance mutation strategy by introducing diversity-oriented scaling factor and modified elitism for improved exploration and convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        diversity_factor = np.std(self.population, axis=0) / (self.ub - self.lb + 1e-10)\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + diversity_factor * np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + diversity_factor * np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget + 0.1) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60705 with standard deviation 0.24715.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.678377913585769, 0.722636853613914, 0.725041385238271, 0.7869808071935918, 0.7384801023702916, 0.723322476197448, 0.12140223661542637, 0.7900860170521312, 0.17712299909414175]}}
{"id": "e2169bc0-e1ed-4495-8e12-e7b8b44da4c2", "fitness": 0.8669790966726985, "name": "DEALSAdaptiveRefined", "description": "Introduce a dynamic resizing factor and dynamic learning rate based on evaluations to enhance diversity and convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            dynamic_resizing_factor = self.resizing_factor + 0.05 * (self.evaluations / self.budget)\n            self.population_size = int(self.population_size * dynamic_resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86698 with standard deviation 0.02495.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8785942990365397, 0.86576035749553, 0.8860475765034419, 0.9045851667986785, 0.880409336299296, 0.872827546861678, 0.8637005918651645, 0.8227919122652888, 0.8280950829286697]}}
{"id": "c6b856fb-e01a-4c13-a8b2-e3fc53902f01", "fitness": 0.8024383754862332, "name": "DEALSAdaptiveDynamic", "description": "Introduce dynamic scaling and elitist crossovers to balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        dynamic_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget))) * np.random.rand()\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        \n        mutant1 = np.clip(a + dynamic_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + dynamic_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n\n        # Elitist crossover enhancement\n        if np.random.rand() < 0.05:\n            elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n            trial = trial + np.random.normal(0, 0.1, self.dim) * (elite_avg - trial)\n\n        return np.clip(trial, self.lb, self.ub)\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm DEALSAdaptiveDynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80244 with standard deviation 0.09259.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8288514842358371, 0.7016558405670048, 0.9182105333546348, 0.8962991411038582, 0.7305773601909031, 0.8818937022558443, 0.7567966421646302, 0.640245523387707, 0.8674151521156795]}}
{"id": "563d7186-91e6-4d12-b40d-d412da5e4b58", "fitness": 0.08223983131635962, "name": "DEALSAdaptiveRefined", "description": "Refine mutation by introducing an enhanced elite selection method to improve diversity and convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._enhanced_elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _enhanced_elitist_selection(self):\n        elite_size = int(self.elitism_rate * (1 + np.sin(np.pi * self.evaluations / self.budget)) * self.population_size)  # Enhanced selection\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._enhanced_elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08224 with standard deviation 0.04498.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.057446797610098965, 0.055178568995642885, 0.05475387518453667, 0.14228232653840744, 0.14351381633649285, 0.15058949402457866, 0.04722661460334965, 0.04223603694693745, 0.04693095160719196]}}
{"id": "902282f6-f64d-46b3-8778-582dfbf24b35", "fitness": 0.8669790966726985, "name": "DEALSAdaptiveRefined", "description": "Introduce dynamic learning rate adjustment and adaptive resizing for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.initial_learning_rate = 0.1\n        self.learning_rate = self.initial_learning_rate\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, self.learning_rate, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, self.learning_rate, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * (self.resizing_factor * (1 + 0.1 * np.sin(iteration))))\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n            self.learning_rate = self.initial_learning_rate * (1 - self.evaluations / self.budget)\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86698 with standard deviation 0.02495.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8785942990365397, 0.86576035749553, 0.8860475765034419, 0.9045851667986785, 0.880409336299296, 0.872827546861678, 0.8637005918651645, 0.8227919122652888, 0.8280950829286697]}}
{"id": "8a3afb39-9c5b-401d-a812-59717166c71d", "fitness": 0.8274697914019113, "name": "DEALSAdaptiveRefined", "description": "Introduce stochastic scaling of the mutation factor to improve exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget))) * np.random.uniform(0.9, 1.1)  # Stochastic scaling\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82747 with standard deviation 0.05218.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8424505035377414, 0.8189393178588549, 0.8688529476338485, 0.8585272835957231, 0.8603263487493553, 0.8833607894044447, 0.8412540051280565, 0.7551851619268498, 0.7183317647823293]}}
{"id": "daa845b9-836e-49a2-9bef-0bc292f06109", "fitness": 0.12116993417330926, "name": "DEALSHybridAdaptive", "description": "Hybridize differential evolution with a self-adaptive learning mechanism to dynamically adjust parameters and promote exploration-exploitation balance.", "code": "import numpy as np\n\nclass DEALSHybridAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_min, self.F_max = 0.5, 0.9\n        self.CR_min, self.CR_max = 0.1, 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F_min + np.random.rand() * (self.F_max - self.F_min)\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR_min + np.random.rand() * (self.CR_max - self.CR_min)\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 79, "feedback": "The algorithm DEALSHybridAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12117 with standard deviation 0.04464.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.09659499546412453, 0.09111372676870233, 0.1050566030375425, 0.1677126414956508, 0.19376003314232437, 0.18625124241777413, 0.08210751196500754, 0.09408982817345057, 0.07384282509520645]}}
{"id": "6051df51-e493-414a-9e6d-2ca5161cfaf3", "fitness": 0.09529645302974034, "name": "DEALSAdaptiveRefinedEnhanced", "description": "Introduce dynamic elitism and adaptive resizing to better balance exploration and exploitation across varying problem landscapes.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefinedEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.1\n        self.resizing_factor = 0.85\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        dynamic_elitism_rate = self.elitism_rate * (1 + 0.5 * np.sin(np.pi * self.evaluations / self.budget))\n        elite_size = int(dynamic_elitism_rate * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(max(self.population_size * self.resizing_factor, 5))\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm DEALSAdaptiveRefinedEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09530 with standard deviation 0.04749.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.0683204802975057, 0.06827534766457488, 0.07597553686135794, 0.17774391670200562, 0.1509764345121729, 0.15416134350709476, 0.053652236193174496, 0.05548210174929058, 0.05308067978048614]}}
{"id": "ea0f16d4-54e8-4eb4-b918-929565f134c7", "fitness": 0.4166346639969621, "name": "DEALSAdaptiveDynamic", "description": "Enhance exploitation by introducing a dynamic learning rate for refined mutation and incorporating a Gaussian perturbation for improved exploration.", "code": "import numpy as np\n\nclass DEALSAdaptiveDynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.dynamic_learning_rate = 0.1\n        self.gaussian_perturbation_strength = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        dynamic_learning_rate = self.dynamic_learning_rate * (1 - self.evaluations / self.budget)\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        perturbation = np.random.normal(0, self.gaussian_perturbation_strength, self.dim)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + perturbation, self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + dynamic_learning_rate * (e - a) + perturbation, self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm DEALSAdaptiveDynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41663 with standard deviation 0.33485.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8660753239966772, 0.12574633317016481, 0.10709466976336235, 0.8639908713361706, 0.5275966483738708, 0.22729091334007823, 0.8356108387210395, 0.10144468458831246, 0.09486169268298283]}}
{"id": "9f8504e8-903f-49ae-b4d8-06909404698d", "fitness": 0.09246696089134335, "name": "DEALSAdaptiveRefined", "description": "Refine selection dynamics by integrating adaptive elitism rate and stochastic tournament selection to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        adaptive_rate = self.elitism_rate * (1 + 0.5 * np.sin(2 * np.pi * self.evaluations / self.budget))\n        elite_size = int(adaptive_rate * self.population_size)\n        elite_size = max(elite_size, 2)\n        tournament_size = 3\n        tournament_indices = np.random.choice(self.population_size, tournament_size, replace=False)\n        selected_idx = np.argmin(self.scores[tournament_indices])\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return np.concatenate(([tournament_indices[selected_idx]], elite_indices))\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09247 with standard deviation 0.04507.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.0625703167750874, 0.06344539369178093, 0.0667939547016363, 0.1581150519554677, 0.15377743991414972, 0.15551005337669355, 0.06687810206855649, 0.05264128517838107, 0.052471050360336946]}}
{"id": "c9b97eac-a4b0-4c32-9bee-714991a66425", "fitness": 0.07096245197126307, "name": "DEALSSelfAdaptiveEnhanced", "description": "Introduce a novel self-adaptive mechanism with adaptive learning rates and elite-guided mutation to boost convergence speed and solution quality.", "code": "import numpy as np\n\nclass DEALSSelfAdaptiveEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.alpha_min = 0.1\n        self.alpha_max = 0.9\n        self.beta = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _self_adaptive_parameters(self):\n        alpha = self.alpha_min + (self.alpha_max - self.alpha_min) * (1 - self.evaluations / self.budget)\n        return alpha\n\n    def _elitist_avg(self):\n        elite_indices = self._elitist_selection()\n        return np.mean(self.population[elite_indices], axis=0)\n\n    def _mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        alpha = self._self_adaptive_parameters()\n        elite_avg = self._elitist_avg()\n        F_dynamic = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        mutant1 = np.clip(a + F_dynamic * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + F_dynamic * (e - a) * alpha + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = max(int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size), 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target = self.population[i]\n                mutant1, mutant2 = self._mutation(i)\n                trial1 = self._crossover(target, mutant1, iteration)\n                trial2 = self._crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[i]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[i] = best_trial[0]\n                    self.scores[i] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm DEALSSelfAdaptiveEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07096 with standard deviation 0.04494.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.043270430217055234, 0.042840430211865344, 0.04517208320973287, 0.13080253744394443, 0.13613013818939246, 0.1358692880431881, 0.034529586185849226, 0.034162025871177226, 0.03588554836916269]}}
{"id": "a4f16be4-888c-4782-81b8-09a5af42ede9", "fitness": 0.7720738417708483, "name": "DEALSAdaptiveEnhanced", "description": "Integrate a dynamic elitism strategy and adaptive mutation scaling to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DEALSAdaptiveEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_initial = 0.9\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F_initial * (1 - (self.evaluations / self.budget))\n        elite_avg = np.mean(self.population[self._dynamic_elitist_selection()], axis=0)  # Dynamic elitism\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _dynamic_elitist_selection(self):\n        elite_size = int((np.sin(np.pi * self.evaluations / self.budget) * self.elitism_rate * self.population_size))\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._dynamic_elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 84, "feedback": "The algorithm DEALSAdaptiveEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77207 with standard deviation 0.15567.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.6653971809749768, 0.8492572241020846, 0.9278795071144061, 0.6245418465381009, 0.846990684963959, 0.9083918408270935, 0.4286773733070479, 0.8283777422370249, 0.8691511758729404]}}
{"id": "1ad31926-f7dc-4055-a947-326351599442", "fitness": 0.08522032419478699, "name": "DEALSAdaptiveRefined", "description": "Enhance convergence by incorporating a dynamic elitism rate based on iteration performance and using a more refined resizing factor.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.9  # Modified resizing factor\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * max(1, self.evaluations / (0.2 * self.budget)) * self.population_size)  # Dynamic elite size\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08522 with standard deviation 0.04673.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.05567215246996604, 0.05427526671954197, 0.06243534205481571, 0.1617317401574091, 0.13944396509947876, 0.15006826465684797, 0.05360507534599168, 0.039907407401911565, 0.04984370384712011]}}
{"id": "d6052c9a-c169-463a-bcdd-336d81a6d12a", "fitness": 0.8514843576238819, "name": "DEALSAdaptiveRefined", "description": "Enhance the mutation strategy by incorporating adaptive learning rates based on iteration progress to improve convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        learning_rate_adjustment = self.learning_rate * (self.budget - self.evaluations) / self.budget  # Change 1\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, learning_rate_adjustment, self.dim), self.lb, self.ub)  # Change 2\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, learning_rate_adjustment, self.dim), self.lb, self.ub)  # Change 3\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 86, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85148 with standard deviation 0.02842.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8777559458261572, 0.8670555358822407, 0.8395568900559456, 0.901174246633338, 0.8510010975766138, 0.8516707531542628, 0.8560896629765496, 0.8191339758154208, 0.7999211106944086]}}
{"id": "21a1f929-44dd-445a-b982-767faf14efcd", "fitness": 0.8561296810864767, "name": "DEALSAdaptiveRefined", "description": "Enhance mutation strategy by incorporating Gaussian noise to elite average for improved exploration.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  \n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a + np.random.normal(0, 0.1, self.dim)), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 87, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85613 with standard deviation 0.04200.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8783429592065236, 0.7875048544926948, 0.9078084514921841, 0.8865354440031592, 0.8431139666002425, 0.8538350620891848, 0.8783135960950716, 0.7823980826783894, 0.8873147131208395]}}
{"id": "e23a6272-50a4-49f3-80be-dab4c85a4310", "fitness": 0.610439187488029, "name": "DEALSAdaptiveRefined", "description": "Refine adaptive mutation by introducing a dynamic strategy selection based on the best solutions' variance to enhance convergence rate.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        elite_var = np.var(self.population[self._elitist_selection()], axis=0)  # New line: Calculate variance\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, elite_var.mean(), self.dim), self.lb, self.ub)  # Modified line\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61044 with standard deviation 0.26363.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8780231148004328, 0.5513750224346673, 0.7229737374562306, 0.8955396068425656, 0.2056099090947655, 0.685872783774738, 0.8324739172236904, 0.12315601879634486, 0.5989285769688257]}}
{"id": "59bce615-86c5-4a35-a906-fef127efa920", "fitness": 0.8500679366019082, "name": "DEALSAdaptiveRefined", "description": "Enhance the elitism by dynamically adjusting the rate based on the diversity of the population.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _elitist_selection(self):\n        # Dynamically adjust the elitism rate based on diversity\n        diversity = np.mean(np.std(self.population, axis=0))\n        adjusted_rate = self.elitism_rate + 0.1 * (1 - diversity)\n        elite_size = int(adjusted_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 89, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85007 with standard deviation 0.01862.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8615153969780373, 0.8324799533462247, 0.8752864976771692, 0.8791454120656275, 0.8421325190762332, 0.8444857635829385, 0.8371131835115805, 0.8205037488841758, 0.857948954295187]}}
{"id": "bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381", "fitness": 0.8669790966727048, "name": "DEALSAdaptiveRefined", "description": "Enhance the crossover strategy by incorporating a dynamically adjusted learning rate for improved exploration.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(iteration / self.budget * np.pi))  # Adjusted learning rate\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86698 with standard deviation 0.02495.", "error": "", "parent_ids": ["041cf206-3d3a-46c6-9e86-a4d9f0ee29ef"], "operator": null, "metadata": {"aucs": [0.8785942990365403, 0.8657603574955293, 0.886047576503496, 0.904585166798678, 0.8804093362992925, 0.8728275468616872, 0.8637005918651632, 0.8227919122652787, 0.8280950829286786]}}
{"id": "cf03d9dd-2e36-40d7-9999-16a4de6ff563", "fitness": 0.8504373095323863, "name": "DEALSAdaptiveRefined", "description": "Introduce a dynamic resizing factor and adjust the elitism rate for enhanced adaptation during the optimization process.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0.1, 0.02, self.dim), self.lb, self.ub)  # Changed line\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(iteration / self.budget * np.pi))  # Adjusted learning rate\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget + 0.05) * self.population_size)  # Changed line\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85044 with standard deviation 0.05431.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.878349364757943, 0.8733086096416256, 0.8658182000427026, 0.898795183608531, 0.8782435175609439, 0.8754924950415501, 0.8280840675671397, 0.7063197979385275, 0.8495245496325137]}}
{"id": "edd4413e-e115-4af3-a471-d434728d4347", "fitness": 0.6165457600182106, "name": "DEALSDiversityPreserved", "description": "Incorporate a diversity-preserving mechanism with a self-adaptive parameter adjustment to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DEALSDiversityPreserved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.diversity_threshold = 0.05\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        diversity_factor = np.std(self.population, axis=0).mean() / self.diversity_threshold\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1 * diversity_factor, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1 * diversity_factor, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 92, "feedback": "The algorithm DEALSDiversityPreserved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61655 with standard deviation 0.20264.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.7596435017636032, 0.46809749560344616, 0.7629071447829239, 0.829014761730565, 0.20811856904217962, 0.760008599102656, 0.6705831896162315, 0.3720685963631717, 0.7184699821591181]}}
{"id": "07f21044-8532-4efa-a658-f14f35b31a8e", "fitness": 0.0894674013954077, "name": "DEALSDiversityEnhanced", "description": "Introduce diversity preservation and adaptive scaling factors to enhance exploration and avoid premature convergence.", "code": "import numpy as np\n\nclass DEALSDiversityEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_min, self.F_max = 0.6, 0.9\n        self.CR_min, self.CR_max = 0.7, 0.95\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _diversity_preserved_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        distance = np.linalg.norm(b - c)\n        adaptive_F = (self.F_max - self.F_min) * (1 - distance / self.dim) + self.F_min\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR_min + (self.CR_max - self.CR_min) * np.cos(iteration / self.budget * np.pi)\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(iteration / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._diversity_preserved_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm DEALSDiversityEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08947 with standard deviation 0.03739.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.06716135311615434, 0.06697826263180351, 0.06708948250984181, 0.1433763269539703, 0.1412151537328703, 0.14181511313437278, 0.05990297250844323, 0.06052318924018196, 0.057144758731030976]}}
{"id": "d89bcb03-e074-4ca0-b70c-893fed2ab5ce", "fitness": 0.08829395959108582, "name": "DEALSSelfAdaptiveRefined", "description": "Introduce a self-adaptive parameter adjustment mechanism to optimize both exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass DEALSSelfAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.initial_F = 0.8\n        self.initial_CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.F_adapt = np.full(self.population_size, self.initial_F)\n        self.CR_adapt = np.full(self.population_size, self.initial_CR)\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F_adapt[idx]\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, idx):\n        dynamic_CR = self.CR_adapt[idx]\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(self.evaluations / self.budget * np.pi))\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n            self.F_adapt = self.F_adapt[:self.population_size]\n            self.CR_adapt = self.CR_adapt[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, target_idx)\n                trial2 = self._adaptive_crossover(target, mutant2, target_idx)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n                    self.F_adapt[target_idx] = np.clip(self.F_adapt[target_idx] + 0.1 * (np.random.rand() - 0.5), 0.1, 1.0)\n                    self.CR_adapt[target_idx] = np.clip(self.CR_adapt[target_idx] + 0.1 * (np.random.rand() - 0.5), 0.1, 1.0)\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 94, "feedback": "The algorithm DEALSSelfAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08829 with standard deviation 0.04059.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.06276896789829967, 0.06690014258670973, 0.06140395231829343, 0.14535114072321187, 0.14742852203710555, 0.14279502582046022, 0.05364838997683519, 0.04899142698208914, 0.06535806797676758]}}
{"id": "5fe42a6f-2b14-4512-a663-e8e220608fed", "fitness": 0.07647395997023688, "name": "DEALSAdaptiveEnhanced", "description": "Improve efficiency by integrating a rank-based selection mechanism and dynamic parameter tuning for enhanced adaptability.", "code": "import numpy as np\n\nclass DEALSAdaptiveEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.initial_F = 0.8\n        self.initial_CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _dynamic_parameters(self, iteration):\n        adaptive_F = self.initial_F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        dynamic_CR = self.initial_CR * (1 - np.cos(iteration / self.budget * np.pi))\n        return adaptive_F, dynamic_CR\n\n    def _adaptive_mutation(self, idx, adaptive_F):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant\n\n    def _adaptive_crossover(self, target, mutant, dynamic_CR):\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def _rank_based_selection(self):\n        sorted_indices = np.argsort(self.scores)\n        rank_probabilities = np.linspace(1, 0, self.population_size)\n        rank_probabilities /= rank_probabilities.sum()\n        return np.random.choice(sorted_indices, p=rank_probabilities)\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            adaptive_F, dynamic_CR = self._dynamic_parameters(iteration)\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = self._rank_based_selection()\n                target = self.population[target_idx]\n                mutant = self._adaptive_mutation(target_idx, adaptive_F)\n                trial = self._adaptive_crossover(target, mutant, dynamic_CR)\n\n                trial_score = func(trial)\n                self.evaluations += 1\n\n                if trial_score < self.scores[target_idx]:\n                    self.population[target_idx] = trial\n                    self.scores[target_idx] = trial_score\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm DEALSAdaptiveEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07647 with standard deviation 0.04520.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.05283032703883683, 0.04627226162498688, 0.053273736235878166, 0.1350456556586691, 0.14089320654758797, 0.14355118269584466, 0.03518117895904416, 0.037497540060647094, 0.04372055091063709]}}
{"id": "f60134b1-4fcf-414f-984c-1f9d7d30bbad", "fitness": 0.8545496633905715, "name": "DEALSAdaptiveRefined", "description": "Integrate a dynamic elitism rate that adapts based on the iteration to improve convergence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(iteration / self.budget * np.pi))  # Adjusted learning rate\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        self.elitism_rate = 0.15 + 0.1 * np.sin(self.evaluations / self.budget * np.pi)  # Dynamic elitism rate\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 96, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.85455 with standard deviation 0.02752.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.8627177609586387, 0.8246400003173802, 0.8855102485044407, 0.9045443411173274, 0.8410541494929779, 0.8765320101157821, 0.8427436356594153, 0.8227004187328333, 0.830504405616348]}}
{"id": "0fc5e2ea-1f8e-4120-8458-3e9f451f16d0", "fitness": 0.8669790966727048, "name": "DEALSAdaptiveRefined", "description": "Introduce a decay mechanism to the learning rate to enhance convergence stability and precision.  ", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(iteration / self.budget * np.pi)) * (1 - iteration / self.budget)  # Introduced decay mechanism\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.86698 with standard deviation 0.02495.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.8785942990365403, 0.8657603574955293, 0.886047576503496, 0.904585166798678, 0.8804093362992925, 0.8728275468616872, 0.8637005918651632, 0.8227919122652787, 0.8280950829286786]}}
{"id": "b9e07afd-73cd-4cb6-a1c9-2669ae77b500", "fitness": 0.6822445733086681, "name": "EnhancedDEALSAdaptive", "description": "Integrate self-adaptive control parameters with a diversity-preserving mechanism to maintain balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedDEALSAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F_base = 0.8\n        self.CR_base = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.history = []\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        \n        # Self-adaptive F based on diversity\n        diversity = np.mean(np.std(self.population, axis=0))\n        adaptive_F = self.F_base * (1 - np.tanh(diversity))\n        \n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)\n        mutant1 = np.clip(a + adaptive_F * (b - c) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        diversity = np.mean(np.std(self.population, axis=0))\n        dynamic_CR = self.CR_base * (1 - np.cos(iteration / self.budget * np.pi)) * (1 + diversity)\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(iteration / self.budget * np.pi))\n        \n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n                self.history.append((self.population.copy(), self.scores.copy()))\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedDEALSAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68224 with standard deviation 0.21096.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.747658456618624, 0.5821941416740388, 0.839338920979178, 0.7588734233801195, 0.722497828702322, 0.8612325766973247, 0.6872023924648728, 0.12969432850817897, 0.8115090907533538]}}
{"id": "a42f07ee-fa11-4e0e-9a47-15e5814eb3ee", "fitness": 0.8195160463235265, "name": "DEALSAdaptiveRefined", "description": "Introduce a momentum term in mutation for enhanced search direction persistence.", "code": "import numpy as np\n\nclass DEALSAdaptiveRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.F = 0.8\n        self.CR = 0.9\n        self.population = None\n        self.scores = np.full(self.population_size, np.inf)\n        self.evaluations = 0\n        self.elitism_rate = 0.15\n        self.resizing_factor = 0.85\n        self.learning_rate = 0.1\n        self.momentum = 0.9  # Newly added momentum term\n\n    def _initialize_population(self, lb, ub):\n        self.population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        self.lb, self.ub = lb, ub\n\n    def _adaptive_mutation(self, idx):\n        indices = np.random.choice(self.population_size, 5, replace=False)\n        while idx in indices:\n            indices = np.random.choice(self.population_size, 5, replace=False)\n        a, b, c, d, e = self.population[indices]\n        adaptive_F = self.F * (1 - np.tanh(self.evaluations / (0.5 * self.budget)))\n        elite_avg = np.mean(self.population[self._elitist_selection()], axis=0)  # Enhanced mutation strategy\n        # Introduced momentum in mutation\n        mutant1 = np.clip(a + adaptive_F * (b - c) + self.momentum * (d - e) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        mutant2 = np.clip(elite_avg + adaptive_F * (e - a) + np.random.normal(0, 0.1, self.dim), self.lb, self.ub)\n        return mutant1, mutant2\n\n    def _adaptive_crossover(self, target, mutant, iteration):\n        dynamic_CR = self.CR * (1 - np.cos(iteration / self.budget * np.pi))\n        dynamic_LR = self.learning_rate * (1 + 0.5 * np.sin(iteration / self.budget * np.pi))  # Adjusted learning rate\n        cross_points = np.random.rand(self.dim) < dynamic_CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target * dynamic_LR + (1 - dynamic_LR) * target)\n        return trial\n\n    def _elitist_selection(self):\n        elite_size = int(self.elitism_rate * (self.evaluations / self.budget) * self.population_size)\n        elite_size = max(elite_size, 2)\n        elite_indices = np.argsort(self.scores)[:elite_size]\n        return elite_indices\n\n    def _resize_population(self, iteration):\n        if iteration > 0 and iteration % (self.budget // 10) == 0:\n            self.population_size = int(self.population_size * self.resizing_factor)\n            self.population = self.population[:self.population_size]\n            self.scores = self.scores[:self.population_size]\n\n    def __call__(self, func):\n        self._initialize_population(func.bounds.lb, func.bounds.ub)\n\n        iteration = 0\n        while self.evaluations < self.budget:\n            self._resize_population(iteration)\n            elite_indices = self._elitist_selection()\n\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                target_idx = elite_indices[i % len(elite_indices)]\n                target = self.population[target_idx]\n                mutant1, mutant2 = self._adaptive_mutation(target_idx)\n                trial1 = self._adaptive_crossover(target, mutant1, iteration)\n                trial2 = self._adaptive_crossover(target, mutant2, iteration)\n\n                trial_score1 = func(trial1)\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    break\n\n                trial_score2 = func(trial2)\n                self.evaluations += 1\n\n                if min(trial_score1, trial_score2) < self.scores[target_idx]:\n                    best_trial = min((trial1, trial_score1), (trial2, trial_score2), key=lambda x: x[1])\n                    self.population[target_idx] = best_trial[0]\n                    self.scores[target_idx] = best_trial[1]\n\n            iteration += 1\n\n        best_idx = np.argmin(self.scores)\n        return self.population[best_idx], self.scores[best_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm DEALSAdaptiveRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81952 with standard deviation 0.06760.", "error": "", "parent_ids": ["bdbd7bb6-f17a-45f6-9a1b-f1ef5d412381"], "operator": null, "metadata": {"aucs": [0.8801010726443779, 0.8189675771878565, 0.8552481174086178, 0.9040332534140648, 0.6853206715813999, 0.8578736005806383, 0.8603106340042663, 0.751937113758561, 0.7618523763319556]}}
