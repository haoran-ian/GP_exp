{"id": "3d251c22-318f-407e-8361-ae8266bf2105", "fitness": 0.06607523192401726, "name": "AdaptiveOppositionSearch", "description": "A dynamic adaptive search with hybrid exploration-exploitation strategy using opposition-based learning and adaptive step control.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.uniform(-step_size, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06608 with standard deviation 0.05983.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.1406576760773437, 0.14508540609181841, 0.14883934547712319, 0.04733377872813194, 0.0487033021908968, 0.06255757875084156, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6bd89306-bef1-4b7e-bf27-b4c6ab6ad8fb", "fitness": 0.06408699688846456, "name": "EnhancedAdaptiveOppositionSearch", "description": "Improved Adaptive Opposition Search with Dynamic Population Resizing and Centroid-based Exploration for Enhanced Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            centroid = np.mean(population, axis=0)\n            for i in range(pop_size):\n                exploration_vector = np.random.uniform(bounds[0], bounds[1], self.dim)\n                new_candidate = 0.5 * (population[i] + centroid) + 0.5 * (exploration_vector - centroid)\n                new_candidate = np.clip(new_candidate, bounds[0], bounds[1])\n                new_fitness = func(new_candidate)\n                evals += 1\n                \n                if new_fitness < fitness[i]:\n                    population[i] = new_candidate\n                    fitness[i] = new_fitness\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n            if evals < self.budget // 2:\n                pop_size = min(pop_size + 1, self.budget // 5)\n            else:\n                pop_size = max(10, pop_size - 1)\n                \n            population = population[:pop_size]\n            fitness = fitness[:pop_size]\n\n        return best_solution", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06409 with standard deviation 0.05749.", "error": "", "parent_ids": ["3d251c22-318f-407e-8361-ae8266bf2105"], "operator": null, "metadata": {"aucs": [0.13743016902082827, 0.13839405769702995, 0.14322351796306654, 0.05157029538001079, 0.055107676623063706, 0.049557255312181914, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8dbeb181-eb06-4d6e-a762-fe7e8359c598", "fitness": 0.06714911163675034, "name": "AdaptiveOppositionSearch", "description": "A dynamic adaptive search with hybrid exploration-exploitation strategy using improved opposition-based learning and adaptive step control.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)  # Changed uniform to normal\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06715 with standard deviation 0.05911.", "error": "", "parent_ids": ["3d251c22-318f-407e-8361-ae8266bf2105"], "operator": null, "metadata": {"aucs": [0.13792816878711767, 0.150308667100704, 0.1436954247059421, 0.059698988752205695, 0.05286950130543466, 0.05834125407934909, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3acdbe34-44c1-45ed-8eb5-540a094479c9", "fitness": 0.06594877614942528, "name": "EnhancedAdaptiveOppositionSearch", "description": "Enhanced Adaptive Opposition Search using dynamic opposition-based reflection, elite retention, and covariance-guided perturbation for improved convergence.  ", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            reflect_pop = (bounds[0] + bounds[1]) - population + np.random.uniform(-0.1, 0.1, population.shape) * (best_solution - population)\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_pop = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_pop[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            elite_size = max(1, pop_size // 5)\n            elite_pop = population[:elite_size]\n            cov_matrix = np.cov(elite_pop.T) + np.eye(self.dim) * 1e-6\n            perturbation = np.random.multivariate_normal(np.zeros(self.dim), cov_matrix, pop_size)\n            \n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06595 with standard deviation 0.06021.", "error": "", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {"aucs": [0.1422133086306635, 0.14442526042163983, 0.15045796135656353, 0.04887586139701183, 0.05720519399268498, 0.048861399546264006, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a7fd0cfc-70b4-40bd-97a6-bbdedc0f6e0a", "fitness": 0.06474760306922296, "name": "AdaptiveOppositionSearch", "description": "Enhanced Adaptive Opposition Search with improved perturbation scaling and elite retention.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.05 * (bounds[1] - bounds[0])  # Reduced step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            elite_retention = int(0.1 * pop_size)  # Retain top 10% elite solutions\n            population[elite_retention:] += perturbation[elite_retention:]  # Apply perturbation to non-elite only\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06475 with standard deviation 0.05712.", "error": "", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {"aucs": [0.13564153800930012, 0.1359802349423037, 0.14578837553152424, 0.05492277907059029, 0.05619800265741981, 0.05269749741186869, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "50b1c77d-76ea-48ef-b666-d1cf7617a819", "fitness": 0.0645530595161843, "name": "EnhancedAdaptiveOppositionSearch", "description": "Enhanced Adaptive Opposition Search with Lévy Flight perturbation for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def levy_flight(self, step_size, dim):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, size=dim)\n        v = np.random.normal(0, 1, size=dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step_size * step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.1 * (bounds[1] - bounds[0])\n            for i in range(pop_size):\n                levy_step = self.levy_flight(step_size, self.dim)\n                population[i] += levy_step\n                population[i] = np.clip(population[i], bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06455 with standard deviation 0.05777.", "error": "", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {"aucs": [0.13715263571577319, 0.1376624120284652, 0.14637071371064692, 0.05117774664403896, 0.05364275799533702, 0.05347126955139758, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "118b0d6e-a974-4531-87e5-7f75abc70cdd", "fitness": 0.06413551598177103, "name": "HybridOppositionMemeticSearch", "description": "Hybrid Opposition-Inspired Memetic Search: Integrates improved opposition-based learning with memetic exploration utilizing adaptive learning rates and candidate pool refinement.", "code": "import numpy as np\n\nclass HybridOppositionMemeticSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            # Improved opposition-based learning\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and sort the population by fitness\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Memetic exploration with adaptive learning rate\n            step_size = 0.1 * (bounds[1] - bounds[0]) * (1 - evals / self.budget)\n            for i in range(pop_size):\n                local_search_candidates = np.random.uniform(bounds[0], bounds[1], (3, self.dim))\n                local_search_candidates[0] = population[i]\n                local_fitness = np.apply_along_axis(func, 1, local_search_candidates)\n                local_best_idx = np.argmin(local_fitness)\n                population[i] = local_search_candidates[local_best_idx]\n                fitness[i] = local_fitness[local_best_idx]\n                \n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 6, "feedback": "The algorithm HybridOppositionMemeticSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06414 with standard deviation 0.06120.", "error": "", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {"aucs": [0.13979218754732514, 0.13922558793660267, 0.159860993241696, 0.04710150643931932, 0.04522611046095637, 0.04451325821003993, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "385f5533-4c68-4dea-addc-33bda4aa573c", "fitness": 0.065548838443602, "name": "AdaptiveOppositionSearch", "description": "Enhanced adaptive search using opposition-based learning and adaptive step control with Gaussian perturbation.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.05 * (bounds[1] - bounds[0])  # Changed step size from 0.1 to 0.05\n            perturbation = np.random.normal(0, step_size, population.shape) \n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06555 with standard deviation 0.05920.", "error": "", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {"aucs": [0.14148807184207224, 0.14640411241486717, 0.14310483015104092, 0.05494676624170469, 0.0536019368138233, 0.04889382852890989, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "146d160f-03dd-4439-af1b-46fdd9c5bacf", "fitness": 0.06364123689652676, "name": "AdaptiveOppositionSearch", "description": "A dynamic adaptive search with hybrid exploration-exploitation strategy using improved opposition-based learning and adaptive step control, now with adaptive population size.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)  # Changed uniform to normal\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n            \n            pop_size = max(10, min(100, int(pop_size * 1.1)))  # Line changed: Adaptive population size adjustment\n                \n        return best_solution", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06364 with standard deviation 0.05812.", "error": "", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {"aucs": [0.13922423096686076, 0.13792561954489857, 0.14500160877247747, 0.051606163732102805, 0.050296046762158486, 0.04721746229024293, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "43db49f9-b517-4a4e-9606-73f8f92e3ccc", "fitness": 0.0638042926658589, "name": "EnhancedAdaptiveOppositionSearch", "description": "Enhanced AdaptiveOppositionSearch: Incorporates a selective elitism mechanism and adaptive perturbation scaling for improved convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            \n            sorted_indices = np.argsort(combined_fitness)\n            combined_population = combined_population[sorted_indices]\n            combined_fitness = combined_fitness[sorted_indices]\n            \n            # Selective elitism: keep the best solutions and explore further\n            elite_pop = combined_population[:pop_size // 2]\n            elite_fitness = combined_fitness[:pop_size // 2]\n            \n            # Explore the remaining space\n            explore_pop = combined_population[pop_size // 2:pop_size]\n            explore_fitness = combined_fitness[pop_size // 2:pop_size]\n            \n            step_size = 0.1 * (bounds[1] - bounds[0]) * (1 - evals/self.budget)\n            perturbation = np.random.normal(0, step_size, explore_pop.shape)\n            explore_pop += perturbation\n            explore_pop = np.clip(explore_pop, bounds[0], bounds[1])\n            \n            explore_fitness = np.apply_along_axis(func, 1, explore_pop)\n            evals += pop_size // 2\n            \n            # Combine elite and explored populations\n            population = np.vstack((elite_pop, explore_pop))\n            fitness = np.hstack((elite_fitness, explore_fitness))\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06380 with standard deviation 0.05808.", "error": "", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {"aucs": [0.13830529175628403, 0.14105178480258074, 0.14293587811571473, 0.051699767262381235, 0.04938092325049792, 0.049364988805271515, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ab452010-c03c-47c3-8843-dad37b3fcc48", "fitness": -Infinity, "name": "EnhancedAdaptiveOppositionSearch", "description": "Enhanced AdaptiveOppositionSearch uses an adaptive neighborhood-based mutation and elitism to improve exploration while preserving promising solutions.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            # Generate reflection population\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select the best individuals\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive neighborhood-based mutation\n            elite = population[:max(1, pop_size // 5)]\n            neighborhood_size = 0.05 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, neighborhood_size, population.shape)\n            new_population = elite + perturbation\n            new_population = np.clip(new_population, bounds[0], bounds[1])\n            \n            # Elitism to preserve best solutions\n            population = np.vstack((population, new_population))\n            population = population[np.random.choice(population.shape[0], pop_size, replace=False)]\n            population[:elite.shape[0]] = elite  # Preserve elite solutions\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            # Update best solution\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 10, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (10,20) (50,20) ').", "error": "ValueError('operands could not be broadcast together with shapes (10,20) (50,20) ')", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {}}
{"id": "c977cc1f-d4f2-404b-b804-63d4f99f2ab2", "fitness": 0.0707983626889771, "name": "AdaptiveOppositionSearchV2", "description": "AdaptiveOppositionSearch 2.0 with enhanced exploration using Lévy flights and local search intensification through dynamic neighborhood resizing.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 11, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07080 with standard deviation 0.06843.", "error": "", "parent_ids": ["8dbeb181-eb06-4d6e-a762-fe7e8359c598"], "operator": null, "metadata": {"aucs": [0.20029045242594856, 0.13550557690566456, 0.14341988559755303, 0.05784550284937506, 0.04986653158637344, 0.04875731483587942, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "cc79bad6-f4e6-4083-adbe-c14846317164", "fitness": 0.06504723972120044, "name": "AdaptiveOppositionSearchV2", "description": "AdaptiveOppositionSearch 2.1 with enhanced exploration using Lévy flights and local search intensification through dynamic neighborhood resizing, including a refined opposition mechanism.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Refined reflective opposition\n            reflect_pop = np.clip(bounds[0] + np.random.rand(pop_size, self.dim) * (bounds[1] - population), bounds[0], bounds[1])\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 12, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06505 with standard deviation 0.06160.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14397252987047016, 0.14089739708359084, 0.15811349497055815, 0.04306840393998834, 0.04770658861738575, 0.050166743008810855, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5e3f4785-4f4d-444b-99c7-083a72c365d2", "fitness": 0.06324857860489315, "name": "AdaptiveOppositionSearchV2", "description": "AdaptiveOppositionSearchV2.1 with enhanced local search steps and a revised Lévy flight parameter for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.15 * (bounds[1] - bounds[0])  # Modified\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.3)  # Modified\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 13, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06325 with standard deviation 0.05859.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14057986473074247, 0.13658116035367007, 0.14696091753546692, 0.05018422783858656, 0.04644250659767446, 0.046988530387898075, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "31956bef-8b7e-4a3b-9ee3-784470911f00", "fitness": 0.06794834667818204, "name": "HierarchicalAdaptiveOppositionSearch", "description": "HierarchicalAdaptiveOppositionSearch employs layered exploration through multi-scale opposition-based strategies and adaptive Lévy flights for improved solution diversity and convergence pace.", "code": "import numpy as np\n\nclass HierarchicalAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def hierarchical_opposition(individual, best, bounds):\n            return bounds[0] + bounds[1] - individual + np.random.uniform(-0.1, 0.1, self.dim) * (best - individual)\n\n        while evals < self.budget:\n            # Multi-scale reflective opposition\n            reflect_pop = np.array([hierarchical_opposition(ind, best_solution, bounds) for ind in population])\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0]) * (1 - evals / self.budget)\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Adaptive Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5 + 0.5 * (evals / self.budget))\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Re-evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 14, "feedback": "The algorithm HierarchicalAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06795 with standard deviation 0.06163.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1422133086306635, 0.16123200144392158, 0.14363968027425333, 0.056429264777160815, 0.05665645801441488, 0.04986440696322447, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7e36bc83-bf6f-4f19-956e-39f02777271e", "fitness": 0.0660497291029344, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3: Enhanced with stochastic restarts, mutation-based diversity, and adaptive Lévy flight scaling for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n    \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        restart_threshold = self.budget // 4\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n\n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n\n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n\n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                scale = 1.5 if evals < restart_threshold else 1.0\n                levy_step = levy_flight(scale)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n\n            if evals >= self.budget:\n                break\n\n            # Stochastic restarts to prevent stagnation\n            if evals % restart_threshold == 0:\n                new_population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n                new_fitness = np.apply_along_axis(func, 1, new_population)\n                evals += pop_size\n                combined_population = np.vstack((population, new_population))\n                combined_fitness = np.hstack((fitness, new_fitness))\n                sorted_indices = np.argsort(combined_fitness)\n                population = combined_population[sorted_indices][:pop_size]\n                fitness = combined_fitness[sorted_indices][:pop_size]\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n\n        return best_solution", "configspace": "", "generation": 15, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06605 with standard deviation 0.06031.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1583343003340485, 0.13517517384459943, 0.14293587811571473, 0.05784550284937506, 0.04711789915383091, 0.05153880762884111, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "cdc758d7-16d0-491e-93db-adcdacd42040", "fitness": 0.0654252407466508, "name": "AdaptiveOppositionSearchV2", "description": "Enhance the adaptive search by incorporating a non-uniform step size adaptation scheme for more efficient local search.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size * (1 - evals/self.budget), population.shape)  # Changed line\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 16, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06543 with standard deviation 0.05686.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.13405952875981064, 0.13803503001457862, 0.14412295183449808, 0.06349218755697228, 0.05547814289820441, 0.05213932565579338, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2558446d-0e1a-4d98-b5cd-78a9e3a33cf8", "fitness": 0.0648873762619949, "name": "AdaptiveOppositionSearchV2", "description": "Enhanced AdaptiveOppositionSearchV2 with dynamic Lévy exponent for improved exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            dynamic_lambda = 1.5 + 0.5 * np.random.rand()  # Changed line (dynamic Lévy exponent)\n            for i in range(pop_size):\n                levy_step = levy_flight(dynamic_lambda)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 17, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06489 with standard deviation 0.05792.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1409887700593183, 0.13444475187011717, 0.1464514818538668, 0.04724112237250633, 0.052900053620916654, 0.06046020658122897, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9b7e21e8-8a78-447e-a445-f88796556a83", "fitness": 0.0654252407466508, "name": "AdaptiveOppositionSearchV2", "description": "AdaptiveOppositionSearchV2.1 adds adaptive step size scaling to enhance the efficiency of local search intensification.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification with adaptive step size\n            step_size = 0.1 * (bounds[1] - bounds[0]) * (1 - evals/self.budget)\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 18, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06543 with standard deviation 0.05686.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.13405952875981064, 0.13803503001457862, 0.14412295183449808, 0.06349218755697228, 0.05547814289820441, 0.05213932565579338, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5061024e-a5bd-436c-94ea-23d9cc350f9a", "fitness": 0.06835569353321488, "name": "AdaptiveOppositionSearchV2", "description": "Improved exploration-exploitation balance by adjusting dynamic neighborhood resizing factor for local search intensification.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.12 * (bounds[1] - bounds[0])  # Changed line for improved exploration-exploitation balance\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 19, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06836 with standard deviation 0.06240.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1498644868932747, 0.13577321390736186, 0.16535699805100146, 0.057454806133671044, 0.04963046190048026, 0.055621274913144836, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fe6e0a39-e7db-4292-8671-abc77a279351", "fitness": 0.06581494247216041, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 enhances exploration with fractional Lévy flights and incorporates a history-driven opposition strategy for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        history = []\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # History-driven opposition\n            if history:\n                reflect_pop = 2 * np.mean(history, axis=0) - population\n            else:\n                reflect_pop = bounds[0] + bounds[1] - population\n            \n            reflect_pop = np.clip(reflect_pop, bounds[0], bounds[1])\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Fractional Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n            \n            # Update history\n            if len(history) < 5:\n                history.append(best_solution)\n            else:\n                history.pop(0)\n                history.append(best_solution)\n                \n        return best_solution", "configspace": "", "generation": 20, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06581 with standard deviation 0.05810.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14275428494653042, 0.1379846221385036, 0.14390533759826707, 0.05157937068333396, 0.05571358240409763, 0.05889728447871112, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5cb3e94b-2202-4773-8083-08617920a89d", "fitness": 0.06537706625371052, "name": "AdaptiveOppositionSearchV2", "description": "Enhanced AdaptiveOppositionSearch with refined perturbation strategy for improved local search.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size * 0.9, population.shape)  # Modified line\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 21, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06538 with standard deviation 0.05820.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14070689691790872, 0.1406399241133911, 0.1431851552066432, 0.0491041263980484, 0.061319580066823365, 0.051937913580580086, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a2c133c6-bc8e-4185-960d-e6b37e8e9c42", "fitness": 0.06725596413855622, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 incorporates self-adaptive step sizes for perturbation to enhance local search performance.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0]) * np.random.rand()\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 22, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06726 with standard deviation 0.06004.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14088602239482062, 0.14227798682622073, 0.15419208980239796, 0.05047883917514806, 0.0552670610685112, 0.06070167797990755, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "163205ab-66f6-46ce-a115-4417c60a9785", "fitness": 0.06613656801209931, "name": "AdaptiveOppositionSearchV2", "description": "Enhanced adaptive strategy with Lévy flights and improved local search balance.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 23, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06614 with standard deviation 0.06041.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1583343003340485, 0.13550557690566456, 0.14341988559755303, 0.05784550284937506, 0.04986653158637344, 0.04875731483587942, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3ab034e9-4e22-4941-bf77-ccfe54040ab6", "fitness": 0.06765581604250186, "name": "AdaptiveOppositionSearchV2", "description": "AdaptiveOppositionSearchV2 with improved balancing between exploration and exploitation by adjusting population size dynamically based on budget.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50 + self.budget // 1000, self.budget // 10)  # Dynamically adjust population size\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 24, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06766 with standard deviation 0.06046.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14012692105980062, 0.1561364248402033, 0.14396764782613924, 0.05104037547967666, 0.056831148476611526, 0.05929982670008549, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5840a058-23d8-4ed6-81cc-08547d8ae2b7", "fitness": 0.0648022630632837, "name": "HybridOppositionSearch", "description": "HybridOppositionSearch integrates adaptive opposition with a synergistic blend of Lévy flights, dynamic local search intensification, and population variance control for superior exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            mean_position = np.mean(population, axis=0)\n            reflect_pop = 2 * mean_position - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            variance = np.var(population, axis=0)\n            dynamic_factor = np.clip(variance / (0.1 * (bounds[1] - bounds[0])), 0.5, 1.0)\n            population += np.random.normal(0, dynamic_factor, population.shape)\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            if evals >= self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 25, "feedback": "The algorithm HybridOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06480 with standard deviation 0.05677.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.13440652582119927, 0.13711485993834405, 0.14388170875085704, 0.05799488960463661, 0.053833841037671526, 0.054488542416844976, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "716df393-1f0e-45d1-ab21-1663b6e357da", "fitness": -Infinity, "name": "EnhancedAdaptiveOppositionSearch", "description": "Enhanced AdaptiveOppositionSearch with stochastic gradient-based neighborhood adaptation and chaotic map initialization to optimize exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        \n        # Chaotic map for initialization\n        def chaotic_map(size):\n            chaotic_seq = np.zeros(size)\n            x = 0.7  # Arbitrary choice for logistic map\n            for i in range(size):\n                x = 4 * x * (1 - x)\n                chaotic_seq[i] = x\n            return chaotic_seq\n        \n        population = bounds[0] + (bounds[1] - bounds[0]) * chaotic_map((pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def stochastic_gradient_perturbation(pop):\n            gradients = (np.random.rand(pop.shape[0], self.dim) - 0.5) * 2\n            return gradients * (bounds[1] - bounds[0])\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Stochastic gradient-based neighborhood adaptation\n            perturbation = stochastic_gradient_perturbation(population)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 26, "feedback": "An exception occurred: TypeError(\"'tuple' object cannot be interpreted as an integer\").", "error": "TypeError(\"'tuple' object cannot be interpreted as an integer\")", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {}}
{"id": "8a37e3eb-9a4b-4dfc-aa8e-ee386b4e03d4", "fitness": 0.06622731500422743, "name": "AdaptiveOppositionSearchV3", "description": "Improved AdaptiveOppositionSearchV2 by introducing an adaptive Lévy exponent and dynamic population size adjustment for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        Lambda = 1.5\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                Lambda = 1.5 + 0.5 * (evals / self.budget)  # adaptive Lévy exponent\n                levy_step = levy_flight(Lambda)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 27, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06623 with standard deviation 0.06071.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1452185426021626, 0.14781670845496298, 0.14763199898094037, 0.049938673472467054, 0.049612687911083975, 0.054327223616430054, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "93cb3bdd-db3a-469b-af67-b48788f2b537", "fitness": 0.0645479885483807, "name": "DualPhaseAdaptiveSearch", "description": "DualPhaseAdaptiveSearch combines early-stage global exploration through Adaptive Opposition and Lévy Flights with late-stage local exploitation using Adaptive Neighborhood Search to optimize black box functions.", "code": "import numpy as np\n\nclass DualPhaseAdaptiveSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        exploration_phase_end = int(0.6 * self.budget)\n        \n        while evals < self.budget:\n            if evals < exploration_phase_end:\n                # Reflective opposition for exploration\n                reflect_pop = bounds[0] + bounds[1] - population\n                reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n                evals += pop_size\n                \n                # Combine and select\n                combined_population = np.vstack((population, reflect_pop))\n                combined_fitness = np.hstack((fitness, reflect_fitness))\n                sorted_indices = np.argsort(combined_fitness)\n                population = combined_population[sorted_indices][:pop_size]\n                fitness = combined_fitness[sorted_indices][:pop_size]\n                \n                if fitness[0] < best_fitness:\n                    best_solution = population[0]\n                    best_fitness = fitness[0]\n                \n                # Lévy flight for enhanced exploration\n                for i in range(pop_size):\n                    levy_step = levy_flight(1.5)\n                    child = population[i] + levy_step\n                    child = np.clip(child, bounds[0], bounds[1])\n                    child_fitness = func(child)\n                    evals += 1\n                    if child_fitness < fitness[i]:\n                        population[i] = child\n                        fitness[i] = child_fitness\n                        if child_fitness < best_fitness:\n                            best_solution = child\n                            best_fitness = child_fitness\n            else:\n                # Adaptive Neighborhood Search for exploitation\n                step_size = 0.05 * (bounds[1] - bounds[0]) * ((self.budget - evals) / (self.budget - exploration_phase_end))\n                perturbation = np.random.normal(0, step_size, population.shape)\n                population += perturbation\n                population = np.clip(population, bounds[0], bounds[1])\n                \n                # Evaluate the perturbed population\n                fitness = np.apply_along_axis(func, 1, population)\n                evals += pop_size\n                \n                best_idx = np.argmin(fitness)\n                if fitness[best_idx] < best_fitness:\n                    best_solution = population[best_idx]\n                    best_fitness = fitness[best_idx]\n\n        return best_solution", "configspace": "", "generation": 28, "feedback": "The algorithm DualPhaseAdaptiveSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06455 with standard deviation 0.05803.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.13770965088647824, 0.14207768439273094, 0.14293587811571473, 0.05449890741374097, 0.04691335328333668, 0.05529642284342495, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "33a18a9b-77f4-43c4-94cf-839bd53e8390", "fitness": 0.06737800486276327, "name": "AdaptiveOppositionSearchV2", "description": "AdaptiveOppositionSearch 2.1 with a refined step size strategy for local search intensification.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])  # Refined step size strategy\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 29, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06738 with standard deviation 0.05968.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14201874498430744, 0.15017491251895865, 0.14293587811571473, 0.055102908050029265, 0.048803248704256785, 0.06586635139160268, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5b0c132b-dc91-45f4-bc27-7b04c271f11a", "fitness": 0.06613656801209931, "name": "AdaptiveOppositionSearchV2_1", "description": "AdaptiveOppositionSearch 2.1 with enhanced diversity through individual step size adaptation based on fitness ranking.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2_1:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 30, "feedback": "The algorithm AdaptiveOppositionSearchV2_1 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06614 with standard deviation 0.06041.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1583343003340485, 0.13550557690566456, 0.14341988559755303, 0.05784550284937506, 0.04986653158637344, 0.04875731483587942, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "713c36cf-2eeb-432b-af80-3698e3a9ce59", "fitness": 0.06408715409943391, "name": "AdaptiveOppositionSearchV2", "description": "Introduce adaptive Lévy flight scaling based on current best fitness to enhance exploration-exploitation balance while maintaining most of the original structure.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda, scaling_factor):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = scaling_factor * (u / np.power(np.abs(v), 1/Lambda))\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            scaling_factor = (best_fitness + 1) # Adaptive scaling based on fitness\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5, scaling_factor)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06409 with standard deviation 0.05714.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.13629894504974494, 0.13709219171954246, 0.1436172583077946, 0.05466409661327243, 0.052011758117553986, 0.051600137086996956, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6fbc5482-ac10-4cf8-be9b-d85525d85b73", "fitness": 0.06737800486276327, "name": "AdaptiveOppositionSearchV2", "description": "Improved intensification by modifying step size calculation in local search for better convergence.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])  # Modified step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 32, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06738 with standard deviation 0.05968.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14201874498430744, 0.15017491251895865, 0.14293587811571473, 0.055102908050029265, 0.048803248704256785, 0.06586635139160268, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c3891235-ac28-457c-b1eb-71fdf059851d", "fitness": 0.06576998311058373, "name": "AdaptiveOppositionSearchV2", "description": "Improved AdaptiveOppositionSearchV2 using a variable Lévy flight exponent for diverse exploration.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.2 + 0.3 * np.random.rand())  # Slight change in the exponent\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 33, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06577 with standard deviation 0.05882.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.140091680708455, 0.14600965741730842, 0.14293587811571473, 0.05315619111735215, 0.05621338433313583, 0.05202305630328752, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "948178d8-7c60-437e-aacf-0adebe1d4aae", "fitness": 0.06497408688317179, "name": "EnhancedAdaptiveOppositionSearch", "description": "Enhanced Adaptive Opposition Search with adaptive neighborhood exploration, memory-based opposition strategy, and chaotic local search for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        memory = population.copy()\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n        \n        def chaotic_local_search(sol, chaos_factor):\n            perturbation = np.random.normal(0, chaos_factor, sol.shape)\n            new_sol = sol + perturbation\n            return np.clip(new_sol, bounds[0], bounds[1])\n\n        chaos_factor = 0.1 * (bounds[1] - bounds[0])\n\n        while evals < self.budget:\n            # Memory-based reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - memory\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive neighborhood exploration\n            step_size = chaos_factor / np.sqrt(1 + evals / float(self.budget))\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = chaotic_local_search(population[i] + levy_step, chaos_factor)\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            # Update memory\n            memory = population.copy()\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06497 with standard deviation 0.05864.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14262441319723906, 0.1415141032543088, 0.14293587811571473, 0.05396742396385468, 0.04896524848017558, 0.053259714937253344, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "11a945dc-642a-4e16-9310-465690abbf8d", "fitness": 0.06708234671542383, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 enhances convergence by incorporating differential evolution for diversity and a dynamic Lévy flight parameter to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evals = pop_size\n        \n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Differential Evolution for diversity\n            F = 0.5\n            CR = 0.9\n            for i in range(pop_size):\n                indices = [index for index in range(pop_size) if index != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), bounds[0], bounds[1])\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            # Dynamic Lévy flight parameter\n            Lambda = 1.5 + (3.0 - 1.5) * (best_fitness / np.mean(fitness))\n\n            for i in range(pop_size):\n                levy_step = levy_flight(Lambda)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 35, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06708 with standard deviation 0.06078.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14443691845213658, 0.14771591306187282, 0.15010923695851042, 0.05382255343837261, 0.05126064932361596, 0.054895849204306235, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "42e7a8ca-82e5-4aad-94cb-718c79b1d65f", "fitness": 0.06675073093809249, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 improves global and local search balance with elite archiving and adaptive Lévy flight scaling for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        elite_archive = []\n\n        def levy_flight(Lambda, scale=1.0):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return scale * step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n                \n            # Update elite archive and use it to guide the search\n            elite_archive.append(best_solution)\n            elite_archive = sorted(elite_archive, key=lambda x: func(x))[:5]  # Keep top 5 elites\n\n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Adaptive Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                scale = 0.1 + 0.9 * (1 - fitness[i] / (best_fitness + 1e-10))  # Scale based on fitness\n                levy_step = levy_flight(1.5, scale)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 36, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06675 with standard deviation 0.05907.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14577277084119222, 0.14240892517719828, 0.14293587811571473, 0.04718236097283057, 0.05949409305287956, 0.06146255028301717, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "1c6d9493-fa36-48a2-9fc4-2fa80d6af84d", "fitness": 0.06628253005208397, "name": "EnhancedDynamicOppositionSearch", "description": "Enhanced Dynamic Opposition Search using adaptive Lévy flight scaling and differential evolution-inspired mutation for robust global and local search balance.", "code": "import numpy as np\n\nclass EnhancedDynamicOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            scale = np.random.uniform(0.1, 1.0)  # Adaptive scaling factor\n            return scale * step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n\n            # Differential evolution-inspired mutation\n            F = 0.8  # Differential weight\n            for i in range(pop_size):\n                candidates = range(pop_size)\n                a, b, c = population[np.random.choice(candidates, 3, replace=False)]\n                mutant = np.clip(a + F * (b - c), bounds[0], bounds[1])\n                mutant_fitness = func(mutant)\n                evals += 1\n                if mutant_fitness < fitness[i]:\n                    population[i] = mutant\n                    fitness[i] = mutant_fitness\n                    if mutant_fitness < best_fitness:\n                        best_solution = mutant\n                        best_fitness = mutant_fitness\n\n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedDynamicOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06628 with standard deviation 0.05901.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.13558112875761674, 0.13964411260133547, 0.15409151668729038, 0.05151031644709092, 0.05090203184804043, 0.06331366412738193, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "fe7adb48-456e-4a55-aec8-b8990fbcde49", "fitness": 0.06366434534453713, "name": "AdaptiveOppositionSearchV2", "description": "Improved exploration by adjusting the dimensionality in Lévy flights.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step * np.random.randint(1, self.dim + 1)  # Change\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 38, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06366 with standard deviation 0.05777.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1405907091663372, 0.13655533459465907, 0.14294491997338377, 0.04673443854511017, 0.05365434843542294, 0.05099935738592121, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "44664642-c5c3-4063-a491-5066cb80c09f", "fitness": 0.0653610701777259, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 incorporates a multi-population strategy and adaptive mutation rates for improved global and local search balance.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        num_subpopulations = 3\n        subpop_sizes = [pop_size // num_subpopulations] * num_subpopulations\n        populations = [np.random.uniform(bounds[0], bounds[1], (size, self.dim)) for size in subpop_sizes]\n        fitness = [np.apply_along_axis(func, 1, pop) for pop in populations]\n        best_idx = np.argmin([f.min() for f in fitness])\n        best_solution = populations[best_idx][np.argmin(fitness[best_idx])]\n        best_fitness = fitness[best_idx].min()\n        evals = sum(subpop_sizes)\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            for idx in range(num_subpopulations):\n                # Reflective opposition\n                reflect_pop = bounds[0] + bounds[1] - populations[idx]\n                reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n                evals += subpop_sizes[idx]\n                \n                # Combine and select\n                combined_population = np.vstack((populations[idx], reflect_pop))\n                combined_fitness = np.hstack((fitness[idx], reflect_fitness))\n                sorted_indices = np.argsort(combined_fitness)\n                populations[idx] = combined_population[sorted_indices][:subpop_sizes[idx]]\n                fitness[idx] = combined_fitness[sorted_indices][:subpop_sizes[idx]]\n                \n                if fitness[idx][0] < best_fitness:\n                    best_solution = populations[idx][0]\n                    best_fitness = fitness[idx][0]\n                \n                # Dynamic mutation rate\n                mutation_rate = (1 - (evals / self.budget)) * 0.1\n                step_size = mutation_rate * (bounds[1] - bounds[0])\n                perturbation = np.random.normal(0, step_size, populations[idx].shape)\n                populations[idx] += perturbation\n                populations[idx] = np.clip(populations[idx], bounds[0], bounds[1])\n                \n                # Lévy flight for enhanced exploration\n                for i in range(subpop_sizes[idx]):\n                    levy_step = levy_flight(1.5)\n                    child = populations[idx][i] + levy_step\n                    child = np.clip(child, bounds[0], bounds[1])\n                    child_fitness = func(child)\n                    evals += 1\n                    if child_fitness < fitness[idx][i]:\n                        populations[idx][i] = child\n                        fitness[idx][i] = child_fitness\n                        if child_fitness < best_fitness:\n                            best_solution = child\n                            best_fitness = child_fitness\n                \n                if evals >= self.budget:\n                    break\n\n            if evals >= self.budget:\n                break\n            \n            # Evaluate all populations\n            for idx in range(num_subpopulations):\n                fitness[idx] = np.apply_along_axis(func, 1, populations[idx])\n                evals += subpop_sizes[idx]\n                \n                best_idx = np.argmin(fitness[idx])\n                if fitness[idx][best_idx] < best_fitness:\n                    best_solution = populations[idx][best_idx]\n                    best_fitness = fitness[idx][best_idx]\n\n        return best_solution", "configspace": "", "generation": 39, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06536 with standard deviation 0.05760.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.14037366753654457, 0.13673791987778894, 0.14408119124872842, 0.05280152788847359, 0.05594119021039545, 0.056814134837602226, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c4cef363-9411-4a0a-ba71-4ec3bc705963", "fitness": -Infinity, "name": "EnhancedAdaptiveOppositionSearch", "description": "EnhancedAdaptiveOppositionSearch with stochastic ranking and adaptive Lévy flight parameter for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        Lambda = 1.5\n        \n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select using stochastic ranking\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            ranks = np.argsort(np.argsort(combined_fitness))\n            rank_prob = np.random.uniform(0, 1, rank_prob.shape)\n            selection_criteria = rank_prob < 0.45  # Stochastic selection probability\n            selected_indices = np.argsort(combined_fitness + rank_prob)[:pop_size]\n            population = combined_population[selected_indices]\n            fitness = combined_fitness[selected_indices]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Adaptive Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                if np.random.rand() < 0.3:  # Adjust Lambda to balance exploration\n                    Lambda = 1.3 + np.random.rand()\n                levy_step = levy_flight(Lambda)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 40, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'rank_prob' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'rank_prob' referenced before assignment\")", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {}}
{"id": "d9eb3345-d6ab-478b-b8e9-3f419d45b326", "fitness": 0.07068855721206209, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 enhances local search with a self-adaptive Lévy flight parameter and dynamically adjusts population diversity based on fitness convergence.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        Lambda = 1.5  # Initial Lévy flight parameter\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive local search intensification\n            step_size = 0.1 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration with adaptive parameter\n            for i in range(pop_size):\n                levy_step = levy_flight(Lambda)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Check fitness convergence and adjust Lambda\n            fitness_std = np.std(fitness)\n            if fitness_std < 1e-5:  # Detect convergence\n                Lambda = min(2.0, Lambda + 0.1)  # Increase exploration\n            else:\n                Lambda = max(1.1, Lambda - 0.1)  # Enhance exploitation\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 41, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07069 with standard deviation 0.06561.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.1879938919016242, 0.13636729984637797, 0.14293587811571473, 0.05784550284937506, 0.05534121675252979, 0.054213225442937274, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6e29c4d4-12f3-49dc-a602-ba07e53575f4", "fitness": -Infinity, "name": "AdaptiveOppositionSearchV3", "description": "AOS V3 blends adaptive multilevel Gaussian perturbations with Lévy flights for enhanced exploration, balancing global exploration and local exploitation.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Multilevel Gaussian perturbations\n            step_size = np.linspace(0.05, 0.15, num=3) * (bounds[1] - bounds[0])\n            for size in step_size:\n                perturbation = np.random.normal(0, size, population.shape)\n                perturbed_population = population + perturbation\n                perturbed_population = np.clip(perturbed_population, bounds[0], bounds[1])\n                perturbed_fitness = np.apply_along_axis(func, 1, perturbed_population)\n                evals += pop_size\n                \n                improved_indices = perturbed_fitness < fitness\n                population[improved_indices] = perturbed_population[improved_indices]\n                fitness[improved_indices] = perturbed_fitness[improved_indices]\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 42, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (3,) (20,) ').", "error": "ValueError('operands could not be broadcast together with shapes (3,) (20,) ')", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {}}
{"id": "78636404-2341-44e4-8d69-8c296460eb69", "fitness": 0.0721498057861759, "name": "AdaptiveOppositionSearchV2", "description": "AdaptiveOppositionSearch 2.1 with enhanced exploration using Lévy flights and improved local search by dynamic scaling of step sizes.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])  # Changed from 0.1 to 0.05\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07215 with standard deviation 0.06675.", "error": "", "parent_ids": ["c977cc1f-d4f2-404b-b804-63d4f99f2ab2"], "operator": null, "metadata": {"aucs": [0.18496495329502116, 0.15017491251895865, 0.14293587811571473, 0.055102908050029265, 0.048803248704256785, 0.06586635139160268, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2821089b-a86f-4e14-af9a-c1b828322c16", "fitness": 0.06677365240964446, "name": "EnhancedOppositionSearch", "description": "EnhancedOppositionSearch leverages Chaotic Lévy Flights and Adaptive Scale Reduction to intensify search efficiency and solution refinement.", "code": "import numpy as np\n\nclass EnhancedOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return 0.01 * step  # Reduced scale for finer exploration\n\n        def chaotic_map(x):\n            return 4 * x * (1 - x)\n\n        chaos_param = np.random.rand()\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n\n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n\n            step_size = 0.02 * (bounds[1] - bounds[0])  # Further decreased step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            for i in range(pop_size):\n                chaos_param = chaotic_map(chaos_param)\n                levy_step = chaos_param * levy_flight(1.7)  # Chaotic Lévy flight\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n\n            if evals >= self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06677 with standard deviation 0.05933.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.14169271368275838, 0.14605144111707713, 0.14549841538996133, 0.05393457826559034, 0.05916158864940613, 0.05312413458200704, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c6a646cc-32ac-4911-a9aa-be6b93c3ff16", "fitness": 0.06518957437203747, "name": "EnhancedAdaptiveOppositionSearch", "description": "Enhanced AdaptiveOppositionSearch with stochastic ranking to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass EnhancedAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def stochastic_ranking(fitness, constraints, pf=0.45):\n            indices = np.arange(len(fitness))\n            np.random.shuffle(indices)\n            for i in range(len(indices) - 1):\n                for j in range(len(indices) - 1 - i):\n                    idx1, idx2 = indices[j], indices[j + 1]\n                    if (constraints[idx1] < constraints[idx2]) or (constraints[idx1] == constraints[idx2] and fitness[idx1] < fitness[idx2] and np.random.rand() < pf):\n                        indices[j], indices[j + 1] = indices[j + 1], indices[j]\n            return indices\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select using stochastic ranking\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            constraints = np.zeros(combined_fitness.shape)  # No constraints in this problem\n            sorted_indices = stochastic_ranking(combined_fitness, constraints)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06519 with standard deviation 0.05826.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.135994656170762, 0.1452342514777728, 0.1435697529302311, 0.054406325578526316, 0.050514534850536696, 0.05548664834050843, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "bf1f356a-9f6e-433e-bd8d-caa3d4a303b2", "fitness": 0.06418759394980769, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 with integrated adaptive mutation scaling and neighborhood exploration to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n\n            step_size = 0.01 + 0.1 * (1 - evals / self.budget) * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n\n            if evals >= self.budget:\n                break\n\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            neighborhood_explore = np.random.normal(0, 0.1 * (bounds[1] - bounds[0]), population.shape)\n            neighborhood_population = population + neighborhood_explore\n            neighborhood_population = np.clip(neighborhood_population, bounds[0], bounds[1])\n            neighborhood_fitness = np.apply_along_axis(func, 1, neighborhood_population)\n            evals += pop_size\n\n            combined_population = np.vstack((population, neighborhood_population))\n            combined_fitness = np.hstack((fitness, neighborhood_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 46, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06419 with standard deviation 0.05832.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.14613733691692887, 0.13444475187011717, 0.14320607066542101, 0.049299864079279665, 0.0524236418032481, 0.05067668021327454, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e9c59dbd-b931-4ca9-ba87-b6650c74b467", "fitness": 0.06600859850855618, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 with improved step size control and a slight increase in population diversity for better exploration.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.04 * (bounds[1] - bounds[0])  # Changed from 0.05 to 0.04\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 47, "feedback": "The algorithm AdaptiveOppositionSearchV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06601 with standard deviation 0.05911.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.13787951636977935, 0.14580490464304185, 0.1469348439295186, 0.049192747823025074, 0.0595357360600558, 0.05322963775158518, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "2b630d82-00be-4f3b-8a5d-84d174381bf9", "fitness": 0.0654374682633197, "name": "AdaptiveOppositionSearchV2", "description": "Enhanced convergence by adapting perturbation step size based on fitness improvement rate to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0]) * (1 if fitness[0] < best_fitness else 0.5)  # Changed step size adaptation based on fitness improvement\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 48, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06544 with standard deviation 0.05841.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.14118587209270195, 0.14210782386266507, 0.14293587811571473, 0.05035981774290166, 0.05742508469398078, 0.053422737861913316, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "e6bbe4c5-10d8-402a-b43d-d3d692c7d8c9", "fitness": 0.0654374682633197, "name": "AdaptiveOppositionSearchV2", "description": "Refined intensification step by adjusting perturbation scale for better local search.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.025 * (bounds[1] - bounds[0])  # Changed from 0.05 to 0.025\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 49, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06544 with standard deviation 0.05841.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.14118587209270195, 0.14210782386266507, 0.14293587811571473, 0.05035981774290166, 0.05742508469398078, 0.053422737861913316, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "f7ef503c-d9a8-4f5d-8ebd-c34cdae876ac", "fitness": 0.0661532743562761, "name": "AdaptiveOppositionSearchV2", "description": "AdaptiveOppositionSearch 2.2 enhances exploration by adjusting the Lévy flight exponent for varied exploration intensity.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])  # Changed from 0.1 to 0.05\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.3)  # Adjusted from 1.5 to 1.3\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 50, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06615 with standard deviation 0.05889.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.13666754663058533, 0.1498287366670883, 0.14293587811571473, 0.057698210612894485, 0.05119090834232343, 0.055558188837878886, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "a7fcc125-8b10-4ecb-918a-e2909a3f67d2", "fitness": 0.0678251896946574, "name": "AdaptiveOppositionSearchV2", "description": "Introduced dynamic adjustment of Lévy flight parameter for enhanced balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])  # Changed from 0.1 to 0.05\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            Lambda = 1.5 + 0.5 * (evals / self.budget)  # Dynamically adjusted\n            for i in range(pop_size):\n                levy_step = levy_flight(Lambda)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 51, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06783 with standard deviation 0.06207.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.15279656370658967, 0.14207775349589635, 0.15532577281684823, 0.0558223084608207, 0.04999882023546409, 0.05290548853629762, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7df4e48e-988a-4875-9890-c221b3c3ae3d", "fitness": 0.0661532743562761, "name": "AdaptiveOppositionSearchV2", "description": "Improved solution update by optimizing the Lévy flight parameter for enhanced exploration efficiency.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_fitness = np.apply_along_axis(func, 1, reflect_pop)\n            evals += pop_size\n            \n            # Combine and select\n            combined_population = np.vstack((population, reflect_pop))\n            combined_fitness = np.hstack((fitness, reflect_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])  # Changed from 0.1 to 0.05\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.3)  # Changed from 1.5 to 1.3\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n            \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 52, "feedback": "The algorithm AdaptiveOppositionSearchV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06615 with standard deviation 0.05889.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.13666754663058533, 0.1498287366670883, 0.14293587811571473, 0.057698210612894485, 0.05119090834232343, 0.055558188837878886, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "667a03b0-a738-4699-bce9-9b8bc9ac59dd", "fitness": -Infinity, "name": "AdaptiveOppositionSearchV3", "description": "AdaptiveOppositionSearchV3 with enhanced opposition-based learning and adaptive population resizing for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveOppositionSearchV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def opposition_based_learning(point, global_best, bounds):\n            return bounds[0] + bounds[1] - point + np.random.normal(0, 0.1 * (global_best - point))\n\n        while evals < self.budget:\n            # Enhanced opposition-based learning\n            opp_population = np.array([opposition_based_learning(ind, best_solution, bounds) for ind in population])\n            opp_fitness = np.apply_along_axis(func, 1, opp_population)\n            evals += pop_size\n\n            # Combine and select\n            combined_population = np.vstack((population, opp_population))\n            combined_fitness = np.hstack((fitness, opp_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic local search intensification\n            step_size = 0.05 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Lévy flight for enhanced exploration\n            for i in range(pop_size):\n                levy_step = levy_flight(1.5)\n                child = population[i] + levy_step\n                child = np.clip(child, bounds[0], bounds[1])\n                child_fitness = func(child)\n                evals += 1\n                if child_fitness < fitness[i]:\n                    population[i] = child\n                    fitness[i] = child_fitness\n                    if child_fitness < best_fitness:\n                        best_solution = child\n                        best_fitness = child_fitness\n\n            # Adaptive population resizing\n            if evals >= 0.5 * self.budget:\n                pop_size = max(10, pop_size // 2)\n                population = population[:pop_size]\n                fitness = fitness[:pop_size]\n                \n            if evals >= self.budget:\n                break\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 53, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {}}
{"id": "d117eec8-8391-409b-809e-50f1e09c6ce8", "fitness": 0.07223765900134413, "name": "HybridAdaptiveOppositionSearch", "description": "Hybrid AdaptiveOpposition Search integrating Cuckoo Search principles for enhanced global exploration and adaptive opposition for accelerated convergence.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.02 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 54, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07224 with standard deviation 0.06605.", "error": "", "parent_ids": ["78636404-2341-44e4-8d69-8c296460eb69"], "operator": null, "metadata": {"aucs": [0.1870481217252774, 0.1396691774922023, 0.14593519210236505, 0.05708827022446006, 0.06677920239129509, 0.052118967076497436, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5c08f164-2cba-4014-a64a-9cb6fbf59d6a", "fitness": 0.06690345504873152, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search incorporating dynamic population sizing and adaptive Levy flight tuning for improved exploitation and exploration balance.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        initial_pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (initial_pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = initial_pop_size\n        \n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n        \n        def adaptive_population_size(evals, max_evals, init_size):\n            return max(5, init_size - int((evals / max_evals) * init_size))\n        \n        while evals < self.budget:\n            current_pop_size = adaptive_population_size(evals, self.budget, initial_pop_size)\n            \n            reflect_pop = bounds[0] + bounds[1] - population\n            levy_exponent = 1.5 + 0.5 * (best_fitness / (best_fitness + np.std(fitness)))\n            new_pop = population + levy_flight(levy_exponent)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_pop = np.clip(eval_pop, bounds[0], bounds[1])\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            combined_population = np.vstack((population, eval_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:current_pop_size]\n            fitness = combined_fitness[sorted_indices][:current_pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.01 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += current_pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06690 with standard deviation 0.05840.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.13877270274275955, 0.1421197165378616, 0.1467439754075317, 0.05464405050379151, 0.05930483583427315, 0.05904581441236634, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "abc0896c-92da-47c7-879a-1a0d417c0078", "fitness": 0.06319848204706859, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search incorporating dynamic population size adjustment and variance-based perturbation for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.02 * (np.std(population, axis=0) + 1e-5)\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            pop_size = max(10, pop_size - 1) if evals < self.budget * 0.75 else min(50, pop_size + 1)\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06320 with standard deviation 0.05795.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.1386636986344867, 0.13848519894443423, 0.14350345172072165, 0.04987288257514677, 0.04829495590120392, 0.04846615064762416, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ce86cae0-416c-44e8-aea4-3053b032410b", "fitness": 0.06632970072642688, "name": "HybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search with refined step size calculation for improved local exploration.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.01 * (bounds[1] - bounds[0])  # Changed from 0.02 to 0.01\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 57, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06633 with standard deviation 0.05751.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.13494441722559902, 0.14104181729751564, 0.14537468756979033, 0.059219064254151244, 0.05404329737700453, 0.06084402281378132, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5f82f44b-5b95-4567-9ad3-5e2a6385ab5a", "fitness": 0.06511001322214965, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search with a dynamic Lévy flight exponent and diversity preservation to improve exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def dynamic_levy_flight(iteration, max_iters):\n            Lambda = 1.5 + 0.5 * (1 - iteration / max_iters)  # Dynamic adjustment\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        iteration = 0\n        max_iters = self.budget // pop_size\n\n        while evals < self.budget:\n            iteration += 1\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + dynamic_levy_flight(iteration, max_iters)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Diversity preservation through mutation\n            diversity_factor = 0.1 * (bounds[1] - bounds[0])\n            mutation = np.random.normal(0, diversity_factor, population.shape)\n            population += mutation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Evaluate the mutated population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06511 with standard deviation 0.05844.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.14419450130694422, 0.13856174842094338, 0.14293587811571473, 0.05877722317173739, 0.05175245728366984, 0.048268310700337436, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ab59dc82-2f43-46d6-8807-6cbbf0eb3eed", "fitness": 0.0639552004253728, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search leveraging adaptive step-size covariance matrix adaptation for improved convergence and robustness.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        C = np.eye(self.dim)\n        sigma = 0.3\n        \n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5).dot(C)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n\n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n\n            perturbation = np.random.multivariate_normal(np.zeros(self.dim), C * sigma, pop_size)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n\n            # Update covariance matrix using successful steps\n            successful_steps = perturbation[fitness < best_fitness]\n            if len(successful_steps) > 0:\n                mean_step = np.mean(successful_steps, axis=0)\n                C = (1 - 0.2) * C + 0.2 * np.outer(mean_step, mean_step)\n                sigma *= 0.9  # Decrease step size for finer search\n\n        return best_solution", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06396 with standard deviation 0.05708.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.1349424141382829, 0.13707207568137325, 0.14435570150765276, 0.05433036059588525, 0.05216085024475292, 0.0512354016604083, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "af23ef48-329f-4563-a7ae-1b662ca9e01f", "fitness": 0.06526248392199127, "name": "HybridAdaptiveOppositionSearch", "description": "Enhanced exploration by incorporating a mutation step in the reflective opposition phase.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy and mutation\n            reflect_pop = bounds[0] + bounds[1] - population\n            reflect_pop += np.random.normal(0, 0.1, reflect_pop.shape)  # Mutation step added\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.02 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 60, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06526 with standard deviation 0.05647.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.1338688814894219, 0.13627431002971935, 0.14362077544534357, 0.05746693369377054, 0.06165560349175769, 0.05297585114790859, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ee911e41-c71c-4ecb-995d-170ee174d922", "fitness": 0.06708688348493794, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Enhanced HybridAdaptiveOppositionSearch using dynamic population size and differential evolution crossover to improve exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def differential_evolution_crossover(target, mutant, cr=0.9):\n            cross_points = np.random.rand(self.dim) < cr\n            if not np.any(cross_points):\n                cross_points[np.random.randint(0, self.dim)] = True\n            trial = np.where(cross_points, mutant, target)\n            return trial\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            mutants = population + levy_flight(1.5)\n            new_pop = np.array([differential_evolution_crossover(population[i], mutants[i]) for i in range(pop_size)])\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n\n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n\n            step_size = 0.02 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06709 with standard deviation 0.05970.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.13273962703856557, 0.15614224622573336, 0.14544538524100337, 0.05610190197685028, 0.059334821039794816, 0.05251796984249424, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "84037352-2f58-4276-a04c-b55363471377", "fitness": 0.0656056090464792, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search incorporating Differential Evolution strategies for improved diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def differential_evolution_mutation(target_idx):\n            idxs = [idx for idx in range(pop_size) if idx != target_idx]\n            a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n            mutant = np.clip(a + 0.8 * (b - c), bounds[0], bounds[1])\n            return mutant\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search and Differential Evolution strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            de_pop = np.array([differential_evolution_mutation(i) for i in range(pop_size)])\n            eval_pop = np.vstack((reflect_pop, new_pop, de_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, eval_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.02 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06561 with standard deviation 0.05896.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.13415932026220612, 0.14038583359591617, 0.15391170128592913, 0.05410425288519016, 0.048600864918322606, 0.05778850847074879, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "5828bfea-6bdb-41b0-96ab-654a96a52d94", "fitness": 0.06570996923990122, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search introducing adaptive Levy flight scale and dynamic population adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        \n        while evals < self.budget:\n            Lambda = 1.5\n            levy_factor = np.random.uniform(0.5, 1.5)\n            \n            def levy_flight(Lambda, scale):\n                u = np.random.normal(0, 1, self.dim)\n                v = np.random.normal(0, 1, self.dim)\n                step = scale * (u / np.power(np.abs(v), 1/Lambda))\n                return step\n            \n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(Lambda, levy_factor)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.02 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            # Dynamic population adjustment\n            if evals < self.budget * 0.5:\n                pop_size = min(pop_size + 1, self.budget // 10)\n            elif evals > self.budget * 0.75:\n                pop_size = max(pop_size - 1, 10)\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06571 with standard deviation 0.05970.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.14027817469775916, 0.1506304607705775, 0.14293587811571473, 0.049184208381011785, 0.05572025920349022, 0.051140741990557737, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "39ace1c5-ad75-402a-b22c-bfb454be4fd6", "fitness": 0.07058543607673605, "name": "HybridAdaptiveOppositionSearch", "description": "Enhanced HybridAdaptiveOpposition Search with adaptive Levy flight exponent and dynamic population size adjustment for improved convergence.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        dynamic_Lambda = 1.5\n        \n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(dynamic_Lambda)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.02 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                dynamic_Lambda = 1 + np.random.rand()  # Line changed to adapt Lambda dynamically\n\n            if evals % (self.budget // 5) == 0:  # Line changed for dynamic pop_size adjustment\n                pop_size = min(pop_size + 5, self.budget // 5)  # Line changed for dynamic pop_size adjustment\n                \n        return best_solution", "configspace": "", "generation": 64, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07059 with standard deviation 0.06239.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.1663697374623042, 0.14070292614698143, 0.14608031009375688, 0.05663135692051824, 0.07088402974475605, 0.05310056432230781, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "667aebee-c9e7-48a8-870c-1982fc1784a1", "fitness": -Infinity, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Enhanced HybridAdaptiveOppositionSearch utilizes an adaptive multi-modal search approach combining dynamic population resizing and elite opposition-based learning for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with elite substitution\n            reflect_pop = bounds[0] + bounds[1] - population\n            elite_samples = population[np.argsort(fitness)[:pop_size // 5]]\n            reflect_pop[:len(elite_samples)] = elite_samples\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Dynamic population resizing\n            if evals < self.budget // 2:\n                pop_size = len(eval_pop) // 2\n            else:\n                pop_size = len(eval_pop) // 3\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.01 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 65, "feedback": "An exception occurred: IndexError('index 0 is out of bounds for axis 0 with size 0').", "error": "IndexError('index 0 is out of bounds for axis 0 with size 0')", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {}}
{"id": "d0f5a630-6871-4657-bb6a-2c4c0698541d", "fitness": 0.1302495610216323, "name": "HybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search with reinforced top-solutions retention and amplified local perturbation for improved convergence.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.03 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]  # Reinforce top solutions\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 66, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13025 with standard deviation 0.21255.", "error": "", "parent_ids": ["d117eec8-8391-409b-809e-50f1e09c6ce8"], "operator": null, "metadata": {"aucs": [0.7125877442515509, 0.13993510688173183, 0.14968292075325385, 0.059834067916968214, 0.052394156687414095, 0.05631205270377171, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "c836a9d3-b8e9-4dd3-b07d-badaf4fc3bcf", "fitness": 0.0654512144292648, "name": "QuantumTunnelingHybridSearch", "description": "Introducing Quantum-Tunneling Hybrid Search, which leverages quantum-inspired tunneling for escaping local optima and enhancing convergence in multimodal landscapes.", "code": "import numpy as np\n\nclass QuantumTunnelingHybridSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def quantum_tunneling(x, best):\n            tunneling_prob = np.random.rand(self.dim)\n            tunnel = np.where(tunneling_prob < 0.5, best - (best - x) * np.random.rand(self.dim), x)\n            return tunnel\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n\n            step_size = 0.03 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            population[:2] = combined_population[sorted_indices][:2]\n            \n            tunneling_population = np.array([quantum_tunneling(x, best_solution) for x in population])\n            tunneling_fitness = np.apply_along_axis(func, 1, tunneling_population)\n            evals += pop_size\n            \n            combined_population = np.vstack((population, tunneling_population))\n            combined_fitness = np.hstack((fitness, tunneling_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n\n        return best_solution", "configspace": "", "generation": 67, "feedback": "The algorithm QuantumTunnelingHybridSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06545 with standard deviation 0.05969.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.14250371225702352, 0.1473188312469753, 0.14395336168846007, 0.051051814998697154, 0.04939206280982078, 0.05334114686240654, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "0522e0cc-0db7-4f49-964e-51e94045b173", "fitness": 0.06567054659271722, "name": "HybridAdaptiveOppositionSearch", "description": "Minor adjustment to opposition-based reflection strategy to enhance exploration and convergence.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + 0.5 * (bounds[1] - population)  # Adjusted reflection\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.03 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]  # Reinforce top solutions\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 68, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06567 with standard deviation 0.05883.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.14349451345457342, 0.1424001511668478, 0.14293587811571473, 0.05013000613693064, 0.059547652396612305, 0.05102671806377623, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "1ffa5d52-31ab-4efd-92e0-3147af860182", "fitness": 0.06890864058623211, "name": "HybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search with an optimized levy flight for improved exploration.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step * 0.1  # Reduced factor to balance exploration\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.03 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]  # Reinforce top solutions\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 69, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06891 with standard deviation 0.05820.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.14387275236931496, 0.14051351098503617, 0.1437393737185928, 0.06631257242545519, 0.06142652269295634, 0.06281303308473374, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3c6f226b-9e97-4c5c-8b47-668a37e4dd6b", "fitness": 0.06550453558498955, "name": "HybridAdaptiveOppositionSearch", "description": "Introduced a decay factor to the step size adjustment for more refined local exploration over iterations.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            decay = 0.99  # Introduced decay factor\n            step_size = 0.03 * (bounds[1] - bounds[0]) * decay ** (evals // pop_size)  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]  # Reinforce top solutions\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 70, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06550 with standard deviation 0.05774.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.14152860823320423, 0.1368313389742778, 0.14363409151485051, 0.057883265518741345, 0.04957229875841718, 0.05859121726541505, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8a562074-f47a-47ec-83d0-ff3284c29413", "fitness": 0.0697625692916123, "name": "AdvancedReflectiveOpposition", "description": "Advanced Reflective Opposition with Dynamic Population Resizing and Adaptive Mutation Rates for Enhanced Global and Local Search Balance.", "code": "import numpy as np\n\nclass AdvancedReflectiveOpposition:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def adaptive_mutation(iter_count, max_iters):\n            return 0.01 + 0.5 * np.exp(-10 * iter_count / max_iters)\n\n        iter_count = 0\n        max_iters = self.budget // pop_size\n\n        while evals < self.budget:\n            # Reflective opposition combined with dynamic mutation\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5) * adaptive_mutation(iter_count, max_iters)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Dynamic population resizing\n            if iter_count % (max_iters // 5) == 0 and pop_size > 10:\n                pop_size = max(10, pop_size // 2)\n                population = population[:pop_size]\n                fitness = fitness[:pop_size]\n\n            # Adaptive step size for local search\n            step_size = adaptive_mutation(iter_count, max_iters) * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n            \n            iter_count += 1\n                \n        return best_solution", "configspace": "", "generation": 71, "feedback": "The algorithm AdvancedReflectiveOpposition got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06976 with standard deviation 0.05903.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.14078235411734874, 0.14999961800626582, 0.14320481470097024, 0.06510125478524098, 0.06424698182671196, 0.06302810018797311, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "83e844d8-6b86-435d-90af-322532887810", "fitness": 0.0666805639639455, "name": "HybridAdaptiveOppositionSearch", "description": "Advanced Hybrid AdaptiveOpposition Search with enhanced mutation and strategic solution reinforcement for superior convergence efficiency.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.05 * (bounds[1] - bounds[0])  # Slightly increased step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Strengthened retention of top solutions\n            population[:3] = combined_population[sorted_indices][:3]  # Keeping top 3 solutions\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 72, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06668 with standard deviation 0.06031.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.1488872819063578, 0.1429207484706987, 0.14681743633115008, 0.04675460439946144, 0.0583718404068716, 0.0548731641609701, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "6b21ecaf-4cc5-4a6c-b670-28b240a0e4ed", "fitness": 0.06818917959763807, "name": "MultiScaleAdaptiveOpposition", "description": "Multi-Scale Adaptive Opposition Algorithm with Dynamic Recombination and Contextual Memory to enhance convergence speed and solution precision.", "code": "import numpy as np\n\nclass MultiScaleAdaptiveOpposition:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n        memory = np.copy(population[:2])  # Initialize with top 2 solutions\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1 / Lambda)\n            return step\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n\n            # Dynamic recombination and contextual memory usage\n            if evals < self.budget // 2:\n                diversity_factor = 0.5\n            else:\n                diversity_factor = 1.0\n            memory_recombination = (memory + population[:2]) / 2\n            memory_recombination += np.random.normal(0, diversity_factor, memory_recombination.shape)\n\n            population[:2] = memory_recombination\n            memory = np.copy(population[:2])\n\n            step_size = 0.03 * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n\n        return best_solution", "configspace": "", "generation": 73, "feedback": "The algorithm MultiScaleAdaptiveOpposition got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06819 with standard deviation 0.06170.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.1517343780588628, 0.15372265870772095, 0.14293587811571473, 0.050689460057756985, 0.06202461825497163, 0.05109562318371563, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7ab2502b-ec0f-48bf-af2f-83c54bc2b616", "fitness": 0.06589304111149223, "name": "HybridAdaptiveOppositionSearch", "description": "Synergistic Adaptive Opposition Search with dynamic synergy amplification and stochastic elitism to bolster convergence efficacy.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Dynamic synergy amplification\n            synergy_factor = np.random.uniform(0.8, 1.2)\n            combined_population = np.vstack((population, reflect_pop, synergy_factor * new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.05 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Stochastic elitism for top solutions\n            if np.random.rand() < 0.5:\n                population[:2] = combined_population[sorted_indices][:2]\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 74, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06589 with standard deviation 0.05825.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.1348628446122353, 0.1419582640018443, 0.1484059339106525, 0.051872295331393925, 0.05463527343080521, 0.05980275871649898, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ad99dfdf-24cf-4b56-a2a6-8038820e8976", "fitness": 0.0679389325198448, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Optimized Hybrid AdaptiveOpposition Search with probabilistic dynamic topology selection and diversified perturbation mechanisms for superior exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition and probabilistic dynamic topology\n            reflect_pop = bounds[0] + bounds[1] - population\n            rand_pop = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n            new_pop = np.where(np.random.rand(pop_size, self.dim) < 0.5, population + levy_flight(1.5), rand_pop)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Diversified perturbation mechanism with adaptive step size\n            step_size = 0.02 * (bounds[1] - bounds[0])  # Reduced step size for precision\n            perturbation = (np.random.randn(*population.shape) * step_size) * np.random.choice([-1, 1], size=population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Retain top solutions with diversity enhancement\n            population[:2] = combined_population[sorted_indices][:2]\n            population[2:] += np.random.normal(0, step_size / 2, population[2:].shape)  # Further diversify\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06794 with standard deviation 0.06014.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.14696642971710283, 0.14904541321130238, 0.14293587811571473, 0.06261737626242037, 0.048914406901398366, 0.05947088847066473, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "7163701e-fba0-420d-b745-d3eed3008cc9", "fitness": 0.06799963018191531, "name": "AdvancedHybridAdaptiveOppositionSearch", "description": "Advanced Hybrid AdaptiveOpposition Search with dynamic exploration-exploitation balancing and breakthrough learning for superior convergence.", "code": "import numpy as np\n\nclass AdvancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def dynamic_exploration_exploitation_rate(evals):\n            return 0.5 + 0.5 * np.cos(np.pi * evals / self.budget)\n\n        while evals < self.budget:\n            exploration_rate = dynamic_exploration_exploitation_rate(evals)\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5) * exploration_rate\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.03 * (bounds[1] - bounds[0]) * exploration_rate\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            population[:2] = combined_population[sorted_indices][:2]\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n            breakthrough_learning_rate = 0.02\n            for i in range(1, pop_size):\n                if np.random.rand() < breakthrough_learning_rate:\n                    population[i] = population[0] + np.random.normal(0, step_size, self.dim)\n                    population[i] = np.clip(population[i], bounds[0], bounds[1])\n                    fitness[i] = func(population[i])\n                    evals += 1\n                    if fitness[i] < best_fitness:\n                        best_solution = population[i]\n                        best_fitness = fitness[i]\n\n        return best_solution", "configspace": "", "generation": 76, "feedback": "The algorithm AdvancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06800 with standard deviation 0.06059.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.1366988856790351, 0.14035124609618177, 0.1628429485136963, 0.051441945370004905, 0.0582726399570056, 0.06088900602131431, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "8b45a588-0d39-4ac0-8da0-fb1b01037d8c", "fitness": 0.06490575783831898, "name": "HybridAdaptiveOppositionSearch", "description": "Improved Hybrid AdaptiveOpposition Search with dynamic population size adjustment and refined local exploration strategy.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 20)  # Adjusted initial population size\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.02 * (bounds[1] - bounds[0])  # Reduced step size for finer local exploration\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            population[:3] = combined_population[sorted_indices][:3]  # Retain more top solutions\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 77, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06491 with standard deviation 0.05773.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.13709145665989242, 0.14147597863953854, 0.14293587811571473, 0.055694892773349935, 0.05370389026630262, 0.051749724090072724, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "0d9b259b-0da6-4b55-859a-6546dadc0177", "fitness": 0.0665156830733488, "name": "HybridAdaptiveOppositionSearch", "description": "The algorithm now includes an adaptive population size for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, max(10, self.budget // 20))  # Adaptive population size\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.03 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]  # Reinforce top solutions\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 78, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06652 with standard deviation 0.05867.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.13898284271699968, 0.13993510688173183, 0.14968292075325385, 0.059834067916968214, 0.052394156687414095, 0.05631205270377171, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "ecfa0ee2-4a3e-442f-94fd-00492313e053", "fitness": -Infinity, "name": "QuantumInspiredCoevolutionarySearch", "description": "\"Quantum-inspired Coevolutionary Search with dynamic dimensional adaptation and energy-based population refinement for enhanced convergence efficiency.\"", "code": "import numpy as np\n\nclass QuantumInspiredCoevolutionarySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def quantum_perturbation(qbit_size):\n            qbit = np.random.choice([0, 1], size=(qbit_size, self.dim))\n            perturbation = np.where(qbit == 1, np.random.normal(0, 0.02, (qbit_size, self.dim)), 0)\n            return perturbation\n\n        while evals < self.budget:\n            # Coevolutionary adaptation\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n\n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n\n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n\n            # Quantum-inspired perturbation\n            q_perturbation = quantum_perturbation(5)  # Dynamic dimensional adaptation\n            population += q_perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n\n            # Energy-based population refinement\n            energies = -fitness / np.max(fitness)\n            selection_prob = np.exp(energies) / np.sum(np.exp(energies))\n            selected_indices = np.random.choice(pop_size, pop_size, p=selection_prob)\n            population = population[selected_indices]\n\n            # Evaluate the refined population\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n\n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n\n        return best_solution", "configspace": "", "generation": 79, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (50,20) (5,20) (50,20) ').", "error": "ValueError('operands could not be broadcast together with shapes (50,20) (5,20) (50,20) ')", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {}}
{"id": "fe138eca-fdb3-4c6d-a2a8-c0162ecc15db", "fitness": 0.07164174428471291, "name": "HybridAdaptiveOppositionSearch", "description": "Improved Hybrid AdaptiveOpposition Search with stochastic rank-based selection enhancing exploration and diversity.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[np.random.choice(sorted_indices, pop_size, replace=False)]\n            fitness = np.apply_along_axis(func, 1, population)\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.03 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]  # Reinforce top solutions\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 80, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07164 with standard deviation 0.06969.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.199293494329016, 0.1464379529584644, 0.1447318946722148, 0.04886281445985807, 0.05344389540504413, 0.05050564673781899, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "46ec61be-3336-4ff5-9988-6fbb828542b9", "fitness": 0.06465195146659054, "name": "HybridAdaptiveOppositionSearch", "description": "Enhanced Hybrid AdaptiveOpposition Search with adaptive mutation scale based on convergence rate and dynamic population size adjustments for robust optimization.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        initial_pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (initial_pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = initial_pop_size\n        convergence_rate = np.inf\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:initial_pop_size]\n            fitness = combined_fitness[sorted_indices][:initial_pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n                new_convergence_rate = (convergence_rate + (fitness[0] - best_fitness)) / 2\n            else:\n                new_convergence_rate = convergence_rate\n            \n            # Adaptive mutation scale based on convergence rate\n            scaling_factor = max(0.03, min(0.1, convergence_rate / (new_convergence_rate + 1e-9)))\n            step_size = scaling_factor * (bounds[1] - bounds[0])\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Dynamic population size adjustment\n            if evals + population.shape[0] > self.budget:\n                population = population[:self.budget - evals]\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += population.shape[0]\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                convergence_rate = new_convergence_rate\n                \n        return best_solution", "configspace": "", "generation": 81, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06465 with standard deviation 0.05909.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.14279466051117828, 0.13856174842094338, 0.1475922167267667, 0.048892883854864566, 0.04794903982354215, 0.05457701386201996, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "3bee36e3-d8ae-4674-a79c-07292b805549", "fitness": 0.06607775026355715, "name": "HybridAdaptiveOppositionSearch", "description": "Improved HybridAdaptiveOppositionSearch with enhanced perturbation strategy using controlled Gaussian noise for better exploration.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.03 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size * 0.7, population.shape)  # Controlled Gaussian noise\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:2] = combined_population[sorted_indices][:2]  # Reinforce top solutions\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 82, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06608 with standard deviation 0.05969.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.1358856113862239, 0.15259549277052686, 0.14537561926984155, 0.05305664892374218, 0.05095014519325036, 0.05533623482842964, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "9e47c4df-dcd9-4823-9822-cff0a341873b", "fitness": 0.06544908238958334, "name": "MultiStrategicAdaptiveSearch", "description": "Multi-Strategic Adaptive Search combining Levy flights and reflective opposition with dynamic population resizing and enhanced local exploration for accelerated convergence.", "code": "import numpy as np\n\nclass MultiStrategicAdaptiveSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition and Levy flights\n            reflect_pop = bounds[0] + bounds[1] - population\n            levy_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, levy_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, levy_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.02 * (bounds[1] - bounds[0])  # Reduced step size for finer exploration\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Dynamic population resizing based on convergence\n            if evals > self.budget * 0.5:\n                pop_size = max(5, pop_size // 2)  # Reduce population size for intensified search\n            \n            # Retention and evaluation\n            population[:2] = combined_population[sorted_indices][:2]  # Reinforce top solutions\n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 83, "feedback": "The algorithm MultiStrategicAdaptiveSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06545 with standard deviation 0.05769.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.13579904725380232, 0.14010658673578869, 0.1458066957375478, 0.05418552533705967, 0.057940115637937106, 0.0537037708041147, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "718af49b-1afc-4c95-9e51-f8f40b4401e0", "fitness": 0.06587941860990582, "name": "EnhancedHybridAdaptiveOppositionSearch", "description": "Synergistic Exploration-Augmented Adaptive Search with dynamic opposition-based learning and improved adaptive perturbation strategies for superior global optimization.", "code": "import numpy as np\n\nclass EnhancedHybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(60, self.budget // 8)  # Increased population size\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.standard_cauchy(self.dim)  # Cauchy distribution for steps\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        def dynamic_opposition(x):\n            return bounds[0] + bounds[1] - x + np.random.uniform(-0.1, 0.1, self.dim)\n\n        while evals < self.budget:\n            reflect_pop = dynamic_opposition(population)\n            new_pop = population + levy_flight(1.8)  # Tweak Levy exponent\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            step_size = 0.05 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            population[:3] = combined_population[sorted_indices][:3]  # Enhance top solutions retention\n            \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedHybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06588 with standard deviation 0.05770.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.13748547902942332, 0.14193516872868572, 0.14293587811571473, 0.0590254428846565, 0.056363506794372076, 0.05366929193630021, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
{"id": "254aadfc-30c9-480b-897a-6e94e3348f21", "fitness": 0.06382909724506204, "name": "HybridAdaptiveOppositionSearch", "description": "Refined Adaptive Opposition Search with dual-layer top-solution retention for enhanced convergence.", "code": "import numpy as np\n\nclass HybridAdaptiveOppositionSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        \n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub])\n        pop_size = min(50, self.budget // 10)\n        population = np.random.uniform(bounds[0], bounds[1], (pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        best_fitness = fitness[best_idx]\n        evals = pop_size\n\n        def levy_flight(Lambda):\n            u = np.random.normal(0, 1, self.dim)\n            v = np.random.normal(0, 1, self.dim)\n            step = u / np.power(np.abs(v), 1/Lambda)\n            return step\n\n        while evals < self.budget:\n            # Reflective opposition with Cuckoo Search strategy\n            reflect_pop = bounds[0] + bounds[1] - population\n            new_pop = population + levy_flight(1.5)\n            eval_pop = np.vstack((reflect_pop, new_pop))\n            eval_fitness = np.apply_along_axis(func, 1, eval_pop)\n            evals += eval_pop.shape[0]\n            \n            # Combine, select and update best\n            combined_population = np.vstack((population, reflect_pop, new_pop))\n            combined_fitness = np.hstack((fitness, eval_fitness))\n            sorted_indices = np.argsort(combined_fitness)\n            population = combined_population[sorted_indices][:pop_size]\n            fitness = combined_fitness[sorted_indices][:pop_size]\n            \n            if fitness[0] < best_fitness:\n                best_solution = population[0]\n                best_fitness = fitness[0]\n            \n            # Adaptive step size adjustment for local search\n            step_size = 0.03 * (bounds[1] - bounds[0])  # Adjusted step size\n            perturbation = np.random.normal(0, step_size, population.shape)\n            population += perturbation\n            population = np.clip(population, bounds[0], bounds[1])\n            \n            # Ensure retention of top solutions\n            population[:3] = combined_population[sorted_indices][:3]  # Dual-layer top solutions retention\n            \n            # Evaluate the perturbed population \n            fitness = np.apply_along_axis(func, 1, population)\n            evals += pop_size\n            \n            best_idx = np.argmin(fitness)\n            if fitness[best_idx] < best_fitness:\n                best_solution = population[best_idx]\n                best_fitness = fitness[best_idx]\n                \n        return best_solution", "configspace": "", "generation": 85, "feedback": "The algorithm HybridAdaptiveOppositionSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06383 with standard deviation 0.05705.", "error": "", "parent_ids": ["d0f5a630-6871-4657-bb6a-2c4c0698541d"], "operator": null, "metadata": {"aucs": [0.13600495857388073, 0.13680752627440174, 0.14325746621751267, 0.05005166706358255, 0.055114364464384, 0.05172589261179683, 0.0004999999999999449, 0.0004999999999999449, 0.0004999999999999449]}}
