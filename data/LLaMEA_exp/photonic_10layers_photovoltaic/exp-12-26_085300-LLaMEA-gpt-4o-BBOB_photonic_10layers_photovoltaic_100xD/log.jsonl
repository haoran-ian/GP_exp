{"id": "42594836-8cca-4035-96b4-0d6e9c980af7", "fitness": -Infinity, "name": "HybridQuorumDifferentialEvolution", "description": "A hybrid metaheuristic combining differential evolution and quorum sensing-inspired communication for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 0, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 98, in evaluateBBOB\n    np.random.seed(rep)\n  File \"<string>\", line 42, in __call__\n  File \"<string>\", line 20, in mutate\nNameError: name 'bounds' is not defined\n.", "error": "NameError(\"name 'bounds' is not defined\")Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 98, in evaluateBBOB\n    np.random.seed(rep)\n  File \"<string>\", line 42, in __call__\n  File \"<string>\", line 20, in mutate\nNameError: name 'bounds' is not defined\n", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "e93dcc38-4488-410d-b802-8fa29fb8c69e", "fitness": -Infinity, "name": "EnhancedQuorumDifferentialEvolution", "description": "An enhanced differential evolution incorporating quorum sensing and adaptive mutation for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        adaptive_factor = self.mutation_factor * np.random.rand()\n        mutant_vector = np.clip(a + adaptive_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                noise = np.random.normal(0, 0.1, self.dim)\n                population[i] = np.clip(best_solution + noise, bounds.lb, bounds.ub)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        bounds = func.bounds\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 1, "feedback": "An exception occurred: NameError(\"name 'bounds' is not defined\").", "error": "NameError(\"name 'bounds' is not defined\")", "parent_ids": ["42594836-8cca-4035-96b4-0d6e9c980af7"], "operator": null, "metadata": {}}
{"id": "5df639e0-eec5-4212-a0fa-f19c3698c8c8", "fitness": 0.13883217000909898, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13883 with standard deviation 0.08394.", "error": "", "parent_ids": ["42594836-8cca-4035-96b4-0d6e9c980af7"], "operator": null, "metadata": {"aucs": [0.3495284701381547, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "5b37d340-c34d-47a3-8bc7-c8f1cb60e71a", "fitness": 0.1073002206013492, "name": "EnhancedQuorumDifferentialEvolution", "description": "Introduced adaptive learning rate scheduling and enhanced population diversity for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = max(0.1, self.quorum_threshold * (1 - progress))  # Adaptive quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                noise = np.random.normal(0, 0.1, self.dim)\n                population[i] = best_solution + noise * (fitness[i] - fitness[best_idx]) / np.mean(fitness)  # Diversity enhancement\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10730 with standard deviation 0.04428.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.04512160478431504, 0.0766055080276119, 0.047638231016787436, 0.15168626927444495, 0.16610614381970956, 0.16456214524525536, 0.12297687217586906, 0.1004940481715928, 0.0905111628965567]}}
{"id": "94c44ba4-b07c-44e1-a53a-bd48967de0a4", "fitness": 0.10091602594111554, "name": "AdaptiveOppositionDifferentialEvolution", "description": "Incorporating Adaptive Opposition-Based Learning with Improved Parameter Control to enhance convergence and diversity in Differential Evolution.", "code": "import numpy as np\n\nclass AdaptiveOppositionDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n    \n    def opposition_based_learning(self, bounds, population):\n        lb, ub = bounds.lb, bounds.ub\n        return lb + ub - population\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.2 + 0.2 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            opposition_population = self.opposition_based_learning(func.bounds, self.population)\n            opposition_fitness = np.array([func(ind) for ind in opposition_population])\n            evaluations += len(opposition_population)\n\n            for i in range(self.population_size):\n                if opposition_fitness[i] < fitness[i]:\n                    self.population[i] = opposition_population[i]\n                    fitness[i] = opposition_fitness[i]\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveOppositionDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10092 with standard deviation 0.04289.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06695482056043323, 0.04907724032287675, 0.053476991358285986, 0.15103985280744492, 0.16610614381970956, 0.15245772599629615, 0.10729727224703267, 0.09111287653364553, 0.07072130982431513]}}
{"id": "6a9f608c-f6c5-4b98-be9d-61ea3938d1cf", "fitness": 0.10592104234336239, "name": "EnhancedSwarmDifferentialEvolution", "description": "Enhanced Swarm-Inspired Differential Evolution with Stochastic Quorum Sensing, employing dynamic parameter adaptation and swarm-inspired cooperation for robust convergence.", "code": "import numpy as np\n\nclass EnhancedSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.swarm_influence_factor = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, best_idx, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        best_solution = population[best_idx]\n        influence = self.swarm_influence_factor * (best_solution - population[idx])\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c) + influence, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.swarm_influence_factor = 0.1 + 0.2 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold) or np.random.rand() < 0.1:\n                noise = np.random.normal(0, 0.1, self.dim)\n                population[i] = best_solution + noise\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            best_idx = np.argmin(fitness)\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, best_idx, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10592 with standard deviation 0.03993.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.0956555939716941, 0.05682953200984098, 0.05729323053178059, 0.15040147591305109, 0.16610614381970956, 0.1554551017964363, 0.10711354083270197, 0.09432954521887371, 0.07010521699617323]}}
{"id": "f7ae5d06-78fd-4d0f-8156-8e767052ba49", "fitness": 0.1091791425036818, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with both adaptive quorum sensing and a stochastic element added for diversity in case of stagnation.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            if np.allclose(fitness, fitness[0]):  # Check for stagnation\n                self.population += np.random.normal(0, 0.1, self.population.shape)  # Introduce diversity\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10918 with standard deviation 0.03982.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "d19cb897-f4a8-4555-b537-28e3a90daaaf", "fitness": 0.10757899370178409, "name": "EnhancedQuorumDifferentialEvolution", "description": "Refined Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating stochastic quorum threshold and adaptive Gaussian mutation for better exploration.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        # Adaptive Gaussian mutation for better exploration\n        noise = np.random.normal(0, 0.1, self.dim)\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c) + noise, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        # Stochastic quorum threshold for better adaptation\n        self.quorum_threshold = 0.2 + 0.1 * np.random.rand()\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10758 with standard deviation 0.03870.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08370332185887341, 0.07491651629537599, 0.041899346058090536, 0.1503720898352029, 0.1672515835554954, 0.15061605931594702, 0.10818380248854387, 0.09642102855248347, 0.09484719535604424]}}
{"id": "0669438e-db95-4188-b738-72ebed4644cd", "fitness": 0.1091791425036818, "name": "EnhancedQuorumDifferentialEvolution", "description": "EnhancedQuorumDifferentialEvolution with Adaptive Quorum and Targeted Restart Mechanism for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.restart_threshold = 0.1  # New: Threshold for restarts\n        self.population = None\n        self.best_fitness = float('inf')  # New: Track the global best fitness\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def targeted_restart(self, population, fitness, best_fitness, bounds):\n        # New: Restart mechanism to escape local optima\n        if np.min(fitness) > best_fitness * (1 + self.restart_threshold):\n            new_population = self.initialize_population(bounds)\n            new_fitness = np.array([func(ind) for ind in new_population])\n            return new_population, new_fitness\n        return population, fitness\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.population, fitness = self.targeted_restart(self.population, fitness, self.best_fitness, func.bounds)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10918 with standard deviation 0.03982.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "24aa05c8-fc54-4e40-850e-d7f8f1cd48f0", "fitness": 0.10433182938216584, "name": "SynergisticDifferentialEvolution", "description": "Synergistic Differential Evolution with Adaptive Thresholding (SDE-AT) - Enhances differential evolution through synergistic parameter adaptation and dynamic quorum thresholding for robust convergence.", "code": "import numpy as np\n\nclass SynergisticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations, fitness):\n        # Synergistic adaptation of mutation factor and crossover probability\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - np.tanh(progress))\n        self.crossover_probability = 0.9 - 0.5 * (1 - np.tanh(progress))\n\n        best_idx = np.argmin(fitness)\n        best_fitness = fitness[best_idx]\n\n        # Adaptive quorum threshold based on fitness diversity\n        diversity = np.std(fitness) / (best_fitness + 1e-8)\n        self.quorum_threshold = 0.1 + 0.15 * np.tanh(diversity)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations, fitness)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm SynergisticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10433 with standard deviation 0.04041.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.05850211804181671, 0.05200231392968835, 0.05965886911569929, 0.15148306722195093, 0.16610614381970956, 0.14552847402287583, 0.11026111023637153, 0.09749221327257429, 0.09795215477880614]}}
{"id": "b8e274b6-89b9-4eba-92ee-d815bc905494", "fitness": 0.1070830551764541, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning for improved convergence and enhanced quorum threshold adaptation.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n        self.quorum_threshold *= 0.95  # Decrease the quorum threshold over time\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10708 with standard deviation 0.04065.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08813517899615586, 0.05717341615395399, 0.04662990290513047, 0.15877798502287355, 0.16610614381970956, 0.15048421511142251, 0.10681583018448171, 0.09819331784698748, 0.09143150654737175]}}
{"id": "eaa27a04-45e5-43d3-bc9c-33be6f80dc91", "fitness": 0.10255988697021273, "name": "AnisotropicQuorumDifferentialEvolution", "description": "Adaptive Differential Evolution with Anisotropic Quorum Sensing, leveraging direction-sensitive updates and adaptive strategies for improved convergence in diverse optimization scenarios.", "code": "import numpy as np\n\nclass AnisotropicQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        direction_vector = np.random.uniform(-1, 1, self.dim)\n        direction_vector /= np.linalg.norm(direction_vector) + 1e-9\n        mutant_vector = a + self.mutation_factor * (b - c) * direction_vector\n        mutant_vector = np.clip(mutant_vector, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.2 * (1 - progress)\n    \n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        distance_measures = np.linalg.norm(population - best_solution, axis=1)\n        thresholds = np.median(distance_measures) * self.quorum_threshold\n        for i in range(self.population_size):\n            if distance_measures[i] > thresholds:\n                direction_vector = np.random.uniform(-1, 1, self.dim)\n                direction_vector /= np.linalg.norm(direction_vector) + 1e-9\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim) * direction_vector\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 11, "feedback": "The algorithm AnisotropicQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10256 with standard deviation 0.04761.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.041437979289613125, 0.054382464677197095, 0.03813455881042915, 0.15816441564118566, 0.16610614381970956, 0.15737299638808222, 0.10749595988669514, 0.10304622432809307, 0.09689823989090951]}}
{"id": "9a262dad-05a0-4c9a-974f-42fd5764df0f", "fitness": 0.09159651670689205, "name": "HybridQuorumDifferentialEvolution", "description": "Hybrid Quorum Differential Evolution with Dynamic Neighborhood, combines adaptive quorum sensing and neighborhood-based diversity to enhance exploration and convergence.", "code": "import numpy as np\n\nclass HybridQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.neighborhood_radius = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.neighborhood_radius = 0.1 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                local_best = self.find_local_best(population, fitness, i)\n                perturbation = np.random.normal(0, self.neighborhood_radius, self.dim)\n                population[i] = local_best + perturbation\n\n    def find_local_best(self, population, fitness, idx):\n        distances = np.linalg.norm(population - population[idx], axis=1)\n        neighborhood_indices = np.where(distances < self.neighborhood_radius)[0]\n        if len(neighborhood_indices) == 0:\n            return population[idx]\n        local_best_idx = neighborhood_indices[np.argmin(fitness[neighborhood_indices])]\n        return population[local_best_idx]\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm HybridQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09160 with standard deviation 0.05061.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.036880980563723575, 0.03305695467113412, 0.033713864711623964, 0.15412340520028478, 0.16695653652744868, 0.15011843561330596, 0.08918540906367067, 0.07940004781166177, 0.08093301619917492]}}
{"id": "83067aac-97d9-4720-b81f-99f235a322e5", "fitness": 0.09645232377794104, "name": "ImprovedAdaptiveQuorumDifferentialEvolution", "description": "Improved Adaptive Quorum Differential Evolution with Dynamic Scaling and Enhanced Inertia, integrating dynamic dimensional scaling and inertia-based selection for superior convergence.", "code": "import numpy as np\n\nclass ImprovedAdaptiveQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.inertia_weight = 0.7\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.inertia_weight = 0.7 + 0.3 * progress  # Increase inertia over time\n        self.dim_scale = 1 + progress * 0.5  # Gradual increase of dimensional scaling\n    \n    def inertia_based_selection(self, current, trial, fitness_current, fitness_trial):\n        if fitness_trial < fitness_current:\n            return trial, fitness_trial\n        else:\n            return (self.inertia_weight * current + (1 - self.inertia_weight) * trial), fitness_current\n    \n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                mutant_vector *= self.dim_scale  # Apply dimensional scaling\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                self.population[i], fitness[i] = self.inertia_based_selection(\n                    self.population[i], trial_vector, fitness[i], trial_fitness)\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm ImprovedAdaptiveQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09645 with standard deviation 0.04589.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.033222874990941786, 0.05308187858294722, 0.055470550451522826, 0.15220822500664155, 0.16610614381970956, 0.15165959972830723, 0.08594193586186327, 0.0816699616163441, 0.08870974394319175]}}
{"id": "18b0e40d-de9a-440b-8fff-5f7533cc8c0c", "fitness": 0.0898669370853686, "name": "AdaptiveQuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution integrates quantum-inspired representation and adaptive strategies to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.bounds = None\n\n    def initialize_population(self):\n        lb, ub = self.bounds.lb, self.bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.bounds.lb, self.bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = self.population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                self.population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def apply_quantum_inspiration(self):\n        for i in range(self.population_size):\n            r = np.random.rand(self.dim)\n            self.population[i] = np.where(r < 0.5, self.population[i], np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(fitness)\n            self.apply_quantum_inspiration()\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm AdaptiveQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08987 with standard deviation 0.05081.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.03271807059426213, 0.03518867509140566, 0.029308217551251348, 0.1508120326409691, 0.16713396610662468, 0.14613026731868672, 0.09593026618769707, 0.07940004781166177, 0.07218089046575893]}}
{"id": "7485feaa-7d75-42fd-9f39-7713d6c6877d", "fitness": 0.11265639821908942, "name": "EnhancedQuorumDifferentialEvolution", "description": "Optimized Enhanced Quorum Differential Evolution with Dynamic Population Strategy for Improved Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        if progress > 0.5:  # Adjust population size dynamically\n            self.population_size = max(5, int((1 - progress) * 10 * self.dim))\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11266 with standard deviation 0.03764.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.10331049285309402, 0.06365216650933059, 0.06322407241119266, 0.15610616420098833, 0.16673102570053655, 0.15975915361490234, 0.11225854786773715, 0.10221772935380602, 0.08664823146021727]}}
{"id": "32faf8d0-c6a8-46ce-877d-d45d5626db6c", "fitness": 0.111776869446568, "name": "EnhancedQuorumDifferentialEvolution", "description": "Improved Differential Evolution with Enhanced Adaptive Quorum Sensing and Dynamic Population Size Adjustment.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.population_size = int(10 * self.dim * (1 - 0.3 * progress))  # Dynamic population size\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11178 with standard deviation 0.03957.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.05835129000077466, 0.13212924164409579, 0.05758041098720068, 0.1503720898352029, 0.16726987379004277, 0.15517705972331197, 0.11047157767680016, 0.0981319779316826, 0.07650830343000037]}}
{"id": "d89e43f6-3c81-4be3-abbe-d57046ef7205", "fitness": 0.11094591021593803, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Progressive Population Resizing for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            # Progressive population resizing by reducing size after half budget\n            if evaluations > self.budget / 2:\n                self.population_size = max(4, int(self.population_size * 0.95))\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11095 with standard deviation 0.03884.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.09385021767602675, 0.057210913061354174, 0.06228971871365274, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.11208089688611766, 0.10221772935380602, 0.08889225461688466]}}
{"id": "c66eaba6-d437-4d19-8558-f9780d36ac83", "fitness": 0.11088542465709911, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Target-to-Best Crossover, incorporating dynamic parameter tuning for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant, best):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target + 0.5 * (best - target))\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            best_idx = np.argmin(fitness)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector, self.population[best_idx])\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11089 with standard deviation 0.03464.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.10196471764254855, 0.07713839419778512, 0.05986903325921844, 0.15275740378692448, 0.16610614381970956, 0.14604152832409312, 0.11263451377734601, 0.09864202062131733, 0.0828150664849493]}}
{"id": "c8cab84b-cb42-487e-a61b-9cd90c237cb5", "fitness": 0.1091791425036818, "name": "AdaptiveMultimodalDifferentialEvolution", "description": "Adaptive Multimodal Differential Evolution with Dynamic Niching, introducing niche preservation and adaptive parameter control for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveMultimodalDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.niche_radius = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def dynamic_niching(self, population, fitness):\n        niche_centers = []\n        niche_fitness = []\n        for i in range(self.population_size):\n            if all(np.linalg.norm(population[i] - np.array(nc)) > self.niche_radius for nc in niche_centers):\n                niche_centers.append(population[i])\n                niche_fitness.append(fitness[i])\n            else:\n                j = np.argmin([np.linalg.norm(population[i] - np.array(nc)) for nc in niche_centers])\n                if fitness[i] < niche_fitness[j]:\n                    niche_centers[j] = population[i]\n                    niche_fitness[j] = fitness[i]\n        return niche_centers, niche_fitness\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            niche_centers, niche_fitness = self.dynamic_niching(self.population, fitness)\n            for i in range(len(niche_centers)):\n                idxs = [j for j, ind in enumerate(self.population) if np.linalg.norm(ind - np.array(niche_centers[i])) <= self.niche_radius]\n                for idx in idxs:\n                    mutant_vector = self.mutate(idx, self.population, func.bounds)\n                    trial_vector = self.crossover(self.population[idx], mutant_vector)\n                    trial_fitness = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_fitness < fitness[idx]:\n                        self.population[idx] = trial_vector\n                        fitness[idx] = trial_fitness\n\n                    if evaluations >= self.budget:\n                        break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 19, "feedback": "The algorithm AdaptiveMultimodalDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10918 with standard deviation 0.03982.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "55e2c60e-2fce-478f-84c1-e149292038a2", "fitness": 0.10970613438721664, "name": "EnhancedQuorumDifferentialEvolution", "description": "Improved Enhanced Differential Evolution with Stochastic Quorum Sensing and Adaptive Scaling, boosting exploration and convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.3  # Modified line\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        scaling_factor = np.random.rand()  # Added line\n        mutant_vector = np.clip(a + scaling_factor * self.mutation_factor * (b - c), bounds.lb, bounds.ub)  # Modified line\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.2, self.dim)  # Modified line\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10971 with standard deviation 0.03584.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08838829380264657, 0.07088287846430752, 0.06260915614952534, 0.15886906985039273, 0.16610614381970956, 0.1457112760750383, 0.10135912531244673, 0.10296209351039864, 0.09046717250048442]}}
{"id": "baa412a5-8061-4660-9a1a-7ff1c5624257", "fitness": 0.11338461713821449, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Neighborhood Search for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def dynamic_neighborhood_search(self, population, fitness):\n        mean_fitness = np.mean(fitness)\n        for i in range(self.population_size):\n            neighbors = np.random.choice(self.population_size, 3, replace=False)\n            best_neighbor = min(neighbors, key=lambda x: fitness[x])\n            if fitness[i] > mean_fitness:\n                population[i] += 0.01 * (population[best_neighbor] - population[i])\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.dynamic_neighborhood_search(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11338 with standard deviation 0.03771.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06132097650824886, 0.07693335830134729, 0.08291009711611108, 0.1656574977549241, 0.16610614381970956, 0.1571514281158093, 0.11179272365664139, 0.0989889612849062, 0.0996003676862326]}}
{"id": "6a5f6e2c-9be9-4b52-9314-49f1787a4ed1", "fitness": 0.111564945984384, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution using Quorum Sensing and Adaptive Learning Rates, incorporating dynamic parameter tuning and learning rate adjustment for better convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.learning_rate = 0.05\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.learning_rate = 0.05 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                population[i] = best_solution + self.learning_rate * perturbation\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11156 with standard deviation 0.06014.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.07209975251378731, 0.04616947420506934, 0.04777338085588323, 0.18851105686165803, 0.18324781826494752, 0.20780180882402743, 0.09839046963967579, 0.08903965224616806, 0.07105110044823937]}}
{"id": "0d27061c-e9ca-4ea7-8619-76674f1d9297", "fitness": 0.1091791425036818, "name": "OpportunisticDifferentialEvolution", "description": "Opportunistic Differential Evolution with Adaptive Quorum and Dynamic Archive Leverage, enhancing exploration-exploitation balance via historical data.", "code": "import numpy as np\n\nclass OpportunisticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.archive = []\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def leverage_archive(self, idx, func_val, candidate):\n        if len(self.archive) > 0 and func_val > np.mean([entry[1] for entry in self.archive]):\n            self.archive.append((candidate, func_val))\n            self.archive = sorted(self.archive, key=lambda x: x[1])[:self.population_size]\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n        self.archive = [(ind, fit) for ind, fit in zip(self.population, fitness)]\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                self.leverage_archive(i, trial_fitness, trial_vector)\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm OpportunisticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10918 with standard deviation 0.03982.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "ac1d8002-6f46-4045-b7d0-97d802f89ba5", "fitness": 0.09710525281485098, "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Quorum-Sensing and Self-Adaptive Strategies, integrating restart mechanisms for enhanced global exploration and convergence.", "code": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.restarts = 3\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def restart(self, func, bounds):\n        new_population = self.initialize_population(bounds)\n        new_fitness = np.array([func(ind) for ind in new_population])\n        return new_population, new_fitness\n\n    def __call__(self, func):\n        for _ in range(self.restarts):\n            self.population = self.initialize_population(func.bounds)\n            fitness = np.array([func(ind) for ind in self.population])\n            evaluations = self.population_size\n\n            while evaluations < self.budget / self.restarts:\n                self.adapt_parameters(evaluations)\n                for i in range(self.population_size):\n                    mutant_vector = self.mutate(i, self.population, func.bounds)\n                    trial_vector = self.crossover(self.population[i], mutant_vector)\n                    trial_fitness = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_fitness < fitness[i]:\n                        self.population[i] = trial_vector\n                        fitness[i] = trial_fitness\n\n                    if evaluations >= self.budget / self.restarts:\n                        break\n\n                self.quorum_sensing(self.population, fitness)\n\n            best_idx = np.argmin(fitness)\n            if _ == 0 or fitness[best_idx] < best_fitness:\n                best_solution = self.population[best_idx]\n                best_fitness = fitness[best_idx]\n\n            self.population, fitness = self.restart(func, func.bounds)\n\n        return best_solution", "configspace": "", "generation": 24, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09711 with standard deviation 0.04656.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.05066139634855582, 0.049423515920279604, 0.02982294936601093, 0.15199869330811833, 0.16610614381970956, 0.14395852726556446, 0.11007475292849134, 0.09516604899065861, 0.07673524738627013]}}
{"id": "03ce8e48-4ec1-4945-b749-00bee922cf62", "fitness": 0.09065444246481129, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Fitness Sharing and Quorum Refinement, leveraging dynamic parameters and fitness diversity control for robust optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_refinement(self, population, fitness):\n        # Encourage diversity and avoid premature convergence\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                perturbation = np.random.normal(0, 0.1, self.dim) * (fitness[i] - fitness[best_idx])\n                population[i] = best_solution + perturbation\n\n    def fitness_sharing(self, fitness):\n        # Apply fitness sharing to encourage diversity\n        niche_radius = np.std(fitness) * 0.1\n        for i in range(len(fitness)):\n            shared_fitness = 0\n            count = 0\n            for j in range(len(fitness)):\n                distance = np.linalg.norm(fitness[i] - fitness[j])\n                if distance < niche_radius:\n                    shared_fitness += fitness[j]\n                    count += 1\n            fitness[i] = shared_fitness / count if count > 0 else fitness[i]\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.fitness_sharing(fitness)\n            self.quorum_refinement(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09065 with standard deviation 0.05395.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.03604614365484804, 0.032747583144943415, 0.032500058002971066, 0.15746935746377633, 0.16610614381970956, 0.16377699606685292, 0.08594193586186327, 0.07940004781166177, 0.061901716356675185]}}
{"id": "40845d88-9010-4a77-b00e-044dcf0e354b", "fitness": 0.1156994426914868, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Lvy Flights for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        # Introduce Lvy flight for mutation step\n        step = self.levy_flight()\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c) + step, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def levy_flight(self):\n        beta = 1.5\n        sigma_u = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                  (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma_u, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return 0.01 * step  # Control step size\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11570 with standard deviation 0.03283.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.09286459856273643, 0.07868262670764337, 0.08534040347718119, 0.16586555644518652, 0.16610614381970956, 0.14984631552274674, 0.10243931872503187, 0.09955083567507439, 0.1005991852880711]}}
{"id": "cd619a28-2adf-403f-a3e7-3132cd587c45", "fitness": 0.10427757200560148, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning and noise reduction for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.05, self.dim)  # Reduced noise\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10428 with standard deviation 0.03984.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08096410115619712, 0.052565087828726376, 0.05324023625062679, 0.1503720898352029, 0.16610614381970956, 0.1472306782420174, 0.10887880577234033, 0.09995726687968065, 0.07918373826591218]}}
{"id": "80a849bd-6ff9-41ce-85de-39b428da106e", "fitness": 0.10743937536005939, "name": "EnhancedQuorumDifferentialEvolution", "description": "Improved Enhanced Quorum Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning and an elite preservation mechanism for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.elite_rate = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def elite_preservation(self, population, fitness):\n        elite_count = int(self.elite_rate * self.population_size)\n        elite_indices = np.argsort(fitness)[:elite_count]\n        population[:elite_count] = population[elite_indices]\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.elite_preservation(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10744 with standard deviation 0.04079.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.09961572449654055, 0.05903336217017585, 0.03840021988634468, 0.15983288554962027, 0.16623474803764005, 0.14402216730960837, 0.10574219133544727, 0.09237908935073902, 0.10169399010441849]}}
{"id": "a8b2097d-c5fd-4e28-9ab9-0fd3a52a5494", "fitness": 0.09206425706202753, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Cluster-based Quorum Sensing and Improved Adaptation Mechanism for Effective Convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.8 - 0.3 * (1 - progress)  # Changed from 0.9 - 0.5\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        thresholded_indices = [i for i in range(self.population_size) \n                               if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold)]\n        if len(thresholded_indices) > 0:\n            cluster_mean = np.mean(population[thresholded_indices], axis=0)\n            for i in thresholded_indices:\n                population[i] = cluster_mean + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09206 with standard deviation 0.04757.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.03534144360467306, 0.043855173244798706, 0.04732718331359931, 0.1503720898352029, 0.16610614381970956, 0.14945520003351953, 0.08594193586186327, 0.07940004781166177, 0.07077909603321964]}}
{"id": "2e276419-76f4-47cb-9b9f-3cc5cd40e586", "fitness": 0.1069500991436169, "name": "QuantumEnhancedDifferentialEvolution", "description": "Quantum-Inspired Enhanced Differential Evolution, integrating quantum superposition principles and adaptive parameter control for superior global exploration and convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.quantum_population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim)) + \\\n               np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))  # small quantum perturbation\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def quantum_superposition(self, population):\n        return population + np.random.uniform(-0.05, 0.05, population.shape)  # subtle quantum superposition effect\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        self.quantum_population = self.quantum_initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.population = self.quantum_superposition(self.population)\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10695 with standard deviation 0.04506.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06908234627863097, 0.05504894845293817, 0.045690502863624194, 0.1503720898352029, 0.17781551702287346, 0.16395806427251924, 0.10436604045429065, 0.10423733855524175, 0.09198004455723074]}}
{"id": "9eb4cd6e-86b9-4fd4-a8db-048cfa9df87d", "fitness": 0.1080051391495645, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing using dynamic quorum threshold adjustment for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.2 * (1 - progress)  # Dynamic quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10801 with standard deviation 0.03636.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06639437392555103, 0.0740804044782668, 0.0655199155506716, 0.15193538256849048, 0.16610614381970956, 0.14835192067724734, 0.10692595968645957, 0.0949958402403841, 0.09773631139929995]}}
{"id": "88119daf-011a-4c67-9052-ca9960faf48e", "fitness": 0.09534747423809468, "name": "QuantumEnhancedQuorumDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Quorum Sensing, integrating quantum superposition for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def quantum_superposition(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        quantum_population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        return (population + quantum_population) / 2\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.population = self.quantum_superposition(self.population, func.bounds)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm QuantumEnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09535 with standard deviation 0.04542.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.052450117715712175, 0.0492932219769463, 0.050405660408688435, 0.1527311908609531, 0.16610614381970956, 0.15250432362080246, 0.08594193586186327, 0.07940004781166177, 0.06929462606651504]}}
{"id": "1d9877d8-4222-4d79-97ae-9f66f6d97b18", "fitness": 0.10101739197856281, "name": "AdaptiveQuorumDifferentialEvolution", "description": "Adaptive Quorum Differential Evolution with Memory-Based Learning, leveraging historical mutations to refine search strategy and enhance convergence efficiency.", "code": "import numpy as np\n\nclass AdaptiveQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.mutation_memory = []\n        self.memory_size = 5\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        perturbation = self.mutation_factor * (b - c)\n        mutant_vector = np.clip(a + perturbation, bounds.lb, bounds.ub)\n        \n        # Update mutation memory\n        if len(self.mutation_memory) >= self.memory_size:\n            self.mutation_memory.pop(0)\n        self.mutation_memory.append(perturbation)\n\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n    \n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                noise = np.mean(self.mutation_memory, axis=0) if self.mutation_memory else np.random.normal(0, 0.1, self.dim)\n                population[i] = best_solution + noise\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 33, "feedback": "The algorithm AdaptiveQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10102 with standard deviation 0.04154.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08065422093288843, 0.05642441391900066, 0.03761459105986731, 0.1503720898352029, 0.16610614381970956, 0.14543068933986436, 0.10078939173246904, 0.08529129762327115, 0.08647368954479195]}}
{"id": "c7201089-d532-4046-b622-3481e376a539", "fitness": 0.10708475806313913, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning and stochastic local perturbation for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n            # Apply a stochastic local perturbation to the best solution\n            best_idx = np.argmin(fitness)\n            self.population[best_idx] += np.random.normal(0, 0.01, self.dim) * (1 - evaluations / self.budget)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10708 with standard deviation 0.04152.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08740659479540447, 0.05419248273693067, 0.05084220919694549, 0.15655360420521103, 0.17551385183942714, 0.14513488454088086, 0.11312943903162553, 0.0916319053255823, 0.0893578508962447]}}
{"id": "b656de3d-0a68-48dd-8122-f367f00f72f0", "fitness": 0.10754663757039427, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and improved boundary handling for better exploration.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)  # Added boundary handling\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10755 with standard deviation 0.03928.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15383337060448365, 0.1102993434523164, 0.09476185300352202, 0.08598665078035772]}}
{"id": "1df4f010-5403-4b50-98e0-727338142bb9", "fitness": 0.09861270982294618, "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Enhanced Quorum and Elite Archiving, integrating adaptive scaling, elite retention, and dynamic quorum sensing for robust convergence.", "code": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.elite_archive = []\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * np.tanh(1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * np.tanh(1 - progress)\n        self.quorum_threshold = 0.2 + 0.1 * np.tanh(progress)\n\n    def elite_archiving(self, population, fitness):\n        # Retain the top 5% best solutions in elite archive\n        elite_size = max(1, int(0.05 * self.population_size))\n        elite_indices = np.argsort(fitness)[:elite_size]\n        self.elite_archive.extend(population[elite_indices])\n        self.elite_archive = self.elite_archive[:elite_size]\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                # Mix with an elite solution to encourage exploration\n                elite_mate = self.elite_archive[np.random.randint(len(self.elite_archive))]\n                population[i] = (best_solution + elite_mate) / 2 + np.random.normal(0, 0.05, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            self.elite_archiving(self.population, fitness)\n\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09861 with standard deviation 0.04473.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.060804945423070356, 0.07027184339110704, 0.039200579589393825, 0.15493103855882384, 0.16610614381970956, 0.156218745274879, 0.0892357573822089, 0.07940004781166177, 0.07134528715566124]}}
{"id": "07ba43ff-5242-46e5-bcaa-c518a250411c", "fitness": 0.1091791425036818, "name": "MultiStrategyQuorumDifferentialEvolution", "description": "Multi-strategy Differential Evolution using Adaptive Quorum Sensing and Diversity Preservation for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass MultiStrategyQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.diversity_threshold = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def preserve_diversity(self, population, fitness):\n        mean_fitness = np.mean(fitness)\n        std_deviation = np.std(fitness)\n\n        if std_deviation < self.diversity_threshold:\n            diversity_indices = np.argsort(fitness)[-int(self.population_size * 0.1):]\n            worst_solutions = population[diversity_indices]\n            new_solutions = self.initialize_population(bounds)\n            population[diversity_indices] = new_solutions[:len(diversity_indices)]\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.preserve_diversity(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm MultiStrategyQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10918 with standard deviation 0.03982.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "5407f4ba-f56c-47f9-81e6-a6ed561985b5", "fitness": 0.12159444095081066, "name": "EnhancedQuorumDifferentialEvolution", "description": "Improved Differential Evolution with Adaptive Quorum Sensing and Dynamic Population Resizing for Enhanced Convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        # Dynamic population resizing\n        self.population_size = max(5, int(10 * self.dim * (1 - progress)))\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12159 with standard deviation 0.04689.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.10954373919169313, 0.07100188931347107, 0.0395018622050739, 0.16896894199169066, 0.16610614381970956, 0.19853543905571258, 0.11416948241229774, 0.11217864349727014, 0.11434382707037705]}}
{"id": "542d8a58-7a53-4180-a56e-920aa9ff4577", "fitness": 0.10819291420517514, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, improved by fine-tuning the mutation factor's lower bound for better exploration.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.7 + 0.3 * (1 - progress)  # Changed line\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10819 with standard deviation 0.03910.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.07877792111176407, 0.05684895919957744, 0.07232125894390529, 0.15347026245640494, 0.16610614381970956, 0.16122475746852882, 0.10482493665684234, 0.09657297612356974, 0.08358901206627412]}}
{"id": "b71b1918-8cce-4698-be94-eb18c5afbcba", "fitness": 0.09484920899907327, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Fitness Aggregation for improved convergence", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            fitness -= fitness.min()  # Dynamic Fitness Aggregation\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09485 with standard deviation 0.05107.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.040824112015897196, 0.031906027804466386, 0.027563230333634947, 0.1553086468589051, 0.16610614381970956, 0.1502020581605067, 0.10623989836167225, 0.09213326463189597, 0.0833594990049713]}}
{"id": "e7e6e31f-2922-4086-b657-4d506db2150a", "fitness": -Infinity, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, integrating dynamic Gaussian mutation for improved exploration.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        # Implementing dynamic Gaussian mutation\n        noise = np.random.normal(0, 0.1 * (1 - evaluations/self.budget), self.dim)\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c) + noise, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 41, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {}}
{"id": "22402812-0010-42da-818e-3d651344fdc1", "fitness": 0.11597813887249148, "name": "EnhancedQuorumDifferentialEvolution", "description": "Introduced adaptive quorum threshold to improve dynamic adjustments during optimization.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.2 + 0.2 * progress  # Adaptive quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11598 with standard deviation 0.04099.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.16935764579720847, 0.05480045782180498, 0.062114909766526005, 0.1514102312983927, 0.16610614381970956, 0.14505006933874487, 0.10544709301873811, 0.0962645623797761, 0.09325213661152254]}}
{"id": "3178dc0d-1d81-44a4-be6a-7bb939a0f412", "fitness": 0.11172706064883142, "name": "ImprovedQuorumDifferentialEvolution", "description": "ImprovedQuorumDifferentialEvolution with dynamic subgroup adaptation and elite migration to enhance convergence speed and robustness.", "code": "import numpy as np\n\nclass ImprovedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.subgroup_size = self.population_size // 2\n        self.elite_size = max(1, self.population_size // 10)\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def elite_migration(self, population, fitness):\n        sorted_indices = np.argsort(fitness)\n        elites = population[sorted_indices[:self.elite_size]]\n        for i in range(self.subgroup_size, self.population_size):\n            population[i] = elites[i % self.elite_size]\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.elite_migration(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 43, "feedback": "The algorithm ImprovedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11173 with standard deviation 0.03705.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.07309002798417841, 0.0953691686482625, 0.060264871538856735, 0.15115995225681655, 0.17172937172436875, 0.1544758407370792, 0.11666775302721788, 0.09883847024702264, 0.08394808967568024]}}
{"id": "3703dba6-ce9d-48ab-a310-e4d91511fe1e", "fitness": 0.11343719882072273, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning for improved convergence and a refined mutation strategy.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        base_vector = a if np.random.rand() < 0.5 else b  # Added a condition to select base vector\n        mutant_vector = np.clip(base_vector + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11344 with standard deviation 0.03461.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.09694364947249123, 0.05688460085784741, 0.08070335402823792, 0.1566015723977423, 0.16610614381970956, 0.14978575439415198, 0.10985685557938685, 0.10425541220104895, 0.09979744663588841]}}
{"id": "effbd26c-51f0-4575-ba13-08cc04db3419", "fitness": 0.0981798748750888, "name": "EnhancedQuorumDifferentialEvolutionWithLocalSearch", "description": "Enhanced Quorum DE with Randomized Local Search boosts convergence by integrating stochastic local search after quorum sensing.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolutionWithLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.local_search_iterations = 5\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def local_search(self, candidate, func, bounds):\n        best_candidate = candidate.copy()\n        best_fitness = func(best_candidate)\n        for _ in range(self.local_search_iterations):\n            perturbation = np.random.normal(0, 0.05, self.dim)\n            new_candidate = np.clip(best_candidate + perturbation, bounds.lb, bounds.ub)\n            new_fitness = func(new_candidate)\n            if new_fitness < best_fitness:\n                best_candidate = new_candidate\n                best_fitness = new_fitness\n        return best_candidate, best_fitness\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n            # Apply local search to each individual\n            for i in range(self.population_size):\n                local_candidate, local_fitness = self.local_search(self.population[i], func, func.bounds)\n                if local_fitness < fitness[i]:\n                    self.population[i] = local_candidate\n                    fitness[i] = local_fitness\n                evaluations += self.local_search_iterations\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedQuorumDifferentialEvolutionWithLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09818 with standard deviation 0.05228.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.04021155347005201, 0.03640668234457611, 0.027110166274767145, 0.15644147243841955, 0.16610614381970956, 0.1630439732966258, 0.1082351197053778, 0.09223904243837089, 0.09382472008790033]}}
{"id": "32ecab40-20e1-436a-b130-0ad0ed57a5f3", "fitness": 0.09356611768728257, "name": "EnhancedClusteringDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Population Clustering, utilizing adaptive parameter control and dynamic clustering to improve search efficiency and convergence.", "code": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass EnhancedClusteringDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.cluster_count = max(2, dim // 2)\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def dynamic_clustering(self, population, fitness):\n        kmeans = KMeans(n_clusters=self.cluster_count).fit(population)\n        cluster_labels = kmeans.labels_\n        cluster_centers = kmeans.cluster_centers_\n\n        for cluster in range(self.cluster_count):\n            cluster_indices = np.where(cluster_labels == cluster)[0]\n            if len(cluster_indices) < 2:\n                continue\n\n            cluster_fitness = fitness[cluster_indices]\n            best_idx = cluster_indices[np.argmin(cluster_fitness)]\n            best_solution = population[best_idx]\n\n            for idx in cluster_indices:\n                if fitness[idx] > fitness[best_idx] * (1 + self.quorum_threshold):\n                    population[idx] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.dynamic_clustering(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedClusteringDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09357 with standard deviation 0.04698.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.03948865547786906, 0.04428042120926701, 0.04273853190964527, 0.1510976166898519, 0.16610614381970956, 0.14711521594746546, 0.09064758168254028, 0.08836764826477905, 0.07225324418441559]}}
{"id": "56aee506-fde8-403f-a242-6abaf9ffa635", "fitness": 0.1094019340836811, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and improved mutation strategy for robust exploration.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c, d = population[np.random.choice(indices, 4, replace=False)]  # Change: using four vectors\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c + d - b), bounds.lb, bounds.ub)  # Change: modified mutation strategy\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10940 with standard deviation 0.04007.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06325154479566719, 0.08886818614970848, 0.042960817133927964, 0.15223972509384465, 0.16610614381970956, 0.15652182333076825, 0.11435312710780043, 0.1030042878770211, 0.09731175144468218]}}
{"id": "45c2190a-b525-49f8-a0f2-1b938b7329b4", "fitness": 0.10290604699390056, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Adaptive Neighborhood Search, integrating dynamic parameter tuning and local search for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.local_search_prob = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.local_search_prob = 0.1 + 0.4 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def adaptive_local_search(self, individual, bounds):\n        perturbation = np.random.normal(0, 0.05, self.dim)\n        new_individual = np.clip(individual + perturbation, bounds.lb, bounds.ub)\n        return new_individual\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_prob:\n                    trial_vector = self.adaptive_local_search(self.population[i], func.bounds)\n                else:\n                    mutant_vector = self.mutate(i, self.population, func.bounds)\n                    trial_vector = self.crossover(self.population[i], mutant_vector)\n                \n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10291 with standard deviation 0.04167.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.05021945936773087, 0.055990479063226295, 0.06954069178708411, 0.15141457134326486, 0.1677520133867495, 0.15069191548516536, 0.10971327567356293, 0.08987986287335681, 0.08095215396496436]}}
{"id": "c852e9ac-b203-48d9-abd2-9a349085e950", "fitness": 0.10733788551966039, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Improved Quorum Sensing by introducing probabilistic influence, facilitating better exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                if np.random.rand() < 0.5:  # Probabilistic influence\n                    population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10734 with standard deviation 0.04117.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.09159712715697477, 0.08429277513747069, 0.03754856079279145, 0.15591566207496, 0.16610614381970956, 0.1596462842900419, 0.09930816089103667, 0.09144392763512244, 0.08018232787883606]}}
{"id": "c236f52b-5c42-495c-a84f-acfc1ed7be9f", "fitness": -Infinity, "name": "EnhancedQuorumDifferentialEvolution", "description": "Improved convergence by dynamically adjusting quorum threshold based on progress.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        # Dynamically adjust quorum_threshold based on progress\n        self.quorum_threshold = 0.2 + 0.1 * (evaluations / self.budget)\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 50, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {}}
{"id": "e0594ab6-c645-46cb-ac7c-ea3400169027", "fitness": 0.1287256809879891, "name": "AdaptiveCooperativeQuorumEvolution", "description": "Adaptive Cooperative Coevolution with Quorum-Inspired Decision-Making, enhancing mutation strategies and incorporating individual fitness influence for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveCooperativeQuorumEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.influence_factor = 0.5  # New parameter for fitness influence\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, fitness, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        fitness_diff = np.abs(fitness - fitness[idx])\n        influence = self.influence_factor * fitness_diff / np.max(fitness_diff)\n        mutant_vector = np.clip(a + (self.mutation_factor + influence[idx]) * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.influence_factor = 0.5 + 0.4 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, fitness, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 51, "feedback": "The algorithm AdaptiveCooperativeQuorumEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12873 with standard deviation 0.06004.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.2585700689481659, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "c230dbc2-49ef-4b05-831e-773a1264230e", "fitness": 0.06470684252946082, "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-inspired Differential Evolution with Adaptive Quorum Sensing combines quantum superposition principles and adaptive parameter tuning to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.7\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def quantum_superposition(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        q_state = np.random.rand(self.population_size, self.dim) < 0.5\n        superposed_population = np.where(q_state, lb, ub)\n        return np.random.uniform(lb, ub) * superposed_population\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.4 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.8 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.quantum_superposition(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 52, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06471 with standard deviation 0.05318.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.008737784327544351, 0.007838055968926061, 0.0064187234925834336, 0.1330827980306768, 0.13713393898174764, 0.13637143967487564, 0.05747079033985847, 0.04814029316602808, 0.04716775878290691]}}
{"id": "8c5203df-96bf-43cd-9894-22e4a0a6c8f9", "fitness": 0.08666448303506169, "name": "MultiQuorumAdaptiveDifferentialEvolution", "description": "Multi-Quorum Adaptive Differential Evolution with Gradient-based Local Search integrates adaptive parameter tuning, multi-quorum sensing, and gradient-based local search for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass MultiQuorumAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def multi_quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        mean_fitness = np.mean(fitness)\n        for i in range(self.population_size):\n            if fitness[i] > mean_fitness * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def gradient_local_search(self, solution, func, bounds):\n        grad_step = 1e-2\n        grad = np.zeros(self.dim)\n        for i in range(self.dim):\n            pos_solution = np.copy(solution)\n            pos_solution[i] += grad_step\n            grad[i] = (func(pos_solution) - func(solution)) / grad_step\n        new_solution = solution - grad_step * grad\n        new_solution = np.clip(new_solution, bounds.lb, bounds.ub)\n        return new_solution\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.multi_quorum_sensing(self.population, fitness)\n\n            # Apply gradient-based local search\n            for i in range(self.population_size):\n                local_search_solution = self.gradient_local_search(self.population[i], func, func.bounds)\n                local_search_fitness = func(local_search_solution)\n                evaluations += 1\n\n                if local_search_fitness < fitness[i]:\n                    self.population[i] = local_search_solution\n                    fitness[i] = local_search_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 53, "feedback": "The algorithm MultiQuorumAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08666 with standard deviation 0.05294.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.03242013403917121, 0.02951968599103094, 0.0230588835166331, 0.1503720898352029, 0.17118705479503338, 0.14262353269091732, 0.08795899642578497, 0.08064110273773129, 0.06219886728405011]}}
{"id": "7182c4f7-34f8-401a-8017-9f527046d3bd", "fitness": 0.11576829928117165, "name": "EnhancedQuorumDifferentialEvolution", "description": "EnhancedQuorumDifferentialEvolution with Lvy Flight mutation strategy and adaptive quorum threshold for improved exploration and convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.initial_quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def levy_flight(self, idx, population, bounds):\n        # Implementing Levy Flight for mutation strategy\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1 / beta)\n        step_size = self.mutation_factor * step\n        mutant_vector = np.clip(population[idx] + step_size, bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def adapt_quorum_threshold(self, evaluations):\n        # Adapt quorum threshold based on the progress of evaluations\n        self.quorum_threshold = self.initial_quorum_threshold * (1 - evaluations / self.budget)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            self.adapt_quorum_threshold(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.levy_flight(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11577 with standard deviation 0.03497.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.10681709418952756, 0.09913854843983394, 0.07231267784177764, 0.1503720898352029, 0.16610614381970956, 0.16986421914751082, 0.08761405712076342, 0.08004705122145062, 0.10964281191476843]}}
{"id": "5bf38c28-1f88-41dd-893c-dd3a87713fcc", "fitness": 0.10954126771133213, "name": "AdaptiveQuorumDifferentialEvolution", "description": "Adaptive Quorum Differential Evolution with Stochastic Parameter Control, utilizing progressive mutation strategy and elitist selection for robust convergence.", "code": "import numpy as np\n\nclass AdaptiveQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.5\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def stochastic_adapt_parameters(self):\n        # Stochastic adjustment of mutation factor and crossover probability\n        self.mutation_factor = np.random.uniform(0.5, 1.0)\n        self.crossover_probability = np.random.uniform(0.7, 1.0)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def elitist_selection(self, population, fitness, new_population, new_fitness):\n        for i in range(self.population_size):\n            if new_fitness[i] < fitness[i]:\n                population[i] = new_population[i]\n                fitness[i] = new_fitness[i]\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.stochastic_adapt_parameters()\n            new_population = np.copy(self.population)\n            new_fitness = np.copy(fitness)\n\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < new_fitness[i]:\n                    new_population[i] = trial_vector\n                    new_fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.elitist_selection(self.population, fitness, new_population, new_fitness)\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 55, "feedback": "The algorithm AdaptiveQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10954 with standard deviation 0.04053.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06039739096535668, 0.08931127887414991, 0.05311855030428814, 0.15289054823760329, 0.16610614381970956, 0.16666542707436605, 0.10733358905108525, 0.09698897528027517, 0.0930595057951551]}}
{"id": "28adf893-f230-4d71-be96-e6d2bcad8a79", "fitness": 0.09601336877453091, "name": "EnhancedQuorumDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with Enhanced Quorum Sensing incorporating adaptive scaling of mutation based on diversity.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        diversity_factor = np.std(population) / np.mean(population)  # New line\n        mutant_vector = np.clip(a + self.mutation_factor * diversity_factor * (b - c), bounds.lb, bounds.ub)  # Modified line\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09601 with standard deviation 0.04655.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.07586834245012997, 0.06035638176620095, 0.022012185615279845, 0.15258520332825898, 0.1684755408412978, 0.14687490779127854, 0.09451000353277583, 0.07973972442166644, 0.0636980292238899]}}
{"id": "7f78b04c-d819-4089-90f1-9751abcc0fff", "fitness": 0.1091791425036818, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning and elitism for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n        best_fitness = np.min(fitness)  # Track best fitness found\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                # Apply elitism by retaining the best solution found so far\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10918 with standard deviation 0.03982.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "1a25c4fc-8c47-4f2e-b5ba-69861697242d", "fitness": 0.10752271880990635, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Elite Preservation, focusing on maintaining diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.elite_preservation_factor = 0.1  # New parameter for elite preservation\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def preserve_elites(self, population, fitness):\n        elite_size = int(self.elite_preservation_factor * self.population_size)\n        elite_indices = np.argsort(fitness)[:elite_size]\n        elites = population[elite_indices]\n        return elites\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            elites = self.preserve_elites(self.population, fitness)  # Preserve the best solutions\n            \n            for i in range(self.population_size):\n                if i in elites:  # Skip mutation for elite solutions\n                    continue\n                \n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10752 with standard deviation 0.04054.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06962580199989066, 0.10139227005002127, 0.03345490958364428, 0.15610616420098833, 0.16610614381970956, 0.14726516883265484, 0.1068979161950373, 0.09897784425765488, 0.0878782503495561]}}
{"id": "462197f2-f805-401c-a70d-0d490bbf0423", "fitness": 0.11468993747512098, "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with focused mutation and crossover strategies, integrating diversity preservation to enhance convergence robustness.", "code": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds, best_idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        best = population[best_idx]\n        # Focused mutation strategy using the best solution\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (best - a), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        # Use target vector when mutation fails to increase diversity\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.7 + 0.2 * np.sin(np.pi * progress)  # Use a sinusoidal pattern\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                # Preserve diversity by adding random perturbation \n                population[i] = best_solution + np.random.normal(0, 0.2, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            best_idx = np.argmin(fitness)\n\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds, best_idx)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 59, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11469 with standard deviation 0.03709.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08357781135783715, 0.10881238712413477, 0.06185890262169891, 0.1503720898352029, 0.16911982746278742, 0.17088427157317376, 0.09385773304767575, 0.10465345924269465, 0.08907295501088353]}}
{"id": "dfa3b5aa-5e5c-4f5d-9cea-beb4a509ece8", "fitness": 0.1079119147516517, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Quorum Differential Evolution with Adaptive Clustering dynamically refines solutions using adaptive clustering for more focused search and convergence.  ", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def adaptive_clustering(self, population, fitness):\n        cluster_threshold = 0.1\n        clusters = []\n        for i in range(self.population_size):\n            found_cluster = False\n            for cluster in clusters:\n                if np.linalg.norm(population[i] - cluster['center']) < cluster_threshold:\n                    cluster['members'].append(i)\n                    found_cluster = True\n                    break\n            if not found_cluster:\n                clusters.append({'center': population[i], 'members': [i]})\n        \n        for cluster in clusters:\n            cluster_center = np.mean(population[cluster['members']], axis=0)\n            for idx in cluster['members']:\n                population[idx] = cluster_center + np.random.normal(0, 0.05, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.adaptive_clustering(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10791 with standard deviation 0.03427.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.072833498914321, 0.07418830956625777, 0.06979213282201291, 0.1503720898352029, 0.16610614381970956, 0.14172983623854385, 0.10864143049357555, 0.09677630226708622, 0.09076748880815555]}}
{"id": "a259cd83-3ac0-485f-8ba2-d654dbdd4348", "fitness": 0.1027858193966651, "name": "AdaptiveQuorumDifferentialEvolution", "description": "Adaptive Quorum Differential Evolution with Dynamic Neighborhood Plan, enhancing exploration and exploitation balance by dynamic grouping and elite migration.", "code": "import numpy as np\n\nclass AdaptiveQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.elite_fraction = 0.1  # Fraction of population considered elite\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.2 * (1 - progress)\n\n    def dynamic_neighborhood(self, population, fitness):\n        sorted_indices = np.argsort(fitness)\n        elite_size = int(self.elite_fraction * self.population_size)\n        elite_indices = sorted_indices[:elite_size]\n        for i in range(self.population_size):\n            if i not in elite_indices:\n                neighbors = np.random.choice(elite_indices, 2, replace=False)\n                population[i] = np.mean(population[neighbors], axis=0) + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.dynamic_neighborhood(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm AdaptiveQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10279 with standard deviation 0.03872.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.07979223272658376, 0.08003382359146305, 0.061183623887782534, 0.15688631062076674, 0.16610614381970956, 0.14593315631547255, 0.08594193586186327, 0.0794060530964169, 0.06978909464992755]}}
{"id": "45f1d3d5-fe1a-46b0-88c5-603b93b9a5ac", "fitness": 0.10698300027123658, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, introducing elite reinitialization and improved mutation strategy for robust convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds, elite):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (elite - a), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            elite = self.population[np.argmin(fitness)]  # Track elite individual\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds, elite)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            # Reinitialize worst population members\n            if evaluations < self.budget:\n                worst_indices = fitness.argsort()[-int(0.1 * self.population_size):]\n                self.population[worst_indices] = self.initialize_population(func.bounds)[0:len(worst_indices)]\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10698 with standard deviation 0.03546.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06568395186184117, 0.07999283662602452, 0.06367171900357149, 0.1503720898352029, 0.16626824664609285, 0.14138363613504168, 0.10968189004728268, 0.09632399991883445, 0.08946863236723757]}}
{"id": "bf7adfb0-dc5d-4711-8c0b-5526cb09adb4", "fitness": 0.10015381357803507, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning and opposition-based learning for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.bounds = None\n\n    def initialize_population(self):\n        lb, ub = self.bounds.lb, self.bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), self.bounds.lb, self.bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def opposition_based_learning(self, population):\n        lb, ub = self.bounds.lb, self.bounds.ub\n        opposition_population = lb + ub - population\n        opposition_population = np.clip(opposition_population, lb, ub)\n        return opposition_population\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        self.population = self.initialize_population()\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            opposition_population = self.opposition_based_learning(self.population)\n            opposition_fitness = np.array([func(ind) for ind in opposition_population])\n            for i in range(self.population_size):\n                if opposition_fitness[i] < fitness[i]:\n                    self.population[i] = opposition_population[i]\n                    fitness[i] = opposition_fitness[i]\n            \n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10015 with standard deviation 0.04308.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.05641017986210495, 0.055169695153685416, 0.06268033290913722, 0.15799742931146632, 0.16610614381970956, 0.15109462202138935, 0.09304008155383969, 0.08856381544880021, 0.07032202212218297]}}
{"id": "46acef00-62c2-4fe7-a897-62d9cccdc097", "fitness": 0.10948267574011826, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Local Search, incorporating dynamic parameter tuning and neighborhood exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.local_search_probability = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def local_search(self, individual, func, bounds):\n        new_individual = individual + np.random.normal(0, 0.01, self.dim)\n        new_individual = np.clip(new_individual, bounds.lb, bounds.ub)\n        new_fitness = func(new_individual)\n        return new_individual, new_fitness\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_probability:\n                    trial_vector, trial_fitness = self.local_search(self.population[i], func, func.bounds)\n                else:\n                    mutant_vector = self.mutate(i, self.population, func.bounds)\n                    trial_vector = self.crossover(self.population[i], mutant_vector)\n                    trial_fitness = func(trial_vector)\n                \n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10948 with standard deviation 0.03635.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08162613298991128, 0.05801385033087214, 0.07188672327571788, 0.15741639429224663, 0.16610614381970956, 0.1458149024241041, 0.10642018879288517, 0.09903622397869138, 0.09902352175692619]}}
{"id": "01cd0e2e-98c3-4c7a-8b4c-6a5aa1c06733", "fitness": 0.1080051391495645, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning and adaptive quorum threshold for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.2 * (1 - progress)  # Adapt quorum threshold based on progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10801 with standard deviation 0.03636.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.06639437392555103, 0.0740804044782668, 0.0655199155506716, 0.15193538256849048, 0.16610614381970956, 0.14835192067724734, 0.10692595968645957, 0.0949958402403841, 0.09773631139929995]}}
{"id": "6a785d20-8588-41be-abd7-1f518e599fbc", "fitness": 0.11159711015953327, "name": "AdaptiveBiQuorumDE", "description": "Adaptive Bi-Quorum Differential Evolution with Self-Organized Criticality, introducing dual quorum thresholds and critical mutations for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveBiQuorumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.lower_quorum_threshold = 0.1\n        self.upper_quorum_threshold = 0.3\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.upper_quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n            \n            elif fitness[i] > fitness[best_idx] * (1 + self.lower_quorum_threshold):\n                # Introduce self-organized criticality with higher variance in mutations\n                population[i] = best_solution + np.random.normal(0, 0.5, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm AdaptiveBiQuorumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11160 with standard deviation 0.03620.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.10766219652420783, 0.05673327853222143, 0.0778227671428059, 0.1593738735249416, 0.16610614381970956, 0.15074356192396088, 0.09955217216543566, 0.09640975757939652, 0.08997024022312006]}}
{"id": "ac6e7c1f-31ac-4b19-8669-4888e9f65a7b", "fitness": 0.08997242491952373, "name": "EnhancedQuorumDifferentialEvolution", "description": "Adaptive Quorum Differential Evolution with Enhanced Diversity Maintenance, introducing opposition-based learning and an adaptive quorum enhancement for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def opposition_based_learning(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return lb + ub - population\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def enhanced_quorum(self, population, fitness):\n        diversity = np.std(population, axis=0)\n        for i in range(self.population_size):\n            if fitness[i] > np.min(fitness) + self.quorum_threshold * np.mean(fitness):\n                population[i] += diversity * np.random.normal(0, 1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            opposition_population = self.opposition_based_learning(self.population, func.bounds)\n            opposition_fitness = np.array([func(ind) for ind in opposition_population])\n            combined_population = np.vstack((self.population, opposition_population))\n            combined_fitness = np.hstack((fitness, opposition_fitness))\n            best_indices = np.argsort(combined_fitness)[:self.population_size]\n            self.population = combined_population[best_indices]\n            fitness = combined_fitness[best_indices]\n            self.enhanced_quorum(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08997 with standard deviation 0.04886.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.03522205654912913, 0.044594870002569786, 0.03235265372098117, 0.15329381924535546, 0.16610614381970956, 0.14132756566419535, 0.09093390203455909, 0.07940004781166177, 0.06652076542755225]}}
{"id": "5ae6fb4a-a27c-4ce5-9936-d16d9b0d4128", "fitness": 0.10640005265334143, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning and stochastic local search to improve convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                elif np.random.rand() < 0.1:  # Stochastic local search\n                    perturbation = np.random.normal(0, 0.01, self.dim)\n                    new_trial = np.clip(trial_vector + perturbation, func.bounds.lb, func.bounds.ub)\n                    new_fitness = func(new_trial)\n                    evaluations += 1\n                    if new_fitness < fitness[i]:\n                        self.population[i] = new_trial\n                        fitness[i] = new_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10640 with standard deviation 0.04041.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.05866582779907048, 0.05363592923310989, 0.06600185122824831, 0.15076729716610582, 0.16610614381970956, 0.1543911107913788, 0.11146702189227264, 0.10026079652443665, 0.09630449542574071]}}
{"id": "930a3e31-1540-43a3-943d-701cae3a0cfd", "fitness": -Infinity, "name": "EnhancedAdaptivePopulationDifferentialEvolution", "description": "Enhanced Adaptive Population Differential Evolution, integrating adaptive population resizing based on convergence rates and advanced quorum sensing for improved performance in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptivePopulationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                deviation = np.linalg.norm(population[i] - best_solution)\n                adjustment = min(0.1, deviation / 10.0)\n                population[i] = best_solution + np.random.normal(0, adjustment, self.dim)\n\n    def adapt_population_size(self, evaluations):\n        if evaluations < self.budget * 0.5:\n            self.population_size = min(20 * self.dim, self.population_size + 5)\n        else:\n            self.population_size = max(5 * self.dim, self.population_size - 5)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_population_size(evaluations)\n            self.adapt_parameters(evaluations)\n            new_population = []\n\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    fitness[i] = trial_fitness\n                else:\n                    new_population.append(self.population[i])\n\n                if evaluations >= self.budget:\n                    break\n\n            self.population = np.array(new_population)\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 69, "feedback": "An exception occurred: IndexError('index 103 is out of bounds for axis 0 with size 100').", "error": "IndexError('index 103 is out of bounds for axis 0 with size 100')", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {}}
{"id": "f6f744d2-d9cd-45f3-a5ec-c3e14e9c7d32", "fitness": 0.11802656444889337, "name": "ImprovedQuorumDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with Quorum Sensing and Fitness Sharing to enhance exploration and maintain diversity.", "code": "import numpy as np\n\nclass ImprovedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.sharing_intensity = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def fitness_sharing(self, fitness):\n        for i in range(self.population_size):\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            sharing = np.exp(- (distances ** 2) / self.sharing_intensity)\n            fitness[i] = np.sum(fitness / sharing)\n        return fitness\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            fitness = self.fitness_sharing(fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 70, "feedback": "The algorithm ImprovedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11803 with standard deviation 0.04181.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.16457238254569317, 0.0586726444337029, 0.06259935117379611, 0.15872416102843157, 0.16610614381970956, 0.15433209120299352, 0.11925178631346856, 0.08832867136082545, 0.08965184816141936]}}
{"id": "7022c240-ccfb-4722-8bab-57c1aeb5b443", "fitness": -Infinity, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Quorum Sensing and Adaptive Subpopulation Mutation Rate for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        # Adaptive mutation factor based on distance to best solution\n        best_idx = np.argmin([func(ind) for ind in population])\n        adaptive_factor = np.linalg.norm(population[best_idx] - population[idx]) / self.dim\n        mutant_vector = np.clip(a + adaptive_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 71, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {}}
{"id": "6daaf9a2-b455-43a2-97de-0bd7d809bd9a", "fitness": 0.11179642276648079, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive quorum sensing and dynamic neighborhood search for improved exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                # Small neighborhood search added\n                if np.random.rand() < 0.5:  \n                    population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n                else:\n                    population[i] = population[i] + np.random.normal(0, 0.05, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11180 with standard deviation 0.05290.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.18512462377774175, 0.04455632454538849, 0.02497536480366669, 0.1522446815044899, 0.16610614381970956, 0.15491500048571571, 0.10472106644995971, 0.08836745585754768, 0.08515714365410765]}}
{"id": "1f3e99a6-3ae8-4a10-8af3-860ef5aac6e1", "fitness": 0.1092265899491242, "name": "EnhancedAdaptiveQuorumDifferentialEvolution", "description": "Enhanced Adaptive Quorum Differential Evolution with Gradient-Based Local Search, combining adaptive differential evolution with local search for refined convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n                \n    def local_search(self, solution, func, bounds):\n        # Simple gradient-based local search\n        gradient_step = 0.01\n        gradient = np.zeros(self.dim)\n        for i in range(self.dim):\n            perturb = np.zeros(self.dim)\n            perturb[i] = gradient_step\n            plus_perturb = np.clip(solution + perturb, bounds.lb, bounds.ub)\n            minus_perturb = np.clip(solution - perturb, bounds.lb, bounds.ub)\n            gradient[i] = (func(plus_perturb) - func(minus_perturb)) / (2 * gradient_step)\n\n        # Update solution with gradient, clipped to bounds\n        new_solution = np.clip(solution - gradient_step * gradient, bounds.lb, bounds.ub)\n        return new_solution\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n            # Apply local search to the best solution\n            best_idx = np.argmin(fitness)\n            best_solution = self.population[best_idx]\n            refined_solution = self.local_search(best_solution, func, func.bounds)\n            refined_fitness = func(refined_solution)\n            evaluations += 1\n            \n            if refined_fitness < fitness[best_idx]:\n                self.population[best_idx] = refined_solution\n                fitness[best_idx] = refined_fitness\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedAdaptiveQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10923 with standard deviation 0.04666.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.0753213929632166, 0.05706561176139202, 0.04392841580660045, 0.16785725399767937, 0.17579277265755433, 0.16572852589338405, 0.10606760564528983, 0.09889576558346058, 0.09238196523354048]}}
{"id": "bbe0f88e-ebba-40a1-b506-4c3be3333321", "fitness": 0.1091791425036818, "name": "AdaptiveQuorumDifferentialEvolution", "description": "Adaptive Quorum Differential Evolution with Fitness Sharing, improving diversity and convergence by incorporating fitness sharing to manage population diversity dynamically.", "code": "import numpy as np\n\nclass AdaptiveQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.fitness_sharing_radius = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def fitness_sharing(self, fitness):\n        shared_fitness = np.zeros_like(fitness)\n        for i in range(self.population_size):\n            distances = np.linalg.norm(self.population - self.population[i], axis=1)\n            sharing_values = np.maximum(0, 1 - (distances / self.fitness_sharing_radius))\n            shared_fitness[i] = fitness[i] / np.sum(sharing_values)\n        return shared_fitness\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            fitness = self.fitness_sharing(fitness)\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm AdaptiveQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10918 with standard deviation 0.03982.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06066636435197337, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "1eed78ff-c119-4e74-b23c-ec9355055e0a", "fitness": 0.10677490671129536, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Genetic Drift, incorporating dynamic parameter tuning and diversity preservation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.genetic_drift_factor = 0.05\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, self.genetic_drift_factor, self.dim)\n\n    def genetic_drift(self, population, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        drift_vectors = np.random.uniform(-self.genetic_drift_factor, self.genetic_drift_factor, (self.population_size, self.dim))\n        population += drift_vectors\n        population = np.clip(population, lb, ub)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.genetic_drift(self.population, func.bounds)  # Invoking genetic drift here\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10677 with standard deviation 0.04163.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.0598687084218541, 0.07883485790515332, 0.049025314543332366, 0.152216056021802, 0.16610614381970956, 0.1634258155820606, 0.10722173941261726, 0.09766754653037912, 0.08660797816474985]}}
{"id": "4c637846-cea7-4c5c-a6ee-a3f78ad58352", "fitness": 0.09314021346491234, "name": "EnhancedQuorumDifferentialEvolutionMultiSwarm", "description": "Enhanced Quorum Differential Evolution with Multi-Swarm Adaptation, introducing multi-swarm dynamics for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolutionMultiSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.num_swarms = 3\n        self.population = None\n        self.swarms = []\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, swarm, bounds):\n        indices = [i for i in range(len(swarm)) if i != idx]\n        a, b, c = swarm[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(len(population)):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def initialize_swarms(self):\n        swarm_size = self.population_size // self.num_swarms\n        np.random.shuffle(self.population)\n        self.swarms = [self.population[i*swarm_size:(i+1)*swarm_size] for i in range(self.num_swarms)]\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        self.initialize_swarms()\n\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n\n            for swarm in self.swarms:\n                swarm_fitness = np.array([func(ind) for ind in swarm])\n                for i in range(len(swarm)):\n                    mutant_vector = self.mutate(i, swarm, func.bounds)\n                    trial_vector = self.crossover(swarm[i], mutant_vector)\n                    trial_fitness = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_fitness < swarm_fitness[i]:\n                        swarm[i] = trial_vector\n                        swarm_fitness[i] = trial_fitness\n\n                    if evaluations >= self.budget:\n                        break\n\n                self.quorum_sensing(swarm, swarm_fitness)\n\n            self.population = np.vstack(self.swarms)\n            fitness = np.hstack([np.array([func(ind) for ind in swarm]) for swarm in self.swarms])\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedQuorumDifferentialEvolutionMultiSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09314 with standard deviation 0.05105.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.04112314111561621, 0.03687109101252606, 0.031241722157063556, 0.15791184408508685, 0.16598624487995384, 0.1541340183158203, 0.08817211710184991, 0.09222627751113666, 0.07059546500515768]}}
{"id": "306fbb0b-2006-4206-95d8-3a4c51cc151f", "fitness": 0.10423838524828255, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, including random restart to escape local optima and improve convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            \n            # Randomly restart the worst solution to escape local optima\n            if evaluations < self.budget:\n                worst_idx = np.argmax(fitness)\n                self.population[worst_idx] = np.random.uniform(func.bounds.lb, func.bounds.ub, self.dim)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10424 with standard deviation 0.04066.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.07258986149562463, 0.05361876531921539, 0.05177861226756575, 0.15039336049110985, 0.16610614381970956, 0.15014624998574655, 0.1102204274547729, 0.10019711032594147, 0.08309493607485685]}}
{"id": "1f05cb3f-e59c-40d8-b3ba-c4f2273f97d2", "fitness": 0.1095562129689809, "name": "EnhancedQuorumDifferentialEvolutionWithDiversity", "description": "Enhanced Quorum Differential Evolution with Adaptive Diversity Preservation, utilizing a diversity preservation mechanism to maintain exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolutionWithDiversity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.diversity_threshold = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def preserve_diversity(self, population, bounds):\n        centroid = np.mean(population, axis=0)\n        for i in range(self.population_size):\n            if np.linalg.norm(population[i] - centroid) < self.diversity_threshold:\n                population[i] = np.random.uniform(bounds.lb, bounds.ub, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.preserve_diversity(self.population, func.bounds)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedQuorumDifferentialEvolutionWithDiversity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10956 with standard deviation 0.03937.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [0.08265122258940016, 0.05750862533079726, 0.06405999853966526, 0.15610616420098833, 0.16610614381970956, 0.15975915361490234, 0.1102993434523164, 0.10257659214286452, 0.08693867303018421]}}
{"id": "391d0f32-19d7-454a-82ad-22f27ef3f3d6", "fitness": -Infinity, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Dynamic Population Sizing for effective exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.dynamic_population = True\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        if self.dynamic_population:\n            self.population_size = max(4, int(10 * self.dim * (1 - progress)))\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            new_population = []\n            new_fitness = []\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population.append(trial_vector)\n                    new_fitness.append(trial_fitness)\n                else:\n                    new_population.append(self.population[i])\n                    new_fitness.append(fitness[i])\n\n                if evaluations >= self.budget:\n                    break\n\n            self.population = np.array(new_population)\n            fitness = np.array(new_fitness)\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 79, "feedback": "An exception occurred: IndexError('index 3 is out of bounds for axis 0 with size 3').", "error": "IndexError('index 3 is out of bounds for axis 0 with size 3')", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {}}
{"id": "1d45d31f-96c9-4eb7-973f-249aca94b122", "fitness": 0.20813310026594037, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning and adaptive quorum threshold for improved convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress  # Added adaptive quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20813 with standard deviation 0.28274.", "error": "", "parent_ids": ["5df639e0-eec5-4212-a0fa-f19c3698c8c8"], "operator": null, "metadata": {"aucs": [1.0, 0.04581397507614837, 0.06224201141128982, 0.157827437525364, 0.16610614381970956, 0.14990255381443207, 0.1055320786992685, 0.09595216324426259, 0.08982153880298815]}}
{"id": "a7356043-2d83-47ce-82bc-8d59a44ff63d", "fitness": 0.08964908748354844, "name": "AdaptiveQuantumDifferentialEvolution", "description": "Adaptive Quantum Differential Evolution with Dynamic Niching, integrating quantum-inspired sampling and niching to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.niche_radius = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def quantum_sample(self, parent, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.clip(parent + np.random.normal(0, 0.1, self.dim), lb, ub)\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.niche_radius = 0.05 + 0.15 * progress\n\n    def dynamic_niching(self, population, fitness):\n        for i in range(self.population_size):\n            for j in range(i + 1, self.population_size):\n                distance = np.linalg.norm(population[i] - population[j])\n                if distance < self.niche_radius and fitness[i] > fitness[j]:\n                    population[i] = self.quantum_sample(population[j], func.bounds)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.dynamic_niching(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08965 with standard deviation 0.04816.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.03686321038847096, 0.03785677007720578, 0.039627191453886046, 0.1503720898352029, 0.16610614381970956, 0.14249269141698595, 0.08594193586186327, 0.07940004781166177, 0.06818170668694967]}}
{"id": "39cb2fd2-f84f-4cc9-b3e4-e9da8a016aac", "fitness": 0.11243915083296852, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Adaptive Population Resizing, introducing dynamic population size adjustment to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.initial_population_size = self.population_size\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor, crossover probability, and quorum threshold\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def resize_population(self, evaluations):\n        # Dynamically resize the population to improve exploration and exploitation\n        progress = evaluations / self.budget\n        self.population_size = int(self.initial_population_size * (1 - 0.5 * progress))\n        if self.population_size < 4:  # Ensure a minimum size for DE operations\n            self.population_size = 4\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            self.resize_population(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11244 with standard deviation 0.03258.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.07037788114663368, 0.08218341370462046, 0.07769843291003387, 0.1503720898352029, 0.16610614381970956, 0.1467769353841114, 0.11127944923262856, 0.10247765074874271, 0.10468036071503362]}}
{"id": "706d68e5-9b12-4b20-961d-1087d732ed50", "fitness": 0.10391637318716163, "name": "HybridEvolutionaryGreyWolfOptimizer", "description": "Hybridized Evolutionary Grey Wolf Optimizer, integrating adaptive differential evolution and grey wolf optimization for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass HybridEvolutionaryGreyWolfOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.a_param = 2.0  # Grey Wolf parameter\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.a_param = 2.0 * (1 - progress)  # A decreasing factor for Grey Wolf\n\n    def differential_evolution_step(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        \n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant_vector, population[idx])\n        return trial_vector\n\n    def grey_wolf_update(self, population, alpha, beta, delta):\n        A1 = 2 * self.a_param * np.random.rand(self.dim) - self.a_param\n        C1 = 2 * np.random.rand(self.dim)\n        D_alpha = np.abs(C1 * alpha - population)\n        X1 = alpha - A1 * D_alpha\n\n        A2 = 2 * self.a_param * np.random.rand(self.dim) - self.a_param\n        C2 = 2 * np.random.rand(self.dim)\n        D_beta = np.abs(C2 * beta - population)\n        X2 = beta - A2 * D_beta\n\n        A3 = 2 * self.a_param * np.random.rand(self.dim) - self.a_param\n        C3 = 2 * np.random.rand(self.dim)\n        D_delta = np.abs(C3 * delta - population)\n        X3 = delta - A3 * D_delta\n\n        return (X1 + X2 + X3) / 3\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            alpha_idx = np.argmin(fitness)\n            alpha = self.population[alpha_idx]\n            beta_idx = np.argsort(fitness)[1]\n            beta = self.population[beta_idx]\n            delta_idx = np.argsort(fitness)[2]\n            delta = self.population[delta_idx]\n\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if np.random.rand() < 0.5:\n                    trial_vector = self.differential_evolution_step(i, self.population, func.bounds)\n                else:\n                    trial_vector = self.grey_wolf_update(self.population[i], alpha, beta, delta)\n\n                trial_vector = np.clip(trial_vector, func.bounds.lb, func.bounds.ub)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.population = new_population\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm HybridEvolutionaryGreyWolfOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10392 with standard deviation 0.04135.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.08832655146321555, 0.0971530912035048, 0.04888997104957271, 0.16412088127786084, 0.17020788426079903, 0.140018901019756, 0.08594193586186327, 0.07940004781166177, 0.061188094736220666]}}
{"id": "d0e4541a-ab0d-4a73-9d98-ee8f25ccc6dc", "fitness": 0.10816018416828063, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating Boltzmann selection for improved exploration at early stages and intensified exploitation later.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress  # Added adaptive quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / (1 + evaluations / self.budget)):\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10816 with standard deviation 0.04236.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.06806746863346735, 0.06566252340444478, 0.05314357919453505, 0.1505431994614863, 0.18236733389092263, 0.1545849062168042, 0.10280523651114681, 0.10117189350668832, 0.09509551669503025]}}
{"id": "53c71e1c-bbc6-4c01-bd30-a902276300c8", "fitness": 0.10633482232489938, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Strategic Reinitialization, incorporating dynamic parameter tuning and adaptive quorum threshold for improved convergence and diversity maintenance.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def reinitialize_individuals(self, population, fitness, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        worst_idxs = fitness > np.percentile(fitness, 75)  # Change: Add reinitialization of worst solutions\n        population[worst_idxs] = np.random.uniform(lb, ub, (np.sum(worst_idxs), self.dim))\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.reinitialize_individuals(self.population, fitness, func.bounds)  # Change: Call reinitialization method\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10633 with standard deviation 0.04007.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.07745800985658136, 0.061912236018140776, 0.050529815266887046, 0.15373109464089285, 0.16610614381970956, 0.15470151911609087, 0.10621160403238972, 0.08983448247380843, 0.09652849569959387]}}
{"id": "deb391e2-7f0a-4bc3-9050-64f30b7b7f30", "fitness": 0.09487204630868978, "name": "QuantumEnhancedDifferentialEvolution", "description": "Adaptive Quantum-Inspired Enhanced Differential Evolution, integrating quantum superposition principles for diversified exploration and adaptive quorum thresholding for rapid convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def quantum_superposition(self, bounds):\n        # Introduce quantum superposition for exploration\n        return np.random.uniform(bounds.lb, bounds.ub, self.dim) * (2 * np.random.randint(0, 2, size=self.dim) - 1)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                quantum_vector = self.quantum_superposition(func.bounds)\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector + quantum_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 86, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09487 with standard deviation 0.04346.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.08012345078250283, 0.0350738921372763, 0.054290952468207476, 0.1503720898352029, 0.16610614381970956, 0.140018901019756, 0.08594193586186327, 0.07940004781166177, 0.0625210030420279]}}
{"id": "561edd30-46ef-4fb3-8fbd-19fbfd1c40e3", "fitness": -Infinity, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Improved Quorum Feedback, integrating refined mutant selection and diversity preservation for robust optimization.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        # Change: Improved mutant formula with a blend of best solution\n        best_idx = np.argmin([func(ind) for ind in population])\n        best = population[best_idx]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (best - a), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        # Change: Introduced diversity preservation mechanism\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n            if np.std(population[i]) <= 0.01:\n                population[i] = population[i] + np.random.uniform(-0.1, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 87, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {}}
{"id": "6a0a48f1-eaa0-40b8-9c76-36e59344e2dc", "fitness": 0.12118622539833569, "name": "EnhancedQuorumDifferentialEvolution", "description": "Improved Differential Evolution with Adaptive Quorum Sensing and Fitness-based Dynamic Population Adjustment.  ", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress  # Added adaptive quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n        # Dynamic population adjustment based on fitness\n        self.population_size = max(4 * self.dim, min(self.population_size, int(self.population_size * 0.9)))\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12119 with standard deviation 0.03372.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.16065448050118525, 0.10479886409157924, 0.06616288662364245, 0.1503720898352029, 0.16610614381970956, 0.14802299362642257, 0.10803650142588472, 0.09851444667609544, 0.08800762198529899]}}
{"id": "faebc851-f7bf-4406-8cd9-fa3b455071b4", "fitness": 0.1107668434932171, "name": "EnhancedQuorumDifferentialEvolution", "description": "Improved convergence by adjusting mutation factor adaptation for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.6 + 0.2 * (1 - progress)  # Modified mutation factor adaptation\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress  # Added adaptive quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11077 with standard deviation 0.03993.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.07800487625274477, 0.047827712621575924, 0.06656470238334622, 0.15555467988028537, 0.16610614381970956, 0.15752545650865135, 0.10494783213038084, 0.10407317756386414, 0.11629701027839567]}}
{"id": "ec038abc-e175-4bc9-84c3-ac947961fed3", "fitness": 0.1058291475319425, "name": "EnhancedQuasiOppositionalDifferentialEvolution", "description": "Enhanced Quasi-oppositional Differential Evolution with Adaptive Quorum Sensing, integrating quasi-oppositional vectors for enhanced exploration and dynamic parameter tuning for improved exploitation.", "code": "import numpy as np\n\nclass EnhancedQuasiOppositionalDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def quasi_opposition(self, vector, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        opposite_vector = lb + ub - vector\n        quasi_opposite_vector = vector + np.random.uniform(0, 1, self.dim) * (opposite_vector - vector)\n        return np.clip(quasi_opposite_vector, lb, ub)\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                quasi_opposite = self.quasi_opposition(trial_vector, func.bounds)\n                quasi_fitness = func(quasi_opposite)\n                evaluations += 1\n\n                if quasi_fitness < fitness[i]:\n                    self.population[i] = quasi_opposite\n                    fitness[i] = quasi_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedQuasiOppositionalDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10583 with standard deviation 0.04477.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.05216085508857682, 0.0433716335202593, 0.08352231466912352, 0.16382544708778235, 0.1665444975739131, 0.16160914716778463, 0.10386578984579475, 0.09127638701528185, 0.0862862558189662]}}
{"id": "3c71a41c-0a7e-4a1f-b896-ebae79347fc9", "fitness": 0.08335544399915192, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Gradient-Informed Mutation, incorporating gradient approximations to accelerate convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds, func, fitness):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        \n        # New gradient-informed component\n        gradient_estimate = self.estimate_gradient(population[idx], func)\n        mutant_vector += 0.01 * gradient_estimate  # Small step along gradient\n        \n        return mutant_vector\n\n    def estimate_gradient(self, x, func):\n        epsilon = 1e-8\n        grad = np.zeros(self.dim)\n        for i in range(self.dim):\n            x_step = np.array(x)\n            x_step[i] += epsilon\n            grad[i] = (func(x_step) - func(x)) / epsilon\n        return grad\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds, func, fitness)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08336 with standard deviation 0.05319.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.03242013403917121, 0.02620243532373423, 0.022104146995690854, 0.1503720898352029, 0.16610615588936373, 0.14001891128630295, 0.08594195689707684, 0.07940004781166177, 0.047633117914162804]}}
{"id": "3ab239ad-273a-4203-abc1-15366575cc7f", "fitness": 0.10229718970907478, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, improved by dynamically adjusting the crossover probability to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.7 * (1 - progress)  # Changed from 0.5 to 0.7 for more dynamic adaptation\n        self.quorum_threshold = 0.1 + 0.1 * progress  # Added adaptive quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10230 with standard deviation 0.04131.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.06650425920373737, 0.04539973233750216, 0.05038548173131707, 0.15225135243393784, 0.16610614381970956, 0.1414518246522669, 0.10080569353338686, 0.1020446029261799, 0.09572561674363533]}}
{"id": "08d4b1c6-f6c9-4282-b6fa-c0fd92131892", "fitness": 0.11092496339528592, "name": "EnhancedQuorumDifferentialEvolution_v2", "description": "EnhancedQuorumDifferentialEvolution_v2: Integrates self-adaptive mutation and crossover strategies with dynamic learning rates for quorum sensing to improve diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.learning_rate = 0.1\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                step_size = self.learning_rate * np.random.normal(0, 1, self.dim)\n                population[i] = best_solution + step_size\n\n    def self_adaptive_crossover_mutation(self):\n        # Self-adaptive mechanisms for crossover and mutation to retain diversity\n        self.mutation_factor = np.random.normal(0.5, 0.1)\n        self.crossover_probability = np.random.normal(0.7, 0.1)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                self.self_adaptive_crossover_mutation()  # Self-adaptive step\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11092 with standard deviation 0.03593.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.05913934355369532, 0.08178708774599708, 0.08224509153836868, 0.15535701372791277, 0.1662879079378068, 0.15215370189016175, 0.11091494697387749, 0.09947164418908205, 0.0909679330006713]}}
{"id": "dfda8373-3e31-41fb-ad9b-0d86e4b9748b", "fitness": 0.1052748309360559, "name": "EnhancedQuorumDifferentialEvolutionWithMemory", "description": "EnhancedQuorumDifferentialEvolution with Adaptive Memory, integrating historical information to refine mutation strategies for better exploitation and exploration balance.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolutionWithMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n        self.history = []\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def adaptive_mutation_factor(self, idx, success_history):\n        if success_history:\n            return np.mean(success_history)\n        return self.mutation_factor\n\n    def mutate(self, idx, population, bounds, success_history):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        adapt_mutation_factor = self.adaptive_mutation_factor(idx, success_history)\n        mutant_vector = np.clip(a + adapt_mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            success_history = []\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds, success_history)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n                    success_history.append(self.mutation_factor)\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedQuorumDifferentialEvolutionWithMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10527 with standard deviation 0.04100.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.07427557603107626, 0.04581397507614837, 0.06224201141128982, 0.157827437525364, 0.16610614381970956, 0.14990255381443207, 0.1055320786992685, 0.09595216324426259, 0.08982153880295196]}}
{"id": "b6bb1f28-4518-49e5-b4f8-cf0abcf028d7", "fitness": 0.10643848930472238, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing, incorporating dynamic parameter tuning, adaptive quorum threshold, and slight noise added to the quorum sensing strategy for population diversity.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        noise = np.random.normal(0, 0.01, self.dim)  # Added small noise\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim) + noise\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10644 with standard deviation 0.03965.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.06104722734460555, 0.055325336872763975, 0.061984751961276285, 0.1517886974592586, 0.16610614381970956, 0.1492332337945691, 0.10778721787035384, 0.09962067550904674, 0.10505311911091786]}}
{"id": "68d67925-874f-476d-8f11-2cbfcdb906ed", "fitness": 0.10735976676333135, "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Quorum Sensing and Elite Reinsertion, leveraging an adaptive mutation strategy and elite replacement to enhance convergence and diversity.", "code": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.elite_ratio = 0.1\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def elite_reinsertion(self, population, fitness):\n        elite_size = int(self.elite_ratio * self.population_size)\n        elite_indices = np.argsort(fitness)[:elite_size]\n        worst_indices = np.argsort(fitness)[-elite_size:]\n        for ei, wi in zip(elite_indices, worst_indices):\n            if fitness[wi] > fitness[ei]:\n                population[wi] = population[ei].copy()\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.elite_reinsertion(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 96, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10736 with standard deviation 0.03892.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.06641435485006075, 0.06964099570940019, 0.058456616051778765, 0.157827437525364, 0.16610614381970956, 0.14996776112122145, 0.10867754431293652, 0.09528709180606376, 0.09385995567344718]}}
{"id": "50eaa9df-d7d0-4a19-806b-02b4cf09597f", "fitness": 0.10527483093605992, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Quorum Sensing and Diversity Enhancer, adding a diversity mechanism to improve exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        # Adapt mutation factor and crossover probability based on the progress of evaluations\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress  # Added adaptive quorum threshold\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def enhance_diversity(self, population, fitness):\n        # Add diversity enhancement mechanism based on distance\n        if np.std(fitness) < 1e-5:\n            for i in range(self.population_size):\n                if np.linalg.norm(population[i] - population.mean(axis=0)) < 0.1:\n                    population[i] += np.random.uniform(-0.1, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n            self.enhance_diversity(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10527 with standard deviation 0.04100.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.07427557603107626, 0.04581397507614837, 0.06224201141128982, 0.157827437525364, 0.16610614381970956, 0.14990255381443207, 0.1055320786992685, 0.09595216324426259, 0.08982153880298815]}}
{"id": "a62abc09-0fde-4b80-a3c3-d4b0cc5af563", "fitness": -Infinity, "name": "OptimizedQuorumDifferentialEvolution", "description": "Optimized Differential Evolution with Adaptive Quorum and Adaptive Population Dynamic, introducing population resizing based on evaluation progress for enhanced resource allocation.", "code": "import numpy as np\n\nclass OptimizedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n        self.population_size = int(self.initial_population_size * (1 - 0.5 * progress))  # Dynamic population sizing\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            indices = np.random.choice(range(self.initial_population_size), self.population_size, replace=False)\n            new_population = self.population[indices]\n            new_fitness = fitness[indices]\n            self.population = new_population\n            fitness = new_fitness\n            \n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 98, "feedback": "An exception occurred: IndexError('index 95 is out of bounds for axis 0 with size 95').", "error": "IndexError('index 95 is out of bounds for axis 0 with size 95')", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {}}
{"id": "37478795-b62e-4b60-a5db-0b523bd990d7", "fitness": 0.12532801233159713, "name": "EnhancedQuorumDifferentialEvolution", "description": "Enhanced Differential Evolution with Dynamic Quorum and Fitness Diversity Pressure, introducing diversity preservation and adaptive population adjustment for robust exploration.", "code": "import numpy as np\n\nclass EnhancedQuorumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_probability = 0.9\n        self.quorum_threshold = 0.2\n        self.population = None\n\n    def initialize_population(self, bounds):\n        lb, ub = bounds.lb, bounds.ub\n        return np.random.uniform(lb, ub, (self.population_size, self.dim))\n\n    def mutate(self, idx, population, bounds):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant_vector = np.clip(a + self.mutation_factor * (b - c), bounds.lb, bounds.ub)\n        return mutant_vector\n\n    def crossover(self, target, mutant):\n        crossover_mask = np.random.rand(self.dim) < self.crossover_probability\n        trial_vector = np.where(crossover_mask, mutant, target)\n        return trial_vector\n\n    def adapt_parameters(self, evaluations):\n        progress = evaluations / self.budget\n        self.mutation_factor = 0.5 + 0.3 * (1 - progress)\n        self.crossover_probability = 0.9 - 0.5 * (1 - progress)\n        self.quorum_threshold = 0.1 + 0.1 * progress\n\n    def quorum_sensing(self, population, fitness):\n        best_idx = np.argmin(fitness)\n        best_solution = population[best_idx]\n        for i in range(self.population_size):\n            if fitness[i] > fitness[best_idx] * (1 + self.quorum_threshold):\n                population[i] = best_solution + np.random.normal(0, 0.1, self.dim)\n        # Add diversity pressure\n        if np.std(fitness) < 1e-2:\n            for i in range(self.population_size):\n                population[i] += np.random.normal(0, 0.01, self.dim)\n\n    def __call__(self, func):\n        self.population = self.initialize_population(func.bounds)\n        fitness = np.array([func(ind) for ind in self.population])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.adapt_parameters(evaluations)\n            for i in range(self.population_size):\n                mutant_vector = self.mutate(i, self.population, func.bounds)\n                trial_vector = self.crossover(self.population[i], mutant_vector)\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial_vector\n                    fitness[i] = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            self.quorum_sensing(self.population, fitness)\n\n        best_idx = np.argmin(fitness)\n        return self.population[best_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedQuorumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12533 with standard deviation 0.06045.", "error": "", "parent_ids": ["1d45d31f-96c9-4eb7-973f-249aca94b122"], "operator": null, "metadata": {"aucs": [0.25475420859091125, 0.04581397507614837, 0.06224201141128982, 0.157827437525364, 0.16610614381970956, 0.14990255381443207, 0.1055320786992685, 0.09595216324426259, 0.08982153880298815]}}
