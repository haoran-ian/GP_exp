{"id": "73ce59ed-0897-4f62-86ec-046aca36dec0", "fitness": 0.1458811034469925, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Encoding balances exploration and exploitation by dynamically adjusting mutation strategies based on real-time performance and encoding solutions for diverse search space traversal.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        self.mutation_factor = 0.5 + 0.3 * np.sin(0.5 * generation)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14588 with standard deviation 0.13446.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.10441562959620121, 0.3530279052982016, 0.04493630619066602, 0.08903241993099109, 0.3432044141276418, 0.03099228172979185, 0.04985531017915468, 0.2958590843169564, 0.0016065796533277776]}}
{"id": "bf793770-e815-43ae-9252-36dd6c087527", "fitness": 0.32703253850270436, "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution algorithm's mutation factor is enhanced with a damping mechanism to stabilize convergence and improve fine-tuning in later generations.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        self.mutation_factor = 0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)  # Damping factor added\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32703 with standard deviation 0.12176.", "error": "", "parent_ids": ["73ce59ed-0897-4f62-86ec-046aca36dec0"], "operator": null, "metadata": {"aucs": [0.2987976478920943, 0.22596078982432444, 0.521853813559246, 0.28510830002724863, 0.21298733732230724, 0.5148258243561696, 0.2631703993240935, 0.18822361550080857, 0.43236511871804684]}}
{"id": "bc630ff5-bb86-4301-a83c-b99eab59b708", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced with a dynamic population size adjustment to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        self.mutation_factor = 0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)  # Damping factor added\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation)\n        self.population_size = 20 + int(5 * np.sin(0.2 * generation))  # Dynamic population size adjustment\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 2, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 20')", "parent_ids": ["bf793770-e815-43ae-9252-36dd6c087527"], "operator": null, "metadata": {}}
{"id": "d715f9fb-38d4-42a9-982e-9f6ffad686d0", "fitness": 0.40280342310728895, "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution algorithm's mutation factor is enhanced with a damping mechanism to stabilize convergence and improve fine-tuning in later generations, with additional dynamic adjustment of the mutation factor based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Adjusted with diversity factor\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40280 with standard deviation 0.12964.", "error": "", "parent_ids": ["bf793770-e815-43ae-9252-36dd6c087527"], "operator": null, "metadata": {"aucs": [0.44840246989209653, 0.2790855252536344, 0.5602433923997927, 0.4373620223845114, 0.22516065707984478, 0.5529070230327592, 0.41000596463106975, 0.19890366405998827, 0.5131600892319035]}}
{"id": "30eb5e24-f5bc-4b2f-9c3c-2a50a5eb75e4", "fitness": 0.14405823544980145, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with temporary reduction in crossover rate for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation)\n        if generation % 10 == 0:  # Temporarily reduce crossover rate every 10 generations\n            self.crossover_rate *= 0.5\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14406 with standard deviation 0.16778.", "error": "", "parent_ids": ["d715f9fb-38d4-42a9-982e-9f6ffad686d0"], "operator": null, "metadata": {"aucs": [0.3932877292033221, 0.04492864968145538, 0.04537694395146352, 0.383170246510967, 0.030987152066629275, 0.03127661551814753, 0.36416839086525676, 0.0016043739336665253, 0.0017240173173049822]}}
{"id": "a15baf78-2c78-4a98-9aac-02a2aa5234a9", "fitness": 0.39791246531794655, "name": "AdaptiveDifferentialEvolution", "description": "The Adaptive Differential Evolution algorithm introduces a dynamic adjustment for the mutation factor with a sinusoidal variation that synchronizes with the generation cycle to enhance exploration efficiency.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation * np.pi / self.budget) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Adjusted with synchronized sinusoidal variation\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39791 with standard deviation 0.26426.", "error": "", "parent_ids": ["d715f9fb-38d4-42a9-982e-9f6ffad686d0"], "operator": null, "metadata": {"aucs": [0.04493350455764955, 0.5665639871616788, 0.6180804324615073, 0.030990405231811624, 0.5598415130779564, 0.6124333395311988, 0.0016057730327687647, 0.5461589195178789, 0.6006043132890688]}}
{"id": "3bcca54e-95f3-441d-ad99-c96bdf4112d1", "fitness": 0.3241252941414948, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced parameter adaptation strategy using an exponential decay function for dynamic adjustment of mutation factors based on generation count.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * np.exp(-generation / self.budget) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Adjusted with diversity factor\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32413 with standard deviation 0.20559.", "error": "", "parent_ids": ["d715f9fb-38d4-42a9-982e-9f6ffad686d0"], "operator": null, "metadata": {"aucs": [0.4867052575073658, 0.4899752603980603, 0.05439664936379485, 0.4787506105342587, 0.48205809841690406, 0.040546589906527486, 0.4625391671160044, 0.41075301878768633, 0.011402995242851266]}}
{"id": "94bd2289-061a-44d0-b3b5-c20098b1dd6c", "fitness": 0.484848565913894, "name": "AdaptiveDifferentialEvolution", "description": "Refine Adaptive Differential Evolution by altering parameter adaptation to improve convergence dynamics.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)  # Adjusted diversity factor\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48485 with standard deviation 0.08835.", "error": "", "parent_ids": ["d715f9fb-38d4-42a9-982e-9f6ffad686d0"], "operator": null, "metadata": {"aucs": [0.46001925221183804, 0.4975743604981162, 0.6059223963174557, 0.45203487146286836, 0.4145650988534101, 0.5998531787197798, 0.3666085521094423, 0.37963887272147123, 0.5874205103306651]}}
{"id": "857d0951-d47e-4b3c-997e-f3df7c3ddafd", "fitness": 0.5330344664508471, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the crossover rate based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53303 with standard deviation 0.07797.", "error": "", "parent_ids": ["94bd2289-061a-44d0-b3b5-c20098b1dd6c"], "operator": null, "metadata": {"aucs": [0.44434353038575314, 0.6216027151099657, 0.6275048662491093, 0.43611047867768815, 0.6155970639638391, 0.5538905388104981, 0.4188864902467656, 0.5522285837121774, 0.5271459309018267]}}
{"id": "b33ce1a3-cfa8-47dc-8a5d-26ded71ebf49", "fitness": 0.026016514157409205, "name": "AdaptiveDifferentialEvolution", "description": "Improve adaptability by dynamically tuning the mutation factor based on both population diversity and fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * fitness_variance * 0.15)  # Modified to consider both diversity and variance\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02602 with standard deviation 0.01806.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04504188372634721, 0.04504739270427871, 0.04515709502105103, 0.031069162131373673, 0.031028733374988904, 0.03151451722361065, 0.0016560908705499644, 0.0016396985156998944, 0.0019940538487828174]}}
{"id": "64188236-c59e-4af9-b69c-e9addd2c093d", "fitness": 0.14699094276007674, "name": "AdaptiveDifferentialEvolution", "description": "Improved convergence by decaying the mutation factor dynamically over generations.  ", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 - generation / self.budget)  # Decaying mutation factor\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14699 with standard deviation 0.15916.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04683884821722695, 0.10035404589254215, 0.3870345039736113, 0.03210520533141825, 0.03428621574094781, 0.3756291983709643, 0.0020315923597621355, 0.002504643556986874, 0.3421342313972311]}}
{"id": "79e67821-ff66-482d-82ef-0338348b203d", "fitness": 0.027042766606609994, "name": "AdaptiveDifferentialEvolution", "description": "Introduce fitness variance influence on mutation factor to adapt its strategy for diverse exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 + fitness_variance * 0.01)  # Added fitness_variance influence here\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 11, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02704 with standard deviation 0.01872.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04917163797144797, 0.046563191290142414, 0.04492998468101239, 0.03375318548360495, 0.03191034780229429, 0.03098804661679022, 0.0025231547172193114, 0.0019405922456277036, 0.0016047586513506795]}}
{"id": "241225b8-82d2-4f79-aa54-84137555190f", "fitness": 0.025992369515778595, "name": "AdaptiveDifferentialEvolution", "description": "Improve convergence by adjusting the mutation factor based on fitness variance and diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15 + fitness_variance * 0.05)  # Adjusted mutation factor\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02599 with standard deviation 0.01810.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04496361731834486, 0.04526308779137311, 0.04504684202103215, 0.031010389499551372, 0.03110890396722188, 0.03147102575506022, 0.0016082115725711832, 0.0016564651763870675, 0.0018027825404655085]}}
{"id": "cdf82384-06ba-4449-889f-04e15fab8a86", "fitness": 0.07171076364200162, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the mutation factor using both generation number and population diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.18)  # Adjusted factor\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07171 with standard deviation 0.06707.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04499061300789087, 0.04504441115946345, 0.18000819511928257, 0.031028648672537962, 0.031064658164101644, 0.16775463473444807, 0.001622208632902855, 0.0016376756639322476, 0.14224582762345483]}}
{"id": "0d607d38-ea0e-486b-b2d9-5d325ea7d50a", "fitness": 0.0270658432463914, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adapting the mutation factor using both population diversity and fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15 + fitness_variance * 0.01)  # Change made here\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02707 with standard deviation 0.01835.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04496624461443455, 0.04771344701555469, 0.046754607136687554, 0.03139736352862221, 0.03300263203043097, 0.03229565342276486, 0.0016294868613954128, 0.0033666533971951074, 0.002466501210437233]}}
{"id": "494e5526-1998-4f7a-bc54-3606539fa3bf", "fitness": 0.07521001158470858, "name": "AdaptiveDifferentialEvolution", "description": "Improve adaptation by slightly increasing the influence of population diversity in mutation factor adjustment.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.17)  # Changed multiplier from 0.15 to 0.17\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07521 with standard deviation 0.07172.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04493926396002457, 0.06048015427144027, 0.20581230748896617, 0.030994263260750055, 0.03961704911876118, 0.1940592453177563, 0.0016074316491283547, 0.004768211440992043, 0.09461217775455821]}}
{"id": "be0a87e0-abbd-4a05-9da5-9eabe60c82e0", "fitness": 0.18318491428675485, "name": "AdaptiveDifferentialEvolution", "description": "Incorporate exponential decay into the mutation factor to potentially enhance convergence speed.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * np.exp(-0.005 * generation)  # Exponential decay added\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18318 with standard deviation 0.15017.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.2905108530751537, 0.045041006678942286, 0.4513183670735884, 0.279991091700287, 0.031062374506325208, 0.031411121464183234, 0.24289809466299117, 0.0016366923601183192, 0.2747946270592042]}}
{"id": "65666362-5484-44f0-ae0b-7b621acd17a6", "fitness": 0.3725236722421529, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a minor adjustment to dynamically refine the mutation factor by incorporating a small adaptive perturbation in relation to generation and diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15 + 0.05 * np.random.rand())  # Introduced adaptive perturbation\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 17, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37252 with standard deviation 0.27639.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.4528578011443736, 0.7285901044960945, 0.04494385062234363, 0.37983241828830183, 0.715755092234043, 0.030997336281412546, 0.3526334621332077, 0.6454942319154093, 0.0016087530641897274]}}
{"id": "a4bfa0e5-0ba2-4117-8477-e98845b7cf0b", "fitness": 0.02598006980311794, "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation factor adjustment using generation and fitness diversity to improve convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = 0.5 + 0.4 * np.sin(0.4 * generation) * (1 - fitness_variance * 0.05)  # Adjusted mutation factor\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02598 with standard deviation 0.01812.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04540503513647931, 0.04495378076468137, 0.044936648906626964, 0.031605393384164904, 0.031003968951601735, 0.03099251327882624, 0.0017031990639285732, 0.0016134065032145095, 0.001606682238537882]}}
{"id": "5dd6de80-bd59-4764-8cb0-2e0ea3407001", "fitness": 0.026192210691784828, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by adjusting the mutation factor based on both fitness variance and exploration tendency.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15 + fitness_variance * 0.02)  # Adjusted with exploration tendency\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 19, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02619 with standard deviation 0.01822.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.0449266275037028, 0.04632260562362034, 0.04516701153795355, 0.030985797138612048, 0.031909863919263204, 0.03114609222173692, 0.00160379126379806, 0.0019957478991508015, 0.0016723591182257191]}}
{"id": "ffec54cb-31af-40b8-b8da-28996fb7af0e", "fitness": 0.2521682798850517, "name": "AdaptiveDifferentialEvolution", "description": "Optimize search space exploration by slightly increasing mutation factor adaptively based on population diversity.  ", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.2)  # Slightly increased factor\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 20, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25217 with standard deviation 0.17740.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.044959602833178014, 0.2919823643113293, 0.4741773434327651, 0.031007884776841466, 0.2812584370463048, 0.46553963231273887, 0.001613286320238494, 0.24976748653191827, 0.42920848140015067]}}
{"id": "22b7f2a0-cf94-4955-99a4-b4bf05cdf5e6", "fitness": 0.30291778381803325, "name": "AdaptiveDifferentialEvolution", "description": "Improve mutation factor adaptation by adding population diversity influence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        # Change in line below to improve mutation adaptation: add population diversity influence\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01) * (1 + population_diversity * 0.05)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 21, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30292 with standard deviation 0.16978.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.08977372395415373, 0.39892816749894566, 0.48714182820735497, 0.07631280292675224, 0.3722478348886764, 0.4710136841666398, 0.048113730886711226, 0.33726564228800004, 0.44546263954506515]}}
{"id": "2976e679-db09-407e-90b7-08887e63a375", "fitness": 0.2889368325725416, "name": "AdaptiveDifferentialEvolution", "description": "Introduce random perturbation in the mutation factor to enhance exploration capabilities.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) + np.random.normal(0, 0.05) # Added random perturbation\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28894 with standard deviation 0.19117.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.44811099774564445, 0.04493223605487906, 0.47923311709320815, 0.3676405631310917, 0.030989555255976797, 0.4574612272014963, 0.3323432153680984, 0.0016054074934731544, 0.4381151738090062]}}
{"id": "3849d193-3f43-4cb5-9ca1-300232f35266", "fitness": 0.3353962326929121, "name": "AdaptiveDifferentialEvolution", "description": "Improve convergence by incorporating a dynamic elitism mechanism to retain top individuals across generations.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n        self.elitism_rate = 0.1  # Added elitism rate for retaining top individuals\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def elitism_selection(self):\n        elite_count = int(self.elitism_rate * self.population_size)\n        elite_indices = np.argsort(self.fitness)[:elite_count]\n        return self.population[elite_indices], self.fitness[elite_indices]\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            elite_population, elite_fitness = self.elitism_selection()\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n            # Re-combine population with elites\n            self.population = np.vstack((elite_population, self.population[len(elite_population):]))\n            self.fitness = np.concatenate((elite_fitness, self.fitness[len(elite_fitness):]))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33540 with standard deviation 0.18147.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.566502632233678, 0.12891222193218643, 0.3563665050775888, 0.5598504949410485, 0.11457384722212827, 0.3468873773378178, 0.5319226563336314, 0.08655756422769934, 0.32699279493043]}}
{"id": "d91d9fae-df01-4626-b229-2d5ac83ddbbf", "fitness": 0.02589882640691585, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the mutation factor based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + fitness_variance * 0.15)  # Adjusted mutation factor with fitness variance\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 24, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02590 with standard deviation 0.01809.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04511195513959698, 0.04501699416074045, 0.045002344368145764, 0.03099477203137435, 0.031025073471217746, 0.031031134581319675, 0.0016199961492299186, 0.0016476614489335795, 0.0016395063116841913]}}
{"id": "6b1ac38f-178f-4487-9a6e-c746ea397ca7", "fitness": 0.025841266704574636, "name": "AdaptiveDifferentialEvolution", "description": "Improve adaptability by dynamically adjusting the mutation factor based on current fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 - np.mean(self.fitness) / np.max(self.fitness))  # Change made here\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02584 with standard deviation 0.01806.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04496142088876087, 0.04491740133648958, 0.0449171804220132, 0.031013143466301685, 0.030979613061633327, 0.030979466841300707, 0.0016009779886424491, 0.001601127552140369, 0.0016010687838895477]}}
{"id": "c96fab4d-a711-4173-8c41-fff13c52e240", "fitness": 0.025859290709020252, "name": "AdaptiveDifferentialEvolution", "description": "Improve the adaptation strategy by factoring in both diversity and mean fitness to adjust parameters more effectively.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        mean_fitness = np.mean(self.fitness)  # Changed from fitness_variance to mean_fitness\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + mean_fitness * 0.01)  # Adjusted with mean fitness\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 26, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02586 with standard deviation 0.01807.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04494128041764611, 0.044928128916196686, 0.045003334204148926, 0.031023789524095013, 0.031003810331512005, 0.031019208632005912, 0.0016088643130252045, 0.0016026795362211743, 0.0016025205063312509]}}
{"id": "85a20421-cce8-4235-966d-bdec76ca78ee", "fitness": 0.027314659435015196, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting both the mutation factor and crossover rate based on fitness variance and population diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02731 with standard deviation 0.01894.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.044928983855418325, 0.04505319237066563, 0.052083202159601605, 0.030987376053288607, 0.031070209105710345, 0.03523202335132436, 0.0016044702955886336, 0.0016398994890187701, 0.0032325782345205]}}
{"id": "83a5ada2-f421-4a87-8e9b-ea737c7bb4a5", "fitness": 0.027042766606609994, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting both crossover rate and mutation factor based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02704 with standard deviation 0.01872.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04917163797144797, 0.046563191290142414, 0.04492998468101239, 0.03375318548360495, 0.03191034780229429, 0.03098804661679022, 0.0025231547172193114, 0.0019405922456277036, 0.0016047586513506795]}}
{"id": "68609a29-5424-47b4-9c7c-79bf6c179a7f", "fitness": 0.025832986889202374, "name": "AdaptiveDifferentialEvolution", "description": "Refine the mutation strategy by introducing a dynamic mutation factor based on generation progress.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        dynamic_factor = 0.5 + (0.5 * (self.budget / self.population_size))  # Changed line\n        mutant = parents[0] + dynamic_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02583 with standard deviation 0.01805.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04491755659483232, 0.04491832145686592, 0.04491757026975185, 0.030979718780108634, 0.03098023134014083, 0.03097972794446524, 0.0016011770722571539, 0.0016013975302794359, 0.00160118101411999]}}
{"id": "b81a986e-ff22-4e06-9f74-8ce7485650f9", "fitness": 0.5330344664508471, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting the mutation factor based on generation progress.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53303 with standard deviation 0.07797.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.44434353038575314, 0.6216027151099657, 0.6275048662491093, 0.43611047867768815, 0.6155970639638391, 0.5538905388104981, 0.4188864902467656, 0.5522285837121774, 0.5271459309018267]}}
{"id": "c0d21f47-f324-4230-a7c5-ef4af33848ee", "fitness": 0.027042766606609994, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by integrating a dynamic mutation factor based on fitness variance and diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02704 with standard deviation 0.01872.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04917163797144797, 0.046563191290142414, 0.04492998468101239, 0.03375318548360495, 0.03191034780229429, 0.03098804661679022, 0.0025231547172193114, 0.0019405922456277036, 0.0016047586513506795]}}
{"id": "124e18a2-e2bd-4526-ad0d-7da4cc7e7a0e", "fitness": 0.2521682798850517, "name": "AdaptiveDifferentialEvolution", "description": "Refine convergence by incorporating population diversity directly into the mutation factor adjustment.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.2)  # Adjusted with increased population diversity effect\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25217 with standard deviation 0.17740.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.044959602833178014, 0.2919823643113293, 0.4741773434327651, 0.031007884776841466, 0.2812584370463048, 0.46553963231273887, 0.001613286320238494, 0.24976748653191827, 0.42920848140015067]}}
{"id": "ce59a845-fe49-484b-87d6-5224755ec80c", "fitness": 0.02589882640691585, "name": "AdaptiveDifferentialEvolution", "description": "Improve convergence by adapting the mutation factor based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + fitness_variance * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 33, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02590 with standard deviation 0.01809.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04511195513959698, 0.04501699416074045, 0.045002344368145764, 0.03099477203137435, 0.031025073471217746, 0.031031134581319675, 0.0016199961492299186, 0.0016476614489335795, 0.0016395063116841913]}}
{"id": "dfd86735-f91a-4fc4-a71f-43d4e86f36b3", "fitness": 0.027042766606609994, "name": "AdaptiveDifferentialEvolution", "description": "Improve parameter adaptation by integrating fitness variance into mutation factor calculation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)  # Added fitness variance consideration\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 + fitness_variance * 0.01)  # Integrated fitness variance\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)  # Adjusted with fitness variance\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 34, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02704 with standard deviation 0.01872.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.04917163797144797, 0.046563191290142414, 0.04492998468101239, 0.03375318548360495, 0.03191034780229429, 0.03098804661679022, 0.0025231547172193114, 0.0019405922456277036, 0.0016047586513506795]}}
{"id": "90525010-8002-410d-a2b3-3c73672d8609", "fitness": 0.6070363967853658, "name": "AdaptiveDifferentialEvolution", "description": "Refine Adaptive Differential Evolution by introducing adaptive population size based on early convergence detection.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 35, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60704 with standard deviation 0.09766.", "error": "", "parent_ids": ["857d0951-d47e-4b3c-997e-f3df7c3ddafd"], "operator": null, "metadata": {"aucs": [0.7463458192182907, 0.6216027151099657, 0.5059674506249221, 0.725560308137605, 0.6155970639638391, 0.49837243308481427, 0.7148936277094569, 0.5522285837121774, 0.48275956950722176]}}
{"id": "bf793512-3767-461a-a3c5-645b509fe9e6", "fitness": 0.3724751303254059, "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic mutation and crossover rates based on fitness improvement to enhance convergence adaptability.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            self.mutation_factor = max(0.4, self.mutation_factor - 0.02)  # Reduced mutation factor on improvement\n            self.crossover_rate = min(0.9, self.crossover_rate + 0.02)   # Increased crossover rate on improvement\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37248 with standard deviation 0.13264.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.2474967362696987, 0.5782354336266081, 0.3789508174613625, 0.23573841106478965, 0.5322560479633227, 0.3696327082964408, 0.19647133522885518, 0.5134895669565935, 0.30000511606098235]}}
{"id": "30ff8d83-fff5-4f58-9baf-9c2a954348ff", "fitness": 0.025832911535847533, "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation factor adaptively based on fitness improvement to improve exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 + np.mean(self.fitness) / 100.0)  # Modified line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02583 with standard deviation 0.01805.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.044917266716225646, 0.04491816440720242, 0.04491748689594366, 0.03097972153256401, 0.030980033236429838, 0.030979672072792397, 0.001601175030369384, 0.0016016212573247701, 0.0016010626737756883]}}
{"id": "1d438f01-0e3b-4a15-ad27-25ab1f781790", "fitness": 0.5871127529062555, "name": "AdaptiveDifferentialEvolution", "description": "Improve adaptive parameters by introducing exponential decay for mutation factor and crossover rate.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = 0.5 * np.exp(-0.1 * generation / self.budget)  # Changed line\n        self.crossover_rate = 0.7 * np.exp(-0.05 * generation / self.budget)  # Changed line\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 38, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.58711 with standard deviation 0.12914.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.4887561271357963, 0.8012073575006115, 0.5358547717893901, 0.4766996325943593, 0.7563323982264483, 0.5290344037621395, 0.45966023214473617, 0.7398455817412406, 0.49662427126157804]}}
{"id": "09c6a37c-60e1-4ca5-839d-6af33c6d32b4", "fitness": 0.3186832616481102, "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by incorporating a random scaling factor for increased diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        random_scaling = np.random.uniform(0.4, 0.6)  # Add a random scaling factor\n        mutant = parents[0] + random_scaling * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31868 with standard deviation 0.18758.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.1942939963188376, 0.2408649776919436, 0.5998927641325196, 0.18248681896374563, 0.22341568244050325, 0.5741217421721496, 0.09351548005974764, 0.19947939711696716, 0.5600784959365779]}}
{"id": "2500771c-aebe-493c-9e8a-bd81351c7121", "fitness": 0.08511304521744854, "name": "AdaptiveDifferentialEvolution", "description": "Enhance Adaptive Differential Evolution by introducing dynamic scaling of mutation and crossover rates based on population diversity and fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        improvement_rate = (np.mean(self.fitness) - np.min(self.fitness)) / np.mean(self.fitness)\n        \n        self.mutation_factor = 0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)\n        self.mutation_factor *= (1 + population_diversity * 0.2)\n        \n        self.crossover_rate = 0.6 + 0.25 * np.cos(0.3 * generation)\n        self.crossover_rate *= (1 + fitness_variance * 0.02) * (1 + improvement_rate * 0.1)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 40, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08511 with standard deviation 0.05069.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.04606559424779155, 0.15894920003084057, 0.1292724004527327, 0.031741647806966866, 0.14666398309946982, 0.10422743049492345, 0.0019253026689297625, 0.07103790075957939, 0.07613394739580281]}}
{"id": "baa013ff-a2d8-4bf8-927b-b18c894d7188", "fitness": 0.2039684374506448, "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic scaling of mutation factor based on convergence rate to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                self.mutation_factor *= 1.05 if np.std(self.fitness) > 0.1 else 0.95  # Dynamic scaling based on fitness std\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 41, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20397 with standard deviation 0.13176.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.27185626413341646, 0.04492729668289863, 0.37420740399193353, 0.2598852891086111, 0.030986245587611427, 0.3206129698705348, 0.23346102033786453, 0.0016039841516068964, 0.2981754631913257]}}
{"id": "01b350aa-e421-46f1-86b7-16e430e66786", "fitness": 0.5067207153053699, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution by incorporating a dynamic scaling mechanism for mutation and crossover rates based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Dynamic scaling mechanism\n        if generation > 5:\n            recent_improvement = np.ptp(self.fitness[-10:]) if len(self.fitness) > 10 else np.ptp(self.fitness)\n            scaling_factor = 1.0 + (recent_improvement / np.max(self.fitness)) * 0.1\n            self.mutation_factor *= scaling_factor\n            self.crossover_rate *= scaling_factor\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 42, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50672 with standard deviation 0.25552.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.7342271411423964, 0.72526579450202, 0.05629203123459592, 0.6778834172057585, 0.6227385935338672, 0.06969783682946296, 0.6771462203959129, 0.6041512359192244, 0.39308416698509085]}}
{"id": "f4a6b942-aec9-40eb-b1e6-8e2663fa4004", "fitness": 0.5330344664508471, "name": "AdaptiveDifferentialEvolution", "description": "Enhance Adaptive Differential Evolution by refining the convergence criteria for adaptive parameter adjustment.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.mean(self.fitness[-5:]) < 0.1:  # Changed line 1\n            self.population_size = max(10, self.population_size - 1)  # Changed line 2\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53303 with standard deviation 0.07797.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.44434353038575314, 0.6216027151099657, 0.6275048662491093, 0.43611047867768815, 0.6155970639638391, 0.5538905388104981, 0.4188864902467656, 0.5522285837121774, 0.5271459309018267]}}
{"id": "d9021ea6-79d7-4aa6-9529-043a2e5f6cd0", "fitness": 0.43319377428097333, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by incorporating strategy adaptation and dynamic parameters adjustment.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n        # Enhanced strategy adaptation\n        if fitness_variance < 0.05:\n            self.mutation_factor *= 1.1\n            self.crossover_rate *= 0.9\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 44, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43319 with standard deviation 0.04113.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.39373992086941345, 0.46902492249409933, 0.47967442375524916, 0.3804714177243441, 0.45445527879294023, 0.47089408208009886, 0.36144993323259134, 0.43535990461095, 0.45367408496907324]}}
{"id": "801a14bf-c7a0-4ca2-9bd9-399448fdf156", "fitness": 0.3960754336672366, "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic mutation factor adjustment based on generation to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        # Changed line: Adjust mutation factor for better exploration-exploitation balance.\n        self.mutation_factor = 0.3 + 0.2 * np.exp(-0.01 * generation) * (1 + population_diversity * 0.15) \n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 45, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39608 with standard deviation 0.28747.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.04494466710193468, 0.7355813664884727, 0.4478420862822098, 0.030997883865797493, 0.7283362428145408, 0.43962216087116324, 0.0016089888024147792, 0.7132815177270071, 0.42246398905158844]}}
{"id": "d82cce9c-18d3-4ac0-8cf2-aa36b3390683", "fitness": 0.3186832616481102, "name": "AdaptiveDifferentialEvolution", "description": "Enhance the mutation strategy by diversifying the scaling factor for each individual.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        # Change: Diversify scaling factor for each individual\n        individual_factor = np.random.uniform(0.4, 0.6)\n        mutant = parents[0] + individual_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 46, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31868 with standard deviation 0.18758.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.1942939963188376, 0.2408649776919436, 0.5998927641325196, 0.18248681896374563, 0.22341568244050325, 0.5741217421721496, 0.09351548005974764, 0.19947939711696716, 0.5600784959365779]}}
{"id": "97424d33-d19a-462f-9d6a-bcbf353e1640", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Improve Adaptive Differential Evolution by integrating population clustering and dynamic parameter tuning for enhanced exploitation-exploration balance.", "code": "import numpy as np\nfrom sklearn.cluster import KMeans\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n        self.max_clusters = 5\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self, cluster_labels, target_idx):\n        cluster_members = np.where(cluster_labels == cluster_labels[target_idx])[0]\n        idxs = np.random.choice(cluster_members, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        self.mutation_factor += 0.001 * np.sin(generation)\n        self.crossover_rate -= 0.005 * np.cos(generation)\n\n    def cluster_population(self):\n        kmeans = KMeans(n_clusters=min(self.max_clusters, self.population_size // 2)).fit(self.population)\n        return kmeans.labels_\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n            cluster_labels = self.cluster_population()\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents(cluster_labels, i)\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 47, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {}}
{"id": "ad9d758c-5100-4e92-bd8c-ebbf834581a4", "fitness": 0.3361089552677882, "name": "AdaptiveDifferentialEvolution", "description": "Enhance the Adaptive Differential Evolution by introducing a dynamic crossover selection mechanism based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        \n        # Dynamic crossover rate based on fitness variance\n        self.crossover_rate = 0.6 + 0.4 * (1 - np.tanh(fitness_variance))\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 48, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33611 with standard deviation 0.22009.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.044953961491240535, 0.5076197798670119, 0.5092190545569923, 0.031004109798211665, 0.487000334691456, 0.5011447343683633, 0.0016116653788289526, 0.45839694831144784, 0.48403000894654147]}}
{"id": "65f09cd8-8ae6-4bd3-a19d-832888610430", "fitness": 0.6070363967853658, "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation diversity by adjusting the mutation factor based on population variance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 49, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60704 with standard deviation 0.09766.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.7463458192182907, 0.6216027151099657, 0.5059674506249221, 0.725560308137605, 0.6155970639638391, 0.49837243308481427, 0.7148936277094569, 0.5522285837121774, 0.48275956950722176]}}
{"id": "97740f46-f090-452d-b10d-9d06c1b08fff", "fitness": 0.33954501141896487, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive strategies by dynamically adjusting crossover rate to improve exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n            # Enhance exploration with dynamic crossover rate adjustment\n            self.crossover_rate = 0.5 + np.random.rand() * 0.4\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 50, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33955 with standard deviation 0.26987.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.6950760855056677, 0.04493327934902358, 0.3246457751286653, 0.6904927757148962, 0.030990254181932353, 0.3119729719248424, 0.6655933096103126, 0.001605707999875472, 0.2905949433554681]}}
{"id": "024392e1-9331-4f4e-83ba-f15a75fc0c67", "fitness": 0.6070363967853658, "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration by dynamically adjusting mutation factor and introducing a random restart mechanism when stagnation is detected.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n\n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n            # Random restart mechanism\n            if np.std(self.fitness) < 0.01:\n                self.initialize_population()\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 51, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60704 with standard deviation 0.09766.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.7463458192182907, 0.6216027151099657, 0.5059674506249221, 0.725560308137605, 0.6155970639638391, 0.49837243308481427, 0.7148936277094569, 0.5522285837121774, 0.48275956950722176]}}
{"id": "7b6ca941-6176-47c5-897f-c1e7812ff950", "fitness": 0.6070363967853658, "name": "AdaptiveDifferentialEvolution", "description": "Enhance Adaptive Differential Evolution by dynamically adapting the mutation factor based on fitness improvements.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n        \n        # Dynamically adjust mutation factor based on fitness improvement\n        if generation > 1 and np.min(self.fitness) < np.min(self.fitness) * 0.95:\n            self.mutation_factor *= 1.1\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 52, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60704 with standard deviation 0.09766.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.7463458192182907, 0.6216027151099657, 0.5059674506249221, 0.725560308137605, 0.6155970639638391, 0.49837243308481427, 0.7148936277094569, 0.5522285837121774, 0.48275956950722176]}}
{"id": "c63ad32c-55e4-44ff-b356-ae9ef8aa3031", "fitness": 0.6070363967853658, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive conditions by considering population fitness diversity to refine convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        fitness_diversity = np.std(self.fitness)  # New line added\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and fitness_diversity < 0.1:  # Modified line\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 53, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60704 with standard deviation 0.09766.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.7463458192182907, 0.6216027151099657, 0.5059674506249221, 0.725560308137605, 0.6155970639638391, 0.49837243308481427, 0.7148936277094569, 0.5522285837121774, 0.48275956950722176]}}
{"id": "4465b7d6-967f-40f2-ba04-3956e83bcbfb", "fitness": 0.23935334803550912, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive parameter adjustment by incorporating a dampening factor for smoother transition.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        dampening_factor = 0.05  # New line: added dampening factor\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15) * (1 - dampening_factor)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01) * (1 - dampening_factor)  # Modified line: added dampening factor\n\n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 54, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23935 with standard deviation 0.15427.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.045670055947777066, 0.4018753614442505, 0.32805230781633354, 0.031481946459004706, 0.3926281039300845, 0.3174826102430146, 0.0018161833036112185, 0.3389619057059019, 0.2962116574696041]}}
{"id": "e39d2424-1a19-48a5-bf64-b6024d32eb4a", "fitness": 0.19310578940530673, "name": "AdaptiveDifferentialEvolution", "description": "Enhance convergence by dynamically adjusting mutation factor with population diversity and shift crossover strategy.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        diversity_factor = np.std(self.population)\n        mutant = parents[0] + (self.mutation_factor + 0.1 * diversity_factor) * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(mutant)  # Directly use mutant during crossover\n        for j in range(self.dim):\n            if np.random.rand() >= self.crossover_rate:\n                trial[j] = target[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 55, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19311 with standard deviation 0.14625.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.3999037486564937, 0.23292913703228435, 0.045786560581094427, 0.39060141967266504, 0.16401929285443084, 0.031533383458585584, 0.33636725467136663, 0.13498407678802526, 0.0018272309328145608]}}
{"id": "ea52ebf3-8547-4137-a0a3-43a55dca9da3", "fitness": 0.5034834945600544, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic crossover rate adaptation based on population diversity to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + population_diversity * 0.1)  # Changed line\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 56, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50348 with standard deviation 0.20910.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.7980526403894532, 0.42021757164976603, 0.332075608016006, 0.795048839136894, 0.4087937015060078, 0.3195200539406281, 0.7887756118058475, 0.3793717195272225, 0.2894957050686635]}}
{"id": "5fcaa50b-4696-4bcb-aef3-5f45aedf0277", "fitness": 0.23591369789652195, "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic selection of crossover points to enhance exploration capabilities of the algorithm.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        crossover_points = np.random.choice(range(self.dim), size=np.random.randint(1, self.dim), replace=False)\n        for j in crossover_points:\n            trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 57, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23591 with standard deviation 0.14619.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.35318370493954065, 0.36641313857416125, 0.05953998675438843, 0.3431922346426992, 0.33316758403798674, 0.032103270391333205, 0.3227920978650969, 0.3109381991269702, 0.0018930647365211772]}}
{"id": "10cf95d4-97eb-4e4f-9870-11004b2f232a", "fitness": 0.4528627515762995, "name": "AdaptiveDifferentialEvolution", "description": "Improve search efficiency by increasing crossover intensity dynamically based on fitness improvements.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        # Increased crossover intensity based on fitness improvement\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + (1 - np.std(self.fitness)/np.mean(self.fitness)) * 0.05)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 58, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45286 with standard deviation 0.16634.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.42528485957162177, 0.6887932202521974, 0.3072669145730831, 0.4168390636785094, 0.6952346288464037, 0.2910224491852045, 0.35523963610831155, 0.6424628306006752, 0.2536211613706888]}}
{"id": "1211dc40-6739-4667-aaea-8a4a735b29f5", "fitness": 0.4109436700171798, "name": "AdaptiveDifferentialEvolution", "description": "Improve AdaptiveDifferentialEvolution by introducing a dynamic crossover rate based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n        self.last_mean_fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.last_mean_fitness = np.inf\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        mean_fitness = np.mean(self.fitness)\n        fitness_improvement = self.last_mean_fitness - mean_fitness\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.5 + 0.2 * np.tanh(fitness_improvement) * (1 + fitness_variance * 0.01)\n        self.last_mean_fitness = mean_fitness\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 59, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41094 with standard deviation 0.21512.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.2004344253010022, 0.3723081494848708, 0.7043194026842002, 0.18831510132362317, 0.36103055718875676, 0.6997001187990702, 0.1472075849932376, 0.34089674022023586, 0.6842809501596211]}}
{"id": "6b264d16-21b6-42b4-b579-27f3bc29d1b2", "fitness": 0.26808574065324936, "name": "AdaptiveDifferentialEvolution", "description": "Refine Adaptive Differential Evolution by modifying mutation factor adaptation to enhance exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.3)  # Modified line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26809 with standard deviation 0.21709.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.25271631169921815, 0.5601480880124865, 0.045697174586232014, 0.2416692106633057, 0.5533145075656279, 0.03149956077378857, 0.18655225383381213, 0.5393510709139266, 0.0018234878308467373]}}
{"id": "4c738046-7225-4dd0-bedd-7c3230c387dd", "fitness": 0.025617083225639666, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance Adaptive Differential Evolution by integrating Lvy Flights for exploration and dynamic adaptation of crossover and mutation strategies.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def levy_flight(self, L):\n        return np.power(np.random.normal(0, 1), -1 / L)\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2]) + self.levy_flight(1.5)\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n        \n        # Dynamic crossover and mutation adaptation\n        if generation % 3 == 0:\n            self.crossover_rate = np.random.uniform(0.5, 0.9)\n            self.mutation_factor = np.random.uniform(0.4, 0.9)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02562 with standard deviation 0.01806.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.04470702055902476, 0.04470619216299021, 0.04470624956161673, 0.030765506936275, 0.03076495180406913, 0.03076499026875046, 0.0013797662425614199, 0.001379527475697806, 0.0013795440197714726]}}
{"id": "f780954f-f261-497d-b951-b393a668ca07", "fitness": 0.19126479048833275, "name": "AdaptiveDifferentialEvolution", "description": "Enhance Adaptive Differential Evolution by incorporating a fitness-based adaptive mutation factor and enhanced early convergence detection.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = max(0.4, min(0.9, 0.5 + 0.2 * np.tanh(fitness_variance)))  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Enhanced early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.05:  # Changed line\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19126 with standard deviation 0.22061.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.04493855197841545, 0.0478885686442827, 0.5350636723520728, 0.031172077765917128, 0.03156232665996528, 0.5282127212892836, 0.0016131357406623525, 0.0631215343120578, 0.43781052565233736]}}
{"id": "2269588c-617b-4f89-94cf-de0f59771f3a", "fitness": 0.7181902114228922, "name": "AdaptiveDifferentialEvolution", "description": "Enhance the mutation strategy by incorporating a dynamic mutation factor based on generation count for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        # Adjust the mutation factor here\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.01)\n        \n        # Adaptive population size based on early convergence detection\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71819 with standard deviation 0.07448.", "error": "", "parent_ids": ["90525010-8002-410d-a2b3-3c73672d8609"], "operator": null, "metadata": {"aucs": [0.7931186883848238, 0.7790421982103715, 0.6268108466313516, 0.7899001287068074, 0.7751393280552312, 0.6213603734309279, 0.7007089455343449, 0.7677556179992717, 0.6098757758528999]}}
{"id": "92ae521d-1464-4b80-91d0-e3c119fac239", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive mechanism by refining parameter adaptation based on population diversity and fitness variance for more efficient exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)  # Changed line\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 64, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["2269588c-617b-4f89-94cf-de0f59771f3a"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "784c1d56-6a64-47e9-84a8-d99aec23c2eb", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Further enhance mutation factor adaptation using dynamic generation-based scaling to improve exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1)) * (1 - (generation / (self.budget + 1)))  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 65, "feedback": "An exception occurred: NameError(\"name 'generation' is not defined\").", "error": "NameError(\"name 'generation' is not defined\")", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {}}
{"id": "891805f5-cf13-414a-8728-8b1b50f00e19", "fitness": 0.2137555327064793, "name": "AdaptiveDifferentialEvolution", "description": "Adjust mutation factor scaling to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.6 * (self.budget / (self.budget + 1))  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21376 with standard deviation 0.26619.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.5977991800833042, 0.044938837897555595, 0.04493060379867586, 0.5918232057946046, 0.030993978487312557, 0.030988461534006584, 0.5791132801026624, 0.0016073095355014777, 0.0016049371246903421]}}
{"id": "528eeb19-ec9d-403f-ac78-63e611403f04", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive mutation and crossover strategies by incorporating a dynamic feedback mechanism based on fitness improvement trends to optimize exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                if self.fitness[i] < np.mean(self.fitness):  # New line\n                    self.mutation_factor *= 1.02  # New line\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "a6825762-9747-4f69-8a7f-96620aa24385", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Slightly enhance the mutation factor adaptation by incorporating a dynamic element based on fitness improvement.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1 + 0.01 * np.exp(-fitness_variance))  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "e80c0961-bcfc-4e21-a291-75249856630a", "fitness": 0.6031509590819789, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive mechanism by refining parameter adaptation based on population diversity and fitness variance for more efficient exploration, with boosted diversity through random restart.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n            if generation % 10 == 0:  # Changed line\n                self.initialize_population()  # Random restart to boost diversity\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 69, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60315 with standard deviation 0.13479.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.5508303841051818, 0.5134415578205789, 0.8104373984799406, 0.5422420833546783, 0.47715248230277185, 0.8074887068124565, 0.527975544276823, 0.4531966674542818, 0.7455938071310967]}}
{"id": "b942b712-7418-4cb7-b4fb-3ce65e96e4df", "fitness": 0.03129559803853399, "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adaptation of mutation factor based on the ratio of successful trials to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n        self.successful_trials = 0\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        # Changed line: Dynamic adaptation of mutation factor\n        self.mutation_factor = 0.5 + 0.5 * (self.successful_trials / (self.population_size + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n            self.successful_trials += 1  # Changed line: Increase successful trial count\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n            self.successful_trials = 0  # Reset successful trials for each generation\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 70, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03130 with standard deviation 0.02658.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.04495660799164902, 0.044949961477431466, 0.08942857012671934, 0.031005876580939784, 0.03100143041826109, 0.03463252332905886, 0.0016124219631035164, 0.0016105879434579196, 0.002462402516184903]}}
{"id": "d4debccb-afc7-4857-bed7-06378ba117d4", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive mechanism by further refining parameter adaptation based on more sensitive adjustments for dynamic exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget) + np.tanh(fitness_variance * 0.05)) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 71, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "f3df7813-b443-41f8-89ac-4b63cd9e4edc", "fitness": 0.45689412874500207, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic reduction in population size to balance exploration and exploitation based on convergence speed and diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - (1 if np.std(self.population) < 0.05 else 0))  # Changed line\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45689 with standard deviation 0.16202.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.3700668969659292, 0.3674552530655404, 0.739170845382183, 0.3597980099085917, 0.35787403707779397, 0.6602497901627518, 0.27762719531848945, 0.33804318319844284, 0.641761947625296]}}
{"id": "97bec60b-ef8d-4eb1-b1bb-e72cfd83f5e0", "fitness": 0.560450150316498, "name": "AdaptiveDifferentialEvolution", "description": "Further enhance parameter adaptation by introducing a dynamic crossover rate scaling based on fitness improvement rate.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02) + 0.05 * (np.max(self.fitness) - np.min(self.fitness))  # Changed line\n\n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56045 with standard deviation 0.23761.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7326436631779721, 0.7448395633532792, 0.24174064337337942, 0.7256664966144868, 0.7314219217100608, 0.2297234008462269, 0.7152627075119959, 0.719653357929268, 0.20309959833181312]}}
{"id": "47be925b-a11b-4a94-883c-bfb7f9789d43", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic population resizing mechanism based on fitness diversity to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "10fd8d11-d36e-4ca0-84d1-2b46d8970d9d", "fitness": 0.7560521294954954, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive mechanism by refining parameter adaptation with periodic cooling to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02) * (0.95 ** (generation // 50))  # Changed line\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595003994049878, 0.789657661017204, 0.7751393048783376, 0.755904137248014, 0.6786187412495567, 0.7677556085774137, 0.7061212119837126]}}
{"id": "3fdbb1a3-f49f-4288-a3c0-7536371b9149", "fitness": 0.23656202685297906, "name": "AdaptiveDifferentialEvolution", "description": "Enhance the algorithm's efficiency by introducing a generation-based adaptive scaling of mutation factor for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + (0.5 * np.sin(np.pi * target[0] / 5.0))  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  \n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)  \n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23656 with standard deviation 0.12864.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.330567899769016, 0.3732707550445651, 0.08274541935578594, 0.32075245298201316, 0.36394016809991236, 0.06454884831058594, 0.30011025982848116, 0.25748609194191885, 0.03563634634453272]}}
{"id": "c54e876f-6ec2-4590-b285-d3060d398b29", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive mechanism by optimizing mutation factor scaling and reducing population size stagnation threshold for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)**2) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(5, self.population_size - 1)  # Changed line\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "9dcfec47-4b96-4294-a293-01b8b1b9877b", "fitness": 0.025614349655811393, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic mutation factor based on fitness improvement rate to enhance local search capability.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n        self.previous_best_fitness = np.inf  # Added line\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        improvement_rate = np.abs(self.previous_best_fitness - np.min(self.fitness)) / np.abs(self.previous_best_fitness + 1e-9)\n        self.mutation_factor = 0.5 + 0.5 * improvement_rate  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02561 with standard deviation 0.01806.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.044701973739280976, 0.044702580162159666, 0.044702345921033615, 0.0307621248470884, 0.03076253124556627, 0.030762374267528814, 0.001378311544295796, 0.0013784863479969767, 0.0013784188273520126]}}
{"id": "41105e2f-4b9e-41f7-9f7e-ebb78c6f483c", "fitness": 0.5807136662930199, "name": "AdaptiveDifferentialEvolution", "description": "Refine mutation strategy by introducing self-adaptive mutation scaling based on fitness improvement rate to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        fitness_improvement_rate = (self.fitness.max() - self.fitness.min()) / self.fitness.max()  # Changed line\n        self.mutation_factor = 0.5 + fitness_improvement_rate * 0.5  # Adjust mutation factor based on fitness improvement\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  \n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)  \n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 79, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.58071 with standard deviation 0.08660.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.5676136922448626, 0.6237684522454928, 0.5834768694990169, 0.6377967325042292, 0.5469612676954196, 0.4446380053398279, 0.7703096935295906, 0.5431789552842785, 0.5086793282944622]}}
{"id": "bcdec6e0-71f0-459f-83a9-1c12569d12cb", "fitness": 0.6778586043696069, "name": "AdaptiveDifferentialEvolution", "description": "Fine-tuned adaptive crossover rate by dynamically adjusting to population convergence for improved search efficiency.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02) * (1 - 0.1 * population_diversity)  # Changed line\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67786 with standard deviation 0.04497.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.6518732190590628, 0.7498001083830764, 0.6554674153573217, 0.6466328574302669, 0.7461177850222992, 0.6503579698243778, 0.6357393909031064, 0.7250699185953069, 0.6396687747516445]}}
{"id": "1223c845-9cbf-4c7f-8317-4974ab015c28", "fitness": 0.31343502708291693, "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adjustment of mutation factor using exponential decay to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * np.exp(-0.01 * self.budget)  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31344 with standard deviation 0.21071.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.4039594404576664, 0.044942387391844196, 0.5347859229531682, 0.3951614395442604, 0.030996356306539963, 0.527600505481093, 0.37671399724650767, 0.0016083318569195537, 0.5051468625082528]}}
{"id": "dc9fbaec-adf0-4cef-b0bf-2d502fe6f1dc", "fitness": 0.6791393826555685, "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive mechanism by adjusting crossover rate based on historical success ratio of trial vectors for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        success_ratio = np.mean(self.fitness < np.inf)  # Changed line\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = (0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)) * (0.5 + success_ratio)  # Changed line\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67914 with standard deviation 0.05009.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.6566737501684805, 0.761066278231993, 0.6496349602945841, 0.6516045613885495, 0.7470464074904398, 0.6436719486375688, 0.6409805382935676, 0.7373588760654872, 0.6242171233294458]}}
{"id": "ccf48b0b-5152-4374-8215-d846345416d5", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Improve adaptive parameter tuning using historical fitness trends to adjust the mutation factor dynamically.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)  # Changed line\n        \n        if np.mean(self.fitness) < np.median(self.fitness):  # Changed line\n            self.mutation_factor *= 1.1  # Changed line\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "64dddea5-b682-4996-a206-dbbed59a39b4", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Adjust the adaptive parameter mechanism using cosine oscillation for mutation factor and crossover rate to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.cos(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 84, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "39c54161-740f-4f01-8269-81d19ccf8768", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the mutation factor adjustment to improve exploration-exploitation balance based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.15)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "78144af0-8cb9-45a3-b058-d8460b33ad0e", "fitness": 0.02583273660876024, "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the mutation factor adaptation formula for more responsive adjustments based on dynamic factors.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.3 * (1 - np.mean(self.fitness) / (np.std(self.fitness) + 1e-9))  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 86, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02583 with standard deviation 0.01805.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.04491730669325178, 0.044917514675751, 0.044917476747726615, 0.030979551312116493, 0.030979690688854422, 0.030979665271850698, 0.0016011050419355577, 0.0016011649897862412, 0.0016011540575693317]}}
{"id": "009f5d76-170f-493e-aef9-72b65690ce28", "fitness": 0.4842066530738861, "name": "AdaptiveDifferentialEvolution", "description": "Introduce dynamic adjustment of the crossover rate based on population convergence to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n        self.crossover_rate = 0.5 + 0.5 * np.std(self.fitness) / np.mean(self.fitness)  # Changed line\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 87, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48421 with standard deviation 0.07856.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.6297873759575283, 0.3657863727801681, 0.536484759994509, 0.49961056058402165, 0.36821970124732717, 0.5294226952573503, 0.44357522318850695, 0.4862178393894162, 0.4987553492661475]}}
{"id": "d5f752ae-6e54-46d8-842f-538c9d407336", "fitness": 0.026612036211243542, "name": "AdaptiveDifferentialEvolution", "description": "Improve exploration-exploitation balance by modifying the mutation factor based on fitness diversity and a dynamic population size adjustment. ", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        fitness_diversity = np.std(self.fitness)  # Changed line\n        self.mutation_factor = 0.5 + 0.3 * fitness_diversity  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02661 with standard deviation 0.01848.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.04496465973264352, 0.04821228104059205, 0.044984740050112215, 0.03111455148174147, 0.03373692076852386, 0.03102748849647774, 0.0018476644398977005, 0.001632817183917279, 0.0019872027072860288]}}
{"id": "b03473f6-e97e-4c88-9d4a-ce652caaac3a", "fitness": 0.11089951965904243, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a dynamic mutation strategy based on both population diversity and an exponential decay to encourage exploration in early generations and fine-tuning in later ones.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        population_diversity = np.std(self.population)\n        self.mutation_factor = 0.5 + 0.5 * np.exp(-self.budget / (self.budget + 1)) * (1 + population_diversity)  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 89, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11090 with standard deviation 0.12247.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.308725225230028, 0.044926618344089286, 0.04492973491979868, 0.2958128890448105, 0.03098579110669497, 0.030987879248702166, 0.23851906364804232, 0.0016037887222766223, 0.001604686666939359]}}
{"id": "52a3645e-1556-415d-ad9a-eeb7972c3b12", "fitness": 0.671935713539365, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a decay mechanism to the crossover rate based on generation number to enhance exploitation in later stages.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = (0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)) * (1 - generation / self.budget)  # Changed line\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67194 with standard deviation 0.03593.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7220173960572875, 0.6781476210535664, 0.671977382866042, 0.7179206626991332, 0.6337306930614857, 0.6537182782880732, 0.7093227449656322, 0.6180549283338128, 0.6425317145292522]}}
{"id": "3cc13792-fa5d-4435-9b15-325c0c5d75a1", "fitness": 0.21813502202219243, "name": "AdaptiveDifferentialEvolution", "description": "Introduce temperature-based annealing in mutation factor to enhance exploration and convergence balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        temperature = 1 - (self.budget / (self.budget + 1))\n        self.mutation_factor = (0.5 + 0.5 * temperature)  # Changed line\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21814 with standard deviation 0.25454.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.07242109602522795, 0.04492539450512856, 0.5916036281031261, 0.05796529510432835, 0.030986190892708487, 0.5798050662816523, 0.023948496927648666, 0.002052102488202312, 0.5595079278717092]}}
{"id": "12d35759-18de-42f4-8116-4ad6649ece0a", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive strategy by integrating a dynamic crossover rate adjustment based on population stagnation detection for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n        if generation > 5 and np.std(self.fitness) < 0.05:  # New line\n            self.crossover_rate *= 0.9  # New line\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 92, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "ddea2a6f-a0f7-4faf-ab92-add01e24b4e8", "fitness": 0.6273834474115838, "name": "AdaptiveDifferentialEvolution", "description": "Enhance mutation strategy by incorporating dynamic scaling based on fitness improvement over generations.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        improvement_factor = np.exp(-np.var(self.fitness) / 100)  # Changed line\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1)) * improvement_factor\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62738 with standard deviation 0.26251.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.27144893867152553, 0.8211356122045084, 0.8149085658352985, 0.2595955290922275, 0.8144535324057044, 0.8121993299233484, 0.23799920791792728, 0.8082141081923205, 0.806496202461394]}}
{"id": "54fbcf0b-ea6c-464f-8dd6-580609f7d0db", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Enhance parameter adaptation strategy by introducing generation-based dynamic scaling to mutation factor.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1) * (0.9 + 0.1 * (generation / self.budget))  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 94, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "cd9ba97b-7af0-4306-b566-45851472872e", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive mechanism by further enhancing mutation factor adaptation based on a dynamic mix of diversity and generational progress.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation + 0.1) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "af5d9924-599e-4a1a-acdc-f4bd2b8537d3", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Fine-tune the adaptation function using a logarithmic decay for a more stable mutation factor evolution over generations.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - np.log1p(generation) / np.log1p(self.budget))) * (1 + population_diversity * 0.1)  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 96, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
{"id": "ecf30531-81b6-48a6-a211-3d92d31106ed", "fitness": 0.7268544390717457, "name": "AdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover rate adjustment based on generation feedback to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02) + 0.1 * (np.std(self.fitness) / 0.1)  # Changed line\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72685 with standard deviation 0.06352.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7494670089044245, 0.8023217303177144, 0.6738422642699579, 0.7427010425577674, 0.7984034255333752, 0.6687419797456122, 0.7057356286645462, 0.7915629602462111, 0.6089139114061024]}}
{"id": "ad6f2c4b-5df8-41ae-b4c1-5553109300f4", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Enhance adaptive strategy by dynamically adjusting the population size based on a novel diversity and fitness variance metric for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1)\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        dynamic_factor = 1 + 0.5 * (population_diversity + fitness_variance)  # Changed line\n        self.population_size = max(10, int(self.population_size * dynamic_factor))  # Changed line\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 98, "feedback": "An exception occurred: IndexError('index 51 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 51 is out of bounds for axis 0 with size 20')", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {}}
{"id": "269f8a88-c331-4943-9b9b-ded15e4cf03f", "fitness": 0.7560521331928161, "name": "AdaptiveDifferentialEvolution", "description": "Refine adaptive mechanism by incorporating exponential scaling based on generation to mutation factor for better exploration.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.7\n        self.population = None\n        self.fitness = None\n\n    def initialize_population(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n\n    def select_parents(self):\n        idxs = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[idxs]\n\n    def mutate(self, target, parents):\n        self.mutation_factor = 0.5 + 0.5 * (self.budget / (self.budget + 1))\n        mutant = parents[0] + self.mutation_factor * (parents[1] - parents[2])\n        mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        trial = np.copy(target)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate:\n                trial[j] = mutant[j]\n        return trial\n\n    def select(self, target_idx, trial, func):\n        trial_fitness = func(trial)\n        if trial_fitness < self.fitness[target_idx]:\n            self.population[target_idx] = trial\n            self.fitness[target_idx] = trial_fitness\n\n    def adapt_parameters(self, generation):\n        population_diversity = np.std(self.population)\n        fitness_variance = np.var(self.fitness)\n        self.mutation_factor = (0.5 + 0.3 * np.sin(0.5 * generation) * (1 - generation / self.budget)) * (1 + population_diversity * 0.1) * (1 + np.exp(-generation / self.budget))  # Changed line\n        self.crossover_rate = 0.7 + 0.2 * np.cos(0.3 * generation) * (1 + fitness_variance * 0.02)\n        \n        if generation > 5 and np.std(self.fitness) < 0.1:\n            self.population_size = max(10, self.population_size - 1)\n\n    def __call__(self, func):\n        self.initialize_population()\n        self.evaluate_population(func)\n\n        evaluations = self.population_size\n        generation = 0\n\n        while evaluations < self.budget:\n            generation += 1\n            self.adapt_parameters(generation)\n\n            for i in range(self.population_size):\n                target = self.population[i]\n                parents = self.select_parents()\n                mutant = self.mutate(target, parents)\n                trial = self.crossover(target, mutant)\n                self.select(i, trial, func)\n                evaluations += 1\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75605 with standard deviation 0.03652.", "error": "", "parent_ids": ["92ae521d-1464-4b80-91d0-e3c119fac239"], "operator": null, "metadata": {"aucs": [0.7927299405481235, 0.779042160552109, 0.7595004128164219, 0.789657661017204, 0.7751393048783376, 0.7559041459156945, 0.6786187412495567, 0.7677556085774137, 0.7061212231804845]}}
