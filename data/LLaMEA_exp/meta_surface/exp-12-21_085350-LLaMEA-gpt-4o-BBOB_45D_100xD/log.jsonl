{"id": "19b0eace-4051-4f14-ac22-1a0622aae824", "fitness": 0.055540342065557025, "name": "HybridMetaheuristic", "description": "A novel hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.scaling_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Simulated Annealing Acceptance Criteria\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]\n\n# The code above defines a hybrid optimization algorithm that uses both Differential Evolution for generating\n# candidate solutions and Simulated Annealing for probabilistic acceptance, which helps to escape local optima.", "configspace": "", "generation": 0, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05554 with standard deviation 0.05338.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.12397051707635987, 0.13458133856054066, 0.12399147422268952, 0.04169299523298875, 0.0378365974511673, 0.037123489379600416, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5070f2e3-b931-4e33-aad1-f1c2bf066306", "fitness": 0.05723803192715046, "name": "HybridMetaheuristic", "description": "An enhanced hybrid metaheuristic with adaptive parameters to improve exploration and exploitation balance for black box optimization.", "code": "import numpy as np\n\nclass HybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            # Differential Evolution Mutation and Crossover\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * np.random.rand()  # New adaptive scaling factor\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Simulated Annealing Acceptance Criteria with dynamic temperature\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 1, "feedback": "The algorithm HybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05724 with standard deviation 0.05490.", "error": "", "parent_ids": ["19b0eace-4051-4f14-ac22-1a0622aae824"], "operator": null, "metadata": {"aucs": [0.12849345122322342, 0.13798219237586662, 0.1272581795357579, 0.04099945412616257, 0.042027660082274654, 0.03771468333440231, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "bdc405ad-936d-4d02-824f-4c374d9c453f", "fitness": 0.0568342974185824, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with dynamic population sizing and adaptive crossover to improve search diversity and convergence rate.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population_size = self.initial_population_size\n        population = np.random.rand(population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = population_size\n        \n        while eval_count < self.budget:\n            # Dynamically adjust population size\n            population_size = min(self.initial_population_size, self.budget - eval_count)\n            new_population = np.zeros((population_size, self.dim))\n            new_fitness = np.zeros(population_size)\n            \n            # Differential Evolution Mutation and Crossover\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(len(population), 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * np.random.rand()  # Adaptive scaling factor\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                \n                # Adaptive crossover rate based on diversity\n                diversity = np.std(population, axis=0).mean()\n                adaptive_crossover_rate = min(1.0, self.crossover_rate + diversity)\n                cross_points = np.random.rand(self.dim) < adaptive_crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Simulated Annealing Acceptance Criteria\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            self.temperature *= self.cooling_rate\n        \n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05683 with standard deviation 0.05422.", "error": "", "parent_ids": ["5070f2e3-b931-4e33-aad1-f1c2bf066306"], "operator": null, "metadata": {"aucs": [0.13063442309807372, 0.13393610219823782, 0.12496017766944023, 0.04039161661988189, 0.03839288148037745, 0.04252680903456374, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "9261399a-4b22-4714-83e7-7595dcf01478", "fitness": 0.057543092448308894, "name": "ImprovedHybridMetaheuristic", "description": "An improved adaptive hybrid metaheuristic with enhanced exploration via chaos theory-based perturbations to optimize black box functions.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n        self.chaos_coefficient = 0.5  # Coefficient for chaos-based perturbation\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic behavior\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Adaptive scaling factor based on chaotic map\n            chaos_factor = self.chaotic_map(np.random.rand())\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * chaos_factor\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Simulated Annealing Acceptance Criteria with dynamic temperature\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 3, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05754 with standard deviation 0.05392.", "error": "", "parent_ids": ["5070f2e3-b931-4e33-aad1-f1c2bf066306"], "operator": null, "metadata": {"aucs": [0.13200113668306457, 0.13048839154194003, 0.1264546388616179, 0.04782100188906735, 0.039385023545563724, 0.04107097284685979, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "17f576ea-89d6-43f1-bd12-743351b51282", "fitness": 0.057326273375280325, "name": "ImprovedHybridMetaheuristic", "description": "An adaptive chaos-informed heuristic with quantum-inspired initialization and periodic search space contraction for optimizing black box functions.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Slightly increased cooling for more exploration\n        self.chaos_coefficient = 0.5\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def quantum_init(self, bounds):\n        # Quantum-inspired initialization to enhance diversity\n        return np.random.uniform(bounds[:, 0], bounds[:, 1], (self.population_size, self.dim)) + \\\n               np.random.randn(self.population_size, self.dim) * 0.1\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = self.quantum_init(bounds)\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            chaos_factor = self.chaotic_map(np.random.rand())\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * chaos_factor\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n            \n            # Periodic contraction of search space for intensified search\n            if eval_count % (self.budget // 10) == 0:\n                contraction_factor = 0.9\n                bounds_center = (bounds[:, 0] + bounds[:, 1]) / 2\n                bounds_range = (bounds[:, 1] - bounds[:, 0]) * contraction_factor\n                bounds = np.array([bounds_center - bounds_range/2, bounds_center + bounds_range/2]).T\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 4, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05733 with standard deviation 0.05540.", "error": "", "parent_ids": ["9261399a-4b22-4714-83e7-7595dcf01478"], "operator": null, "metadata": {"aucs": [0.1324759662324887, 0.13033104487965286, 0.13410165754006453, 0.03830106710829728, 0.03788576533888188, 0.04217429261147099, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "11091e23-60b4-47cb-bbc1-19f9f94a458f", "fitness": 0.056908761909653105, "name": "ImprovedHybridMetaheuristic", "description": "Enhance mutation strategy by dynamically adjusting the scaling factor using a cosine function for better exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n        self.chaos_coefficient = 0.5  # Coefficient for chaos-based perturbation\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic behavior\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Adaptive scaling factor based on chaotic map\n            chaos_factor = self.chaotic_map(np.random.rand())\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                # Adjust scaling factor using cosine function.\n                scaling_factor = self.scaling_factor * chaos_factor * (0.5 * (1 + np.cos(np.pi * eval_count / self.budget)))\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Simulated Annealing Acceptance Criteria with dynamic temperature\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 5, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05691 with standard deviation 0.05464.", "error": "", "parent_ids": ["9261399a-4b22-4714-83e7-7595dcf01478"], "operator": null, "metadata": {"aucs": [0.12982749804472848, 0.1311363730934333, 0.13117966688903981, 0.041361399586460235, 0.03712323046448551, 0.040884022442063905, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "56882bff-6eab-4e01-b125-9695cacdc46b", "fitness": -Infinity, "name": "ImprovedHybridMetaheuristic", "description": "A refined hybrid metaheuristic enhancing exploitation with Lévy flights and dynamic chaos integration for improved black box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n        self.chaos_coefficient = 0.5  # Coefficient for chaos-based perturbation\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic behavior\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, size):\n        # Lévy flight for enhanced exploration\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(size) * sigma\n        v = np.random.randn(size)\n        step = u / np.abs(v) ** (1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Adaptive scaling factor based on chaotic map\n            chaos_factor = self.chaotic_map(np.random.rand())\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * chaos_factor\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i]) + self.levy_flight(self.dim)  # Apply Lévy flight\n\n                # Simulated Annealing Acceptance Criteria with dynamic temperature\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 6, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["9261399a-4b22-4714-83e7-7595dcf01478"], "operator": null, "metadata": {}}
{"id": "9d650eae-c732-4df4-b4eb-a68e9694f36c", "fitness": 0.06639828167260588, "name": "ImprovedHybridMetaheuristic", "description": "An improved adaptive hybrid metaheuristic with enhanced exploration via chaos theory-based perturbations and an adaptive crossover rate to optimize black box functions.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n        self.chaos_coefficient = 0.5  # Coefficient for chaos-based perturbation\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic behavior\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Adaptive scaling factor based on chaotic map\n            chaos_factor = self.chaotic_map(np.random.rand())\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * chaos_factor\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate * chaos_factor\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Simulated Annealing Acceptance Criteria with dynamic temperature\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 7, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06640 with standard deviation 0.07134.", "error": "", "parent_ids": ["9261399a-4b22-4714-83e7-7595dcf01478"], "operator": null, "metadata": {"aucs": [0.21609394679141658, 0.1303043139600666, 0.13030333736943833, 0.041851859668090685, 0.04135442744206819, 0.037009983155705806, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "69cf4ab9-daa3-4aa0-9bd6-001c2b268cd9", "fitness": 0.0561921379167869, "name": "ImprovedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with memory-based adaptation and improved chaos-influenced exploration for black box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Slightly adjusted cooling rate\n        self.chaos_coefficient = 0.5\n        self.memory_factor = 0.1  # Memory factor for previous best solutions\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic behavior\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_overall = population[np.argmin(fitness)]  # Track best overall solution\n\n        while eval_count < self.budget:\n            chaos_factor = self.chaotic_map(np.random.rand())\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * chaos_factor\n                mutant = np.clip(a + scaling_factor * diff_vector + self.memory_factor * (best_overall - a), bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate * chaos_factor\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(best_overall):  # Update best overall if improved\n                        best_overall = trial\n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 8, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05619 with standard deviation 0.05420.", "error": "", "parent_ids": ["9d650eae-c732-4df4-b4eb-a68e9694f36c"], "operator": null, "metadata": {"aucs": [0.1272387086372393, 0.12995297034881015, 0.13112943930902365, 0.04362262954556129, 0.038390765104376334, 0.03472806163940467, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "7bec08ab-f607-450c-aee9-7347f53bae38", "fitness": 0.056081616882159784, "name": "EnhancedChaoticHybridMetaheuristic", "description": "Enhanced Chaotic Hybrid Metaheuristic utilizing multi-chaotic map blending for dynamic perturbation and adaptive scaling factor, to optimize black box functions efficiently.", "code": "import numpy as np\n\nclass EnhancedChaoticHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.chaos_coefficient = 0.5\n\n    def logistic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def tent_map(self, x):\n        return 2 * x if x < 0.5 else 2 * (1 - x)\n\n    def blend_chaotic_maps(self, x):\n        return 0.5 * self.logistic_map(x) + 0.5 * self.tent_map(x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            chaos_factor = self.blend_chaotic_maps(np.random.rand())\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * chaos_factor\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate * chaos_factor\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedChaoticHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05608 with standard deviation 0.05315.", "error": "", "parent_ids": ["9d650eae-c732-4df4-b4eb-a68e9694f36c"], "operator": null, "metadata": {"aucs": [0.12694469987167845, 0.13109940964208222, 0.12448122646000359, 0.0430458526245614, 0.04010434464739854, 0.03839235202704716, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "9706cc87-6e3e-4dc2-8bb4-b68c932b1f64", "fitness": -Infinity, "name": "EnhancedHybridMetaheuristic", "description": "An enhanced adaptive hybrid metaheuristic utilizing Lévy flight-based exploration and a dynamically adaptive chaos coefficient to optimize black box functions.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for simulated annealing\n        self.chaos_coefficient = 0.5  # Initial chaos coefficient\n\n    def chaotic_map(self, x):\n        # Logistic map for chaotic behavior\n        return 4 * x * (1 - x)\n\n    def levy_flight(self, size):\n        # Lévy flight step generation\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v)**(1 / beta)\n        return 0.01 * step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            chaos_factor = self.chaotic_map(np.random.rand())\n            self.chaos_coefficient = 0.5 * chaos_factor + 0.5 * (self.budget - eval_count) / self.budget\n            \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                diff_vector = b - c\n                scaling_factor = self.scaling_factor * self.chaos_coefficient\n                mutant = np.clip(a + scaling_factor * diff_vector, bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate * self.chaos_coefficient\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Apply Lévy flight for exploration\n                trial = trial + self.levy_flight(self.dim)\n\n                # Simulated Annealing Acceptance Criteria with dynamic temperature\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            self.temperature *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 10, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["9d650eae-c732-4df4-b4eb-a68e9694f36c"], "operator": null, "metadata": {}}
{"id": "15eaa2bc-9065-4ddc-a31a-1d557d201fa3", "fitness": 0.0677257577124618, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic utilizing adaptive swarm intelligence and Levy flight perturbations for superior exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06773 with standard deviation 0.07392.", "error": "", "parent_ids": ["9d650eae-c732-4df4-b4eb-a68e9694f36c"], "operator": null, "metadata": {"aucs": [0.22400850397559846, 0.13838319389046927, 0.12836233665428598, 0.040541156075215135, 0.038660997668721775, 0.03890896448119885, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "1e236423-2448-43b0-b397-0248ad642baa", "fitness": -Infinity, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive parameter tuning and differential evolution crossover for improved exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7  # Adjusted inertia weight for better balance\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_factor = 0.5  # Added mutation factor for differential evolution\n        self.adaptive_rate = 0.05  # Adaptive rate for parameter tuning\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def differential_evolution(self, population, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = population[np.random.choice(indices, 3, replace=False)]\n        mutant = a + self.mutation_factor * (b - c)\n        return np.clip(mutant, func.bounds.lb, func.bounds.ub)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Adaptive parameter tuning\n                if np.random.rand() < self.adaptive_rate:\n                    self.inertia_weight = np.random.uniform(0.5, 0.9)\n                    self.cognitive_constant = np.random.uniform(1.0, 2.0)\n                    self.social_constant = np.random.uniform(1.0, 2.0)\n                    self.mutation_factor = np.random.uniform(0.3, 0.7)\n\n                # Differential evolution crossover\n                donor = self.differential_evolution(population, i)\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, donor, population[i])\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    trial += levy_step\n\n                # Boundary constraints\n                trial = np.clip(trial, bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(trial)\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = trial\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = trial\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 12, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {}}
{"id": "ca01390f-08e3-47b9-9837-f528c1983e99", "fitness": 0.06587619367841718, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic using adaptive swarm intelligence and Levy flight perturbations, with dynamic inertia weight for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            # Dynamic adjustment of inertia weight\n            self.inertia_weight = 0.9 - (0.9 - 0.4) * (eval_count / self.budget)  # Modified line\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06588 with standard deviation 0.07052.", "error": "", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {"aucs": [0.21391750397110387, 0.13191389194645997, 0.12553810418113232, 0.042080845851742765, 0.04277620587144859, 0.03599252461720037, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5353a1c0-b2bd-47dd-8133-9148f41be047", "fitness": 0.0560504932947072, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive dynamic reduction of temperature and inertia weight for improved exploration-exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.95  # Adjusted cooling rate for quicker convergence\n        self.inertia_weight = 0.7  # Increased initial inertia weight\n        self.inertia_weight_min = 0.3  # Minimum inertia weight for dynamic reduction\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n            # Adaptive inertia weight reduction\n            self.inertia_weight = max(self.inertia_weight * self.cooling_rate, self.inertia_weight_min)\n            # Adaptive temperature reduction\n            self.temperature *= self.cooling_rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05605 with standard deviation 0.05393.", "error": "", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {"aucs": [0.12717288584303987, 0.13113015867713418, 0.12850577102581617, 0.04036562922604081, 0.03932056472385537, 0.0372927634898117, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5b037e4b-7d83-4793-b003-d76460b136a5", "fitness": 0.055340862636181924, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive inertia weight and dynamic scaling factor for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_constant = 1.7  # Adjusted cognitive constant\n        self.social_constant = 1.7  # Adjusted social constant\n        self.scaling_factor = 0.5  # Adjusted initial scaling factor\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.inertia_weight = 0.9 - 0.7 * (eval_count / self.budget)  # Dynamic inertia weight\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n                # Dynamic scaling factor adjustment\n                self.scaling_factor = 0.3 + 0.4 * (1 - eval_count / self.budget)\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05534 with standard deviation 0.05312.", "error": "", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {"aucs": [0.12466381712857677, 0.12995297034881015, 0.1265690549047218, 0.040252069851881345, 0.037002086352310726, 0.03896109847266982, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c33ad378-1d54-4ac4-a3e5-45295aea32e8", "fitness": 0.05699865299963595, "name": "SynergisticAdaptiveMetaheuristic", "description": "Synergistic Adaptive Metaheuristic incorporating dynamic inertia and adaptive crossover for robust exploration-exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass SynergisticAdaptiveMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.98\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def adaptive_inertia(self, eval_count):\n        return self.inertia_max - (self.inertia_max - self.inertia_min) * (eval_count / self.budget)\n\n    def adaptive_crossover(self, eval_count):\n        return self.crossover_rate * (1 - np.exp(-eval_count / (0.1 * self.budget)))\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using adaptive inertia\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                inertia_weight = self.adaptive_inertia(eval_count)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < self.adaptive_crossover(eval_count):\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 16, "feedback": "The algorithm SynergisticAdaptiveMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05700 with standard deviation 0.05420.", "error": "", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {"aucs": [0.12816684372745468, 0.12995297034881015, 0.13177992797818816, 0.04042797668631004, 0.04106096462725772, 0.04093252696203609, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "9154bc01-e9f5-42d2-8154-953c03a3ad38", "fitness": 0.05619670109511669, "name": "EnhancedHybridMetaheuristic", "description": "An optimized hybrid metaheuristic combining adaptive swarm intelligence with quantum-inspired exploration and Levy flight perturbations for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Slightly increased cooling rate\n        self.inertia_weight = 0.7  # Increased inertia weight for exploration\n        self.cognitive_constant = 1.7  # Increased cognitive constant\n        self.social_constant = 1.7  # Increased social constant\n        self.quantum_exploration_probability = 0.2  # Probability for quantum-inspired exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def quantum_exploration(self, position, bounds):\n        return np.random.uniform(bounds[:, 0], bounds[:, 1], self.dim)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Quantum inspired exploration\n                if np.random.rand() < self.quantum_exploration_probability:\n                    population[i] = self.quantum_exploration(population[i], bounds)\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05620 with standard deviation 0.05418.", "error": "", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {"aucs": [0.1321270727773417, 0.13053013035152183, 0.1257058897295643, 0.040382223107727766, 0.038009312605181145, 0.03834901461804674, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "cf3c56d2-a773-46e3-be01-84ef3e6d6aca", "fitness": 0.055744581809553946, "name": "EnhancedHybridMetaheuristic", "description": "Slightly adjusts the inertia weight to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.6  # Adjusted from 0.5 to 0.6\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05574 with standard deviation 0.05332.", "error": "", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {"aucs": [0.12593716543278788, 0.13142657070219033, 0.12555167168958947, 0.041429321308123046, 0.038149293908907755, 0.038540546577720325, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "72eff725-385e-46d5-bc37-d4b67f7a5cf8", "fitness": 0.055512141651669906, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced adaptive hybrid metaheuristic using dynamic parameter control and chaotic maps for improved exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.995\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.cooling_schedule = lambda t: self.initial_temperature * (self.cooling_rate ** t)\n        \n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def chaotic_map(self, current_time_step):\n        return 0.5 * (1 - np.cos(np.pi * current_time_step))\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        time_step = 0\n\n        while eval_count < self.budget:\n            temperature = self.cooling_schedule(time_step)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Dynamic parameter adjustments\n                self.inertia_weight = self.chaotic_map(time_step)\n                self.cognitive_constant = 1.5 + 0.5 * np.sin(np.pi * time_step / self.budget)\n                self.social_constant = 1.5 + 0.5 * np.cos(np.pi * time_step / self.budget)\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n            time_step += 1\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05551 with standard deviation 0.05375.", "error": "", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {"aucs": [0.12762969954651493, 0.13043637742700553, 0.126827889449319, 0.040252069851881345, 0.036182975553761376, 0.037613596369880264, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "3d538673-b9b1-441f-9444-a900ddf62cf1", "fitness": -Infinity, "name": "EnhancedHybridMetaheuristicV2", "description": "Enhanced hybrid metaheuristic with adaptive parameter tuning, Gaussian perturbations, and dynamic population control for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristicV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.min_population_size = 5\n        self.max_population_size = 20 * self.dim\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def gaussian_perturbation(self, scale):\n        return np.random.normal(0, scale, self.dim)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adjust inertia weight adaptively\n                self.inertia_weight = 0.9 - (0.5 * eval_count / self.budget)\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Gaussian perturbation\n                if np.random.rand() < 0.3:\n                    population[i] += self.gaussian_perturbation(0.05)\n\n                # Dynamic population size control\n                if i == 0 and eval_count % (self.budget // 10) == 0:\n                    new_size = np.random.randint(self.min_population_size, self.max_population_size)\n                    population = np.resize(population, (new_size, self.dim))\n                    velocities = np.resize(velocities, (new_size, self.dim))\n                    personal_best = np.resize(personal_best, (new_size, self.dim))\n                    personal_best_fitness = np.resize(personal_best_fitness, new_size)\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 20, "feedback": "An exception occurred: IndexError('index 251 is out of bounds for axis 0 with size 251').", "error": "IndexError('index 251 is out of bounds for axis 0 with size 251')", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {}}
{"id": "f82cfc22-fd48-4d81-b518-c258d0f874c9", "fitness": 0.07301709352706147, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive cooling rate integration for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07302 with standard deviation 0.08569.", "error": "", "parent_ids": ["15eaa2bc-9065-4ddc-a31a-1d557d201fa3"], "operator": null, "metadata": {"aucs": [0.27163052630699547, 0.13838319389046927, 0.12836233665428598, 0.040541156075215135, 0.038660997668721775, 0.03890896448119885, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "ed88015b-4ee7-48df-884b-84b355f51e8d", "fitness": 0.05630117342550392, "name": "ImprovedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with adaptive weight adjustment and stochastic perturbation for enhanced exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.adaptive_weight_factor = 0.05  # New factor for adaptive weight adjustment\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def stochastic_perturbation(self, individual):\n        perturbation = np.random.normal(0, 1, self.dim) * 0.1  # Small stochastic perturbation\n        return individual + perturbation\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with adaptive inertia weight\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.inertia_weight = 0.9 - (0.9 - 0.4) * (eval_count / self.budget)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Stochastic perturbation\n                if np.random.rand() < 0.1:\n                    population[i] = self.stochastic_perturbation(population[i])\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 22, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05630 with standard deviation 0.05369.", "error": "", "parent_ids": ["f82cfc22-fd48-4d81-b518-c258d0f874c9"], "operator": null, "metadata": {"aucs": [0.13317486314108307, 0.13160781468833038, 0.12071506442016267, 0.04080446032667029, 0.0402549296080158, 0.039486761978606344, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "42bd754c-b740-47d9-9e01-20971b5f2755", "fitness": 0.056148934597771545, "name": "ImprovedEnhancedHybridMetaheuristic", "description": "Improved Enhanced Hybrid Metaheuristic with dynamic adaptive mechanisms for cooling and parameter tuning to enhance convergence efficiency in black box optimization.", "code": "import numpy as np\n\nclass ImprovedEnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Increased for better exploration\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.eval_count = 0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def dynamic_parameter_tuning(self):\n        # Dynamically adjust parameters based on progress\n        progress = self.eval_count / self.budget\n        self.inertia_weight = max(0.4, 0.9 - 0.5 * progress)  # Decrease inertia over time\n        self.cooling_rate = 0.99 - 0.04 * progress  # Adjust cooling rate\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        self.eval_count = self.population_size\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                self.eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n            # Dynamic parameter tuning\n            self.dynamic_parameter_tuning()\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 23, "feedback": "The algorithm ImprovedEnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05615 with standard deviation 0.05339.", "error": "", "parent_ids": ["f82cfc22-fd48-4d81-b518-c258d0f874c9"], "operator": null, "metadata": {"aucs": [0.12637217224529318, 0.13191389194645997, 0.12553810418113232, 0.042080845851742765, 0.04277620587144859, 0.03599252461720037, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "03f2ca33-4c22-4a5f-8a28-31481fdff0f2", "fitness": 0.05667913832276948, "name": "EnhancedHybridMetaheuristic", "description": "Adaptive Particle Swarm Optimization (APSO) with self-tuning parameters and dynamic neighborhood topology for enhanced search efficiency in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Increased inertia weight for exploration\n        self.cognitive_constant = 1.7  # Slightly adjusted cognitive factor\n        self.social_constant = 1.7  # Slightly adjusted social factor\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Dynamic neighborhood selection\n                neighbors = np.random.choice(self.population_size, 5, replace=False)\n                local_best = personal_best[neighbors[np.argmin(personal_best_fitness[neighbors])]]\n\n                # Adaptive PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (local_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i] + self.levy_flight(0.05)\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05668 with standard deviation 0.05415.", "error": "", "parent_ids": ["f82cfc22-fd48-4d81-b518-c258d0f874c9"], "operator": null, "metadata": {"aucs": [0.12776427056761186, 0.1377848719840431, 0.12298212082531823, 0.04064492424764565, 0.04044455368151045, 0.03982483693212935, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b79c40ed-9b0b-46fa-a999-fbb197dbeca3", "fitness": -Infinity, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic incorporating dynamic population adjustment for improved exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < 0.3:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n            # Dynamic population adjustment\n            if eval_count < self.budget // 2:\n                self.population_size = int(self.population_size * 1.05)  # Increase population size\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 25, "feedback": "An exception occurred: IndexError('index 450 is out of bounds for axis 0 with size 450').", "error": "IndexError('index 450 is out of bounds for axis 0 with size 450')", "parent_ids": ["f82cfc22-fd48-4d81-b518-c258d0f874c9"], "operator": null, "metadata": {}}
{"id": "96e85b69-d7e2-4b6e-a292-cb714f0bc8e4", "fitness": 0.08673283936932666, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation probability and dynamic search space adjustment for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08673 with standard deviation 0.11875.", "error": "", "parent_ids": ["f82cfc22-fd48-4d81-b518-c258d0f874c9"], "operator": null, "metadata": {"aucs": [0.3921842386733778, 0.1329393241948803, 0.13551952460650385, 0.04351179515675463, 0.037638066539803616, 0.03813593848595298, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5a82c3b8-1af8-43a9-8f65-f3ad6e7d0dce", "fitness": 0.05645662337723198, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with time-varying social influence, adaptive inertia weight, and chaotic initialization for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def chaotic_initialization(self, size, bounds):\n        return bounds[:, 0] + (bounds[:, 1] - bounds[:, 0]) * np.sin(np.pi * np.random.rand(size, self.dim))\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = self.chaotic_initialization(self.population_size, bounds)\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            inertia_weight = self.inertia_weight_max - (self.inertia_weight_max - self.inertia_weight_min) * (eval_count / self.budget)\n            social_influence = self.social_constant * (1 + np.cos(np.pi * eval_count / self.budget))\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + social_influence * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05646 with standard deviation 0.05365.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12689694750466385, 0.1295834514271117, 0.1295287104919215, 0.03988956837881619, 0.042418101814233555, 0.039126164111674355, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "d633e8eb-aba6-4de0-a068-bace4dad47f0", "fitness": 0.05805018246319901, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with chaotic map-based parameter tuning and elitist selection for improved diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def chaotic_map(self, eval_count):\n        return 0.7 * eval_count / self.budget\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                mutation_prob = self.chaotic_map(eval_count)  # Chaotic map-based probability\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n            \n            elitist_indices = np.argsort(personal_best_fitness)[:self.population_size // 2]\n            global_best = personal_best[elitist_indices[np.argmin(personal_best_fitness[elitist_indices])]]\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05805 with standard deviation 0.05614.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12987554802255075, 0.13502787143334427, 0.13713322433162478, 0.041916577457047355, 0.03947692952310655, 0.03835482473445073, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "752b89ee-3ff1-4665-8b39-50ec56acb053", "fitness": 0.0593239298860225, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with self-adaptive parameters and history-based search for accelerated convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        history_best = global_best.copy()\n        \n        while eval_count < self.budget:\n            mutation_prob = 0.2 + 0.1 * np.sin(2 * np.pi * eval_count / self.budget)  # Self-adaptive mutation\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * np.sin(2 * np.pi * eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        if fitness < func(history_best):\n                            history_best = population[i]\n\n        return history_best, func(history_best)", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05932 with standard deviation 0.05626.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13137573863993457, 0.13506823659401157, 0.13815287557553457, 0.041678146913231684, 0.04873461299319004, 0.03823909159163341, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "2aacb580-efc3-4dec-a8cd-0ec73e813620", "fitness": 0.0557255231854488, "name": "EnhancedHybridMetaheuristic", "description": "Hybrid metaheuristic with enhanced adaptive inertia weight and crossover for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            self.inertia_weight = 0.9 - eval_count / (2 * self.budget)  # Adaptive inertia weight\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Crossover step\n                if np.random.rand() < self.crossover_rate:\n                    idx = np.random.randint(self.population_size)\n                    crossover_mask = np.random.rand(self.dim) < 0.5\n                    population[i] = np.where(crossover_mask, personal_best[idx], population[i]) \n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05573 with standard deviation 0.05361.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1287984401117328, 0.13133328096999775, 0.12424931655775595, 0.04131568077791159, 0.03631679540829802, 0.03884952817667642, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "17197df2-5e07-4ee4-bf53-d8c077899ff3", "fitness": 0.05531340408649051, "name": "EnhancedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with dynamic inertia and adaptive cognitive-social factors for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Changed initial inertia weight\n        self.cognitive_constant = 1.0  # Changed cognitive constant\n        self.social_constant = 2.0  # Changed social constant\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05531 with standard deviation 0.05354.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12609993536262454, 0.12995297034881015, 0.12737615860801188, 0.04064793552129997, 0.03607213688161104, 0.03700483338939031, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "1398215b-4071-4255-a710-b4122f57b3c8", "fitness": 0.05575131503156957, "name": "ImprovedHybridMetaheuristic", "description": "Introducing multi-agent communication and learning between diverse strategies and dynamic adaptation of parameters to enhance convergence.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.learning_rate = 0.1\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using hybrid PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Communication and learning between agents\n                if i > 0:\n                    influence = self.learning_rate * (personal_best[i - 1] - population[i])\n                    population[i] += np.random.rand(self.dim) * influence\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 32, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05575 with standard deviation 0.05294.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12672988819757092, 0.13036109871055435, 0.12376668653745315, 0.04146998196820717, 0.03926694739433256, 0.03950056580934125, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "0753b3a4-2a24-43f6-a13d-82279f7eed5c", "fitness": 0.05540052003824003, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive differentiation blending and dynamically adjusted exploration-exploitation balance for superior convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - 2 * (eval_count / self.budget)))  # More aggressive mutation adaptation\n            exploration_exploitation_balance = np.exp(-3 * eval_count / self.budget)  # Dynamic balance\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Adaptive Differentiation Blending\n                diff = personal_best[np.random.randint(self.population_size)] - personal_best[np.random.randint(self.population_size)]\n                if np.random.rand() < self.crossover_rate:\n                    population[i] += self.scaling_factor * diff * exploration_exploitation_balance\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05540 with standard deviation 0.05331.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12862124771364492, 0.12995297034881015, 0.12371685853243342, 0.040252069851881345, 0.03857997071464969, 0.03681489651607406, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "38a2ed28-8c17-4f44-a3e0-bb7f64e9174d", "fitness": 0.05687960346215601, "name": "RefinedHybridMetaheuristic", "description": "Refined hybrid metaheuristic with adaptive inertia, self-adaptive learning rates, and enhanced levy flight for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            inertia_weight = self.inertia_weight_max - (\n                (self.inertia_weight_max - self.inertia_weight_min) * (eval_count / self.budget)\n            )\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with adaptive inertia\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Enhanced Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget)) * np.random.rand(self.dim)\n                if np.random.rand() < 0.25:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 34, "feedback": "The algorithm RefinedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05688 with standard deviation 0.05465.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13427854240450565, 0.13078655494677294, 0.12699985419374893, 0.040252069851881345, 0.03934676585435648, 0.03958597724147206, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "840ba6bc-14e7-4903-8316-9a255f665952", "fitness": 0.05602949473635388, "name": "ImprovedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with local search intensification and adaptive exploration-exploitation balancing for better convergence.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.local_search_weight = 0.1  # New component for local search intensification\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Local search intensification\n                if np.random.rand() < self.local_search_weight:\n                    local_step = np.random.normal(0, 0.01, self.dim)  # Small local step\n                    population[i] += local_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 35, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05603 with standard deviation 0.05363.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12860525965670955, 0.13184102734201464, 0.12451942945076744, 0.04320147447641731, 0.038129019528847286, 0.03730257550576199, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c96bc8ae-6d7c-4bd9-894b-feb75a2723b0", "fitness": 0.05731663187197658, "name": "EnhancedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with refined inertia adjustment and enhanced levy flight scaling for better convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7  # Adjusted inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.15 + 0.1 * (eval_count / self.budget))  # Enhanced scaling factor\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05732 with standard deviation 0.05438.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12317915833016846, 0.13212244237783333, 0.13551952460650385, 0.04065112982061647, 0.045661594270640204, 0.038049170775360186, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "4f3e6def-2c7f-4691-82a5-468fbe052af8", "fitness": 0.05608391141156169, "name": "AdaptiveDualPhaseHybridMetaheuristic", "description": "Adaptive Dual-Phase Hybrid Metaheuristic combines strategic exploration and exploitation phases with dynamically adjusted mutation and crossover mechanisms for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveDualPhaseHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate_min = 0.5\n        self.crossover_rate_max = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            crossover_rate = self.crossover_rate_min + (self.crossover_rate_max - self.crossover_rate_min) * (eval_count / self.budget)\n            inertia_weight = self.inertia_weight_initial - ((self.inertia_weight_initial - self.inertia_weight_final) * (eval_count / self.budget))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Crossover and mutation\n                if np.random.rand() < crossover_rate:\n                    idxs = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = population[idxs[0]] + self.scaling_factor * (population[idxs[1]] - population[idxs[2]])\n                    trial_vector = np.where(np.random.rand(self.dim) < crossover_rate, mutant_vector, population[i])\n                    trial_vector = np.clip(trial_vector, bounds[:, 0], bounds[:, 1])\n                else:\n                    trial_vector = population[i] + velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < 0.2:  # Fixed small mutation probability\n                    trial_vector += levy_step\n\n                # Boundary constraints\n                trial_vector = np.clip(trial_vector, bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(trial_vector)\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 37, "feedback": "The algorithm AdaptiveDualPhaseHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05608 with standard deviation 0.05428.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12785032924721262, 0.12995297034881015, 0.13098682025780373, 0.040252069851881345, 0.03830687060151994, 0.036739475730160676, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "0bdbd0d1-813d-4fdd-8280-918cce50fe0c", "fitness": 0.05703937459919, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with improved exploration-exploitation balance using adaptive differential evolution and chaotic map initialization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def chaotic_map_initialization(self, bounds):\n        x0 = np.random.rand(self.dim)\n        population = np.zeros((self.population_size, self.dim))\n        for i in range(self.population_size):\n            x0 = 4 * x0 * (1 - x0)\n            population[i] = x0 * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        return population\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = self.chaotic_map_initialization(bounds)\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            # Adaptive scaling factor\n            self.scaling_factor = 0.5 + np.random.rand() * 0.5\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05704 with standard deviation 0.05460.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13052751975527488, 0.13359743017003511, 0.1279398967097325, 0.03914328072347695, 0.03863120692501032, 0.04284837044251355, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "a3bd5513-1064-4221-9ab4-75575f884fa9", "fitness": 0.05585698349573877, "name": "ImprovedHybridMetaheuristic", "description": "Improved Hybrid Metaheuristic with Adaptive Velocity and Dynamic Neighborhood Search for Enhanced Convergence.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.neighborhood_radius = 0.1\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            adaptive_inertia_weight = self.inertia_weight + 0.5 * (1 - eval_count / self.budget)\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    adaptive_inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                dynamic_radius = self.neighborhood_radius * (1.0 - eval_count / self.budget)\n                neighborhood_step = np.random.uniform(-dynamic_radius, dynamic_radius, self.dim)\n                population[i] += neighborhood_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 39, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05586 with standard deviation 0.05388.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12763713465430915, 0.13125702388189453, 0.127280299437048, 0.040252069851881345, 0.03606862976702807, 0.03955102720282111, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c99d7256-67fc-42b3-a30e-8b42b9671164", "fitness": 0.05692502027874692, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with improved initialization strategy using opposition-based population initialization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        opposite_population = bounds[:, 1] + bounds[:, 0] - population  # Opposition-based initialization\n        population = np.concatenate((population, opposite_population), axis=0)\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05693 with standard deviation 0.05457.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1291980363592321, 0.13201400726690438, 0.13052656734243095, 0.0426453640420813, 0.03938761814166836, 0.03788692268973848, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "d96182e2-00e2-450c-af05-505ec2897620", "fitness": 0.056750998215852916, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation probability, dynamic search space adjustment, and modified inertia weight decay for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    (self.inertia_weight - 0.3 * (eval_count / self.budget)) * velocities[i]  # Modified decay\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05675 with standard deviation 0.05466.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12515789218236129, 0.1310597119554564, 0.13551952460650385, 0.04079758561127789, 0.039317980184675694, 0.038239622735734446, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "f72577f8-14ab-4ffe-84ef-44ae3d118f5f", "fitness": 0.056317962963444296, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with dynamic cooperative search balance and adaptive exploration-exploitation adjustment for improved performance.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.exploration_weight = 1.0  # New parameter for balancing exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with exploration-exploitation balance\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                    + self.exploration_weight * np.random.normal(0, 1, self.dim)  # Exploration term\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05632 with standard deviation 0.05329.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12585132339632343, 0.13045648226163986, 0.1270003930337662, 0.048129084885090934, 0.03634932473543062, 0.03840839169208088, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "efb06fc1-0070-4f86-ab5a-b0c5dbd3079f", "fitness": 0.055745821683611946, "name": "EnhancedHybridMetaheuristicV2", "description": "Introducing stochastic dynamic learning factors and improved exploration-exploitation balance through adaptive velocity scaling.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristicV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Stochastic dynamic factors\n                cognitive_dynamic = self.cognitive_constant * np.random.rand()\n                social_dynamic = self.social_constant * np.random.rand()\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + cognitive_dynamic * r1 * (personal_best[i] - population[i])\n                    + social_dynamic * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedHybridMetaheuristicV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05575 with standard deviation 0.05369.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12616457564196293, 0.13228387648833506, 0.12645665289030095, 0.04048618438988083, 0.03800421893772543, 0.03765022013763564, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "50657ada-42db-4c11-8986-3ec19030e289", "fitness": 0.05764039425885618, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation probability and dynamic search space adjustment for improved convergence and slightly increased initialization diversity.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.uniform(bounds[:, 0], bounds[:, 1], (self.population_size, self.dim))\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05764 with standard deviation 0.05567.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13035223267914353, 0.1329393241948803, 0.13551952460650385, 0.04351179515675463, 0.037638066539803616, 0.03813593848595298, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "283267ab-b669-446d-931e-0a49e5dcd968", "fitness": 0.05720530486714288, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation probability, dynamic search space adjustment, and self-adaptive population resizing for optimized convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.min_population_size = 4\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            resized_population_size = max(self.min_population_size, int(self.initial_population_size * (1.0 - eval_count / self.budget)))\n            if resized_population_size != self.population_size:\n                population = population[:resized_population_size]\n                velocities = velocities[:resized_population_size]\n                personal_best = personal_best[:resized_population_size]\n                personal_best_fitness = personal_best_fitness[:resized_population_size]\n                self.population_size = resized_population_size\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05721 with standard deviation 0.05538.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12993354582583183, 0.1310597119554564, 0.13551952460650385, 0.04231738903041127, 0.038692353645691235, 0.03665855207372459, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "6722e68b-ff8a-4ca5-bdcd-6cca873cf743", "fitness": 0.05718433201681575, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation probability, dynamic search space adjustment, and diversity preservation through differential evolution for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Differential Evolution operator\n                if np.random.rand() < mutation_prob:\n                    candidates = list(range(self.population_size))\n                    candidates.remove(i)\n                    a, b, c = population[np.random.choice(candidates, 3, replace=False)]\n                    mutant = np.clip(a + self.scaling_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                    cross_points = np.random.rand(self.dim) < self.crossover_rate\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial = np.where(cross_points, mutant, population[i])\n                    trial_fitness = func(trial)\n                    eval_count += 1\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < global_best_fitness:\n                            global_best = trial\n                            global_best_fitness = trial_fitness\n                            self.cooling_rate *= 0.995\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05718 with standard deviation 0.05568.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12566658480422976, 0.1304675150455603, 0.14134462903422196, 0.040252069851881345, 0.03557738480599171, 0.04068413794278991, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "03fff06e-693d-4a98-8afc-4b672a2b42e3", "fitness": 0.05810096955712888, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation probability, dynamic search space adjustment, and refined inertia weight decay for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n                self.inertia_weight *= 0.995  # Refined inertia weight decay\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05810 with standard deviation 0.05412.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1239686499107534, 0.1310597119554564, 0.13551952460650385, 0.049473915258550605, 0.04025721205528521, 0.04196304556094377, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "06b485c1-3a0c-4fb1-a253-ac303d79077d", "fitness": 0.05635528527000698, "name": "ImprovedHybridMetaheuristic", "description": "Improved hybrid metaheuristic using adaptive dynamic population resizing and mutation strategy to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * self.dim\n        self.population_size = self.initial_population_size\n        self.min_population_size = 4\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            dynamic_population_size = max(self.min_population_size, int(self.initial_population_size * (1 - eval_count / self.budget)))\n            indices = np.random.choice(self.population_size, dynamic_population_size, replace=False)\n            \n            for i in indices:\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 48, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05636 with standard deviation 0.05298.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12478393446219926, 0.13150527131549938, 0.12573128415747514, 0.04094026401707662, 0.04075910834203644, 0.042811038469109275, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c0167c14-f847-4991-a945-2b38d010f846", "fitness": 0.05757721527769794, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with improved adaptive mutation probability and dynamic search space tuning for better convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.15, min(0.35, 1.0 - (eval_count / self.budget)))  # Enhanced adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05758 with standard deviation 0.05569.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13035223267914353, 0.1329393241948803, 0.13551952460650385, 0.04351179515675463, 0.036569192159639385, 0.03863620203569307, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b1776e39-effd-4356-8d93-915105040d71", "fitness": 0.055938849582973266, "name": "ImprovedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with dynamic inertia adjustment and adaptive crossover for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Start with a larger inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n        temperature = self.initial_temperature\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            self.inertia_weight = max(0.4, self.inertia_weight - 0.0001)  # Dynamic inertia adjustment\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n                # Adaptive crossover operation\n                if np.random.rand() < self.crossover_rate:\n                    partner_idx = np.random.randint(0, self.population_size)\n                    child = np.where(np.random.rand(self.dim) > 0.5, personal_best[i], personal_best[partner_idx])\n                    child_fitness = func(child)\n                    eval_count += 1\n                    if child_fitness < personal_best_fitness[i]:\n                        personal_best[i] = child\n                        personal_best_fitness[i] = child_fitness\n                        if child_fitness < global_best_fitness:\n                            global_best = child\n                            global_best_fitness = child_fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 50, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05594 with standard deviation 0.05372.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12832269461267876, 0.1300000592640136, 0.12720522062605688, 0.040252069851881345, 0.03945670211720542, 0.037546233108256666, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "425410a6-cee6-47a5-a5ab-0962fdb7063a", "fitness": 0.05764039425885618, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation probability, dynamic search space adjustment, and improved adaptive cooling for faster convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate = max(0.9, self.cooling_rate * 0.995)  # Improved adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05764 with standard deviation 0.05567.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13035223267914353, 0.1329393241948803, 0.13551952460650385, 0.04351179515675463, 0.037638066539803616, 0.03813593848595298, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "2ff69ece-60d3-4fc3-ba01-0935cb1d0d93", "fitness": 0.05633280242077911, "name": "EnhancedHybridMetaheuristic", "description": "Hybrid metaheuristic with dynamic exploration-exploitation balance and diversity-based adaptive strategy for enhanced optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7  # Adjusted inertia weight for better exploration-exploitation\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7  # Increased social constant to enhance convergence\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def diversity_measure(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  \n            diversity = self.diversity_measure(population)  # Measure population diversity\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  \n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  \n\n        return global_best, global_best_fitness", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05633 with standard deviation 0.05436.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12883514660200057, 0.13211334794082308, 0.12871647997523872, 0.040252069851881345, 0.037894939790159454, 0.03851657096024208, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "9206a40e-2b70-4269-9052-3dc73a4e6aea", "fitness": 0.05720997687910877, "name": "EnhancedHybridMetaheuristic", "description": "Improved hybrid optimization with adaptive inertia weight and reinforced local search for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        # Adjusted inertia weight parameters\n        self.inertia_weight_initial = 0.9\n        self.inertia_weight_final = 0.4\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            # Adaptive inertia weight\n            inertia_weight = self.inertia_weight_initial - (\n                (self.inertia_weight_initial - self.inertia_weight_final) * (eval_count / self.budget)\n            )\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with adaptive inertia weight\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05721 with standard deviation 0.05518.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1271050982901094, 0.13276529482507193, 0.13551952460650385, 0.040252069851881345, 0.04082807619208384, 0.03775306147966184, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "ee3a506f-c4de-4b2c-aea0-fa601d39239b", "fitness": 0.05726071202948027, "name": "AdvancedHybridMetaheuristic", "description": "Advanced hybrid metaheuristic with chaotic sequence initialization and adaptive crossover for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def chaotic_initialization(self, bounds):\n        # Using logistic map for chaotic sequence\n        x = np.random.rand(self.population_size, self.dim)\n        x_next = 4.0 * x * (1.0 - x)\n        return x_next * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = self.chaotic_initialization(bounds)\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            adaptive_crossover = self.crossover_rate * (1.0 - eval_count / self.budget)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 54, "feedback": "The algorithm AdvancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05726 with standard deviation 0.05478.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1331636054084817, 0.12939183606823623, 0.13091750676230218, 0.041630087963338, 0.039493273498416026, 0.04008343189788155, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "8bf5e60b-1321-4f46-adb4-79ead45d86e3", "fitness": 0.05619034921707149, "name": "OptimizedHybridMetaheuristic", "description": "Optimized hybrid metaheuristic using adaptive population size and dynamic exploration-exploitation balance for enhanced performance.", "code": "import numpy as np\n\nclass OptimizedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 8 * self.dim\n        self.final_population_size = 4 * self.dim\n        self.crossover_rate = 0.85\n        self.scaling_factor = 0.9\n        self.temperature = 100.0\n        self.cooling_rate = 0.98\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.4\n        self.social_constant = 1.6\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population_size = self.initial_population_size\n        population = np.random.rand(population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.05, min(0.25, 1.0 - (eval_count / self.budget)))\n            if eval_count % (self.budget // 5) == 0:\n                population_size = max(self.final_population_size, population_size - self.dim)\n\n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.99\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 55, "feedback": "The algorithm OptimizedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05619 with standard deviation 0.05463.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1273788784786738, 0.13379630067788228, 0.1295390048344368, 0.04081986991684161, 0.03646301336385438, 0.03704940901528786, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c0410baa-d71c-44e9-9872-f00389914558", "fitness": 0.05544252715845796, "name": "AdaptiveHybridMetaheuristic", "description": "Hybrid metaheuristic with adaptive swarm intelligence and dynamic perturbation for efficient exploration and exploitation balancing.", "code": "import numpy as np\n\nclass AdaptiveHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.scaling_factor = 0.8\n        self.cooling_rate = 0.99\n\n    def levy_flight(self, scale):\n        u = np.random.normal(0, 1, self.dim) * scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = 0.1 + 0.4 * (1 - eval_count / self.budget)  # More aggressive mutation early on\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Dynamic Levy flight perturbation\n                if np.random.rand() < mutation_prob:\n                    levy_scale = 0.1 + 0.1 * (eval_count / self.budget)\n                    population[i] += self.levy_flight(levy_scale)\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 56, "feedback": "The algorithm AdaptiveHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05544 with standard deviation 0.05312.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1251626057937396, 0.13052079408349948, 0.12564807947277323, 0.04062299803138614, 0.03681771718425586, 0.039543883193800644, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "27b1f062-9928-43e1-a23e-19ce123e62eb", "fitness": 0.05720997687910877, "name": "RefinedHybridMetaheuristic", "description": "Refined hybrid metaheuristic with adaptive inertia and mutation control for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass RefinedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.05, min(0.3, 1.0 - (eval_count / (2 * self.budget))))  # Adaptive mutation probability\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using refined PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 57, "feedback": "The algorithm RefinedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05721 with standard deviation 0.05518.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1271050982901094, 0.13276529482507193, 0.13551952460650385, 0.040252069851881345, 0.04082807619208384, 0.03775306147966184, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "24fd3762-e4c9-4311-9a84-295e571bdafa", "fitness": 0.0572707171562753, "name": "EnhancedHybridMetaheuristic", "description": "Multi-strategy hybrid metaheuristic with adaptive parameter tuning and self-organizing population dynamics for superior exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.mutation_rate = lambda eval_ratio: max(0.05, min(0.3, 0.3 * (1.0 - eval_ratio)))\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            eval_ratio = eval_count / self.budget\n            mutation_prob = self.mutation_rate(eval_ratio)\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Adaptive PSO dynamics with inertia weight adjustment\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                inertia_weight = 0.1 + 0.9 * (1.0 - eval_ratio)  # Adaptive inertia weight\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * eval_ratio)  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate for potential annealing strategy\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05727 with standard deviation 0.05490.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1265261740773338, 0.1319145637303507, 0.13551952460650385, 0.04123759710093433, 0.04163384156501104, 0.03793808665967724, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "1872c415-6ba2-47b5-aebb-28fb6547ed5d", "fitness": 0.05607874887801202, "name": "ImprovedHybridMetaheuristic", "description": "Improved hybrid metaheuristic incorporating chaotic initialization and adaptive differential evolution to enhance exploration and convergence.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def chaotic_initialization(self, bounds):\n        x0 = np.random.rand(self.dim)\n        chaotic_sequence = np.zeros((self.population_size, self.dim))\n        beta = 3.7\n        for i in range(self.population_size):\n            x0 = beta * x0 * (1 - x0)\n            chaotic_sequence[i] = x0\n        return chaotic_sequence * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = self.chaotic_initialization(bounds)\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position using differential evolution strategy\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant_vector = np.clip(a + self.scaling_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector = np.where(cross_points, mutant_vector, population[i])\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    trial_vector += levy_step\n\n                # Boundary constraints\n                trial_vector = np.clip(trial_vector, bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(trial_vector)\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = trial_vector\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 59, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05608 with standard deviation 0.05448.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13765855853319864, 0.12434219737284846, 0.1273351471471178, 0.03769321576082274, 0.03886670947049364, 0.038146244950960195, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "98f828d8-026a-4357-a7f0-a40f0f22ef07", "fitness": 0.05710497776272752, "name": "AdaptiveMultiStrategyMetaheuristic", "description": "Adaptive multi-strategy metaheuristic combining PSO, DE, and simulated annealing with dynamic parameter tuning and self-adaptive Levy flight for efficient convergence.", "code": "import numpy as np\n\nclass AdaptiveMultiStrategyMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.995\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 2.0\n        self.social_constant = 2.0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        current_temperature = self.initial_temperature\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.05, min(0.25, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Differential Evolution (DE) inspired mutation\n                candidates = np.random.choice(self.population_size, 3, replace=False)\n                mutant_vector = population[candidates[0]] + self.scaling_factor * (population[candidates[1]] - population[candidates[2]])\n                trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, population[i])\n                population[i] = np.clip(trial_vector, bounds[:, 0], bounds[:, 1])\n\n                # Simulated Annealing inspired acceptance\n                trial_fitness = func(population[i])\n                eval_count += 1\n                delta_fitness = trial_fitness - personal_best_fitness[i]\n                if delta_fitness < 0 or np.exp(-delta_fitness / current_temperature) > np.random.rand():\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = trial_fitness\n                    if trial_fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = trial_fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n                    population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n            current_temperature *= self.cooling_rate  # Reduce temperature\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveMultiStrategyMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05710 with standard deviation 0.05337.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1282273005146667, 0.12995297034881015, 0.1272867257070205, 0.044457246259914096, 0.04342573011190931, 0.03992816025556023, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "6e9dc3ed-6125-498c-9761-543bf657521f", "fitness": 0.057844419440132265, "name": "EnhancedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with adaptive cooling rate and modified levy flight for enhanced exploration.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.985  # Adjusted cooling rate\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 0.5)  # Modified levy exponent\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.15 * (eval_count / self.budget))  # Adjusted dynamic search space factor\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.990  # Adaptive cooling rate adjustment\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05784 with standard deviation 0.05535.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1294039464310217, 0.13258875613083299, 0.13551952460650385, 0.04156488710926409, 0.03952646714990826, 0.04132952686699276, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "85776acd-6604-44cf-9b47-c3ff100fbbb4", "fitness": 0.05649514008877426, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with dynamic inertia and mutation strategies, incorporating enhanced exploration via chaotic maps for improved convergence. ", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Dynamic inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def logistic_map(self, x, r=3.9):\n        return r * x * (1 - x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n        chaotic_seq = np.random.rand()\n\n        while eval_count < self.budget:\n            chaotic_seq = self.logistic_map(chaotic_seq)\n            mutation_prob = 0.1 + 0.2 * chaotic_seq  # Chaotic mutation probability\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with dynamic inertia\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05650 with standard deviation 0.05402.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13064051069263916, 0.12995297034881015, 0.1274209453320596, 0.041241723311184586, 0.04157100250195955, 0.03696244194564857, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "6a4cc70f-aa3e-4c01-90cb-4a5ef109ac29", "fitness": 0.05592574077139888, "name": "AdaptiveMultiPopulationMetaheuristic", "description": "An adaptive multi-population metaheuristic that utilizes self-adjusting PSO and DE strategies with dynamic learning rates and environmental feedback for robust optimization.", "code": "import numpy as np\n\nclass AdaptiveMultiPopulationMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.diversification_factor = 0.2\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            dynamic_scaling = self.scaling_factor * (1 - (eval_count / self.budget))\n            dynamic_inertia = self.inertia_weight * (0.5 + dynamic_scaling)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with adaptive learning rates\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    dynamic_inertia * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position using DE strategy\n                differential_vector = dynamic_scaling * (personal_best[(i+1) % self.population_size] - personal_best[(i+2) % self.population_size])\n                population[i] += velocities[i] + differential_vector\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(self.diversification_factor + dynamic_scaling)\n                if np.random.rand() < dynamic_scaling:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 63, "feedback": "The algorithm AdaptiveMultiPopulationMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05593 with standard deviation 0.05267.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12738487728363768, 0.12995297034881015, 0.12226347910766044, 0.04243480139194311, 0.03987842991060597, 0.04075044223326585, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "13248d59-4e07-47ab-af11-ca20bf00cfaf", "fitness": 0.0565237954156517, "name": "EnhancedHybridMetaheuristicV2", "description": "Introducing a multi-phase adaptive search strategy with chaotic sequences to enhance exploration and exploitation balance for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristicV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def chaos_sequence(self, size):\n        x = 0.7\n        sequence = []\n        for _ in range(size):\n            x = 4.0 * x * (1.0 - x)  # Logistic map\n            sequence.append(x)\n        return np.array(sequence)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        chaos_seq = self.chaos_sequence(self.budget)\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Chaotic perturbation\n                chaotic_perturbation = chaos_seq[eval_count % self.budget] * (bounds[:, 1] - bounds[:, 0])\n                if np.random.rand() < mutation_prob:\n                    population[i] += chaotic_perturbation\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedHybridMetaheuristicV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05652 with standard deviation 0.05380.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1285351632325572, 0.13033432774384213, 0.12808660446831843, 0.040252069851881345, 0.040378816910685345, 0.040460509866914185, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "8ff84f44-8297-46a7-987f-4ddb1b107782", "fitness": 0.056879612136042645, "name": "EnhancedHybridMetaheuristic", "description": "Optimized hybrid metaheuristic with enhanced inertia weight decay to improve convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n            self.inertia_weight *= 0.995  # Enhance inertia weight decay\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05688 with standard deviation 0.05510.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1277430054699833, 0.1310597119554564, 0.13551952460650385, 0.04293944001314065, 0.03619867158350121, 0.0377894889291317, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "270bb2b1-70f3-4b6a-b14f-931ccf835128", "fitness": 0.05594158079814055, "name": "ImprovedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with adaptive learning rate and dynamic diversity preservation for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.adaptive_learning_rate = 0.01\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n        learning_rate = self.adaptive_learning_rate\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += learning_rate * velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        learning_rate *= 1.01\n                        self.cooling_rate *= 0.995\n            learning_rate *= 0.99\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 66, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05594 with standard deviation 0.05401.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12892681698789665, 0.13000500946228555, 0.1281290034110013, 0.04078851820815721, 0.03664964189443565, 0.038308570552821886, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "a0ca01b8-a8b8-4f74-a272-8f180c1c26c3", "fitness": 0.05760639744790758, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with genotype diversity preservation strategy and adaptive dynamic scaling for robust convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def diversity_preservation(self, population, bounds):\n        # Encourage diversity by introducing random individuals\n        if np.random.rand() < 0.15:  # 15% chance to introduce new individuals\n            random_individuals = np.random.rand(self.population_size // 5, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n            population[:self.population_size // 5] = random_individuals\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            dynamic_scaling = 0.1 + 0.2 * np.cos(np.pi * eval_count / self.budget)  # Adaptive scaling factor\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(dynamic_scaling)  # Use adaptive scaling\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n            self.diversity_preservation(population, bounds)  # Introduce diversity\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05761 with standard deviation 0.05470.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12961619207862396, 0.13221501449502282, 0.13168245999310235, 0.04522364122205136, 0.04032866393324108, 0.03872493864245996, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "a99afe53-7461-4da5-ac2b-9106af2e6a71", "fitness": 0.05538280727327475, "name": "EnhancedHybridMetaheuristic", "description": "Hybridized adaptive metaheuristic with immune-inspired diversity maintenance and synergistic particle interactions for enhanced convergence.  ", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.7  # Modified inertia weight\n        self.cognitive_constant = 1.2  # Adjusted cognitive constant\n        self.social_constant = 1.8  # Adjusted social constant\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.immunity_threshold = 0.1  # Added for immune diversity\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.05, min(0.25, 1.0 - (eval_count / self.budget)))  # Adjusted mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using adjusted PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Immune-inspired diversity maintenance\n                if np.random.rand() < self.immunity_threshold:\n                    population[i] = np.random.rand(self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05538 with standard deviation 0.05301.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1280351978587192, 0.12995297034881015, 0.1225550822101682, 0.04195567106226861, 0.03761618299586855, 0.03766349431697136, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c2c1ed81-4c59-4556-b4b2-7f509b3447dd", "fitness": 0.05609052457856767, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with improved exploration-exploitation balance using adaptive inertia weight and mutation scaling for faster convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            \n            # Adaptive inertia weight\n            self.inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)\n            \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation with dynamic scaling\n                levy_step = self.levy_flight(0.1 + 0.2 * (eval_count / self.budget))  # Adjusted scaling factor\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05609 with standard deviation 0.05320.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12476373521174744, 0.13217027212775656, 0.12582551100334638, 0.04112035562314709, 0.04214683061939262, 0.03812134995505223, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "163e6702-f8a2-443e-bc91-1c92e1235013", "fitness": 0.055971439966966706, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation based on diversity and dynamic search space and velocity adjustments for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            diversity = np.std(population, axis=0).mean()\n            mutation_prob = max(0.1, min(0.5, 1.0 - (diversity / (bounds[:, 1] - bounds[:, 0]).mean())))  # Adaptive mutation probability based on diversity\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n                velocities[i] = np.clip(velocities[i], -0.2 * (bounds[:, 1] - bounds[:, 0]), 0.2 * (bounds[:, 1] - bounds[:, 0]))  # Velocity clamping\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1)\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05597 with standard deviation 0.05330.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1279813865992918, 0.12995297034881015, 0.12531750052804402, 0.04117447509878125, 0.041115158642742844, 0.03753480181836355, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b38f366a-371d-4724-a440-bca7426ba4fc", "fitness": 0.05689635456629885, "name": "EnhancedHybridMetaheuristic", "description": "An enhanced hybrid metaheuristic with differential evolution (DE) integration, adaptive mutation scaling, and stochastic perturbation for superior convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def differential_evolution(self, population, bounds, mutation_prob):\n        for i in range(self.population_size):\n            if np.random.rand() < mutation_prob:\n                idxs = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(idxs, 3, replace=False)]\n                mutant = np.clip(a + self.scaling_factor * (b - c), bounds[:, 0], bounds[:, 1])\n                cross_points = np.random.rand(self.dim) < self.crossover_rate\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, population[i])\n                if np.random.rand() < mutation_prob:\n                    trial += self.levy_flight(0.1)\n                trial = np.clip(trial, bounds[:, 0], bounds[:, 1])\n                yield trial\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i, trial in enumerate(self.differential_evolution(population, bounds, mutation_prob)):\n                if eval_count >= self.budget:\n                    break\n\n                # Evaluate trial solution\n                fitness = func(trial)\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = trial\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = trial\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995\n\n            # Update velocities and positions using PSO dynamics\n            for i in range(self.population_size):\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n                population[i] = np.clip(population[i] + velocities[i], bounds[:, 0], bounds[:, 1])\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05690 with standard deviation 0.05422.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1255992233442501, 0.1306344249263135, 0.13344830430357035, 0.040252069851881345, 0.03938225380961924, 0.042084248194388385, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "39cf5a9f-d2e4-447f-a4b1-43a25fb29c99", "fitness": 0.05643852409105982, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive inertia weight, cooperative learning, and dynamic cooling to improve exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Adjusted initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n        temperature = self.initial_temperature\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cooperative_learn = np.random.choice(self.population_size)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i]) \n                    + 0.5 * np.random.rand(self.dim) * (population[cooperative_learn] - population[i])  # Cooperative learning\n                )\n\n                population[i] += velocities[i]\n                \n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        temperature *= self.cooling_rate ** 0.995  # Dynamic cooling adjustment\n\n                self.inertia_weight *= 0.99  # Dynamic inertia weight adjustment\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05644 with standard deviation 0.05400.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12835411427165544, 0.1318787193815938, 0.12737808510533477, 0.045031333927754935, 0.036013223674572714, 0.03862457379196005, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "52a70a6d-d4d3-40c0-93a5-5aedadf7819b", "fitness": 0.05633948398303818, "name": "SynergisticOptimization", "description": "Multi-strategy synergistic optimizer integrating adaptive mutation, dynamic cooling, and chaotic search for heightened convergence and exploration balance.", "code": "import numpy as np\n\nclass SynergisticOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.cooling_rate = 0.995\n        self.chaotic_factor = 0.7\n\n    def chaotic_map(self, x):\n        return self.chaotic_factor * x * (1 - x)  # Logistic map for chaotic behavior\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < 0.2:\n                    population[i] += levy_step\n\n                # Chaotic search enhancement\n                chaotic_factor = self.chaotic_map(np.random.rand())\n                population[i] += chaotic_factor * (bounds[:, 1] - bounds[:, 0]) * np.random.rand(self.dim)\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 73, "feedback": "The algorithm SynergisticOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05634 with standard deviation 0.05370.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12832610575661163, 0.13098567325474653, 0.12671945438913923, 0.0416654934228744, 0.038570415442053196, 0.04012154691525194, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "7bb0afcf-15bb-4cc0-b12f-f6ce492c5712", "fitness": 0.05788935926117381, "name": "EnhancedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with enhanced adaptive mutation and variable population size for better exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.5, 0.5 - (eval_count / (2 * self.budget))))  # Enhanced adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n                        self.population_size = max(5, int(self.population_size * 0.995))  # Variable population size\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05789 with standard deviation 0.05519.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13035223267914353, 0.13583150705925062, 0.13044476254238013, 0.044341387766230644, 0.040731474601199635, 0.03863620203569307, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "57e6d075-0f90-49db-8b0f-97206a5668d6", "fitness": 0.05569082601499158, "name": "AdvancedHybridMetaheuristic", "description": "Advanced hybrid metaheuristic leveraging chaotic maps for diversity promotion and adaptive cooling for enhanced convergence.", "code": "import numpy as np\n\nclass AdvancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.chaos_parameter = 0.7  # Logistic map parameter for chaos\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def chaotic_sequence(self, size):\n        x = np.random.rand()\n        sequence = np.zeros(size)\n        for i in range(size):\n            x = self.chaos_parameter * x * (1 - x)  # Logistic map\n            sequence[i] = x\n        return sequence\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            chaos_sequence = self.chaotic_sequence(self.population_size)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with chaotic influence\n                r1 = chaos_sequence[i]\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 75, "feedback": "The algorithm AdvancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05569 with standard deviation 0.05363.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.1319989369437986, 0.13058920749408565, 0.12165721996110657, 0.04132914580713498, 0.039072363909394725, 0.035903893352737026, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "f3131cfa-403a-4c77-a3b2-303b563e62c6", "fitness": 0.05785818008221618, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive inertia weight and nonlinear cooling for efficient global exploration and local exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.99\n        self.min_inertia_weight = 0.1\n        self.max_inertia_weight = 0.9\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n        temperature = self.initial_temperature  # Initialize temperature\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            inertia_weight = self.min_inertia_weight + \\\n                             (self.max_inertia_weight - self.min_inertia_weight) * \\\n                             np.cos(np.pi * eval_count / (2 * self.budget))  # Adaptive inertia weight\n            \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with adaptive inertia weight\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n            # Nonlinear cooling schedule\n            temperature *= self.cooling_rate ** (np.log(eval_count + 1))\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05786 with standard deviation 0.05540.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12737179755632477, 0.13475342093088294, 0.13551952460650385, 0.04062383054265373, 0.03917352469711277, 0.04261485573980084, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "4b5b18c0-7692-467e-9774-b3a8a6d0b257", "fitness": 0.05713567958801564, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive dimension reduction and dynamic search behavior for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with additional randomness\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                r3 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                    + 0.1 * r3 * (bounds[:, 1] - bounds[:, 0])  # Additional term for exploration\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation with adaptive intensity\n                levy_step = self.levy_flight(0.1 + 0.2 * (eval_count / self.budget))  # Enhanced dynamic search\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints with dimension reduction\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests with adaptive dimension reduction\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.inertia_weight *= 0.995  # Adaptive inertia weight reduction\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05714 with standard deviation 0.05516.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.13022884537108848, 0.13338941566641516, 0.13173457830781443, 0.040949072159549016, 0.03954074078995495, 0.037711797330652, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "de3b8cef-6a39-420d-8aa0-32159582e124", "fitness": 0.057962909529664014, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive mutation probability, dynamic search space adjustment, and improved inertia weight decay for better convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                self.inertia_weight *= 0.995  # Improved inertia weight decay\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05796 with standard deviation 0.05409.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12367683356479753, 0.1310597119554564, 0.13551952460650385, 0.04841102052849111, 0.040357073596870685, 0.041975354848189816, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "3d82294b-8261-42a5-ae1a-c0f3ef1d254b", "fitness": 0.05741216881687942, "name": "ImprovedHybridMetaheuristic", "description": "Improved hybrid metaheuristic with adaptive inertia and dynamic levy flight scaling for enhanced global exploration and local exploitation.", "code": "import numpy as np\n\nclass ImprovedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.initial_temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n\n    def adaptive_inertia(self, eval_count):\n        return self.final_inertia_weight + (self.inertia_weight - self.final_inertia_weight) * (1 - (eval_count / self.budget))\n\n    def dynamic_levy_flight(self, L, eval_count):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        scale_factor = 1.0 + 0.1 * (eval_count / self.budget)\n        return step * scale_factor\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            inertia_weight = self.adaptive_inertia(eval_count)\n            \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics with adaptive inertia\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation with dynamic scaling\n                levy_step = self.dynamic_levy_flight(0.1, eval_count)\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # Adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 79, "feedback": "The algorithm ImprovedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05741 with standard deviation 0.05486.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12727192238128937, 0.1310597119554564, 0.13551952460650385, 0.04194949222517874, 0.04413377082049008, 0.03610843069632963, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "91991562-52d6-4fe3-bf7e-6f979103930b", "fitness": 0.05796996172284184, "name": "EnhancedHybridMetaheuristic", "description": "Stochastic Adaptive Hybrid Metaheuristic using adaptive temperature scaling and diversity preservation for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.diversity_factor = 0.1  # New parameter for diversity\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget))) \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget)) \n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step * self.diversity_factor  # Adjust levy step for diversity\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995 \n                        self.temperature *= self.cooling_rate  # New adaptive temperature scaling\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05797 with standard deviation 0.05599.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [0.12547990679926257, 0.13969273802524773, 0.13551952460650385, 0.041391400107980036, 0.0406214895940864, 0.0383579297058293, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b8ec28df-0f8d-4b7b-9ea4-b3b725f13ad2", "fitness": -Infinity, "name": "DynamicAdaptiveHybridMetaheuristic", "description": "Dynamic Adaptive Hybrid Metaheuristic combining dynamic population control, adaptive crossover, and mutation with elite selection for efficient exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicAdaptiveHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.995\n        self.inertia_weight = 0.5\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.5\n        self.elite_fraction = 0.1\n        self.dynamic_population_growth_rate = 1.01\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population_size = self.initial_population_size\n        population = np.random.rand(population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            population_size = int(min(self.initial_population_size * self.dynamic_population_growth_rate, self.budget - eval_count))\n            elite_size = max(1, int(self.elite_fraction * population_size))\n            elite_indices = np.argsort(personal_best_fitness)[:elite_size]\n\n            new_population = np.copy(personal_best[elite_indices])\n            new_velocities = np.copy(velocities[elite_indices])\n\n            for i in range(elite_size, population_size):\n                if eval_count >= self.budget:\n                    break\n                \n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                inertia = self.inertia_weight * new_velocities[np.random.choice(elite_size)]\n                cognitive = self.cognitive_constant * r1 * (personal_best[i % elite_size] - new_population[i % elite_size])\n                social = self.social_constant * r2 * (global_best - new_population[i % elite_size])\n                new_velocity = inertia + cognitive + social\n                new_position = new_population[i % elite_size] + new_velocity\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    new_position += levy_step\n\n                new_position = np.clip(new_position, bounds[:, 0], bounds[:, 1])\n                fitness = func(new_position)\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i % elite_size]:\n                    personal_best[i % elite_size] = new_position\n                    personal_best_fitness[i % elite_size] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = new_position\n                        global_best_fitness = fitness\n\n                new_population = np.vstack((new_population, new_position))\n                new_velocities = np.vstack((new_velocities, new_velocity))\n\n            population = new_population[:population_size]\n            velocities = new_velocities[:population_size]\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 81, "feedback": "An exception occurred: IndexError('index 29 is out of bounds for axis 0 with size 3').", "error": "IndexError('index 29 is out of bounds for axis 0 with size 3')", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {}}
{"id": "f8a01e7d-5374-41fc-a4ea-13996aded7be", "fitness": 0.15312889724277903, "name": "EnhancedHybridMetaheuristic", "description": "Improved enhanced hybrid metaheuristic with dynamic cooling adjustment and refined inertia weight for better convergence control.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7  # Adjusted inertia weight for PSO\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7  # Small adjustment for better exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993  # More adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15313 with standard deviation 0.30323.", "error": "", "parent_ids": ["96e85b69-d7e2-4b6e-a292-cb714f0bc8e4"], "operator": null, "metadata": {"aucs": [1.0, 0.13211334794082308, 0.12871647997523872, 0.040252069851881345, 0.037894939790159454, 0.03851657096024208, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "143156d5-2908-42fc-9a4b-d87f4be40bcc", "fitness": 0.05633507195073319, "name": "EnhancedHybridMetaheuristic", "description": "An enhanced synergy of PSO and Levy-flight-based search feedback mechanism with adaptive parameters for more efficient global exploration and local exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def adaptive_parameters(self, eval_count):\n        # Adjust inertia weight and cooling rate more dynamically\n        fraction = eval_count / self.budget\n        self.inertia_weight = 0.7 - 0.4 * fraction\n        self.cooling_rate = 0.99 + 0.005 * fraction\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            self.adaptive_parameters(eval_count)\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            \n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05634 with standard deviation 0.05363.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12857711144771988, 0.1300414906887556, 0.12708936506032797, 0.04067663310556857, 0.04135608008230984, 0.038608300505250104, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b6d19dd2-f6b1-421c-94c9-818be69258be", "fitness": 0.05632333566457236, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with adaptive inertia, global exploration, and local exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Adaptive inertia weight for dynamic control\n        self.cognitive_constant = 1.3  # Adjusted for better local exploitation\n        self.social_constant = 1.8  # Slight increase for enhanced global search\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.05 + 0.15 * (eval_count / self.budget))  # Adjusted for improved exploration\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.992  # Slightly increased adaptability\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05632 with standard deviation 0.05416.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12684570432933062, 0.12995297034881015, 0.13170717605761906, 0.04085778633893111, 0.03884145200967781, 0.038038265230115775, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c5626da2-78ab-4b2c-897b-30b4db9461fc", "fitness": 0.05644364584824275, "name": "MultiAgentEnhancedHybridMetaheuristic", "description": "Multi-Agent Enhanced Hybrid Metaheuristic incorporating adaptive differential evolution and improved exploitation via dynamic neighborhood search to enhance exploration and convergence.", "code": "import numpy as np\n\nclass MultiAgentEnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.993\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n        self.agent_count = 5  # Number of agents to create cooperative behavior\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def dynamic_neighborhood_search(self, position, global_best, bounds):\n        neighbor_size = 0.1 * (bounds[:, 1] - bounds[:, 0])\n        neighbor = position + np.random.uniform(-neighbor_size, neighbor_size, self.dim)\n        return np.clip(neighbor, bounds[:, 0], bounds[:, 1])\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                if eval_count + self.agent_count <= self.budget:\n                    for _ in range(self.agent_count):\n                        neighbor = self.dynamic_neighborhood_search(population[i], global_best, bounds)\n                        fitness = func(neighbor)\n                        eval_count += 1\n                        if fitness < personal_best_fitness[i]:\n                            personal_best[i] = neighbor\n                            personal_best_fitness[i] = fitness\n                            if fitness < global_best_fitness:\n                                global_best = neighbor\n                                global_best_fitness = fitness\n                                self.cooling_rate *= self.cooling_rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 85, "feedback": "The algorithm MultiAgentEnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05644 with standard deviation 0.05324.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12694602921913412, 0.1330510214171613, 0.12345244636792962, 0.04133032791838109, 0.043872890023323285, 0.0386734310215886, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "f5952fc5-aaa0-4d69-93ca-36c0422f0d46", "fitness": 0.057020088247820885, "name": "EnhancedHybridMetaheuristic", "description": "Adaptive dynamic scaling factor and enhanced Levy flight perturbation for improved convergence balance.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7  # Adjusted inertia weight for PSO\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7  # Small adjustment for better exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            self.scaling_factor = 0.6 + 0.4 * (1 - eval_count / self.budget)  # Adaptive dynamic scaling factor\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.2 + 0.2 * (eval_count / self.budget))  # Enhanced dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993  # More adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05702 with standard deviation 0.05498.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.1268754757459296, 0.1316739811565898, 0.13545589383617984, 0.040252069851881345, 0.03932482876362664, 0.03893187820951405, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "9ead7c44-12cf-406b-908b-0bc84481fd23", "fitness": 0.05617132213666306, "name": "EnhancedAdaptiveHybridMetaheuristic", "description": "Introduce a multi-stage adaptive learning rate with neighborhood search to enhance convergence and exploration balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n        self.learning_rate = 0.1  # Initial adaptive learning rate for neighborhood search\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n        \n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Adaptive learning behavior for neighborhood search\n                neighborhood = np.clip(\n                    population[i] + self.learning_rate * np.random.randn(self.dim), \n                    bounds[:, 0], \n                    bounds[:, 1]\n                )\n                neighborhood_fitness = func(neighborhood)\n                eval_count += 1\n\n                if neighborhood_fitness < personal_best_fitness[i]:\n                    population[i] = neighborhood\n                    personal_best_fitness[i] = neighborhood_fitness\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993\n\n                # Adjust learning rate dynamically\n                self.learning_rate = max(0.05, self.learning_rate * (1.0 - eval_count / self.budget))\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedAdaptiveHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05617 with standard deviation 0.05453.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.1284933245314157, 0.13049626725461516, 0.13119726186384373, 0.04075550341991785, 0.03925709200535188, 0.034675783488156475, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "869f1f4b-d0bc-48f6-a1ee-d0da7ed32db4", "fitness": 0.05633280242077911, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced hybrid metaheuristic with optimized dynamic cooling adjustment for improved convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7  # Adjusted inertia weight for PSO\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7  # Small adjustment for better exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.995  # More optimized adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05633 with standard deviation 0.05436.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12883514660200057, 0.13211334794082308, 0.12871647997523872, 0.040252069851881345, 0.037894939790159454, 0.03851657096024208, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "9cf5e77f-99d6-4ee1-b3b6-4764f7a6600f", "fitness": 0.054977933178252676, "name": "EnhancedHybridMetaheuristic", "description": "Adaptive hybrid metaheuristic with adaptive velocity clamping and environment-adapted levy flight for robust exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n        self.velocity_clamp_factor = 0.5  # New velocity clamping factor\n\n    def levy_flight(self, L, scale_factor):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = scale_factor * u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        velocity_clamp = (bounds[:, 1] - bounds[:, 0]) * self.velocity_clamp_factor\n        \n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n                \n                # Apply velocity clamping\n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n\n                population[i] += velocities[i]\n\n                dynamic_levy_scale = 0.1 + 0.2 * (eval_count / self.budget)\n                levy_step = self.levy_flight(dynamic_levy_scale, scale_factor=0.5)\n\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05498 with standard deviation 0.05258.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12542504634091556, 0.12995297034881015, 0.12218884540721042, 0.041348488245837034, 0.03786088973349677, 0.03735849186133744, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "edfc6cc2-3ae0-4683-b852-b319fceb4471", "fitness": 0.055645904144845604, "name": "EnhancedHybridMetaheuristic", "description": "Adaptive multi-population strategy with parallel fitness enhancement and adaptive inertia in a hybrid metaheuristic.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * self.dim  # Slightly larger initial population\n        self.crossover_rate = 0.85  # Adjust crossover to increase diversity\n        self.scaling_factor = 0.75  # Lower scaling factor for more stable convergence\n        self.temperature = 100.0\n        self.cooling_rate = 0.995  # Fine-tuned cooling for temperature\n        self.inertia_weight = 0.9  # Adaptive inertia weight based on budget usage\n        self.cognitive_constant = 1.6  # Increased for better exploitation\n        self.social_constant = 1.4  # Reduced to limit premature convergence\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.2, min(0.4, 1.0 - (eval_count / self.budget)))  # Enhanced adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                adaptive_inertia = self.inertia_weight * (1 - eval_count / self.budget)\n                velocities[i] = (\n                    adaptive_inertia * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.05 * (eval_count / self.budget))  # More gradual adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n\n                        # Adjust cooling dynamically\n                        self.cooling_rate *= 0.9925  # Adjust cooling to stabilize\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05565 with standard deviation 0.05360.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12787102008315876, 0.12995297034881015, 0.1265694980445191, 0.040286440182279004, 0.037837980191585685, 0.03762856178659102, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "d74a6449-9d83-4f02-9316-99119b731541", "fitness": 0.05633280242077911, "name": "EnhancedHybridMetaheuristic", "description": "Adaptive Inertia and Cooling Hybrid Metaheuristic with Swarm Diversity Management for Enhanced Convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n        self.diversity_threshold = 0.1  # New parameter to maintain swarm diversity\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def diversity_measure(self, population):\n        centroid = np.mean(population, axis=0)\n        diversity = np.mean(np.linalg.norm(population - centroid, axis=1))\n        return diversity\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            current_diversity = self.diversity_measure(population)\n            if current_diversity < self.diversity_threshold:\n                self.inertia_weight = min(1.0, self.inertia_weight + 0.05)  # Increase inertia to boost exploration\n\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05633 with standard deviation 0.05436.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12883514660200057, 0.13211334794082308, 0.12871647997523872, 0.040252069851881345, 0.037894939790159454, 0.03851657096024208, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5d9024eb-c951-4d10-8fb3-edd6af77a2d3", "fitness": 0.05685894870709182, "name": "OptimizedHybridMetaheuristic", "description": "An optimized hybrid metaheuristic using adaptive inertia and dynamic neighborhood adjustment for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass OptimizedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Increased initial inertia weight\n        self.cognitive_constant = 2.0  # Increased cognitive constant for broader exploration\n        self.social_constant = 1.5  # Slight reduction to focus more on individual exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            adaptive_inertia = self.inertia_weight * (1 - (eval_count / self.budget))  # Adapting inertia weight\n            neighborhood_radius = 0.1 + 0.1 * (eval_count / self.budget)  # Dynamic neighborhood adjustment\n\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    adaptive_inertia * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(neighborhood_radius)\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 92, "feedback": "The algorithm OptimizedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05686 with standard deviation 0.05446.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12417228785844558, 0.1310597119554564, 0.13551952460650385, 0.04060373409340312, 0.038471312640695254, 0.04123730054265551, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "70e30cdf-5ec1-4d81-af8b-3ff08d16d378", "fitness": 0.05688243987026709, "name": "AdvancedAdaptiveHybridMetaheuristic", "description": "Advanced adaptive hybrid metaheuristic integrating stochastic inertia weight adjustment and strategic crossover for enhanced convergence and robustness.", "code": "import numpy as np\n\nclass AdvancedAdaptiveHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Initial inertia weight\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def adaptive_inertia_weight(self, eval_count):\n        return 0.4 + (0.5 - 0.4) * (1 - eval_count / self.budget)  # Decreasing inertia weight\n\n    def crossover(self, parent1, parent2, crossover_rate):\n        mask = np.random.rand(self.dim) < crossover_rate\n        offspring = np.where(mask, parent1, parent2)\n        return offspring\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                self.inertia_weight = self.adaptive_inertia_weight(eval_count)\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Crossover operation\n                if np.random.rand() < self.crossover_rate:\n                    partner_index = np.random.randint(self.population_size)\n                    population[i] = self.crossover(population[i], population[partner_index], self.crossover_rate)\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 93, "feedback": "The algorithm AdvancedAdaptiveHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05688 with standard deviation 0.05443.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.13111688370602526, 0.13228235819364653, 0.12750588499239712, 0.040252069851881345, 0.04123077976003675, 0.03888731566175008, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "487d196c-237e-443b-951d-0c3f55ec07c3", "fitness": 0.05633280242077911, "name": "EnhancedHybridMetaheuristic", "description": "Fine-tuned cooling rate adjustment for enhanced convergence control in hybrid metaheuristics.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.98  # Adjusted cooling rate for improved convergence\n        self.inertia_weight = 0.7  # Adjusted inertia weight for PSO\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7  # Small adjustment for better exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))  # Adaptive mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993  # More adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05633 with standard deviation 0.05436.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12883514660200057, 0.13211334794082308, 0.12871647997523872, 0.040252069851881345, 0.037894939790159454, 0.03851657096024208, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "fadde0a2-fcf8-46ee-a1c4-a961e3a42eb7", "fitness": 0.05626381534247803, "name": "EnhancedHybridMetaheuristic", "description": "An enhanced hybrid metaheuristic utilizing adaptive control of exploration and exploitation balance through dynamic parameter tuning and elite learning mechanism for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993\n\n            # Elite learning mechanism: Introduce elite solutions to guide exploration\n            elite_fraction = 0.1\n            num_elites = int(self.population_size * elite_fraction)\n            elite_indices = np.argsort(personal_best_fitness)[:num_elites]\n            for elite_idx in elite_indices:\n                elite_position = personal_best[elite_idx]\n                perturbation = self.levy_flight(0.05)\n                new_elite_position = elite_position + perturbation\n                new_elite_position = np.clip(new_elite_position, bounds[:, 0], bounds[:, 1])\n                fitness = func(new_elite_position)\n                eval_count += 1\n\n                if fitness < personal_best_fitness[elite_idx]:\n                    personal_best[elite_idx] = new_elite_position\n                    personal_best_fitness[elite_idx] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = new_elite_position\n                        global_best_fitness = fitness\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05626 with standard deviation 0.05362.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12670871384946003, 0.13004491672854468, 0.12872863386453137, 0.04101216644184147, 0.03755140178290073, 0.04166183874835727, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "e493a17a-2ae1-4724-97b0-62844ee9787c", "fitness": 0.056206644258885094, "name": "EnhancedHybridMetaheuristic", "description": "Enhanced Hybrid Metaheuristic with refined dynamic mutation probability and adaptive cooling rate for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7  # Adjusted inertia weight for PSO\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7  # Small adjustment for better exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.12, min(0.35, 1.0 - (eval_count / self.budget)))  # Refined mutation probability\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))  # Dynamic search space adjustment\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness\n                fitness = func(population[i])\n                eval_count += 1\n\n                # Update personal and global bests\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.992  # More adaptive cooling rate\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05621 with standard deviation 0.05435.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12524131063236632, 0.12995297034881015, 0.13394634057024157, 0.04102246807412402, 0.036513471077515014, 0.03851657096024208, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "939d2190-d31e-4a25-95d6-117a3f583c46", "fitness": 0.056030144256620416, "name": "RefinedAdaptiveHybridMetaheuristic", "description": "Adaptive multi-population hybrid metaheuristic leveraging chaotic maps and dynamic parameter tuning for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedAdaptiveHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.9  # Increased inertia weight for better exploration\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n        self.chaotic_map_factor = 0.5  # Chaotic map factor for dynamic parameter adjustments\n        self.sub_population_size = max(2, self.population_size // 3)  # Split into smaller interacting sub-populations\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def chaotic_map(self, x):\n        return np.sin(self.chaotic_map_factor * np.pi * x)\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            chaotic_inertia = self.chaotic_map(eval_count / self.budget)\n            for i in range(self.population_size):\n                if eval_count >= self.budget:\n                    break\n\n                if i % self.sub_population_size == 0 and i != 0:\n                    sub_population_best = personal_best[np.argmin(personal_best_fitness[i - self.sub_population_size:i])]\n                    if func(sub_population_best) < global_best_fitness:\n                        global_best = sub_population_best\n                        global_best_fitness = func(sub_population_best)\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    (self.inertia_weight * chaotic_inertia) * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 97, "feedback": "The algorithm RefinedAdaptiveHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05603 with standard deviation 0.05290.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.12341563499605823, 0.13054879708153255, 0.1270724479226275, 0.04179405472709674, 0.041971351173079596, 0.03880234574252239, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b53a5e7b-46cb-47ee-a791-b91bc05c92a9", "fitness": 0.05694222965721591, "name": "EnhancedHybridMetaheuristic2", "description": "EnhancedHybridMetaheuristic2: Incorporating dynamic population scaling and adaptive learning rates for improved convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridMetaheuristic2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * self.dim\n        self.min_population_size = 5 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.7\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population_size = self.initial_population_size\n        population = np.random.rand(population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            adaptive_inertia = self.inertia_weight * (1 - eval_count / self.budget)\n            adaptive_cognitive = self.cognitive_constant * (1 + eval_count / self.budget)\n            adaptive_social = self.social_constant * (1 - eval_count / self.budget)\n            \n            for i in range(population_size):\n                if eval_count >= self.budget:\n                    break\n\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    adaptive_inertia * velocities[i]\n                    + adaptive_cognitive * r1 * (personal_best[i] - population[i])\n                    + adaptive_social * r2 * (global_best - population[i])\n                )\n\n                population[i] += velocities[i]\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n                fitness = func(population[i])\n                eval_count += 1\n\n                if fitness < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness\n                    if fitness < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness\n                        self.cooling_rate *= 0.993\n\n            # Dynamic population scaling\n            if eval_count % (self.budget // 10) == 0:\n                population_size = max(\n                    self.min_population_size,\n                    int(self.initial_population_size * (1 - eval_count / self.budget))\n                )\n                population = population[:population_size]\n                velocities = velocities[:population_size]\n                personal_best = personal_best[:population_size]\n                personal_best_fitness = personal_best_fitness[:population_size]\n                \n        return global_best, global_best_fitness", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedHybridMetaheuristic2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05694 with standard deviation 0.05507.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.1285724049566518, 0.13714254524496272, 0.1285425160047905, 0.041709581822240605, 0.03730374656326341, 0.03854260565636747, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "d87a465b-b493-4eb6-8927-39f6a5536d55", "fitness": 0.05699711090146734, "name": "AdvancedHybridMetaheuristic", "description": "Advanced hybrid metaheuristic with adaptive dynamic population resizing and stochastic tunneling for enhanced global exploration.", "code": "import numpy as np\n\nclass AdvancedHybridMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * self.dim\n        self.crossover_rate = 0.9\n        self.scaling_factor = 0.8\n        self.temperature = 100.0\n        self.cooling_rate = 0.99\n        self.inertia_weight = 0.7\n        self.cognitive_constant = 1.5\n        self.social_constant = 1.9  # Enhanced social component for exploration\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, self.dim) * L\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1.0 / 3.0)\n        return step\n\n    def stochastic_tunneling(self, fitness):\n        return 1 - np.exp(-self.temperature * (fitness - np.min(fitness)))\n\n    def __call__(self, func):\n        bounds = np.array([func.bounds.lb, func.bounds.ub]).T\n        population = np.random.rand(self.population_size, self.dim) * (bounds[:, 1] - bounds[:, 0]) + bounds[:, 0]\n        velocities = np.zeros_like(population)\n        personal_best = np.copy(population)\n        personal_best_fitness = np.array([func(ind) for ind in personal_best])\n        global_best = personal_best[np.argmin(personal_best_fitness)]\n        global_best_fitness = np.min(personal_best_fitness)\n        eval_count = self.population_size\n\n        while eval_count < self.budget:\n            mutation_prob = max(0.1, min(0.3, 1.0 - (eval_count / self.budget)))\n            \n            # Adaptive population resizing\n            reduced_population_size = int(self.population_size * (1 - (eval_count / self.budget) * 0.5))\n            if reduced_population_size < 2:\n                reduced_population_size = 2\n\n            for i in range(reduced_population_size):\n                if eval_count >= self.budget:\n                    break\n\n                # Update velocities using PSO dynamics\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                velocities[i] = (\n                    self.inertia_weight * velocities[i]\n                    + self.cognitive_constant * r1 * (personal_best[i] - population[i])\n                    + self.social_constant * r2 * (global_best - population[i])\n                )\n\n                # Update position\n                population[i] += velocities[i]\n\n                # Levy flight perturbation\n                levy_step = self.levy_flight(0.1 + 0.1 * (eval_count / self.budget))\n                if np.random.rand() < mutation_prob:\n                    population[i] += levy_step\n\n                # Boundary constraints\n                population[i] = np.clip(population[i], bounds[:, 0], bounds[:, 1])\n\n                # Evaluate fitness with stochastic tunneling\n                fitness = func(population[i])\n                eval_count += 1\n                fitness_adjusted = self.stochastic_tunneling(fitness)\n\n                # Update personal and global bests\n                if fitness_adjusted < personal_best_fitness[i]:\n                    personal_best[i] = population[i]\n                    personal_best_fitness[i] = fitness_adjusted\n                    if fitness_adjusted < global_best_fitness:\n                        global_best = population[i]\n                        global_best_fitness = fitness_adjusted\n                        self.cooling_rate *= 0.993\n\n        return global_best, global_best_fitness", "configspace": "", "generation": 99, "feedback": "The algorithm AdvancedHybridMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05700 with standard deviation 0.05428.", "error": "", "parent_ids": ["f8a01e7d-5374-41fc-a4ea-13996aded7be"], "operator": null, "metadata": {"aucs": [0.13132338099905816, 0.13354313151861308, 0.1253156101335886, 0.041480743841815215, 0.04035186258325563, 0.04029260237020871, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
