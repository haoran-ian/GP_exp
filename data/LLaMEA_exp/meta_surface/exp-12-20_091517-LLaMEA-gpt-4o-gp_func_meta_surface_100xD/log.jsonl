{"id": "dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261", "fitness": 0.06247576578293536, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Crossover and Mutation Rates for Efficient Black-Box Optimization", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.06247086677341107, 0.0624721703034653, 0.062484260532063574, 0.06247086672105573, 0.062472170250891135, 0.06248426047974298, 0.0624708665657403, 0.06247217009572259, 0.062484260324325525]}}
{"id": "76331061-01ea-4188-9ad5-4784238a8e82", "fitness": 0.062475728122361254, "name": "AdaptiveDifferentialEvolution", "description": "Introduce a diversity-enhancing mechanism using random perturbation to maintain exploration in Adaptive Differential Evolution.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                \n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n            \n            # Diversity enhancement through random perturbation\n            if evaluations < self.budget:  # Ensuring we stay within budget\n                rand_idx = np.random.randint(0, self.population_size)\n                self.pop[rand_idx] += np.random.uniform(-0.1, 0.1, size=self.dim)\n                self.pop[rand_idx] = np.clip(self.pop[rand_idx], self.bounds[0], self.bounds[1])\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247083362073114, 0.06247217128475069, 0.062484179721688404, 0.06247083356834704, 0.062472171232394125, 0.062484179669394346, 0.06247083341296378, 0.06247217107700498, 0.06248417951397678]}}
{"id": "cd8d15e9-6e1d-4302-afe7-2b97ea4ae908", "fitness": 0.062475688407923786, "name": "AdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution with Stepwise Dynamic Parameter Adjustment for Enhanced Black-Box Optimization", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        dynamic_adjustment_steps = 5  # New parameter\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR every few steps\n            if evaluations % dynamic_adjustment_steps == 0:\n                self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05), 0.1, 0.9)\n                self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.062470910274703195, 0.06247221465642461, 0.06248394055273132, 0.062470910222308995, 0.062472214604068044, 0.06248394050035233, 0.06247091006701966, 0.062472214448712426, 0.062483940344993494]}}
{"id": "89cf3a43-a79c-4e38-82a9-98eba8c1c576", "fitness": 0.06247573136348772, "name": "AdaptiveDifferentialEvolution", "description": "Improved dynamic adjustment of mutation factor for better convergence in Adaptive Differential Evolution.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05), 0.1, 0.9)  # Slightly adjusted mutation factor range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.062470809182748166, 0.06247218478150873, 0.06248420038626579, 0.062470809130392824, 0.062472184729163716, 0.06248420033394253, 0.06247080897506441, 0.06247218457377479, 0.062484200178528515]}}
{"id": "494f7aa6-26dc-4490-8880-03d22e0bf7ff", "fitness": -Infinity, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Crossover, Mutation Rates, and Enhanced Random Selection for Efficient Black-Box Optimization", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False, p=[1/self.population_size]*self.population_size)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 4, "feedback": "An exception occurred: ValueError(\"'a' and 'p' must have same size\").", "error": "ValueError(\"'a' and 'p' must have same size\")", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {}}
{"id": "a4894fe4-83c8-4842-9f22-b605506103cf", "fitness": 0.062475688407923786, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Improved Dynamic Parameter Adjustments for Better Convergence.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05), 0.4, 0.9)  # Modified to improve convergence\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.5, 1.0)  # Modified for better adaptability\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.062470910274703195, 0.06247221465642461, 0.06248394055273132, 0.062470910222308995, 0.062472214604068044, 0.06248394050035233, 0.06247091006701966, 0.062472214448712426, 0.062483940344993494]}}
{"id": "9debddd1-3353-4593-b7a9-a612ded3c7df", "fitness": 0.06247571850071395, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Novel Population Diversity Strategy and Adaptive Learning for Superior Black-Box Optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.learning_rate = 0.1  # Rate to adjust F and CR\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors with diversity check\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                selected = np.random.choice(candidates, 3, replace=False)\n                a, b, c = selected if np.std(self.pop[selected], axis=0).mean() > 0.1 else np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive adjustment of F and CR based on population improvement\n            mean_fitness = np.mean(self.fitness)\n            F_improvement = self.learning_rate * (np.min(self.fitness) - mean_fitness)\n            CR_improvement = self.learning_rate * (mean_fitness - np.min(self.fitness))\n            self.F = np.clip(self.F + F_improvement, 0.1, 0.9)\n            self.CR = np.clip(self.CR + CR_improvement, 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247088471617279, 0.06247203817875113, 0.06248423286738014, 0.06247088466381745, 0.062472038126368146, 0.06248423281483051, 0.06247088450848903, 0.06247203797097911, 0.06248423265963721]}}
{"id": "51b7e233-01bb-440e-9d82-d3aa7558a162", "fitness": 0.062475636095235126, "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Target-to-Best Mutation for Improved Convergence in Black-Box Optimization", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n                best = np.argmin(self.fitness)\n\n                # Enhanced Mutation: Target-to-Best\n                mutant = np.clip(self.pop[i] + self.F * (self.pop[best] - self.pop[i]) + self.F * (self.pop[b] - self.pop[c]), \n                                 self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247046276051815, 0.06247224685887154, 0.062484198926402335, 0.06247046270818701, 0.0624722468064105, 0.06248419887404977, 0.06247046255281219, 0.0624722466511739, 0.06248419871869071]}}
{"id": "3bb45a09-b9ae-44c9-9753-884d350bd384", "fitness": 0.06247571704957184, "name": "AdaptiveDifferentialEvolution", "description": "Introduced a learning rate to adaptively update the mutation factor F, enhancing exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        learning_rate = 0.05  # Introduced learning rate for F adjustment\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + learning_rate * np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247089150184504, 0.062472188254344974, 0.06248407165258241, 0.062470891449571186, 0.06247218820198819, 0.06248407160012759, 0.06247089129418826, 0.06247218804662813, 0.06248407144487078]}}
{"id": "ea795c19-2286-4aa2-94c5-1b797f621764", "fitness": 0.06247570624180294, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Self-Adaptive Population Size Control for Improved Black-Box Optimization Efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = min(max(4, 10 * dim), budget // 2)\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.initial_population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n        \n        while evaluations < self.budget:\n            population_size = len(self.pop)\n            for i in range(population_size):\n                # Select three distinct vectors\n                candidates = list(range(population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n            # Self-adaptive population size control\n            if evaluations < self.budget / 2:\n                new_size = int(0.9 * population_size)\n            else:\n                new_size = int(1.1 * population_size)\n            new_size = max(4, min(new_size, self.budget - evaluations))\n            \n            # Adjust population size\n            if new_size < population_size:\n                sort_idx = np.argsort(self.fitness)\n                self.pop = self.pop[sort_idx[:new_size]]\n                self.fitness = self.fitness[sort_idx[:new_size]]\n            elif new_size > population_size:\n                additional_pop = np.random.rand(new_size - population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n                additional_fitness = np.array([func(ind) for ind in additional_pop])\n                evaluations += len(additional_pop)\n                self.pop = np.vstack((self.pop, additional_pop))\n                self.fitness = np.concatenate((self.fitness, additional_fitness))\n        \n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.0624708686473866, 0.062472148743553446, 0.06248410159452966, 0.06247086859503115, 0.062472148691223195, 0.06248410154217343, 0.062470868439703064, 0.06247214853583416, 0.062484101386791724]}}
{"id": "a2f8bb73-b5f5-47d2-91f9-55ecdd007617", "fitness": 0.062475746851686345, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Adaptive Population Resizing and Success-Based Parameter Tuning.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.success_count = 0\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.success_count += 1\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Adjust population size dynamically\n            if evaluations < self.budget:\n                self.population_size = max(4, int(self.initial_population_size * (1 - evaluations / self.budget)))\n                self.pop = self.pop[:self.population_size]\n                self.fitness = self.fitness[:self.population_size]\n\n            # Success-based parameter tuning\n            if self.success_count > 0:\n                self.F = np.clip(self.F + np.random.uniform(0, 0.2), 0.1, 0.9)\n                self.CR = np.clip(self.CR + np.random.uniform(0, 0.1), 0.1, 1.0)\n                self.success_count = 0\n            else:\n                self.F = np.clip(self.F + np.random.uniform(-0.2, 0.0), 0.1, 0.9)\n                self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.0), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247078623025826, 0.06247220538846221, 0.062484249196515074, 0.06247078617780932, 0.062472205336105424, 0.06248424914399986, 0.06247078602248113, 0.06247220518074226, 0.06248424898880356]}}
{"id": "b7ea79a0-15ad-4ef6-953f-d5f8ef4668ef", "fitness": 0.062475688407923786, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Learning-Based Parameter Adjustment for Improved Black-Box Optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.successful_mutations = []\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.successful_mutations.append((self.F, self.CR))\n\n                if evaluations >= self.budget:\n                    break\n\n            # Learning-Based Dynamic Adjustment of F and CR\n            if self.successful_mutations:\n                self.F = np.clip(np.mean([f for f, cr in self.successful_mutations]) + np.random.uniform(-0.05, 0.05), 0.1, 0.9)\n                self.CR = np.clip(np.mean([cr for f, cr in self.successful_mutations]) + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n                self.successful_mutations.clear()\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.062470910274703195, 0.06247221465642461, 0.06248394055273132, 0.062470910222308995, 0.062472214604068044, 0.06248394050035233, 0.06247091006701966, 0.062472214448712426, 0.062483940344993494]}}
{"id": "282483d3-3a1d-4a65-b208-87de3b8a18f0", "fitness": 0.06247561612718942, "name": "AdaptiveDifferentialEvolution", "description": "Introducing a non-uniform mutation factor `F` to increase diversity and potentially escape local optima.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                F_i = np.random.uniform(0.4, 0.9)  # Non-uniform mutation factor\n                mutant = np.clip(self.pop[a] + F_i * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247048514348186, 0.062472213335077575, 0.062484150163147234, 0.06247048509098463, 0.06247221328279373, 0.06248415011059372, 0.06247048493579399, 0.062472213127404586, 0.062484149955427504]}}
{"id": "a98a27ad-1ca8-4454-894b-699b91ec8ad1", "fitness": 0.06247569446975296, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhancing Adaptive Differential Evolution with Self-Adaptive Mechanisms for Mutation and Crossover Rates to Improve Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F_base = 0.5  # Base mutation factor\n        self.CR_base = 0.9  # Base crossover rate\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        F_adapt = self.F_base\n        CR_adapt = self.CR_base\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with self-adaptation\n                F = np.clip(F_adapt + np.random.normal(0, 0.1), 0.1, 0.9)\n                mutant = np.clip(self.pop[a] + F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover with self-adaptation\n                CR = np.clip(CR_adapt + np.random.normal(0, 0.1), 0.1, 1.0)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    # Successful adaptation\n                    F_adapt = F\n                    CR_adapt = CR\n\n                if evaluations >= self.budget:\n                    break\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247086245830058, 0.06247209539884391, 0.06248412581223173, 0.062470862405770156, 0.06247209534648712, 0.06248412575990914, 0.06247086225061582, 0.062472095191097976, 0.06248412560452021]}}
{"id": "3c93d282-bcf2-4aa3-b3b4-f681482e83fd", "fitness": 0.06247575707689888, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population and Learning Mechanism for Improved Convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n        self.learning_rate = 0.1  # Added learning rate for adaptive strategy\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.F += self.learning_rate * (trial_fitness - self.fitness[i])  # Learn from success\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n            if evaluations % (self.population_size // 2) == 0:  # Population change mechanism\n                best_idx = np.argmin(self.fitness)\n                new_ind = np.random.rand(self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n                new_fitness = func(new_ind)\n                evaluations += 1\n                if new_fitness < self.fitness[best_idx]:\n                    self.pop[best_idx] = new_ind\n                    self.fitness[best_idx] = new_fitness\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247083783422713, 0.06247217380803749, 0.06248425984854955, 0.06247083778191198, 0.06247217375546821, 0.06248425979622918, 0.06247083762652861, 0.062472173600299774, 0.062484259640838036]}}
{"id": "c0ac72cb-111a-4e96-a70e-120fb7c42357", "fitness": 0.062475784678674984, "name": "EnhancedDifferentialEvolution", "description": "Integrating Adaptive Differential Evolution with Levy Flight for Enhanced Exploration and Convergence in Black-Box Optimization", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["dc7ef4bd-1c2c-445b-ad0f-24aecc4e2261"], "operator": null, "metadata": {"aucs": [0.06247094244894025, 0.06247224475837332, 0.06248416708896187, 0.06247094239638584, 0.06247224470600932, 0.06248416703646131, 0.06247094224106575, 0.06247224455067524, 0.06248416688120195]}}
{"id": "cdec047a-f68b-4450-bb51-46eb85907a78", "fitness": 0.06247580576199174, "name": "EnhancedDifferentialEvolution", "description": "Slightly increasing the mutation factor dynamics to improve exploration and convergence balance in the Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)  # Slightly increased range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["c0ac72cb-111a-4e96-a70e-120fb7c42357"], "operator": null, "metadata": {"aucs": [0.062470942930580975, 0.06247222771124061, 0.062484246904223495, 0.06247094287822097, 0.06247222765888205, 0.06248424685184906, 0.06247094272290066, 0.06247222750354231, 0.06248424669648556]}}
{"id": "610d38e8-1afe-4217-a235-49f5b6ebbf75", "fitness": 0.062475534618921316, "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with refined random selection to improve diversity and enhance convergence.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors with better diversity\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False, p=np.full(len(candidates), 1/len(candidates)))\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)  # Slightly increased range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 17, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["cdec047a-f68b-4450-bb51-46eb85907a78"], "operator": null, "metadata": {"aucs": [0.06247016280759232, 0.06247217444398023, 0.06248426686520403, 0.06247016275531858, 0.06247217439162367, 0.062484266812853684, 0.06247016259994376, 0.06247217423628093, 0.062484266657494625]}}
{"id": "c3069041-364e-4399-8e62-29c9a08a589c", "fitness": 0.06247577658780606, "name": "EnhancedDifferentialEvolution", "description": "Integrate dynamic scaling of mutation factor and crossover rate based on fitness variance to enhance adaptability in Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            fitness_variance = np.var(self.fitness)\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR based on fitness variance\n            scale_factor = fitness_variance / (fitness_variance + 1)\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12) * scale_factor, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1) * scale_factor, 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["cdec047a-f68b-4450-bb51-46eb85907a78"], "operator": null, "metadata": {"aucs": [0.062470930316329665, 0.062472193296829404, 0.062484206410447496, 0.06247093026381523, 0.06247219324449904, 0.06248420635806884, 0.062470930108494915, 0.06247219308911511, 0.062484206202654824]}}
{"id": "4b565aee-70b8-49cf-b3ed-dd0d9698b265", "fitness": 0.062475428806078, "name": "ImprovedDifferentialEvolution", "description": "Improved Differential Evolution with Adaptive Levy Flight to enhance dynamic exploration and exploitation balance.", "code": "import numpy as np\n\nclass ImprovedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def adaptive_levy_flight(self, lam=1.5):\n        # Adapt lambda based on budget consumption to balance exploration and exploitation\n        lam = 1.5 - 0.5 * (self.budget_consumed / self.budget)\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        self.budget_consumed = evaluations\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Adaptive Levy Flight\n                lev = self.adaptive_levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                self.budget_consumed += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 19, "feedback": "The algorithm ImprovedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["cdec047a-f68b-4450-bb51-46eb85907a78"], "operator": null, "metadata": {"aucs": [0.062469788637366186, 0.06247222063051894, 0.06248427741047735, 0.062469788584941455, 0.06247222057816204, 0.062484277358066165, 0.06246978842968931, 0.06247222042277323, 0.06248427720270733]}}
{"id": "892d4248-cb1c-4ab4-9546-4a7a13856309", "fitness": 0.06247585152709297, "name": "EnhancedDifferentialEvolution", "description": "Slightly increasing the population size to enhance diversity and exploration in Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10 * dim to 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)  # Slightly increased range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["cdec047a-f68b-4450-bb51-46eb85907a78"], "operator": null, "metadata": {"aucs": [0.06247099399863687, 0.062472252668752226, 0.06248430817404793, 0.0624709939461261, 0.062472252616421975, 0.06248430812150174, 0.062470993790971985, 0.06247225246103294, 0.062484307966344965]}}
{"id": "afa822f9-356e-4f88-bb6d-c4de563aec7c", "fitness": 0.0624758344597789, "name": "EnhancedDifferentialEvolution", "description": "Slightly increase the crossover rate and its dynamic range for better exploration in Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10 * dim to 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.95  # Slightly increased initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)  # Slightly decreased adjustment range\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.0624710069377965, 0.06247219820129468, 0.06248429850059578, 0.06247100688544094, 0.062472198148717406, 0.062484298448036046, 0.06247100673009254, 0.06247219799336323, 0.06248429829267299]}}
{"id": "f7c62696-e4ab-42e7-8845-959fad06f541", "fitness": 0.06247584029853163, "name": "EnhancedDifferentialEvolution", "description": "Slightly increase the mutation factor's range for better exploration in Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10 * dim to 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.15, 0.15), 0.1, 0.9)  # Slightly increased range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.06247098748800295, 0.062472252668752226, 0.06248428099897618, 0.062470987435508496, 0.062472252616421975, 0.06248428094663738, 0.06247098728017919, 0.06247225246103294, 0.06248428079127333]}}
{"id": "8029cf6d-1738-4616-9e3e-0634b236e62b", "fitness": 0.06247584029853163, "name": "EnhancedDifferentialEvolution", "description": "Fine-tuned the dynamic adjustment of mutation factor `F` for improved exploration and convergence balance.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10 * dim to 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.15, 0.15), 0.1, 0.9)  # Slightly increased range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.06247098748800295, 0.062472252668752226, 0.06248428099897618, 0.062470987435508496, 0.062472252616421975, 0.06248428094663738, 0.06247098728017919, 0.06247225246103294, 0.06248428079127333]}}
{"id": "23bf90e5-e0df-40e6-a84d-8bc08fbc49b9", "fitness": 0.06247584742801279, "name": "EnhancedDifferentialEvolution", "description": "Integrating a self-adaptive mechanism for mutation factor (F) and crossover rate (CR) to balance exploration and exploitation in Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        success_rates = []\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    success_rates.append(1)\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                else:\n                    success_rates.append(0)\n\n                if evaluations >= self.budget:\n                    break\n\n            # Self-adaptive adjustment of F and CR based on success rates\n            if success_rates:\n                success_ratio = sum(success_rates) / len(success_rates)\n                scale_factor = (success_ratio - 0.5) * 0.2\n                self.F = np.clip(self.F + scale_factor, 0.1, 0.9)\n                self.CR = np.clip(self.CR + scale_factor, 0.1, 1.0)\n                success_rates = []\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.06247098838617082, 0.06247225356785846, 0.06248430059008747, 0.062470988333870436, 0.062472253515501674, 0.0624843005376452, 0.0624709881784955, 0.06247225336011253, 0.06248430038237307]}}
{"id": "653b745e-084e-49ef-a354-a76f641da0a9", "fitness": 0.06247576210304383, "name": "EnhancedDifferentialEvolution", "description": "Increasing the mutation factor slightly to enhance exploration in Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size from 10 * dim to 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.6  # Modified mutation factor from 0.5 to 0.6\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        # Initialization\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Select three distinct vectors\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Mutation with Levy Flight\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)  # Slightly increased range\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.06247096701392607, 0.06247209671721354, 0.06248422283819011, 0.06247096696143162, 0.06247209666470821, 0.06248422278575261, 0.062470966806277506, 0.06247209650946772, 0.06248422263042708]}}
{"id": "c65a0e1f-db1d-499d-9c38-58a98b96a7a6", "fitness": 0.0624758005960685, "name": "EnhancedDifferentialEvolution", "description": "Enhancing mutation diversity in Enhanced Differential Evolution using adaptive Levy flight scale and hyper-parameter tuning.", "code": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5  # Initial mutation factor\n        self.CR = 0.9  # Initial crossover rate\n\n    def levy_flight(self, lam=1.5, scale=0.01):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return scale * u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                # Adaptive Levy Flight scale based on evaluation progress\n                scale = (self.budget - evaluations) / self.budget\n                lev = self.levy_flight(scale=scale)\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive adjustment of F and CR based on convergence feedback\n            self.F = np.clip(self.F + np.random.uniform(-0.15, 0.15), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.15, 0.15), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.06247096701392607, 0.06247220413713972, 0.06248423089728894, 0.06247096696143162, 0.06247220408472198, 0.06248423084492283, 0.062470966806277506, 0.062472203929398895, 0.062484230689508924]}}
{"id": "07676a27-9e93-4798-b0eb-0fbb0aa4b92d", "fitness": 0.06247585152709297, "name": "AdaptivePopulationDifferentialEvolution", "description": "Introducing adaptive population size based on convergence rate to balance exploration and exploitation in Enhanced Differential Evolution.", "code": "import numpy as np\n\nclass AdaptivePopulationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.initial_population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n        convergence_threshold = 0.001  # Convergence threshold for adaptive population size\n        population_size = self.initial_population_size\n\n        while evaluations < self.budget:\n            for i in range(population_size):\n                candidates = list(range(population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            improvement = np.std(self.fitness) / np.mean(self.fitness)\n            if improvement < convergence_threshold:\n                population_size = max(self.dim, population_size - 1)\n            else:\n                population_size = min(self.initial_population_size, population_size + 1)\n\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm AdaptivePopulationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.06247099399863687, 0.062472252668752226, 0.06248430817404793, 0.0624709939461261, 0.062472252616421975, 0.06248430812150174, 0.062470993790971985, 0.06247225246103294, 0.062484307966344965]}}
{"id": "d0a03e04-7f5c-4860-a5dd-be571638a12f", "fitness": 0.062475792022801846, "name": "AdaptiveDifferentialEvolution", "description": "Introducing adaptive population size and stochastic ranking for Enhanced Differential Evolution to improve convergence efficiency and solution quality.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                 (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def stochastic_ranking(self, fitness, constraint_violations):\n        return np.lexsort((fitness, constraint_violations))\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.initial_population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n        population_size = self.initial_population_size\n\n        while evaluations < self.budget:\n            constraint_violations = np.array([np.sum(ind < self.bounds[0]) + np.sum(ind > self.bounds[1]) for ind in self.pop])\n            sorted_indices = self.stochastic_ranking(self.fitness, constraint_violations)\n            self.pop = self.pop[sorted_indices]\n            self.fitness = self.fitness[sorted_indices]\n\n            new_population = []\n            for i in range(population_size):\n                candidates = list(range(population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population.append((trial, trial_fitness))\n                else:\n                    new_population.append((self.pop[i], self.fitness[i]))\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations < self.budget:\n                self.pop, self.fitness = zip(*new_population)\n                self.pop = np.array(self.pop)\n                self.fitness = np.array(self.fitness)\n                population_size = max(5, int(population_size * 0.95))  # adaptively reduce population size\n\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.06247099477327822, 0.062472093895289516, 0.06248428766004066, 0.06247099472075757, 0.06247209384283692, 0.062484287607675326, 0.06247099456560323, 0.062472093687447994, 0.06248428745228718]}}
{"id": "de4daa57-7423-431b-aa0c-4c12e7ac47d1", "fitness": 0.062475836277937194, "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Enhanced Mutation using Lvy Flights and Dynamic Parameter Adjustment to improve convergence efficiency.", "code": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + self.F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            # Dynamic adjustment of F and CR with additional feedback from population diversity\n            diversity = np.mean(np.std(self.pop, axis=0))\n            self.F = np.clip(self.F + np.random.uniform(-0.12, 0.12) * (1 - diversity), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.06247096701392607, 0.062472252668752226, 0.06248428941122908, 0.06247096696143162, 0.062472252616421975, 0.06248428935886374, 0.062470966806277506, 0.06247225246103294, 0.06248428920349958]}}
{"id": "732cad29-01a2-44f0-8d46-f27177938100", "fitness": 0.06247586871031266, "name": "AdaptiveChaoticDifferentialEvolution", "description": "Introducing adaptive parameter control and chaotic sequences in Enhanced Differential Evolution to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass AdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm AdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["892d4248-cb1c-4ab4-9546-4a7a13856309"], "operator": null, "metadata": {"aucs": [0.062470997661087435, 0.06247226989410415, 0.06248433883595117, 0.06247099760859298, 0.06247226984174736, 0.06248433878347415, 0.06247099745343887, 0.06247226968635833, 0.062484338628059466]}}
{"id": "c1bdfc40-b7bc-4e28-93d6-6e50fe70b7f5", "fitness": 0.06247586870851867, "name": "AdaptiveChaoticDifferentialEvolution", "description": "Introducing a self-adjusting chaotic factor based on the best solution's progress to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        best_fitness = np.min(self.fitness)  # Track best fitness\n\n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor) * (best_fitness / np.min(self.fitness))  # Adjust chaotic factor\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.062470997661087435, 0.062472270018370746, 0.06248433870635972, 0.06247099760859298, 0.062472269965833105, 0.06248433865390446, 0.06247099745343887, 0.06247226981045284, 0.06248433849862789]}}
{"id": "fbba57f4-43f8-4d67-990f-80a2a70ffd00", "fitness": 0.062475812489229815, "name": "AdaptiveChaoticDifferentialEvolution", "description": "Enhanced AdaptiveChaoticDifferentialEvolution by incorporating a new chaotic mutation strategy.", "code": "import numpy as np\n\nclass AdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev * chaotic_factor, self.bounds[0], self.bounds[1])  # Changed line\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm AdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.06247098548235408, 0.06247221679605519, 0.06248423544935233, 0.06247098543001228, 0.06247221674369863, 0.062484235396982446, 0.06247098527467887, 0.062472216588362106, 0.06248423524157243]}}
{"id": "c7c2f37b-1723-44d7-89f6-4e34ee245e24", "fitness": 0.062475856167254644, "name": "EnhancedAdaptiveChaoticDifferentialEvolution", "description": "Integrate a dynamic chaotic elitism mechanism into AdaptiveChaoticDifferentialEvolution to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                if chaotic_factor > 0.5:  # Dynamic elitism\n                    mutant = np.clip(mutant + 0.1 * (best_individual - mutant), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedAdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.06247096701392607, 0.062472256658642644, 0.062484345089400706, 0.06247096696143162, 0.062472256606312504, 0.06248434503689615, 0.062470966806277506, 0.06247225645092336, 0.062484344881481246]}}
{"id": "e031195f-ace2-444b-ac7a-da85b80cff7f", "fitness": 0.062475830807533925, "name": "HybridAdaptiveChaoticDifferentialEvolution", "description": "Introducing hybridization of Levy flight with Gaussian perturbation in Adaptive Chaotic Differential Evolution to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridAdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                gaussian_perturbation = np.random.normal(0, 0.1, self.dim)\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + gaussian_perturbation, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 34, "feedback": "The algorithm HybridAdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.062470991924791885, 0.06247218859079562, 0.06248431216706618, 0.06247099187250493, 0.062472188538465256, 0.06248431211459016, 0.06247099171714343, 0.06247218838310964, 0.062484311959338235]}}
{"id": "cafe3494-d1ae-4b30-b242-af27fb07da0a", "fitness": 0.06247576411853539, "name": "AdaptiveChaoticDifferentialEvolution", "description": "Introducing a mutation rate influenced by a sinusoidal function to vary exploration and exploitation dynamically in Enhanced Differential Evolution for better convergence.", "code": "import numpy as np\n\nclass AdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.sin(evaluations), self.bounds[0], self.bounds[1])  # Modified line\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 35, "feedback": "The algorithm AdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.06247096701392607, 0.06247225394803291, 0.06248407165381564, 0.06247096696143162, 0.062472253895702656, 0.06248407160125624, 0.062470966806277506, 0.06247225374031362, 0.06248407144606227]}}
{"id": "5310b3d4-90bd-4273-b026-40a6d12e67bf", "fitness": 0.06247577395877384, "name": "AdaptiveChaoticDifferentialEvolution", "description": "Improve convergence by adapting the population size using chaotic sequences.", "code": "import numpy as np\n\nclass AdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            self.population_size = int(12 * self.dim * chaotic_factor)  # Adapt population size\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm AdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.06247096701392607, 0.06247217229957158, 0.062484182822976075, 0.06247096696143162, 0.0624721722471796, 0.0624841827705328, 0.062470966806277506, 0.06247217209187306, 0.06248418261519628]}}
{"id": "5774a74c-e6e8-4525-9cf0-4c33f6a6fdeb", "fitness": 0.06247201193863919, "name": "RefinedAdaptiveChaoticDifferentialEvolution", "description": "Introducing self-adaptive dynamic scaling factor and memory-enhanced chaotic sequences in Differential Evolution to enhance both exploration and exploitation capabilities.", "code": "import numpy as np\n\nclass RefinedAdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.memory = np.random.rand(100)  # Memory to enhance chaos\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x, index):\n        return 4.0 * x * (1.0 - x) + self.memory[index % len(self.memory)] * 0.01\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor, evaluations)\n            adaptive_F = self.F * (0.5 + chaotic_factor)\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n            self.memory[evaluations % len(self.memory)] = chaotic_factor\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm RefinedAdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06247 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.06247245043597305, 0.062463520448258536, 0.06248006519174665, 0.06247245038362159, 0.06246352039590941, 0.06248006513937154, 0.06247245022828851, 0.06246352024058832, 0.062480064983995054]}}
{"id": "74141e37-353a-45fb-9daa-94e92112f5b2", "fitness": 0.06247577933146421, "name": "AdaptiveChaoticDifferentialEvolution", "description": "Enhance exploration by adding a Gaussian mutation step to improve diversity and escape local optima.", "code": "import numpy as np\n\nclass AdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                \n                # New Gaussian mutation step\n                gauss_mutation = np.random.normal(0, 0.1, size=self.dim)\n                mutant = np.clip(mutant + gauss_mutation, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 38, "feedback": "The algorithm AdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.06247099977211634, 0.0624721911381817, 0.06248414734424823, 0.06247099971977266, 0.06247219108582491, 0.062484147291662184, 0.06247099956444113, 0.06247219093046241, 0.062484147136468327]}}
{"id": "2f9346fd-0e13-444e-97f9-0f2b45c2ce25", "fitness": 0.06247585662902877, "name": "AdaptiveChaoticDifferentialEvolution", "description": "Incorporating a new chaotic sequence for better exploration in Enhanced Differential Evolution to improve convergence.", "code": "import numpy as np\n\nclass AdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 3.8 * x * (1.0 - x)  # Changed from 4.0 to 3.8\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm AdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.06247099411022905, 0.0624722404033784, 0.06248433563353317, 0.06247099405788903, 0.062472240351074015, 0.06248433558116817, 0.06247099390255406, 0.06247224019568487, 0.06248433542574816]}}
{"id": "6b5cbc3f-3830-4b0a-a6c9-3b7c86f4c0dc", "fitness": -Infinity, "name": "EnhancedAdaptiveChaoticDE", "description": "Enhancing Adaptive Chaotic Differential Evolution by integrating opposition-based learning and an elite archive to improve diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.elite_archive = []\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def opposition_based_learning(self):\n        opposite_pop = self.bounds[0] + self.bounds[1] - self.pop\n        opposite_fitness = np.array([func(ind) for ind in opposite_pop])\n        return opposite_pop, opposite_fitness\n\n    def update_archive(self, trial, trial_fitness):\n        if len(self.elite_archive) < self.population_size:\n            self.elite_archive.append((trial, trial_fitness))\n        else:\n            worst_index = np.argmax([fit for _, fit in self.elite_archive])\n            if trial_fitness < self.elite_archive[worst_index][1]:\n                self.elite_archive[worst_index] = (trial, trial_fitness)\n    \n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        chaotic_factor = np.random.rand()\n        \n        while evaluations < self.budget:\n            chaotic_factor = self.chaotic_sequence(chaotic_factor)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            # Perform opposition-based learning\n            opposite_pop, opposite_fitness = self.opposition_based_learning()\n            for i in range(self.population_size):\n                if opposite_fitness[i] < self.fitness[i]:\n                    self.pop[i] = opposite_pop[i]\n                    self.fitness[i] = opposite_fitness[i]\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.update_archive(trial, trial_fitness)\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 40, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {}}
{"id": "1059af3f-e310-4b70-8f43-ae1e052604b8", "fitness": 0.06248386430463234, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introducing multi-chaos mapping and hybrid mutation strategies in Adaptive Differential Evolution to enhance robustness and exploration capability.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            method = 'logistic' if np.random.rand() < 0.5 else 'tent'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1), 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["732cad29-01a2-44f0-8d46-f27177938100"], "operator": null, "metadata": {"aucs": [0.06248585222790315, 0.06247670001584915, 0.06248904093024166, 0.06248585217549707, 0.062476699963510574, 0.06248904087792939, 0.062485852020122246, 0.06247669980810577, 0.06248904072253203]}}
{"id": "448c8b52-c743-4c3b-bbeb-26b08546125c", "fitness": 0.06248390977324706, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced exploration by adjusting the mutation factor to dynamically vary based on population diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            method = 'logistic' if np.random.rand() < 0.5 else 'tent'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            diversity = np.std(self.pop, axis=0).mean()  # Calculate the population diversity\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)  # Adjust F based on diversity\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1059af3f-e310-4b70-8f43-ae1e052604b8"], "operator": null, "metadata": {"aucs": [0.06248594146696185, 0.06247679654626759, 0.06248899156657228, 0.06248594141462871, 0.06247679649393367, 0.062488991514259795, 0.06248594125921414, 0.0624767963385493, 0.06248899135883623]}}
{"id": "14a205f0-b995-4bb5-b86d-9faa5a3ffd21", "fitness": -Infinity, "name": "SelfAdaptiveDifferentialEvolution", "description": "Incorporate self-adaptive mechanisms for both mutation and crossover rates based on historical success to enhance convergence and diversity.", "code": "import numpy as np\n\nclass SelfAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = np.random.uniform(0.5, 0.9, self.population_size)\n        self.CR = np.random.uniform(0.1, 0.9, self.population_size)\n        self.chaotic_x = np.random.rand()\n        self.success_F = []\n        self.success_CR = []\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def adaptive_parameters(self):\n        if self.success_F:\n            self.F = np.clip(np.mean(self.success_F) + 0.1 * np.random.normal(), 0.1, 0.9)\n        if self.success_CR:\n            self.CR = np.clip(np.mean(self.success_CR) + 0.1 * np.random.normal(), 0.1, 1.0)\n        self.success_F, self.success_CR = [], []\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            method = 'logistic' if np.random.rand() < 0.5 else 'tent'\n            chaotic_factor = self.chaotic_sequence(method)\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                adaptive_F = self.F[i] * chaotic_factor\n                adaptive_CR = self.CR[i] * chaotic_factor\n\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.success_F.append(adaptive_F)\n                    self.success_CR.append(adaptive_CR)\n\n                if evaluations >= self.budget:\n                    break\n\n            self.adaptive_parameters()\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 43, "feedback": "An exception occurred: IndexError('invalid index to scalar variable.').", "error": "IndexError('invalid index to scalar variable.')", "parent_ids": ["448c8b52-c743-4c3b-bbeb-26b08546125c"], "operator": null, "metadata": {}}
{"id": "ba279dec-42c5-4dba-8fb3-69ca48c19f5c", "fitness": 0.062483831245762796, "name": "EnhancedDynamicDifferentialEvolution", "description": "Utilize a dual-phase strategy combining chaotic adaptation and differential evolution with a dynamic population size for enhanced convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.initial_population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n        phase = 1  # Start in exploration phase\n\n        while evaluations < self.budget:\n            method = 'logistic' if np.random.rand() < 0.5 else 'tent'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.initial_population_size):\n                if phase == 1:\n                    a, b, c = np.random.choice(range(self.initial_population_size), 3, replace=False)\n                else:\n                    a, b, c = np.random.choice(np.argsort(self.fitness)[:self.initial_population_size//2], 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n            if evaluations > self.budget * 0.5:\n                phase = 2  # Switch to exploitation phase\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["448c8b52-c743-4c3b-bbeb-26b08546125c"], "operator": null, "metadata": {"aucs": [0.0624859665630948, 0.0624765310107972, 0.06248899642348216, 0.062485966510728574, 0.06247653095844763, 0.06248899637113148, 0.06248596635535775, 0.062476530803079244, 0.06248899621574633]}}
{"id": "350583cf-6dcb-4879-960a-89a2b9224433", "fitness": 0.06248399796028222, "name": "SwarmInspiredDifferentialEvolution", "description": "Incorporate a swarm intelligence-inspired adaptive inertia weight to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass SwarmInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = 'logistic' if np.random.rand() < 0.5 else 'tent'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 45, "feedback": "The algorithm SwarmInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["448c8b52-c743-4c3b-bbeb-26b08546125c"], "operator": null, "metadata": {"aucs": [0.06248594963561238, 0.06247704595425729, 0.0624889985510757, 0.062485949583270806, 0.0624770459018934, 0.06248899849874878, 0.0624859494278559, 0.06247704574649149, 0.06248899834333421]}}
{"id": "1ab81cd7-9804-462a-9f9b-4c0e0073eb7e", "fitness": 0.06248393724463977, "name": "RefinedSwarmDifferentialEvolution", "description": "Enhance dynamic exploration-exploitation balance by employing dynamic chaos control and adaptive parameters based on improvement history.", "code": "import numpy as np\n\nclass RefinedSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.improvement_history = []\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n        best_fitness = np.min(self.fitness)\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = 'logistic' if np.random.rand() < 0.5 else 'tent'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.improvement_history.append((evaluations, trial_fitness))\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n\n                if evaluations >= self.budget:\n                    break\n\n            improvement_rate = len(self.improvement_history) / evaluations\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * improvement_rate, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 46, "feedback": "The algorithm RefinedSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["350583cf-6dcb-4879-960a-89a2b9224433"], "operator": null, "metadata": {"aucs": [0.06248584547646896, 0.06247704595425729, 0.0624889205633784, 0.062485845423882136, 0.0624770459018934, 0.06248892051105359, 0.062485845268688056, 0.06247704574649149, 0.06248892035564457]}}
{"id": "bc0f8e88-110c-41bc-b592-aef3db47bca1", "fitness": 0.06248395946845507, "name": "EnhancedSwarmDifferentialEvolution", "description": "Integrate a dynamic parameter adaptation using chaos-enhanced mechanisms to optimize convergence and diversity throughout the evolutionary process.", "code": "import numpy as np\n\nclass EnhancedSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def adaptive_parameters(self, diversity):\n        self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity * self.chaotic_x/2, 0.1, 0.9)\n        self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05) * self.chaotic_x/2, 0.1, 1.0)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = 'logistic' if np.random.rand() < 0.5 else 'tent'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.adaptive_parameters(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["350583cf-6dcb-4879-960a-89a2b9224433"], "operator": null, "metadata": {"aucs": [0.062485939518885036, 0.06247704595425729, 0.06248889319236883, 0.06248593946653336, 0.0624770459018934, 0.062488893139862056, 0.06248593931114499, 0.06247704574649149, 0.062488892984659206]}}
{"id": "0003ee5b-cbab-41f0-8199-4f10f0c50599", "fitness": 0.06248351233929734, "name": "DynamicPopulationDifferentialEvolution", "description": "Introduce a dynamic population resizing mechanism to enhance exploration-exploitation balance and improve convergence speed.", "code": "import numpy as np\n\nclass DynamicPopulationDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                 (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def dynamic_population_size(self, eval_ratio):\n        min_pop_size = self.dim + 1\n        max_pop_size = self.initial_population_size\n        return int(min_pop_size + (max_pop_size - min_pop_size) * (1 - eval_ratio))\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.initial_population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = 'logistic' if np.random.rand() < 0.5 else 'tent'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            current_pop_size = self.dynamic_population_size(eval_ratio)\n            self.pop = self.pop[:current_pop_size]\n            self.fitness = self.fitness[:current_pop_size]\n\n            for i in range(current_pop_size):\n                candidates = list(range(current_pop_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 48, "feedback": "The algorithm DynamicPopulationDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["350583cf-6dcb-4879-960a-89a2b9224433"], "operator": null, "metadata": {"aucs": [0.062485943462496696, 0.06247547524083352, 0.062489118574643565, 0.062485943410130695, 0.06247547518847041, 0.06248911852230232, 0.06248594325471579, 0.06247547503314932, 0.062489118366933716]}}
{"id": "d15deb4b-8646-412f-b8d1-77c545156248", "fitness": 0.06248400651866426, "name": "EnhancedSwarmInspiredDifferentialEvolution", "description": "Enhance differential evolution with adaptive chaotic dynamics and Levy flight for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSwarmInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedSwarmInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["350583cf-6dcb-4879-960a-89a2b9224433"], "operator": null, "metadata": {"aucs": [0.06248588481085926, 0.06247704866191084, 0.06248908634340433, 0.06248588475839745, 0.06247704860954706, 0.06248908629102723, 0.062485884603073916, 0.06247704845414492, 0.062489086135613325]}}
{"id": "f76e5f01-42b5-4f89-b5fd-dc216abf74bc", "fitness": 0.06248383350691997, "name": "EnhancedSwarmInspiredDifferentialEvolution", "description": "Introduce adaptive population resizing and dynamic parameter tuning within enhanced differential evolution for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedSwarmInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def adaptive_population_size(self, eval_ratio):\n        return int(self.initial_population_size * (1 - eval_ratio) + 4)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.initial_population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.initial_population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            current_population_size = self.adaptive_population_size(eval_ratio)\n            self.pop = self.pop[:current_population_size]\n            self.fitness = self.fitness[:current_population_size]\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(current_population_size):\n                candidates = list(range(current_population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedSwarmInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["d15deb4b-8646-412f-b8d1-77c545156248"], "operator": null, "metadata": {"aucs": [0.06248594931801221, 0.06247663971373607, 0.06248891174916815, 0.06248594926570106, 0.06247663966118433, 0.062488911696806926, 0.062485949110280936, 0.06247663950598026, 0.062488911541409786]}}
{"id": "86fbc8f0-fb82-4029-a3ff-376b97899cdf", "fitness": 0.06248380087475162, "name": "EnhancedSwarmInspiredDifferentialEvolution", "description": "Introduce adaptive learning rates based on population diversity to further enhance the balance between exploration and exploitation in differential evolution.", "code": "import numpy as np\n\nclass EnhancedSwarmInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def adaptive_learning_rate(self, diversity):\n        return 0.5 + 0.4 * np.tanh(5 * (diversity - 0.5))\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.chaotic_sequence(method)\n            diversity = np.std(self.pop, axis=0).mean()\n            learning_rate = self.adaptive_learning_rate(diversity)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight * learning_rate\n            adaptive_CR = self.CR * chaotic_factor * learning_rate\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedSwarmInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["d15deb4b-8646-412f-b8d1-77c545156248"], "operator": null, "metadata": {"aucs": [0.062485894045240964, 0.06247656361159881, 0.062488945227678006, 0.06248589399284277, 0.062476563559075604, 0.06248894517517123, 0.06248589383746006, 0.06247656340372876, 0.06248894501996838]}}
{"id": "fcb9a54d-7cd0-4095-82f0-ad2b0f48db21", "fitness": 0.06248402243915671, "name": "QuantumEnhancedDifferentialEvolution", "description": "Introduce adaptive parameter control and quantum-inspired exploration to enhance diversity and convergence speed in differential evolution.", "code": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 52, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["d15deb4b-8646-412f-b8d1-77c545156248"], "operator": null, "metadata": {"aucs": [0.06248594924932449, 0.06247704595425729, 0.06248907237408885, 0.06248594919697359, 0.0624770459018934, 0.06248907232150058, 0.062485949041583, 0.06247704574649149, 0.06248907216629773]}}
{"id": "b7e09178-ef88-48cf-9812-0bbdc61188a1", "fitness": 0.062483936461635414, "name": "QuantumEnhancedDifferentialEvolution", "description": "Enhance exploration and exploitation balance by incorporating chaos-enhanced local search and dynamic control of parameters.", "code": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        exploration_strength = np.random.uniform(0.5, 1.5)\n        return current + exploration_strength * np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def local_search(self, candidate):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(candidate + perturbation, self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                if np.random.rand() < 0.2:\n                    trial = self.local_search(trial)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 53, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["fcb9a54d-7cd0-4095-82f0-ad2b0f48db21"], "operator": null, "metadata": {"aucs": [0.06248586618034324, 0.06247686336626712, 0.06248908009848109, 0.06248586612775642, 0.06247686331393798, 0.062489080046139844, 0.0624858659724814, 0.0624768631585404, 0.06248907989077124]}}
{"id": "d4846c0b-27e9-42ff-8828-c9ceb63fb432", "fitness": 0.062484014488388126, "name": "RefinedQuantumDifferentialEvolution", "description": "Enhance exploration and convergence by incorporating adaptive chaotic parameter control and quantum-inspired diversity mechanisms in differential evolution.", "code": "import numpy as np\n\nclass RefinedQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.chaotic_x = np.random.rand()\n        self.inertia_weight = 0.9\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            for i in range(self.population_size):\n                if np.random.rand() < 0.5:\n                    self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 54, "feedback": "The algorithm RefinedQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["fcb9a54d-7cd0-4095-82f0-ad2b0f48db21"], "operator": null, "metadata": {"aucs": [0.0624859068730752, 0.06247704595425729, 0.062489090897984045, 0.06248590682066424, 0.0624770459018934, 0.062489090845616824, 0.062485906665306734, 0.06247704574649149, 0.06248909069020392]}}
{"id": "1cc7c2a0-faac-4177-af05-6511185ffa23", "fitness": 0.0624840250778704, "name": "QuantumEnhancedDifferentialEvolution", "description": "Tweak chaotic sequence selection to enhance convergence efficiency.", "code": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])  # Removed 'sine' for a minor tweak\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 55, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["fcb9a54d-7cd0-4095-82f0-ad2b0f48db21"], "operator": null, "metadata": {"aucs": [0.06248595553732739, 0.06247704595425729, 0.06248907400213222, 0.062485955484976485, 0.0624770459018934, 0.06248907394977343, 0.062485955329585785, 0.06247704574649149, 0.062489073794396166]}}
{"id": "8b10d1ec-2dca-4885-a5e5-c5d15c92030b", "fitness": 0.06248399783821744, "name": "AdaptiveQuantumDifferentialEvolution", "description": "Integrate adaptive mutation rate and dynamic population resizing based on convergence metrics to boost solution diversity and convergence speed.", "code": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 12 * dim\n        self.population_size = self.initial_population_size\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n            # Dynamic population resizing\n            self.population_size = max(4, int(self.initial_population_size * (1 - eval_ratio)))\n            self.pop = self.pop[:self.population_size]\n            self.fitness = self.fitness[:self.population_size]\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 56, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1cc7c2a0-faac-4177-af05-6511185ffa23"], "operator": null, "metadata": {"aucs": [0.06248591705892892, 0.06247704595425729, 0.062489030761638586, 0.062485917006553815, 0.0624770459018934, 0.06248903070913725, 0.062485916851153456, 0.06247704574649149, 0.06248903055390276]}}
{"id": "99c8c822-04d8-41c9-a9a2-b9ecd8370396", "fitness": 0.062483994248798615, "name": "AdaptiveChaoticDifferentialEvolution", "description": "Incorporate adaptive chaotic mutation and selection for diversity enhancement in convergence.", "code": "import numpy as np\n\nclass AdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n    \n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def adaptive_chaotic_factor(self, eval_ratio):\n        factor = np.random.uniform(0.5, 2.0) * (1.0 - eval_ratio)\n        return factor * self.chaotic_sequence('logistic')\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n            chaotic_factor = self.adaptive_chaotic_factor(eval_ratio)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 57, "feedback": "The algorithm AdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1cc7c2a0-faac-4177-af05-6511185ffa23"], "operator": null, "metadata": {"aucs": [0.062485980704968025, 0.06247699015677266, 0.062489012144737566, 0.062485980652601913, 0.062476990104435526, 0.062489012092385665, 0.06248598049723575, 0.06247698994903339, 0.06248901193701706]}}
{"id": "3f5161ca-33ea-4acd-8f4a-58cff932605b", "fitness": 0.06248372648651449, "name": "ImprovedQuantumEnhancedDifferentialEvolution", "description": "Utilize adaptive chaotic mappings and a refined mutation strategy for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass ImprovedQuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.mutation_strategy = 'current-to-best'\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method='adaptive'):\n        if method == 'adaptive':\n            self.chaotic_x = np.mod(self.chaotic_x + np.random.choice([0.1, 0.2]), 1.0)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = 'adaptive'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n\n                best_idx = np.argmin(self.fitness)\n                best_individual = self.pop[best_idx]\n                if self.mutation_strategy == 'current-to-best':\n                    mutant_classic = np.clip(self.pop[i] + adaptive_F * (best_individual - self.pop[c]), self.bounds[0], self.bounds[1])\n                else:\n                    mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 58, "feedback": "The algorithm ImprovedQuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1cc7c2a0-faac-4177-af05-6511185ffa23"], "operator": null, "metadata": {"aucs": [0.062485927009965136, 0.06247625215262653, 0.06248900055711726, 0.06248592695754496, 0.06247625210012486, 0.06248900050481443, 0.062485926802147485, 0.06247625194489892, 0.062489000349390866]}}
{"id": "f1a00ad5-43ec-445f-90ab-ab9cb8fcd35f", "fitness": 0.06248402243915671, "name": "ImprovedQuantumEnhancedDifferentialEvolution", "description": "Enhance dynamic chaotic sequence and adaptive parameters integration for improved convergence.", "code": "import numpy as np\n\nclass ImprovedQuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])  # Added 'sine' back for diversity\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 59, "feedback": "The algorithm ImprovedQuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1cc7c2a0-faac-4177-af05-6511185ffa23"], "operator": null, "metadata": {"aucs": [0.06248594924932449, 0.06247704595425729, 0.06248907237408885, 0.06248594919697359, 0.0624770459018934, 0.06248907232150058, 0.062485949041583, 0.06247704574649149, 0.06248907216629773]}}
{"id": "e3961feb-83c7-4306-be16-bc9657c4f773", "fitness": 0.06248389741248112, "name": "EnhancedChaoticDifferentialEvolution", "description": "Introduce adaptive chaotic map selection and ensemble mutation strategies to enhance diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        elif method == 'gauss':\n            self.chaotic_x = np.mod(self.chaotic_x + np.random.normal(0, 0.1), 1.0)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine', 'gauss'])\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c, d, e = np.random.choice(candidates, 5, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n                mutant_ensemble = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + adaptive_F * (self.pop[d] - self.pop[e]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_ensemble if np.random.rand() < 0.5 else (mutant_levy if np.random.rand() < 0.5 else mutant_classic), self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1cc7c2a0-faac-4177-af05-6511185ffa23"], "operator": null, "metadata": {"aucs": [0.0624859083116559, 0.062476758357587925, 0.06248902582844207, 0.06248590825929101, 0.06247675830507127, 0.06248902577601989, 0.0624859081039012, 0.06247675814968312, 0.06248902562067771]}}
{"id": "d1a3d469-49d2-4d81-a67f-bc9b285a9257", "fitness": 0.0624839143643327, "name": "QuantumEnhancedDifferentialEvolution", "description": "Introduce a hybrid chaotic mutation operator combining logistic and tent maps to enhance adaptability and convergence speed.", "code": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            return 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            return 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def hybrid_chaotic_mutation(self):\n        logistic_val = self.chaotic_sequence('logistic')\n        tent_val = self.chaotic_sequence('tent')\n        self.chaotic_x = (logistic_val + tent_val) / 2\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.hybrid_chaotic_mutation()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1cc7c2a0-faac-4177-af05-6511185ffa23"], "operator": null, "metadata": {"aucs": [0.0624858560162207, 0.062476934274221185, 0.06248895306277702, 0.062485855963803294, 0.062476934221857294, 0.06248895301030344, 0.062485855808465995, 0.062476934066465484, 0.062488952854879876]}}
{"id": "93146a8d-30a9-456b-a87a-875598627a1d", "fitness": 0.06248357729950232, "name": "QuantumEnhancedDifferentialEvolution", "description": "Refine chaotic sequence selection and levy flight parameters for improved convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.3):  # Changed from 1.5 to 1.3 for better exploration\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':  # Reintroduced 'sine' for diversity\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])  # Changed to include 'sine'\n            chaotic_factor = self.chaotic_sequence(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1cc7c2a0-faac-4177-af05-6511185ffa23"], "operator": null, "metadata": {"aucs": [0.0624858706975554, 0.06247579992484842, 0.06248906153624556, 0.062485870645090924, 0.06247579987239904, 0.062489061483933295, 0.0624858704898007, 0.06247579971713779, 0.06248906132850973]}}
{"id": "0e404327-31d3-4bff-b3a0-556a6c16f3cc", "fitness": 0.062484034555149934, "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhance exploration and exploitation using adaptive chaotic sequences with feedback modulation.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x  # Introduce feedback modulation for diversity\n        return chaotic_x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["1cc7c2a0-faac-4177-af05-6511185ffa23"], "operator": null, "metadata": {"aucs": [0.06248593437945782, 0.06247704595425729, 0.062489123591880524, 0.06248593432698324, 0.0624770459018934, 0.06248912353956826, 0.0624859341716727, 0.06247704574649149, 0.062489123384144696]}}
{"id": "2fd29246-a7a3-4e5a-a26c-c95922ece762", "fitness": 0.0624839843985227, "name": "EnhancedChaoticDifferentialEvolution", "description": "Improve convergence speed by integrating adaptive local search with chaotic differential evolution.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        \n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-1, 1, size=self.dim) * (best - current)\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x  # Introduce feedback modulation for diversity\n        return chaotic_x\n\n    def local_search(self, candidate):\n        perturbation = np.random.uniform(-0.05, 0.05, size=self.dim) * (self.bounds[1] - self.bounds[0])\n        return np.clip(candidate + perturbation, self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                else:  # Perform local search if no improvement\n                    local_candidate = self.local_search(self.pop[i])\n                    local_fitness = func(local_candidate)\n                    evaluations += 1\n                    if local_fitness < self.fitness[i]:\n                        self.fitness[i] = local_fitness\n                        self.pop[i] = local_candidate\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["0e404327-31d3-4bff-b3a0-556a6c16f3cc"], "operator": null, "metadata": {"aucs": [0.06248597141518841, 0.06247684677794352, 0.06248913526247857, 0.06248597136282419, 0.06247684672565734, 0.06248913521016619, 0.06248597120745847, 0.06247684657025543, 0.06248913505473219]}}
{"id": "75a33cf2-9312-475d-ac20-41ef1e8a2e56", "fitness": 0.06248403920980867, "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhance global-local balance using dynamic Levy flights, adaptive chaotic sequences, and stochastic quantum tunneling.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current)\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["0e404327-31d3-4bff-b3a0-556a6c16f3cc"], "operator": null, "metadata": {"aucs": [0.06248594834338428, 0.06247704595425729, 0.062489123591880524, 0.06248594829100895, 0.0624770459018934, 0.06248912353956826, 0.062485948135649116, 0.06247704574649149, 0.062489123384144696]}}
{"id": "46636448-39d4-4f58-bbd2-95195184991d", "fitness": 0.0624838527985045, "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhance exploration-exploitation efficiency using multi-chaotic sequences, memory-driven adaptive control, and quantum tunneling for dynamic fitness landscape navigation.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.memory = np.zeros(dim)\n        self.memory_update_rate = 0.01\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current)\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def update_memory(self, trial, trial_fitness):\n        improvement = (self.fitness.min() - trial_fitness) / (abs(self.fitness.min()) + 1e-9)\n        self.memory = self.memory * (1 - self.memory_update_rate) + trial * self.memory_update_rate * improvement\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + self.memory, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                    self.update_memory(trial, trial_fitness)\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["75a33cf2-9312-475d-ac20-41ef1e8a2e56"], "operator": null, "metadata": {"aucs": [0.062485918321013356, 0.06247651674287469, 0.062489123591880524, 0.062485918268698204, 0.06247651669028187, 0.06248912353956826, 0.06248591811331361, 0.06247651653476527, 0.062489123384144696]}}
{"id": "8e6c582f-ce41-4bfe-9e5c-f0f2dbc9c80e", "fitness": 0.06248401627642919, "name": "EnhancedChaoticDifferentialEvolution", "description": "Introduce multi-population strategy with dynamic topology and adaptive cooperative co-evolution to improve convergence and diversity balance.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.sub_populations = 3\n        self.pop = [None] * self.sub_populations\n        self.fitness = [None] * self.sub_populations\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current)\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        sub_pop_size = self.population_size // self.sub_populations\n        for k in range(self.sub_populations):\n            self.pop[k] = np.random.rand(sub_pop_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n            self.fitness[k] = np.array([func(ind) for ind in self.pop[k]])\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for k in range(self.sub_populations):\n                for i in range(sub_pop_size):\n                    candidates = list(range(sub_pop_size))\n                    candidates.remove(i)\n                    a, b, c = np.random.choice(candidates, 3, replace=False)\n                    \n                    lev = self.levy_flight()\n                    mutant_levy = np.clip(self.pop[k][a] + adaptive_F * (self.pop[k][b] - self.pop[k][c]) + lev, self.bounds[0], self.bounds[1])\n                    mutant_classic = np.clip(self.pop[k][a] + adaptive_F * (self.pop[k][b] - self.pop[k][c]), self.bounds[0], self.bounds[1])\n\n                    cross_points = np.random.rand(self.dim) < adaptive_CR\n                    if not np.any(cross_points):\n                        cross_points[np.random.randint(0, self.dim)] = True\n                    trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[k][i])\n\n                    trial_fitness = func(trial)\n                    evaluations += 1\n\n                    if trial_fitness < self.fitness[k][i]:\n                        self.fitness[k][i] = trial_fitness\n                        self.pop[k][i] = trial\n\n                    if evaluations >= self.budget:\n                        break\n\n                best_idx = np.argmin(self.fitness[k])\n                best_individual = self.pop[k][best_idx]\n\n                for i in range(sub_pop_size):\n                    self.pop[k][i] = self.quantum_exploration(self.pop[k][i], best_individual)\n\n            for k in range(self.sub_populations):\n                diversity = np.std(self.pop[k], axis=0).mean()\n                self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n                self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n        best_fitness = float('inf')\n        best_solution = None\n        for k in range(self.sub_populations):\n            best_idx = np.argmin(self.fitness[k])\n            if self.fitness[k][best_idx] < best_fitness:\n                best_fitness = self.fitness[k][best_idx]\n                best_solution = self.pop[k][best_idx]\n\n        return best_solution", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["75a33cf2-9312-475d-ac20-41ef1e8a2e56"], "operator": null, "metadata": {"aucs": [0.06248591788926128, 0.062477051377753834, 0.06248907982242358, 0.062485917836700766, 0.062477051325435795, 0.062489079770059464, 0.062485917681506575, 0.06247705117003388, 0.062489079614687526]}}
{"id": "c1f43b00-5422-4756-9b8e-96a453b56e0b", "fitness": 0.06248404184870752, "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhance multi-strategy evolution using adaptive chaotic sequences and dynamic exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5  # New parameter for balancing exploration and exploitation\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):  # New method for dynamic adaptation\n        self.exploitation_ratio = 0.5 + 0.5 * (1 - diversity)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)  # Adapt exploitation ratio\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["75a33cf2-9312-475d-ac20-41ef1e8a2e56"], "operator": null, "metadata": {"aucs": [0.062485956260130426, 0.06247704595425729, 0.062489123591880524, 0.06248595620757058, 0.0624770459018934, 0.06248912353956826, 0.06248595605243101, 0.06247704574649149, 0.062489123384144696]}}
{"id": "42f6fb28-40df-4584-b150-b09be53e8e8d", "fitness": 0.06248379122744707, "name": "EnhancedChaoticDifferentialEvolution", "description": "Integrate adaptive feedback control and multi-parent crossover to enhance convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n        self.feedback_factor = 0.8  # New adaptive feedback control parameter\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.5 + 0.5 * (1 - diversity)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                parents = np.random.choice(candidates, 5, replace=False)  # Increased number of parents\n                a, b, c, d, e = parents\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c] + self.pop[d] - self.pop[e]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.feedback_factor * np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + self.feedback_factor * np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["c1f43b00-5422-4756-9b8e-96a453b56e0b"], "operator": null, "metadata": {"aucs": [0.06248586484855556, 0.062476385170495474, 0.062489123923378465, 0.06248586479614282, 0.062476385118156674, 0.0624891238710924, 0.06248586464077466, 0.06247638496275876, 0.06248912371566884]}}
{"id": "f7b7c127-798f-4564-b006-bd3bc4ea123a", "fitness": -Infinity, "name": "EnhancedChaoticDifferentialEvolution", "description": "Integrate chaotic Lvy flight and adaptive population resizing for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Adjusted initial population size\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.6\n        self.CR = 0.8\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) /\n                 (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.3:  # Adjusted probability\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.6 + 0.4 * (1 - diversity)  # Adjusted ratio\n\n    def adapt_population_size(self, diversity):  # New method for adaptive population resizing\n        self.population_size = max(5, int(10 * self.dim * (1 + diversity)))\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n            self.adapt_population_size(diversity)  # Implementing adaptive population size\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 70, "feedback": "An exception occurred: IndexError('index 564 is out of bounds for axis 0 with size 450').", "error": "IndexError('index 564 is out of bounds for axis 0 with size 450')", "parent_ids": ["c1f43b00-5422-4756-9b8e-96a453b56e0b"], "operator": null, "metadata": {}}
{"id": "19ea1adf-8f29-40eb-9c08-24161ac697cb", "fitness": 0.06248403962405354, "name": "EnhancedChaoticDifferentialEvolution", "description": "Refine chaotic sequences and adapt dynamically based on solution convergence to improve optimization efficiency.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        # Refined chaotic sequence for better exploration-exploitation\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':  # Added new chaotic map\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        # Improved adaptability by more frequent chaotic adjustment\n        if np.random.rand() < 0.3:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.5 + 0.5 * (1 - diversity)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            # Dynamic method selection for chaotic sequences\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["c1f43b00-5422-4756-9b8e-96a453b56e0b"], "operator": null, "metadata": {"aucs": [0.062485947826683375, 0.06247704771366891, 0.062489123591880524, 0.062485947774317485, 0.06247704766133155, 0.06248912353956826, 0.06248594761895765, 0.06247704750592942, 0.062489123384144696]}}
{"id": "94cdd54e-3818-4bf7-802d-0e685b6f5ddf", "fitness": 0.06248376085938085, "name": "EnhancedWaveletChaoticDifferentialEvolution", "description": "Integrate adaptive wavelet mutation with chaotic sequences for enhanced exploration-exploitation balance and solution diversity.", "code": "import numpy as np\n\nclass EnhancedWaveletChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def wavelet_mutation(self, individual):\n        wavelet_coeff = np.random.rand(self.dim)\n        return np.clip(individual + wavelet_coeff * (self.bounds[1] - self.bounds[0]) / 10.0, self.bounds[0], self.bounds[1])\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.5 + 0.5 * (1 - diversity)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                if np.random.rand() < 0.5:\n                    mutant_levy = self.wavelet_mutation(mutant_levy)\n                    mutant_classic = self.wavelet_mutation(mutant_classic)\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedWaveletChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["c1f43b00-5422-4756-9b8e-96a453b56e0b"], "operator": null, "metadata": {"aucs": [0.06248597783694965, 0.062476182765402344, 0.062489122235928285, 0.062485977784418, 0.06247618271307975, 0.06248912218356539, 0.06248597762922392, 0.06247618255767762, 0.062489122028182686]}}
{"id": "679fae01-9c67-4219-bc98-585f49c2ba7e", "fitness": 0.06248377152446817, "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhance multi-strategy evolution by integrating dynamic learning rates and adaptive population sizes for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n        self.learning_rates = np.random.rand(self.population_size)  # New array for dynamic learning rates\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.5 + 0.5 * (1 - diversity)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            # Dynamic learning rate adjustment\n            self.learning_rates = np.clip(self.learning_rates + np.random.uniform(-0.05, 0.05, self.population_size), 0.1, 0.9)\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual) * self.learning_rates[i]\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00000.", "error": "", "parent_ids": ["c1f43b00-5422-4756-9b8e-96a453b56e0b"], "operator": null, "metadata": {"aucs": [0.062478139627986984, 0.06248946732482541, 0.062483707880716444, 0.06247813957552273, 0.06248946727250693, 0.06248370782836277, 0.062478139420238055, 0.06248946711707504, 0.06248370767297917]}}
{"id": "5b5a8608-1c55-423b-ac94-daec26846b1b", "fitness": 0.06248395151813403, "name": "AdaptiveDiverseDifferentialEvolution", "description": "Integrate adaptive inertia weight and diversity-driven mutation for enhanced balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDiverseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio, diversity):\n        self.inertia_weight = (0.4 + 0.5 * (1 - eval_ratio)) * (1 + diversity)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.5 + 0.5 * (1 - diversity)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = np.array([func(ind) for ind in self.pop])\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            diversity = np.std(self.pop, axis=0).mean()\n            self.update_inertia_weight(eval_ratio, diversity)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            self.F = np.clip(self.F + np.random.uniform(-0.1, 0.1) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm AdaptiveDiverseDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["c1f43b00-5422-4756-9b8e-96a453b56e0b"], "operator": null, "metadata": {"aucs": [0.06248593495503196, 0.062476796267594614, 0.062489123591880524, 0.06248593490266585, 0.06247679621521818, 0.06248912353956826, 0.06248593474727726, 0.062476796059824924, 0.062489123384144696]}}
{"id": "ad85d413-2c1d-473f-aaea-6a582e2aa620", "fitness": 0.06248404402481743, "name": "EnhancedChaoticDifferentialEvolution", "description": "Integrate dynamic adaptive mechanisms and mutation strategies to enhance convergence and stability in chaotic differential evolution.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.5 + 0.5 * (1 - diversity)\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["c1f43b00-5422-4756-9b8e-96a453b56e0b"], "operator": null, "metadata": {"aucs": [0.06248596278855156, 0.06247704595425729, 0.062489123591880524, 0.06248596273596474, 0.0624770459018934, 0.06248912353956826, 0.062485962580604903, 0.06247704574649149, 0.062489123384144696]}}
{"id": "eb2c8aa3-e419-429c-855c-7b73374eecdb", "fitness": 0.06248404402481743, "name": "AdaptiveQuantumChaoticDifferentialEvolution", "description": "Introduce adaptive chaotic sequences and quantum leap strategies for improved exploration-exploitation balance in differential evolution.", "code": "import numpy as np\n\nclass AdaptiveQuantumChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        elif method == 'sine':\n            self.chaotic_x = np.sin(np.pi * self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.2:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.5 + 0.5 * (1 - diversity)\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent', 'sine'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveQuantumChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["ad85d413-2c1d-473f-aaea-6a582e2aa620"], "operator": null, "metadata": {"aucs": [0.06248596278855156, 0.06247704595425729, 0.062489123591880524, 0.06248596273596474, 0.0624770459018934, 0.06248912353956826, 0.062485962580604903, 0.06247704574649149, 0.062489123384144696]}}
{"id": "00cd287a-2b7f-47de-a0d4-cbadfc2fbb30", "fitness": 0.06248385938544682, "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhance exploration-exploitation balance using adaptive parameters and hybrid mutation strategies in chaotic differential evolution.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self, method):\n        if method == 'logistic':\n            self.chaotic_x = 4.0 * self.chaotic_x * (1.0 - self.chaotic_x)\n        elif method == 'tent':\n            self.chaotic_x = 2.0 * self.chaotic_x if self.chaotic_x < 0.5 else 2.0 * (1.0 - self.chaotic_x)\n        return self.chaotic_x\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self, method):\n        chaotic_x = self.chaotic_sequence(method)\n        if np.random.rand() < 0.3:  # Changed probability for flipping chaotic factor\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.6 + 0.4 * (1 - diversity)  # Adjusted exploitation ratio scaling\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            method = np.random.choice(['logistic', 'tent'])\n            chaotic_factor = self.adaptive_chaotic_factor(method)\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.3 else mutant_classic, self.pop[i])  # Changed probability for choosing mutant strategy\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05) * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["ad85d413-2c1d-473f-aaea-6a582e2aa620"], "operator": null, "metadata": {"aucs": [0.06248588453236592, 0.06247656998037987, 0.06248912390363315, 0.06248588447995174, 0.06247656992806716, 0.062489123851347084, 0.06248588432465718, 0.06247656977269578, 0.06248912369592352]}}
{"id": "caaab3bb-c345-40cb-83a2-cc2a704908bd", "fitness": 0.06248786924604974, "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhance balance between exploration and exploitation by introducing multi-chaotic processes and adaptive learning rate.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["ad85d413-2c1d-473f-aaea-6a582e2aa620"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.06248691455138533, 0.06249405360392024, 0.06248263979060009, 0.06248691449907573, 0.06249405355144311, 0.06248263963522349, 0.06248691434366327, 0.062494053396193405]}}
{"id": "34330d95-70ba-448d-b2d6-af0355a659ec", "fitness": -Infinity, "name": "EnhancedChaoticDifferentialEvolution", "description": "Introduce a dynamic population size adjustment based on the evaluation ratio to improve convergence.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n            self.population_size = int(15 * self.dim * (1 - eval_ratio))  # Dynamic adjustment\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 79, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["caaab3bb-c345-40cb-83a2-cc2a704908bd"], "operator": null, "metadata": {}}
{"id": "bbd2436a-8f74-4a6f-bacd-7494e7caac22", "fitness": 0.062487930679501674, "name": "EnhancedChaoticDifferentialEvolution", "description": "Improved balance by fine-tuning the mutation strategy using a Gaussian perturbation.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                # Changed line\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.1, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["caaab3bb-c345-40cb-83a2-cc2a704908bd"], "operator": null, "metadata": {"aucs": [0.062482642699361435, 0.06248690759965214, 0.06249424199961984, 0.06248264264681347, 0.062486907547333104, 0.062494241947271156, 0.062482642491641927, 0.06248690739195628, 0.06249424179186569]}}
{"id": "7772664a-2aa1-4771-841d-05e0c5f0466c", "fitness": 0.06248789124829641, "name": "EnhancedChaoticDifferentialEvolution", "description": "Incorporate stochastic weight adjustment for enhanced adaptability in the mutation strategy.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.1, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                # Changed line\n                trial = np.where(cross_points, mutant_levy * np.random.uniform(0.95, 1.05), self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482646089104144, 0.06248689486131842, 0.062494133054554646, 0.0624826460367901, 0.06248689480900893, 0.06249413300217965, 0.06248264588136143, 0.06248689465359636, 0.06249413284675398]}}
{"id": "852e9caf-0fb0-4ce7-b29a-21e9709f5e9f", "fitness": 0.062487930679501674, "name": "EnhancedChaoticDifferentialEvolution", "description": "Hybridized chaotic mutation with adaptive exploitation and dynamic exploration to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def restricted_mutation(self, a, b, c, chaotic_factor):\n        return self.pop[a] + chaotic_factor * (self.pop[b] - self.pop[c]) + np.random.normal(0, 0.1, size=self.dim)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.restricted_mutation(a, b, c, adaptive_F) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482642699361435, 0.06248690759965214, 0.06249424199961984, 0.06248264264681347, 0.062486907547333104, 0.062494241947271156, 0.062482642491641927, 0.06248690739195628, 0.06249424179186569]}}
{"id": "d7a3e989-bae4-49dd-965f-46a62ea6836d", "fitness": 0.06248792363299208, "name": "EnhancedChaoticDifferentialEvolution", "description": "Slightly adjusted the adaptive mutation factor to enhance exploration.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.1, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * (0.5 + diversity), 0.1, 0.9)  # Adjusted line\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.062486889372525334, 0.062494241943726436, 0.06248263979060009, 0.06248688932021573, 0.06249424189114039, 0.06248263963522349, 0.06248688916480305, 0.062494241735751244]}}
{"id": "0d0522c2-4ffa-406d-beda-068db681284c", "fitness": 0.06248793004189403, "name": "EnhancedChaoticDifferentialEvolution", "description": "Introduce dynamic parameter adaptation using fitness diversity to enhance convergence and stability.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def dynamic_parameter_adjustment(self, diversity):\n        self.F = np.clip(0.5 + diversity * 0.3, 0.1, 0.9)\n        self.CR = np.clip(0.9 - diversity * 0.2, 0.1, 1.0)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.1, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.dynamic_parameter_adjustment(diversity)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.06248690859921491, 0.062494241943726436, 0.06248263979060009, 0.06248690854692762, 0.06249424189114039, 0.06248263963522349, 0.06248690839151905, 0.062494241735751244]}}
{"id": "948aca70-b19c-4fc9-86ff-7fffd2d820c3", "fitness": 0.06248786924604974, "name": "RefinedChaosQuantumDifferentialEvolution", "description": "Utilize adaptive chaos-driven mutation and crossover with enhanced quantum exploration to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass RefinedChaosQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        exploration_factor = np.random.uniform(-0.5, 0.5, size=self.dim)\n        return current + exploration_factor * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm RefinedChaosQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.06248691455138533, 0.06249405360392024, 0.06248263979060009, 0.06248691449907573, 0.06249405355144311, 0.06248263963522349, 0.06248691434366327, 0.062494053396193405]}}
{"id": "370aacbf-a94f-4e07-9d2c-e30fc4a19666", "fitness": 0.06248786229871788, "name": "EnhancedChaoticDifferentialEvolution", "description": "Refine mutation strategy by adjusting the standard deviation in the Gaussian perturbation for better exploration.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                # Changed line\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.2, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.062486912240679926, 0.06249403507261786, 0.06248263979060009, 0.0624869121883459, 0.06249403502025219, 0.06248263963522349, 0.06248691203293355, 0.062494034864864934]}}
{"id": "6b31bd2b-127b-4d92-b693-75beae562f0c", "fitness": 0.0624878908181289, "name": "EnhancedAdaptiveChaoticDifferentialEvolution", "description": "Enhanced adaptive exploration and exploitation using chaotic sequences and dynamic parameter tuning based on population diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / np.abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.7 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedAdaptiveChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.06248263986497293, 0.062486889372525334, 0.06249414347701632, 0.062482639812630136, 0.06248688932021573, 0.0624941434245605, 0.062482639657253425, 0.06248688916480305, 0.06249414326918268]}}
{"id": "aaac11fc-94c6-4da0-8022-61aead77c219", "fitness": 0.062487908254489716, "name": "EnhancedChaoticDifferentialEvolution", "description": "Slightly refined mutation strategy by adjusting the Gaussian perturbation scale for better exploration.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                # Changed line\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.05, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482644340036364, 0.062486889372525334, 0.062494191311138314, 0.06248264428769368, 0.06248688932021573, 0.06249419125854261, 0.062482644132287546, 0.06248688916480305, 0.06249419110316479]}}
{"id": "7dbd29f0-ae18-4264-b8dc-b7425dd9af18", "fitness": 0.06248790871552411, "name": "EnhancedChaoticDifferentialEvolution", "description": "Enhanced mutation strategy by introducing scale factor adjustment based on chaotic sequences for improved diversity.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.1, size=self.dim) * chaotic_factor, self.bounds[0], self.bounds[1])  # Changed line\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.06248264517930269, 0.06248688991648099, 0.062494191311138314, 0.06248264512674273, 0.06248688986419759, 0.06249419125854261, 0.062482644971362244, 0.06248688970878502, 0.06249419110316479]}}
{"id": "b26a5487-990e-44e9-a30a-813730e74841", "fitness": 0.062487925616251494, "name": "EnhancedChaoticDifferentialEvolution", "description": "Fine-tuned the adaptive crossover probability to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor + 0.05  # Changed line\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.1, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.062486889372525334, 0.06249424789337854, 0.06248263979060009, 0.06248688932021573, 0.06249424784100366, 0.06248263963522349, 0.06248688916480305, 0.06249424768557055]}}
{"id": "142a711e-c4f4-4802-b09c-8876d3b14e8b", "fitness": 0.062475813199163475, "name": "DynamicCoevolutionaryDE", "description": "Introducing a Dynamic Coevolutionary Differential Evolution that leverages coevolution among subpopulations and adaptive strategy refinement for enhanced convergence.", "code": "import numpy as np\n\nclass DynamicCoevolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.subpopulations = 5\n        self.subpop_size = self.population_size // self.subpopulations\n        self.diversity_threshold = 0.1\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def coevolve_subpopulations(self, func):\n        for subpop_idx in range(self.subpopulations):\n            start = subpop_idx * self.subpop_size\n            end = start + self.subpop_size\n            subpop = self.pop[start:end]\n            subfitness = self.fitness[start:end]\n\n            for i in range(self.subpop_size):\n                candidates = list(range(self.subpop_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                mutant_vector = self.mutate(subpop, a, b, c)\n                trial_vector = self.crossover(subpop[i], mutant_vector)\n                trial_vector = np.clip(trial_vector, self.bounds[0], self.bounds[1])\n\n                trial_fitness = func(trial_vector)\n                if trial_fitness < subfitness[i]:\n                    subfitness[i] = trial_fitness\n                    subpop[i] = trial_vector\n\n            self.pop[start:end] = subpop\n            self.fitness[start:end] = subfitness\n\n    def mutate(self, subpop, a, b, c):\n        return subpop[a] + self.F * (subpop[b] - subpop[c])\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.CR\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        return np.where(cross_points, mutant, target)\n\n    def adapt_parameters(self, diversity):\n        self.F = np.clip(self.F + np.random.uniform(-0.05, 0.05), 0.1, 0.9)\n        self.CR = np.clip(self.CR + np.random.uniform(-0.05, 0.05), 0.1, 1.0)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            self.coevolve_subpopulations(func)\n            diversity = np.std(self.pop, axis=0).mean()\n            self.adapt_parameters(diversity)\n\n            if diversity < self.diversity_threshold:\n                self.subpopulations = max(2, self.subpopulations - 1)\n\n            evaluations += self.subpop_size * self.subpopulations\n            if evaluations >= self.budget:\n                break\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm DynamicCoevolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06248 with standard deviation 0.00001.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.06247099221659702, 0.0624722008159343, 0.06248424682500753, 0.062470992164294636, 0.062472200763577734, 0.06248424677266873, 0.06247099200892181, 0.06247220060818859, 0.062484246617280914]}}
{"id": "2e931bd7-874c-4e72-af34-f7be39f65f0a", "fitness": 0.062487923476419786, "name": "EnhancedChaoticDifferentialEvolution", "description": "Introduce stochastic crossover rate adjustment to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = np.clip(self.CR * chaotic_factor + np.random.uniform(-0.02, 0.02), 0.1, 1.0)  # Changed line\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.1, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.062486889372525334, 0.06249424147400939, 0.06248263979060009, 0.06248688932021573, 0.06249424142142357, 0.06248263963522349, 0.06248688916480305, 0.06249424126603442]}}
{"id": "5f658a08-bcae-470b-a52a-89afbb2077eb", "fitness": 0.062487899055451365, "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive mutation scaling and self-adaptive parameter tuning for enhanced convergence in heterogeneous landscapes.", "code": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n        self.mutation_adaptivity = 0.1\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def update_mutation_adaptivity(self, diversity, improvement):\n        self.mutation_adaptivity = 0.1 + 0.4 * (improvement / (diversity + 1e-6))\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n        prev_best_fitness = np.min(self.fitness)\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * self.mutation_adaptivity * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n            best_fitness = self.fitness[best_idx]\n            improvement = prev_best_fitness - best_fitness\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n            self.update_mutation_adaptivity(diversity, improvement)\n            prev_best_fitness = best_fitness\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.06248689146912656, 0.062494166114350214, 0.06248263979060009, 0.06248689141681685, 0.062494166061977774, 0.06248263963522349, 0.06248689126143048, 0.062494165906593846]}}
{"id": "c9e6d6dc-a256-4ca0-853a-dfc75da2c840", "fitness": 0.062487818820527626, "name": "EnhancedDynamicChaoticDifferentialEvolution", "description": "Integration of a dynamic mutation rate and chaotic sequence-driven crossover for enhanced adaptability to diverse optimization landscapes.", "code": "import numpy as np\n\nclass EnhancedDynamicChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def dynamic_mutation_rate(self):\n        diversity = np.std(self.pop, axis=0).mean()\n        return 0.1 + 0.8 * (1 - diversity)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.dynamic_mutation_rate()\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.1, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedDynamicChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.06248264121512026, 0.062486894006336446, 0.062493921500360705, 0.06248264116263014, 0.06248689395397766, 0.06249392144785637, 0.06248264100737433, 0.062486893798614274, 0.06249392129247844]}}
{"id": "3b152038-830b-4b79-b315-bb3982fd3959", "fitness": 0.062487908254489716, "name": "EnhancedChaoticDifferentialEvolution", "description": "Introduced a small adaptive Gaussian noise to enhance solution diversity and escape local optima.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                # Changed line\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + np.random.normal(0, 0.05, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482644340036364, 0.062486889372525334, 0.062494191311138314, 0.06248264428769368, 0.06248688932021573, 0.06249419125854261, 0.062482644132287546, 0.06248688916480305, 0.06249419110316479]}}
{"id": "4f12f453-3db5-4db8-b0bd-50d57aa0d260", "fitness": 0.062487827355590636, "name": "EnhancedChaoticDifferentialEvolution", "description": "Introduce a diversity-enhancing mechanism using a Gaussian mutation to maintain population diversity and adaptively control exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def gaussian_mutation(self, individual, std_dev=0.1):\n        mutation = np.random.normal(0, std_dev, size=self.dim)\n        mutated = np.clip(individual + mutation, self.bounds[0], self.bounds[1])\n        return mutated\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n                else:\n                    mutated_trial = self.gaussian_mutation(self.pop[i])\n                    mutated_fitness = func(mutated_trial)\n                    evaluations += 1\n                    if mutated_fitness < self.fitness[i]:\n                        self.fitness[i] = mutated_fitness\n                        self.pop[i] = mutated_trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.06248691165626208, 0.06249393082765686, 0.06248263979060009, 0.062486911603903406, 0.06249393077528331, 0.06248263963522349, 0.062486911448539684, 0.062493930619903826]}}
{"id": "7f6a6ecc-6d16-4e4a-b5f4-c932ecefbd52", "fitness": 0.06248790092669257, "name": "RefinedChaoticDifferentialEvolution", "description": "Hybridize adaptive chaotic sequences with Cauchy distribution perturbation for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass RefinedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def cauchy_perturbation(self):\n        return np.random.standard_cauchy(size=self.dim)\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                cauchy = self.cauchy_perturbation()\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) + lev + cauchy, self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]), self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm RefinedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.06248264459196762, 0.06248691570714293, 0.06249414274110521, 0.06248264453943231, 0.062486915654804354, 0.062494142688786725, 0.06248264438424811, 0.06248691549939189, 0.06249414253335395]}}
{"id": "ba03bb6b-edc0-42da-bbbe-7c6a9c337e04", "fitness": 0.06248790742942193, "name": "EnhancedDynamicChaoticDifferentialEvolution", "description": "Introduce dynamic scaling and chaotic perturbation for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) /\n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def dynamic_scaling(self, eval_ratio):\n        return 1 + 0.5 * np.sin(2 * np.pi * eval_ratio)\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n\n            chaotic_factor = self.adaptive_chaotic_factor()\n            adaptive_F = self.F * chaotic_factor * self.inertia_weight\n            adaptive_CR = self.CR * chaotic_factor\n\n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                lev = self.levy_flight()\n                scale = self.dynamic_scaling(eval_ratio)\n                mutant_levy = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) * scale + lev + np.random.normal(0, 0.1, size=self.dim), self.bounds[0], self.bounds[1])\n                mutant_classic = np.clip(self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c]) * scale, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant_levy if np.random.rand() < 0.5 else mutant_classic, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            best_idx = np.argmin(self.fitness)\n            best_individual = self.pop[best_idx]\n\n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedDynamicChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482639842943, 0.06248691658104022, 0.06249416612436487, 0.06248263979060009, 0.06248691652867555, 0.06249416607202951, 0.06248263963522349, 0.06248691637330883, 0.06249416591661183]}}
{"id": "229cf285-657a-412b-9259-e96f618b4248", "fitness": 0.06248781216588067, "name": "EnhancedChaoticDifferentialEvolution", "description": "Introduce a dynamic mutation strategy with adaptive inertia weight to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim\n        self.pop = None\n        self.fitness = None\n        self.bounds = None\n        self.F = 0.5\n        self.CR = 0.9\n        self.inertia_weight = 0.9\n        self.chaotic_x1 = np.random.rand()\n        self.chaotic_x2 = np.random.rand()\n        self.exploitation_ratio = 0.5\n\n    def levy_flight(self, lam=1.5):\n        sigma = (np.math.gamma(1 + lam) * np.sin(np.pi * lam / 2) / \n                (np.math.gamma((1 + lam) / 2) * lam * 2**((lam - 1) / 2)))**(1 / lam)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        return u / abs(v)**(1 / lam)\n\n    def chaotic_sequence(self):\n        self.chaotic_x1 = 4.0 * self.chaotic_x1 * (1.0 - self.chaotic_x1)\n        self.chaotic_x2 = 3.75 * self.chaotic_x2 * (1.0 - self.chaotic_x2)\n        return (self.chaotic_x1 + self.chaotic_x2) / 2\n\n    def update_inertia_weight(self, eval_ratio):\n        self.inertia_weight = 0.4 + 0.5 * (1 - eval_ratio)\n\n    def quantum_exploration(self, current, best):\n        return current + np.random.uniform(-0.5, 0.5, size=self.dim) * (best - current) * self.exploitation_ratio\n\n    def adaptive_chaotic_factor(self):\n        chaotic_x = self.chaotic_sequence()\n        if np.random.rand() < 0.15:\n            chaotic_x = 1 - chaotic_x\n        return chaotic_x\n\n    def adapt_exploitation_ratio(self, diversity):\n        self.exploitation_ratio = 0.4 + 0.6 * (1 - diversity)\n\n    def adaptive_learning_rate(self, method='logistic'):\n        return 0.5 * self.chaotic_sequence()\n\n    def evaluate_population(self, func):\n        return np.array([func(ind) for ind in self.pop])\n\n    def dynamic_mutation(self, a, b, c, best):\n        chaotic_factor = self.adaptive_chaotic_factor()\n        adaptive_F = self.F * chaotic_factor * self.inertia_weight\n        if np.random.rand() < 0.5:\n            mutant = self.pop[a] + adaptive_F * (self.pop[b] - self.pop[c])\n        else:\n            mutant = self.pop[a] + adaptive_F * (best - self.pop[a])\n        return mutant\n\n    def __call__(self, func):\n        self.bounds = (func.bounds.lb, func.bounds.ub)\n        self.pop = np.random.rand(self.population_size, self.dim) * (self.bounds[1] - self.bounds[0]) + self.bounds[0]\n        self.fitness = self.evaluate_population(func)\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            eval_ratio = evaluations / self.budget\n            self.update_inertia_weight(eval_ratio)\n            \n            for i in range(self.population_size):\n                candidates = list(range(self.population_size))\n                candidates.remove(i)\n                a, b, c = np.random.choice(candidates, 3, replace=False)\n\n                best_idx = np.argmin(self.fitness)\n                best_individual = self.pop[best_idx]\n\n                lev = self.levy_flight()\n                mutant = np.clip(self.dynamic_mutation(a, b, c, best_individual) + lev, self.bounds[0], self.bounds[1])\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.pop[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.pop[i] = trial\n\n                if evaluations >= self.budget:\n                    break\n            \n            for i in range(self.population_size):\n                self.pop[i] = self.quantum_exploration(self.pop[i], best_individual)\n\n            diversity = np.std(self.pop, axis=0).mean()\n            self.F = np.clip(self.F + self.adaptive_learning_rate() * diversity, 0.1, 0.9)\n            self.CR = np.clip(self.CR + np.random.uniform(-0.025, 0.025), 0.1, 1.0)\n            self.adapt_exploitation_ratio(diversity)\n\n        best_idx = np.argmin(self.fitness)\n        return self.pop[best_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06249 with standard deviation 0.00000.", "error": "", "parent_ids": ["bbd2436a-8f74-4a6f-bacd-7494e7caac22"], "operator": null, "metadata": {"aucs": [0.062482643684429906, 0.062486889372525334, 0.06249390370086361, 0.06248264363208711, 0.06248688932021573, 0.06249390364834917, 0.062482643476710176, 0.06248688916480305, 0.06249390349294193]}}
