{"id": "695172af-439a-456b-9048-b866a454c6ee", "fitness": 0.05759337807934769, "name": "HybridBBO_ADM", "description": "Hybrid Biogeography-Based Optimization with Adaptive Differential Mutation for robust exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n\n    def mutation(self, target_idx, population, best_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_idx)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) for elite solutions\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 0, "feedback": "The algorithm HybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05759 with standard deviation 0.05407.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.1289493487571335, 0.1322694758695302, 0.12866298221766603, 0.047407614727897895, 0.03803447226763235, 0.04234984220760252, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "28c593e2-bf8d-427b-bd2d-3a9a0b482442", "fitness": 0.05770324584234751, "name": "EnhancedHybridBBO_ADM", "description": "Enhanced Hybrid Biogeography-Based Optimization with Adaptive Differential Mutation and Dynamic Crossover for improved convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedHybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) for elite solutions\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedHybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05770 with standard deviation 0.05529.", "error": "", "parent_ids": ["695172af-439a-456b-9048-b866a454c6ee"], "operator": null, "metadata": {"aucs": [0.1345310024376588, 0.13127886816511392, 0.13119389371685608, 0.04210676892760645, 0.03963434247366626, 0.03991767019355941, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "3a84a035-a05d-45ac-b75f-c446e5941516", "fitness": 0.05845818751044669, "name": "EnhancedHybridBBO_ADM", "description": "Enhanced Hybrid BBO with Adaptive Differential Mutation and an incrementally decreasing mutation factor for improved convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedHybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) for elite solutions\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= 0.995\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedHybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05846 with standard deviation 0.05521.", "error": "", "parent_ids": ["28c593e2-bf8d-427b-bd2d-3a9a0b482442"], "operator": null, "metadata": {"aucs": [0.12819219553286565, 0.1288970497754286, 0.13993862219413422, 0.04265407766035745, 0.04829337517659349, 0.037481700587974065, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "d69ea1a2-269c-4585-8968-5a11c39c4cef", "fitness": 0.05652425591346715, "name": "AdaptiveTemporalIslandBBO", "description": "Adaptive Temporal Island-Based Hybrid BBO with Dynamic Elite Learning to enhance diversity and convergence efficiency.", "code": "import numpy as np\n\nclass AdaptiveTemporalIslandBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n        self.mutation_decay = 0.995\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        generation = 0\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Temporal Island Model with Dynamic Elite Learning\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5 + 0.5 * (generation / (generation + 1)):\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= self.mutation_decay\n\n            population = next_population\n            generation += 1\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveTemporalIslandBBO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05652 with standard deviation 0.05488.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.13103392984921391, 0.13344506113313725, 0.12826088662852675, 0.03833467351254105, 0.03771626016000962, 0.03926082527110908, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "bec2c242-1e47-4e39-9f41-17e6f9c011c7", "fitness": 0.057176218478903515, "name": "AdaptiveBBO_DynamicIsland", "description": "Adaptive Biogeography-Based Optimization with Dynamic Island Migration and Adaptive Mutation Factor for Enhanced Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass AdaptiveBBO_DynamicIsland:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n        self.dynamic_migration_probability = 0.5\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Adaptive Biogeography-Based Optimization (BBO)\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    best_island = population[elites[island]]\n                    for idx in island_indices:\n                        if np.random.rand() < self.dynamic_migration_probability:\n                            population[idx] = best_island + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate and migration probability dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.dynamic_migration_probability *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= 0.995\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveBBO_DynamicIsland got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05718 with standard deviation 0.05464.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.13498136330873234, 0.12742631964112838, 0.12955254628874036, 0.03484935726096028, 0.04829337517659349, 0.0388163379673101, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "446e550e-9b8b-42cf-bfd3-27e828ef3a76", "fitness": 0.05676238062952028, "name": "AdaptiveDynamicMutation_EliteReinforcement", "description": "Adaptive Dynamic Mutation with Elite Reinforcement (ADM-ER) synergizes adaptive mutation and elite reinforcement for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDynamicMutation_EliteReinforcement:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.initial_mutation_factor = 0.8\n        self.mutation_factor = self.initial_mutation_factor\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            # Adaptive mutation factor\n            self.mutation_factor = self.initial_mutation_factor * (1 - (budget_spent / self.budget) ** 0.5)\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Elite Reinforcement Strategy\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[best_idx]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveDynamicMutation_EliteReinforcement got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05676 with standard deviation 0.05476.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.13477987827209958, 0.12792915806562188, 0.12961865433700126, 0.04189930306671785, 0.04064964814116723, 0.03531811711640798, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "6a23da48-a985-42a9-9f57-311edcc6042a", "fitness": 0.05845818751044669, "name": "EnhancedIslandBBO_RE", "description": "Adaptive Dynamic Island Model with Adaptive Differential Evolution and Periodic Reinitialization to maintain diversity and avoid premature convergence.", "code": "import numpy as np\n\nclass EnhancedIslandBBO_RE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n        self.restart_threshold = self.budget // 4\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n        restart_counter = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) for elite solutions\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= 0.995\n\n            population = next_population\n\n            # Periodic reinitialization to prevent premature convergence\n            restart_counter += 1\n            if restart_counter >= self.restart_threshold:\n                restart_indices = np.random.choice(self.population_size, self.island_size, replace=False)\n                for idx in restart_indices:\n                    population[idx] = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n                    fitness[idx] = func(population[idx])\n                restart_counter = 0\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedIslandBBO_RE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05846 with standard deviation 0.05521.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.12819219553286565, 0.1288970497754286, 0.13993862219413422, 0.04265407766035745, 0.04829337517659349, 0.037481700587974065, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "862c04d2-bf09-4b84-b57e-d2af364a5b55", "fitness": -Infinity, "name": "AdaptiveHierarchicalHybridBBO", "description": "Adaptive Hierarchical Hybrid BBO with Dynamic Island Crossover to enhance solution diversity and convergence speed.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalHybridBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def dynamic_island_crossover(self, population, fitness):\n        sorted_indices = np.argsort(fitness)\n        elites = sorted_indices[:self.island_size]\n        for island in range(self.num_islands):\n            island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n            emigrant = population[elites[island % len(elites)]]\n            for idx in island_indices:\n                if np.random.rand() < 0.5:\n                    new_solution = emigrant + np.random.normal(0, 0.01, self.dim)\n                    new_solution = np.clip(new_solution, self.bounds.lb, self.bounds.ub)\n                    new_fitness = func(new_solution)\n                    if new_fitness < fitness[idx]:\n                        population[idx] = new_solution\n                        fitness[idx] = new_fitness\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Dynamic Island Crossover\n            if budget_spent < self.budget:\n                self.dynamic_island_crossover(next_population, fitness)\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= 0.995\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 7, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {}}
{"id": "1d30e179-4336-4e6c-9ebe-5fc54b40b1b8", "fitness": 0.058251565353956605, "name": "EnhancedHybridBBO_ADM", "description": "Enhanced Hybrid BBO with Adaptive Differential Mutation and dynamic strategy selection between exploration and exploitation for improved convergence and robustness.", "code": "import numpy as np\n\nclass EnhancedHybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n        self.exploration_phase = True\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n    \n    def strategy_selection(self, func, population, fitness, budget_spent):\n        if self.exploration_phase:\n            self.mutation_factor *= 0.995\n            self.dynamic_crossover_decay *= 1.001\n            if np.std(fitness) < 1e-5:\n                self.exploration_phase = False\n        else:\n            sorted_indices = np.argsort(fitness)\n            for i in sorted_indices[:self.island_size]:\n                trial = population[i] + np.random.normal(0, 0.01, self.dim)\n                trial = np.clip(trial, self.bounds.lb, self.bounds.ub)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                if budget_spent >= self.budget:\n                    break\n        return budget_spent\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            budget_spent = self.strategy_selection(func, population, fitness, budget_spent)\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedHybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05825 with standard deviation 0.05650.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.14792051414947172, 0.1291366058600979, 0.12593603202426074, 0.04193889918062432, 0.039881355443816324, 0.038784014860671734, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "39c6bb73-3bef-4ed4-8c05-66a1ddb9d9fb", "fitness": 0.05575722953349013, "name": "EnhancedHybridBBO_ADM", "description": "Further enhancement of Hybrid BBO with Adaptive Differential Mutation using dynamic population adjustment and improved diversity preservation.", "code": "import numpy as np\n\nclass EnhancedHybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 60\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.75\n        self.elite_rate = 0.25\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.diversity_factor = 0.02\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) for elite solutions\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + self.diversity_factor * np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= 0.993\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedHybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05576 with standard deviation 0.05374.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.13230350273433977, 0.12459939478093252, 0.12823671740209763, 0.04179142535301095, 0.03724603958345951, 0.036971319280904136, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "ff01f1ed-b5e9-4c6a-a5ad-ab8e274b9682", "fitness": 0.05845818751044669, "name": "EnhancedHybridBBO_ADM", "description": "Multi-Island Adaptive Hybrid BBO with Dynamic Elite Influence and Environment-Driven Parameter Tuning for Enhanced Convergence.", "code": "import numpy as np\n\nclass EnhancedHybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n        self.dynamic_mutation_decay = 0.995\n        self.influence_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic elite influence\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                influence_factor = 1.0\n                \n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    \n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            influence = influence_factor * np.random.normal(0, 0.01, self.dim)\n                            population[idx] = emigrant + influence\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n                \n                # Decay influence factor\n                influence_factor *= self.influence_decay\n\n            # Update crossover and mutation rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor *= self.dynamic_mutation_decay\n\n            population = next_population\n        \n        return population[np.argmin(fitness)]", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedHybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05846 with standard deviation 0.05521.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.12819219553286565, 0.1288970497754286, 0.13993862219413422, 0.04265407766035745, 0.04829337517659349, 0.037481700587974065, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "7b1e0b47-efcc-49dc-afdb-929583e53c8f", "fitness": 0.05845818751044669, "name": "EnhancedHybridBBO_ADM", "description": "Enhanced Hybrid BBO with Adaptive Differential Mutation now features a dynamic adjustment in the elite_rate during execution for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) for elite solutions\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= 0.995\n            \n            # Dynamically adjust elite_rate\n            self.elite_rate = 0.2 + 0.1 * (budget_spent / self.budget)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedHybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05846 with standard deviation 0.05521.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.12819219553286565, 0.1288970497754286, 0.13993862219413422, 0.04265407766035745, 0.04829337517659349, 0.037481700587974065, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "caac50ac-8962-4ccd-b113-2b876ad0930a", "fitness": 0.05845818751044669, "name": "EnhancedHybridBBO_ADM", "description": "Enhanced mutation strategy by introducing an adaptive mutation factor based on fitness improvement.", "code": "import numpy as np\n\nclass EnhancedHybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution, fitness):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n            \n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) for elite solutions\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= 0.995\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedHybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05846 with standard deviation 0.05521.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.12819219553286565, 0.1288970497754286, 0.13993862219413422, 0.04265407766035745, 0.04829337517659349, 0.037481700587974065, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "08d13b8b-7df3-45ef-98bd-cd680694bf35", "fitness": 0.05845818751044669, "name": "EnhancedHybridBBO_ADM", "description": "Improved mutation strategy by altering the selection mechanism of indices for mutation to enhance diversity.", "code": "import numpy as np\n\nclass EnhancedHybridBBO_ADM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) for elite solutions\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, 0.01, self.dim)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            \n            # Incrementally decrease the mutation factor\n            self.mutation_factor *= 0.995\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedHybridBBO_ADM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05846 with standard deviation 0.05521.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.12819219553286565, 0.1288970497754286, 0.13993862219413422, 0.04265407766035745, 0.04829337517659349, 0.037481700587974065, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "605a02b0-b7de-4c54-ba12-4af837f90706", "fitness": 0.05898986320826654, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Adaptive Hierarchical BBO with Dynamic Ecosystem Migration integrates adaptive mutation and hierarchical exploration based on species richness for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor *= self.mutation_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 14, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05899 with standard deviation 0.05600.", "error": "", "parent_ids": ["3a84a035-a05d-45ac-b75f-c446e5941516"], "operator": null, "metadata": {"aucs": [0.13056274196060824, 0.13781677855024044, 0.1344776877491155, 0.04069937652935485, 0.0423270140999632, 0.04435850331844993, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "f8958c4a-b291-4ad3-9c29-68a3efa296ef", "fitness": 0.057508677589722876, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Improved Adaptive Hierarchical BBO with Dynamic Ecosystem Migration by fine-tuning mutation, crossover, and migration strategies for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.85  # slightly increased mutation factor\n        self.crossover_rate = 0.75  # slightly increased crossover rate\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.55:  # increased the probability for migration\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor *= self.mutation_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 15, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05751 with standard deviation 0.05472.", "error": "", "parent_ids": ["605a02b0-b7de-4c54-ba12-4af837f90706"], "operator": null, "metadata": {"aucs": [0.1317092463634566, 0.1296702632699107, 0.132186890980866, 0.0422007180281857, 0.038888282498046434, 0.04225603050037374, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "d5e6e03e-cd07-44f3-a947-dd7f89d40ad8", "fitness": 0.05714112940557354, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Improved dynamic mutation adaptation based on fitness variance for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            self.mutation_factor *= np.var(fitness) * 0.01  # Updated line for dynamic mutation factor adjustment\n\n            self.crossover_rate *= self.dynamic_crossover_decay\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 16, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05714 with standard deviation 0.05463.", "error": "", "parent_ids": ["605a02b0-b7de-4c54-ba12-4af837f90706"], "operator": null, "metadata": {"aucs": [0.1306786928913578, 0.1337757187376547, 0.12767771280900442, 0.04157032926086057, 0.04082731184360722, 0.03974039910767713, 0.0, 0.0, 0.0]}}
{"id": "12efd83a-af18-48c8-bbc7-36766d744bba", "fitness": 0.05782880447008206, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhanced Adaptive Hierarchical BBO with dynamic crossover rate adjustment for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= (self.dynamic_crossover_decay + np.random.uniform(-0.01, 0.01))\n            self.mutation_factor *= self.mutation_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 17, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05783 with standard deviation 0.05458.", "error": "", "parent_ids": ["605a02b0-b7de-4c54-ba12-4af837f90706"], "operator": null, "metadata": {"aucs": [0.12804410874132333, 0.1352057921771237, 0.12992407683281182, 0.0411705388216117, 0.04112456160623612, 0.04432349538496516, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "0aef3f11-99fa-461a-976e-12ac0b7b56f9", "fitness": 0.05692630517025374, "name": "EnhancedHierarchicalBBO_AED", "description": "Enhanced Hierarchical BBO with Adaptive Ecosystem Dynamics optimizes migration and mutation strategies based on fitness diversity to improve convergence.", "code": "import numpy as np\n\nclass EnhancedHierarchicalBBO_AED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, fitness):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(fitness)\n        adaptive_mutation = self.mutation_factor + 0.1 * (1 - diversity_factor)\n        mutant = population[a] + adaptive_mutation * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with adaptive ecosystem dynamics\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor *= self.mutation_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedHierarchicalBBO_AED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05693 with standard deviation 0.05588.", "error": "", "parent_ids": ["605a02b0-b7de-4c54-ba12-4af837f90706"], "operator": null, "metadata": {"aucs": [0.1252295602277097, 0.14330689140619135, 0.1293413070449685, 0.035771774869942874, 0.038848629402492674, 0.03917191691431188, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "ca63ac48-2829-4b1e-b472-5d913bdacb46", "fitness": -Infinity, "name": "HybridEcosystemMigration_ACM", "description": "Hybrid Ecosystem Migration with Adaptive Crossover and Mutation combines hierarchical BBO with adaptive parameter evolution and controlled migrations to enhance solution diversity and convergence.", "code": "import numpy as np\n\nclass HybridEcosystemMigration_ACM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.95  # Adjusted for better adaptation\n        self.mutation_decay = 0.97  # Adjusted for better exploration\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adaptive_migration(self, population, fitness):\n        sorted_indices = np.argsort(fitness)\n        elites = sorted_indices[:self.island_size]\n        for island in range(self.num_islands):\n            island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n            emigrant = population[elites[island % len(elites)]]\n            for idx in island_indices:\n                if np.random.rand() < 0.5:\n                    migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                    population[idx] = emigrant + migration_strength\n                    population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                    fitness[idx] = func(population[idx])\n        return population, fitness\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Adaptive migration with ecosystem exploration\n            if budget_spent < self.budget:\n                population, fitness = self.adaptive_migration(population, fitness)\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor *= self.mutation_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 19, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["605a02b0-b7de-4c54-ba12-4af837f90706"], "operator": null, "metadata": {}}
{"id": "3edf42b7-5a85-47df-a6d1-af3bb60b1794", "fitness": 0.0590711755335513, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce a dynamic mutation factor adjustment based on population diversity for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness)) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 20, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05907 with standard deviation 0.05667.", "error": "", "parent_ids": ["605a02b0-b7de-4c54-ba12-4af837f90706"], "operator": null, "metadata": {"aucs": [0.14488888241786124, 0.13035801892653354, 0.13082733610339226, 0.0432753915814873, 0.04076648301571695, 0.04085780109030368, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b612cf50-ff03-4f19-9c21-ce204561be26", "fitness": 0.05716058594953604, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Improve diversity and exploration by modifying mutation strategy and crossover rate decay.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.97  # changed line\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = (population[a] + self.mutation_factor * (population[b] - population[c])\n                  + 0.1 * (best_solution - population[target_idx])) # changed line\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 21, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05716 with standard deviation 0.05506.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.12774868287375463, 0.13466301276475667, 0.13230555401025734, 0.03901478152752391, 0.03927437022203417, 0.040772205480830936, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "f0097b4a-8912-407c-8cbb-c920b1e8aff8", "fitness": 0.05687632736504389, "name": "EnhancedAdaptiveBBO_DEM", "description": "Integrate adaptive parameter control and diversity preservation mechanisms to enhance convergence speed and robustness in dynamic environments.", "code": "import numpy as np\n\nclass EnhancedAdaptiveBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.diversity_threshold = 0.1\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def maintain_diversity(self, population):\n        diversity = np.std(population, axis=0)\n        if np.any(diversity < self.diversity_threshold):\n            for i in range(self.population_size):\n                if np.random.rand() < 0.1:\n                    population[i] = np.random.uniform(self.bounds.lb, self.bounds.ub, self.dim)\n        return population\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness))\n            self.mutation_factor = max(0.1, self.mutation_factor)  # Ensures mutation factor doesn't drop too low\n\n            population = self.maintain_diversity(next_population)\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedAdaptiveBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05688 with standard deviation 0.05360.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.12513524890129457, 0.13035801892653354, 0.13082733610339226, 0.0432753915814873, 0.04076648301571695, 0.04085780109030368, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "90169f9b-ffb6-4e8b-bcfb-71df9ba171c6", "fitness": 0.056619817650503994, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance the mutation factor adjustment by incorporating variance-based scaling to improve convergence precision.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * np.var(fitness) / np.mean(fitness) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 23, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05662 with standard deviation 0.05327.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.127118082159703, 0.12734979526590862, 0.1296350129824556, 0.038696341009125446, 0.042838165877118084, 0.043274294893558496, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "e90934de-4e00-4c8b-a2a6-b60a1fbb4189", "fitness": 0.056956105597399644, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration by dynamically tuning mutation factor and incorporating adaptive elitism for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-8)) #changed line\n            self.elite_rate = 0.1 + 0.1 * (self.global_best_fitness / (np.min(fitness) + 1e-8)) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 24, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05696 with standard deviation 0.05394.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.1304212398825172, 0.13231779963639134, 0.12559622305161833, 0.04176495847646888, 0.04093761944402041, 0.04090044321891395, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "6dd27c92-9a81-45bc-aa36-c5a37a9b5aec", "fitness": 0.0561304634742013, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce adaptive island migration strategy to enhance diversification and convergence rate.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with adaptive migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        migration_strength = np.random.normal(0, 0.02 + 0.01 * (np.random.rand() - 0.5)) #changed line\n                        population[idx] = emigrant + migration_strength * (self.global_best - population[idx]) #changed line\n                        population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                        fitness[idx] = func(population[idx])\n                        budget_spent += 1\n\n                        if budget_spent >= self.budget:\n                            break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 25, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05613 with standard deviation 0.05377.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.12904658128112378, 0.1276205866291339, 0.12942826398123652, 0.03964391241328036, 0.03742291610459669, 0.04134524419177377, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "4d603386-177d-4ace-b438-99c746d1e4d2", "fitness": -Infinity, "name": "EnhancedAdaptiveHierarchicalBBO", "description": "Introduce adaptive island migration with stochastic optimization and feedback-driven parameter tuning for robust convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.feedback_factor = 0.1\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adaptive_migration(self, population, fitness, budget_spent):\n        sorted_indices = np.argsort(fitness)\n        elites = sorted_indices[:self.island_size]\n        for island in range(self.num_islands):\n            island_indices = sorted_indices[island * self.island_size:(island + 1) * self.island_size]\n            emigrant = population[elites[island % len(elites)]]\n            for idx in island_indices:\n                if np.random.rand() < 0.5:\n                    migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                    population[idx] = emigrant + migration_strength\n                    population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                    fitness[idx] = func(population[idx])\n                    budget_spent += 1\n                    if budget_spent >= self.budget:\n                        return budget_spent\n        return budget_spent\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            if budget_spent < self.budget:\n                budget_spent = self.adaptive_migration(population, fitness, budget_spent)\n\n            self.crossover_rate = max(0.1, self.crossover_rate * self.dynamic_crossover_decay)\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness))\n            self.feedback_factor = 0.5 * (1 - np.min(fitness) / (1 + self.global_best_fitness))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 26, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {}}
{"id": "e7f21944-4f70-448e-8d29-f0d4735e2342", "fitness": 0.05893702300872808, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce adaptive mutation factor and crossover rate based on evolutionary success rates and diversity for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.initial_mutation_factor = 0.8\n        self.initial_crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        # Initialize dynamic factors\n        self.mutation_factor = self.initial_mutation_factor\n        self.crossover_rate = self.initial_crossover_rate\n        improvement_count = 0\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n                    improvement_count += 1\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically based on success rate\n            if improvement_count > 0:\n                self.mutation_factor *= (1 + 0.1 * (improvement_count / self.population_size))\n                self.crossover_rate *= self.dynamic_crossover_decay\n\n            population = next_population\n            improvement_count = 0\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 27, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05894 with standard deviation 0.05656.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.15116331995297183, 0.1257723755562722, 0.12686428850104636, 0.042824396910026485, 0.040242619899374055, 0.04289953959219506, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "75e5c0de-669b-444d-b67c-254b2a954cda", "fitness": 0.05738369546394078, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration and exploitation balance using a dynamic mutation strategy with adaptive learning based on population diversity and convergence speed.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.learning_rate = 0.1\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c]) + self.learning_rate * (best_solution - population[target_idx])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            diversity_factor = np.std(fitness) / (np.mean(fitness) + 1e-10)\n            convergence_speed = (self.global_best_fitness - fitness[best_idx]) / (self.global_best_fitness + 1e-10)\n            self.mutation_factor = 0.5 + 0.3 * diversity_factor * (1 + convergence_speed)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05738 with standard deviation 0.05488.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.126696971184307, 0.13320497328054315, 0.13415819044611976, 0.038097975762884095, 0.041197856222550344, 0.04243062561239597, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "2cd7dfa1-2760-4e38-83c6-74e61ccf0e6f", "fitness": -Infinity, "name": "AdaptiveIslandParallelismBBO", "description": "Utilize adaptive island-based parallelism for dynamic exploration and exploitation, enhancing diversity and convergence.", "code": "import numpy as np\n\nclass AdaptiveIslandParallelismBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            # Island-based parallelism\n            for island in range(self.num_islands):\n                island_indices = [i for i in range(island * self.island_size, (island + 1) * self.island_size)]\n                island_population = population[island_indices]\n                island_fitness = fitness[island_indices]\n\n                for i in island_indices:\n                    mutant = self.mutation(i, island_population, best_solution)\n                    trial = self.crossover(population[i], mutant)\n                    trial_fitness = func(trial)\n                    budget_spent += 1\n                    if trial_fitness < fitness[i]:\n                        next_population[i] = trial\n                        fitness[i] = trial_fitness\n\n                    if budget_spent >= self.budget:\n                        break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 29, "feedback": "An exception occurred: IndexError('index 20 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 20 is out of bounds for axis 0 with size 10')", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {}}
{"id": "6cfbdaf8-7f1e-4a05-aa17-8941a6d238ec", "fitness": 0.05801719851922657, "name": "AdaptiveHierarchicalBBO_DEM_Improved", "description": "Enhance convergence by introducing a self-adaptive mutation and crossover strategy based on individual performance improvement over generations.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.initial_mutation_factor = 0.8\n        self.initial_crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.mutation_factors = np.full(self.population_size, self.initial_mutation_factor)\n        self.crossover_rates = np.full(self.population_size, self.initial_crossover_rate)\n    \n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factors[target_idx] * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant, crossover_rate):\n        cross_points = np.random.rand(self.dim) < crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n        \n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant, self.crossover_rates[i])\n                trial_fitness = func(trial)\n                budget_spent += 1\n                \n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    # Adapt mutation factors and crossover rates based on performance\n                    self.mutation_factors[i] = min(1.0, self.mutation_factors[i] * 1.1)\n                    self.crossover_rates[i] = min(1.0, self.crossover_rates[i] * 1.1)\n                else:\n                    self.mutation_factors[i] *= 0.9\n                    self.crossover_rates[i] *= 0.9\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update population\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 30, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05802 with standard deviation 0.05487.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.13807221751558363, 0.13100834109335446, 0.12571209383269977, 0.040708990127680256, 0.04377208002699118, 0.042214397410063165, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "0bb0a1b5-d838-4cd8-9a3b-25a821ed6a27", "fitness": 0.05680205395652322, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Refine the dynamic mutation factor to include a diversity-based scaling for enhanced adaptability.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.4 * (1 - np.std(fitness) / np.mean(fitness)) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05680 with standard deviation 0.05516.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.13047390507626655, 0.1278598339242365, 0.1362389788598637, 0.03722336217057742, 0.038460531200136594, 0.04029520771096151, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b5d7ec6d-9a4c-46c1-ab6f-87d4f0c7c49b", "fitness": 0.056386782491629504, "name": "EnhancedAdaptiveBBO", "description": "Enhanced Adaptive BBO with Adaptive Population Resizing and Inertia Weight for Improved Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.inertia_weight = 0.5\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Adaptive population resizing based on convergence status\n            if budget_spent < self.budget:\n                population_diversity = np.std(fitness) / np.mean(fitness)\n                if population_diversity < 0.1 and self.population_size > self.initial_population_size // 2:\n                    self.population_size = max(self.initial_population_size // 2, int(self.population_size * 0.9))\n                    next_population = next_population[:self.population_size]\n                    fitness = fitness[:self.population_size]\n                elif population_diversity > 0.2 and self.population_size < self.initial_population_size * 2:\n                    self.population_size = min(self.initial_population_size * 2, int(self.population_size * 1.1))\n                    additional_population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size - len(next_population), self.dim))\n                    additional_fitness = np.array([func(ind) for ind in additional_population])\n                    next_population = np.vstack((next_population, additional_population))\n                    fitness = np.concatenate((fitness, additional_fitness))\n                    budget_spent += len(additional_population)\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.inertia_weight = 0.5 + 0.5 * (1 - np.std(fitness) / np.mean(fitness))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedAdaptiveBBO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05639 with standard deviation 0.05463.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.1254829594975867, 0.133212733365211, 0.1322949592725876, 0.03614347377220983, 0.04078566394180694, 0.038894585908596735, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "f75fd9c9-522c-486d-8408-6916db7a9dd5", "fitness": 0.05687632736504389, "name": "RefinedAdaptiveHierarchicalBBO_DEM", "description": "Incorporate adaptive crossover decay and hierarchical island strategies to improve convergence and diversity balance.", "code": "import numpy as np\n\nclass RefinedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate_initial = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n        self.crossover_rate = self.crossover_rate_initial\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = max(0.1, self.crossover_rate * self.dynamic_crossover_decay)\n            fitness_std_dev = np.std(fitness)\n            if fitness_std_dev > 0:\n                self.mutation_factor = 0.5 + 0.3 * (1 - fitness_std_dev / np.mean(fitness))\n            else:\n                self.mutation_factor = 0.8  # reset to a default value if no diversity\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 33, "feedback": "The algorithm RefinedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05688 with standard deviation 0.05360.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.12513524890129457, 0.13035801892653354, 0.13082733610339226, 0.0432753915814873, 0.04076648301571695, 0.04085780109030368, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "774004a3-05c7-4aef-8450-e37f4de589f4", "fitness": 0.058701562627521325, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce an adaptive learning rate for dynamic mutation and crossover rates to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.learning_rate = 0.05  # New adaptive learning rate\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically with learning rate\n            self.crossover_rate = self.crossover_rate * self.dynamic_crossover_decay + self.learning_rate * np.random.rand()\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness)) + self.learning_rate * np.random.rand()\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 34, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05870 with standard deviation 0.05447.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.13152724619679723, 0.12869271449489372, 0.13374504058741943, 0.04558244626936803, 0.0427455810853391, 0.04535436834720774, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "8fad5bf2-45af-4271-9132-ebf17302c436", "fitness": 0.05708674566094851, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by dynamically adjusting mutation and crossover rates based on population diversity and fitness variance.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness)) \n            self.crossover_rate = 0.3 + 0.4 * (np.std(fitness) / (np.std(fitness) + 1)) # changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 35, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05709 with standard deviation 0.05407.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.13222471209422226, 0.12983937298749404, 0.12722256872877202, 0.042586288144210505, 0.04035359547656803, 0.04088750685060305, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "dab94086-e5e4-44cd-a084-7046611fac61", "fitness": 0.05687632736504389, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce adaptive population size based on performance variability to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 50  # renamed for clarity\n        self.population_size = self.base_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / np.mean(fitness))\n\n            # Adaptive population size adjustment\n            if np.std(fitness) < 0.1:  # if convergence is detected\n                self.population_size = max(10, int(self.base_population_size * 0.7))\n            else:\n                self.population_size = self.base_population_size\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 36, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05688 with standard deviation 0.05360.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.12513524890129457, 0.13035801892653354, 0.13082733610339226, 0.0432753915814873, 0.04076648301571695, 0.04085780109030368, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "d25b9508-448a-4df9-91c1-315628e75baa", "fitness": -Infinity, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Introduce adaptive island migration based on local fitness landscape and enhance diversity with controlled mutation adjustments.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with adaptive island migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            # Introduce adaptive migration based on fitness improvement potential\n                            migration_strength = np.random.normal(0, 0.01 + (self.global_best_fitness - fitness[idx]) / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically with controlled mutation to enhance diversity\n            self.crossover_rate *= self.dynamic_crossover_decay\n            diversity = np.std(fitness) / np.mean(fitness)\n            self.mutation_factor = 0.5 + 0.3 * (1 - diversity) + 0.1 * np.clip((0.1 - diversity), 0, 0.1)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 37, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {}}
{"id": "49ea8288-0c44-4532-a2b6-fc0b13fa5ebb", "fitness": 0.059394667785188045, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance mutation factor adaptation by incorporating historical fitness trends to improve convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6)) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 38, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05939 with standard deviation 0.05681.", "error": "", "parent_ids": ["3edf42b7-5a85-47df-a6d1-af3bb60b1794"], "operator": null, "metadata": {"aucs": [0.1464874814297361, 0.13009593506969175, 0.13059955423282466, 0.04028780295277201, 0.041848172869813016, 0.04456639684518815, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "100d165c-3d0f-4799-9d8d-0d51f23c481c", "fitness": 0.05688496406657189, "name": "EnhancedAdaptiveBBO_DEM", "description": "Introduce dynamic population resizing and adaptive migration strategies to enhance exploration and exploitation balance for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 50\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with adaptive ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates and population size dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.population_size = max(10, int(self.initial_population_size * (1 - (budget_spent / self.budget)**0.5)))\n            self.island_size = max(2, int(self.population_size * self.elite_rate))\n            self.num_islands = max(1, self.population_size // self.island_size)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedAdaptiveBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05688 with standard deviation 0.05297.", "error": "", "parent_ids": ["49ea8288-0c44-4532-a2b6-fc0b13fa5ebb"], "operator": null, "metadata": {"aucs": [0.12423633069277629, 0.13150700404925642, 0.12701773548047424, 0.04159812504421134, 0.04322889735129687, 0.04370991731446516, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "331647d3-ec14-4ea7-b8ae-fbae509bec71", "fitness": 0.05610941936364197, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by dynamically adjusting the mutation factor based on the global best fitness improvement rate.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.previous_global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.previous_global_best_fitness = self.global_best_fitness\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor *= (1 + np.tanh((self.previous_global_best_fitness - self.global_best_fitness) / (abs(self.previous_global_best_fitness) + 1e-8))) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 40, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05611 with standard deviation 0.05502.", "error": "", "parent_ids": ["49ea8288-0c44-4532-a2b6-fc0b13fa5ebb"], "operator": null, "metadata": {"aucs": [0.13412421636452965, 0.13160088486274946, 0.12663908011755176, 0.03738197483867689, 0.03657128868518078, 0.038667329404089235, 0.0, 0.0, 0.0]}}
{"id": "a85dba81-6882-45f9-86c0-802709fb0024", "fitness": 0.0571437930126759, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Improve convergence by dynamically adjusting mutation strength based on the diversity of the current population.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 41, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05714 with standard deviation 0.05363.", "error": "", "parent_ids": ["49ea8288-0c44-4532-a2b6-fc0b13fa5ebb"], "operator": null, "metadata": {"aucs": [0.12622960847712683, 0.13009593506969175, 0.13059955423282466, 0.04028780295277201, 0.041848172869813016, 0.04456639684518815, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "65624c85-9a2a-41b5-aa6b-526d6b18e362", "fitness": -Infinity, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce adaptive influence of best individuals in the ecosystem migration phase to enhance convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                best_impact = 1 - np.std(fitness[elites]) / (np.mean(fitness[elites]) + 1e-6) # Changed line\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, best_impact * (0.01 + self.global_best_fitness / (1 + fitness[idx]))) # Changed line\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate *= self.dynamic_crossover_decay\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6)) # Changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 42, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["49ea8288-0c44-4532-a2b6-fc0b13fa5ebb"], "operator": null, "metadata": {}}
{"id": "07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3", "fitness": 0.05991610760154799, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Improve convergence speed by dynamically adjusting the crossover rate based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6)) #changed line\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05992 with standard deviation 0.05340.", "error": "", "parent_ids": ["49ea8288-0c44-4532-a2b6-fc0b13fa5ebb"], "operator": null, "metadata": {"aucs": [0.1325435739834102, 0.1382628823990698, 0.12675577680503736, 0.03702300558872074, 0.042257482075676145, 0.03951335867312866, 0.02244444444444449, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "6809de73-56b2-4f19-a4da-d7435865e340", "fitness": 0.05716614656549419, "name": "EnhancedAdaptiveBBO_DEM", "description": "Improve solution diversity and convergence by integrating adaptive mutation strategies and a novel exploration-exploitation balance mechanism.", "code": "import numpy as np\n\nclass EnhancedAdaptiveBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.diversity_threshold = 1e-5\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def update_diversity(self, population):\n        # Calculate diversity as the average distance between individuals\n        distances = np.sqrt(np.sum((population[:, np.newaxis] - population) ** 2, axis=-1))\n        diversity = np.mean(distances)\n        return diversity\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            # Calculate diversity\n            diversity = self.update_diversity(population)\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i] or (diversity < self.diversity_threshold and np.random.rand() < 0.1):\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically with new mechanisms\n            fitness_variance = np.std(fitness) / (np.mean(fitness) + 1e-6)\n            self.crossover_rate = 0.7 + 0.2 * fitness_variance\n            self.mutation_factor = 0.6 + 0.2 * (1 - fitness_variance)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedAdaptiveBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05717 with standard deviation 0.05388.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13008324825299744, 0.13014697515067952, 0.1280596582150515, 0.04577859268565654, 0.04066590305044193, 0.03909427506795404, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "7eaf8f5e-ba70-4122-9002-82aa1c7522b7", "fitness": 0.05857341822976809, "name": "EliteGuidedAdaptiveBBO", "description": "Introduce elite-guided adaptive mutation and crossover strategies to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EliteGuidedAdaptiveBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_mutation_factor = 0.8\n        self.base_crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.elite_mutation_boost = 1.2\n        self.elite_crossover_boost = 1.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution, elite):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutation_factor = self.base_mutation_factor * (self.elite_mutation_boost if elite else 1.0)\n        mutant = population[a] + mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant, elite):\n        crossover_rate = self.base_crossover_rate * (self.elite_crossover_boost if elite else 1.0)\n        cross_points = np.random.rand(self.dim) < crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            sorted_indices = np.argsort(fitness)\n            elites = sorted_indices[:self.island_size]\n\n            for i in range(self.population_size):\n                elite = i in elites\n                mutant = self.mutation(i, population, best_solution, elite)\n                trial = self.crossover(population[i], mutant, elite)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with elite-guided migration\n            if budget_spent < self.budget:\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[np.random.choice(elites)]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n            \n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 45, "feedback": "The algorithm EliteGuidedAdaptiveBBO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05857 with standard deviation 0.05566.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.1351634301475927, 0.13646425301857634, 0.12862279185039716, 0.040188753032946556, 0.04399284767799605, 0.04206202167373729, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "32776b94-3723-45d0-88e9-8d107a7a34fa", "fitness": 0.05570633326143859, "name": "AdaptiveLearningRateBBO_DEM", "description": "Improve convergence by incorporating adaptive learning rates using a self-adaptive mutation and crossover mechanism based on historical performance.", "code": "import numpy as np\n\nclass AdaptiveLearningRateBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.historical_fitness = []\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def calculate_adaptive_rates(self):\n        if len(self.historical_fitness) > 1:\n            improvements = np.diff(self.historical_fitness)\n            self.crossover_rate = np.clip(0.7 + 0.3 * (np.mean(improvements) / (np.std(improvements) + 1e-6)), 0.1, 1.0)\n            self.mutation_factor = np.clip(0.5 + 0.3 * (1 - np.mean(improvements) / (np.std(improvements) + 1e-6)), 0.1, 1.0)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n        self.historical_fitness.append(np.min(fitness))\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically using historical performance\n            self.historical_fitness.append(np.min(fitness))\n            self.calculate_adaptive_rates()\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 46, "feedback": "The algorithm AdaptiveLearningRateBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05571 with standard deviation 0.05328.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12718074545703983, 0.12617973326866327, 0.12924618437807267, 0.03566813799012436, 0.043169126838693006, 0.03924640475368746, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5069158d-a9ed-495d-9a48-a0499e5c78ba", "fitness": -Infinity, "name": "EnhancedAdaptiveHierarchicalSolver", "description": "Enhance convergence by implementing dynamic learning rates via adaptive mutation and crossover rates, influenced by fitness landscape metrics and hierarchical solvers.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalSolver:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor_base = 0.8\n        self.crossover_rate_base = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Adaptive rates based on fitness metrics\n            fitness_std = np.std(fitness)\n            fitness_mean = np.mean(fitness) + 1e-6\n            self.crossover_rate = self.crossover_rate_base + 0.3 * (fitness_std / fitness_mean)\n            self.mutation_factor = self.mutation_factor_base * (1 - fitness_std / fitness_mean)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 47, "feedback": "An exception occurred: AttributeError(\"'EnhancedAdaptiveHierarchicalSolver' object has no attribute 'mutation_factor'\").", "error": "AttributeError(\"'EnhancedAdaptiveHierarchicalSolver' object has no attribute 'mutation_factor'\")", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "b6fd19d8-9f37-44c9-a06d-e5bcf78675cf", "fitness": 0.05541659638371337, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance global exploration and local exploitation by integrating adaptive DE with island model and fitness sharing mechanism.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def fitness_sharing(self, fitness):\n        sigma_share = np.std(fitness) * 0.5\n        shared_fitness = np.copy(fitness)\n        for i, f_i in enumerate(fitness):\n            sh_sum = sum(np.exp(-((f_i - f_j) ** 2) / (2 * sigma_share ** 2)) for f_j in fitness)\n            shared_fitness[i] = f_i / sh_sum\n        return shared_fitness\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            fitness = self.fitness_sharing(fitness)\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05542 with standard deviation 0.05412.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13623402790729933, 0.12531233366990568, 0.12472206772337446, 0.03396742528527408, 0.0381450982814735, 0.0397017479194266, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "af4b70ec-c20f-4965-8ecd-49863d1dfcab", "fitness": 0.05719830606798842, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance diversity by adapting the mutation factor based on fitness disparity and add an adaptive elitism strategy.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.4 * (self.global_best_fitness - np.min(fitness)) / (np.max(fitness) - np.min(fitness) + 1e-6) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 49, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05720 with standard deviation 0.05416.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12971670420257841, 0.1297430468940377, 0.13058118911401273, 0.039897336804635364, 0.04141563170603468, 0.042764179223930165, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "cdd429b3-fc0a-4eaa-ad46-cb94bfb64cfc", "fitness": 0.055901969266935, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration by incorporating adaptive mutation factors based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (np.std(population) / (np.mean(population) + 1e-6)) #modified line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 50, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05590 with standard deviation 0.05307.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12415749630830608, 0.13102354613112366, 0.1265667598850082, 0.03726145246844015, 0.04201581181341241, 0.0414259901294578, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c94cb1df-fbce-44d2-9e31-0260769e5c6b", "fitness": 0.05561268716443852, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce opposition-based learning to diversify the population by initializing some solutions in the opposite space.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        \n        # Opposition-based learning\n        opposite_population = self.bounds.lb + self.bounds.ub - population[:self.population_size//2]\n        population[:self.population_size//2] = np.where(np.random.rand(self.population_size//2, self.dim) < 0.5, population[:self.population_size//2], opposite_population)\n\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 51, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05561 with standard deviation 0.05296.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.1284556157518152, 0.127344978690084, 0.12498565115417437, 0.04124629405021596, 0.04116239189725901, 0.036652586269731446, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "110c928f-52ba-4e6a-bb78-d293bf768547", "fitness": -Infinity, "name": "AdaptiveHierarchicalBBO_RL", "description": "Integrate adaptive learning into mutation and crossover rates using reinforcement learning rewards based on fitness improvements to enhance convergence speed.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_RL:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.learning_rate = 0.1\n        self.reward_scale = 0.1\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def update_rates(self, fitness, old_fitness):\n        improvement = old_fitness - fitness\n        reward = self.reward_scale * improvement\n        self.crossover_rate = min(1.0, max(0.1, self.crossover_rate + self.learning_rate * reward))\n        self.mutation_factor = min(1.0, max(0.1, self.mutation_factor + self.learning_rate * reward))\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            old_fitness = fitness.copy()\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates based on reinforcement learning\n            self.update_rates(fitness, old_fitness)\n            \n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 52, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "0594df56-85d3-4bac-ae39-85301aaf1476", "fitness": 0.05958838768547999, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance exploitation by adjusting mutation factor based on the ratio of elite solutions' diversity.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            diversity = np.mean(np.linalg.norm(population[elites] - best_solution, axis=1)) # Line changed\n            self.mutation_factor = 0.5 + 0.3 * (diversity / (np.max(fitness) + 1e-6)) # Line changed\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 53, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05959 with standard deviation 0.05730.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.15053371734121235, 0.13284257250489595, 0.1259016808558312, 0.040553160256683096, 0.03983542188867106, 0.045962269655359544, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "24eeb2d6-6a4c-45cb-bd1e-b02f1e2491cf", "fitness": 0.05682959018343107, "name": "AdaptiveHierarchicalBBO_DEM_Improved", "description": "Enhance convergence by integrating adaptive learning rates and strategic island migration.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization with strategic island migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.uniform(-0.1, 0.1)\n                            population[idx] += migration_strength * (emigrant - population[idx])\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update dynamic learning rates\n            fitness_std = np.std(fitness)\n            fitness_mean = np.mean(fitness) + 1e-6  # To avoid division by zero\n            dynamic_adjustment = 0.3 * (fitness_std / fitness_mean)\n            self.crossover_rate = 0.6 + dynamic_adjustment\n            self.mutation_factor = 0.5 + 0.5 * (1 - fitness_std / fitness_mean)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 54, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05683 with standard deviation 0.05362.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.1305556955457522, 0.12645171031072688, 0.12932275772769475, 0.04280216368941481, 0.0437345228315531, 0.0379327948790712, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "6f64e9f6-a043-433f-9935-f22f7fa26f16", "fitness": 0.05773362429565068, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Improve convergence speed by enhancing mutation diversity with adaptive scaling based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        # Changed line: mutation factor dynamically adapts to population diversity\n        diversity_factor = np.mean(np.std(population, axis=0))\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c]) * diversity_factor\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 55, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05773 with standard deviation 0.05316.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12573595122894243, 0.1310116742257612, 0.12827905234022308, 0.04731453102554406, 0.045929466049440926, 0.0406652771242777, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "28bcbb17-acb4-40f6-8dd0-3b51394f1bfc", "fitness": 0.056186675429792755, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance performance by introducing self-adaptive dynamic migration strength for ecosystem migration.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            # Self-adaptive dynamic migration strength\n                            migration_strength = np.random.normal(0, 0.01 + (self.global_best_fitness / (1 + fitness[idx])) * (1 + 0.1 * np.random.rand()))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 56, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05619 with standard deviation 0.05400.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12996629064670462, 0.12754222039673213, 0.1299682573826817, 0.03937679491730062, 0.040193240081234816, 0.03796660877681424, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "bfe4ef13-c663-427a-813e-0ad43baf0ba2", "fitness": 0.057658696600326714, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by implementing adaptive mutation and crossover rates based on population diversity and island migration strategies for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor_initial = 0.8\n        self.crossover_rate_initial = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                self.mutation_factor = self.mutation_factor_initial * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n                self.crossover_rate = self.crossover_rate_initial * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n                mutant = self.mutation(i, population)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05766 with standard deviation 0.05460.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13328806317725483, 0.1350354898819497, 0.12444046755651617, 0.044501987425326406, 0.040257871544208124, 0.040737723151018534, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "4720e788-a5ec-4fe2-b58b-4e2a79403892", "fitness": 0.056926941035814145, "name": "RefinedAdaptiveHierarchicalBBO_DEM", "description": "Leverage adaptive differential evolution with probabilistic adaptation to island migration strategies and dynamic scaling of mutation/crossover rates.", "code": "import numpy as np\n\nclass RefinedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Probabilistic migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    if np.random.rand() < 0.3:  # Adaptively migrate with a probability\n                        emigrant = population[sorted_indices[np.random.randint(0, self.island_size)]]\n                        for idx in island_indices:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            fitness_std = np.std(fitness)\n            fitness_mean = np.mean(fitness)\n            if fitness_std > 0:\n                self.crossover_rate = 0.6 + 0.4 * (fitness_std / (fitness_mean + 1e-6)) # more aggressive adaptation\n                self.mutation_factor = 0.5 + 0.4 * (1 - fitness_std / (fitness_mean + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 58, "feedback": "The algorithm RefinedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05693 with standard deviation 0.05379.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12539513074235364, 0.13339800692981463, 0.128499940958259, 0.04006067409341407, 0.044426810501254854, 0.03989523943056439, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "4fee7289-e2bc-460c-81be-10657a8798f9", "fitness": 0.05706351509009049, "name": "AdaptiveHierarchicalBBO_DEM_Enhanced", "description": "Enhance exploration by introducing dynamic island formation and adaptive learning rates to improve convergence efficiency.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.adaptive_learning_rate = 0.1\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adaptive_learning(self, fitness):\n        return np.std(fitness) / (np.mean(fitness) + 1e-6)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Enhanced Biogeography-Based Optimization with dynamic islands\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = self.adaptive_learning(fitness)\n                            population[idx] = emigrant + migration_strength * np.random.normal(0, 0.01)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * self.adaptive_learning(fitness)\n            self.mutation_factor = 0.5 + 0.3 * (1 - self.adaptive_learning(fitness))\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 59, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05706 with standard deviation 0.05543.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13392763969287336, 0.13322331434745316, 0.12946671894981743, 0.03785123245745048, 0.038635006992904675, 0.03980105670364864, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "1494bc02-4433-44ee-83b2-b2c7246bd807", "fitness": 0.05626863395607351, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration by adjusting mutation factors based on dynamic diversity measures.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            # Adjust mutation based on population diversity\n            diversity = np.std(population, axis=0).mean() #changed line\n            self.mutation_factor *= 1 + 0.1 * (diversity / (self.bounds.ub - self.bounds.lb).mean()) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]\n", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05627 with standard deviation 0.05380.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12711846401622973, 0.13488866080966422, 0.12421072149416679, 0.03926645177411736, 0.039057001074476294, 0.0412097397693405, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "1edaff7b-c42f-44e2-b6cf-346cae6ac537", "fitness": 0.05764641320059601, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance performance by introducing adaptive mutation scaling based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            diversity = np.std(population, axis=0).mean()\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6)) + 0.1 * diversity # changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 61, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05765 with standard deviation 0.05461.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13609833769009694, 0.12778814071746647, 0.129125765311067, 0.04372860010127322, 0.04049683268800375, 0.040913375630790005, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "3706cfd8-25f7-42be-8b34-7d24dc4a11ae", "fitness": 0.0571727668496756, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Improve convergence by dynamically adjusting the island migration strength based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + np.std(fitness) / (1 + fitness[idx]))  # Changed line\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6)) #changed line\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 62, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05717 with standard deviation 0.05382.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13539814940824246, 0.12491355936134463, 0.12688320152717858, 0.03790076974892409, 0.03817908574756845, 0.05061346918715548, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5f21e247-6414-4aaa-b058-ab0c3cfc0a6b", "fitness": 0.05736726092335614, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Introduce adaptive island migration and fitness-weighted mutation to enhance global exploration and convergence in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution, fitness):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        weight = np.exp(-fitness[a] / (np.mean(fitness) + 1e-6))\n        mutant = population[a] + weight * self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution, fitness)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Improved Biogeography-Based Optimization (BBO) with adaptive migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                migration_strength = 0.01 + self.global_best_fitness / (1 + np.min(fitness))\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            population[idx] = emigrant + np.random.normal(0, migration_strength)\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically based on fitness variance\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05737 with standard deviation 0.05486.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.14054536951544438, 0.1260218928686232, 0.1268173015009595, 0.0382383535062365, 0.04200054998890801, 0.04201521426336696, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "4529f3f8-48d9-4e38-8dd8-93a1fcc28401", "fitness": 0.05864115315439473, "name": "EnhancedAdaptiveBBO_DEM", "description": "Enhance convergence and diversity by integrating adaptive Differential Evolution and dynamic migration inspired by Biogeography-Based Optimization with fitness rank-based adaptive rates.", "code": "import numpy as np\n\nclass EnhancedAdaptiveBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.initial_mutation_factor = 0.8\n        self.initial_crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                self.crossover_rate = self.initial_crossover_rate * (1 - i / self.population_size)\n                self.mutation_factor = self.initial_mutation_factor * (1 + i / self.population_size)\n\n                mutant = self.mutation(i, population)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Rank-based Biogeography-Based Optimization (BBO)\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                for idx in sorted_indices:\n                    if np.random.rand() < 0.5:\n                        rank = np.where(sorted_indices == idx)[0][0]\n                        migration_strength = np.random.normal(0, 0.01 * (1 - rank / self.population_size))\n                        emigrant = population[sorted_indices[0]]\n                        population[idx] = emigrant + migration_strength\n                        population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                        fitness[idx] = func(population[idx])\n                        budget_spent += 1\n\n                        if budget_spent >= self.budget:\n                            break\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedAdaptiveBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05864 with standard deviation 0.05564.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.1332988688964667, 0.1332379989428787, 0.13374269192530053, 0.043469554951889644, 0.03723479802659235, 0.04611979897975793, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "34eda43f-fece-4a55-bbc5-8a0e8cae9169", "fitness": -Infinity, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by leveraging adaptive dynamic island migration and fitness diversity-driven adaptive parameters.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Adaptive Biogeography-Based Optimization (ABBO) with enhanced dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    migration_strength_factor = 1 - (np.std(fitness) / (np.mean(fitness) + 1e-6))\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 * migration_strength_factor + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically based on diversity\n            fitness_std = np.std(fitness)\n            fitness_mean = np.mean(fitness)\n            diversity_factor = fitness_std / (fitness_mean + 1e-6)\n            self.crossover_rate = 0.7 + 0.3 * diversity_factor\n            self.mutation_factor = 0.5 + 0.3 * (1 - diversity_factor)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 65, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "77392436-ee82-459f-992b-66d6e94c0e79", "fitness": 0.05926968625824383, "name": "RefinedAdaptiveHierarchicalBBO_DEM", "description": "Introduce adaptive mutation and crossover rates based on fitness diversity and employ multi-phase island migration to leverage diverse solutions.  ", "code": "import numpy as np\n\nclass RefinedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Multi-phase BBO with adaptive migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically based on population diversity\n            fitness_std = np.std(fitness)\n            self.crossover_rate = 0.6 + 0.4 * (fitness_std / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.4 * (1 - fitness_std / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 66, "feedback": "The algorithm RefinedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05927 with standard deviation 0.05112.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12907544928524917, 0.12826303361357938, 0.12765132218164132, 0.0393638953991412, 0.0397093861352793, 0.04514186748708182, 0.023777777777777787, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "d91e293c-6588-4545-baeb-0cacfc212922", "fitness": 0.05752325109089922, "name": "AdaptiveHierarchicalBBO_DEM_Enhanced", "description": "Enhance adaptability by incorporating a success-based reinforcement mechanism for mutation and crossover parameters.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.initial_mutation_factor = 0.8\n        self.initial_crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        \n        # Initialize success-based counters\n        self.success_mutation = 0\n        self.success_crossover = 0\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                self.mutation_factor = max(0.5, min(self.initial_mutation_factor + 0.5 * (self.success_mutation / (self.success_mutation + self.success_crossover + 1e-6)), 1))\n                self.crossover_rate = max(0.5, min(self.initial_crossover_rate + 0.5 * (self.success_crossover / (self.success_mutation + self.success_crossover + 1e-6)), 1))\n                \n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n                    if np.random.rand() < 0.5:\n                        self.success_mutation += 1\n                    else:\n                        self.success_crossover += 1\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 67, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05752 with standard deviation 0.05424.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12744913436398397, 0.13224005236662106, 0.13120627768470305, 0.044475107052589835, 0.04133681315122317, 0.04033520853230521, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b949db6d-ef79-4eac-9afe-95b71a66b3ec", "fitness": 0.05713953286363222, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by incorporating adaptive island migration and fitness-based mutation scaling.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Adaptive BBO with ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update strategy parameters dynamically\n            fitness_std = np.std(fitness)\n            fitness_mean = np.mean(fitness)\n            self.crossover_rate = 0.7 + 0.3 * (fitness_std / (fitness_mean + 1e-6))\n            self.mutation_factor = 0.5 + 0.5 * (1 - fitness_std / (fitness_mean + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05714 with standard deviation 0.05292.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12711138579501757, 0.12430510334998768, 0.13136065092674176, 0.04085365269286678, 0.04255495187984326, 0.04740338446156622, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "922b5da7-f6ed-4572-b004-f69f421a9fdc", "fitness": 0.056770681249033186, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Utilize adaptive migration strength based on fitness change to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            previous_fitness = fitness[idx]\n                            migration_strength = np.random.normal(0, 0.01 + (previous_fitness - fitness[idx]) / (1 + fitness[idx]))  #changed line\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))  #changed line\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))  #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 69, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05677 with standard deviation 0.05571.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13564768777059621, 0.13244677599314958, 0.12940085802154422, 0.03538462409591614, 0.03996575966470017, 0.037423759028725634, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "bdb58c3c-668e-44c6-ba90-fb1e72eba90a", "fitness": 0.05600703180675404, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by introducing adaptive island sizes and dynamic mutation factors based on fitness diversity.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Adaptive island size based on fitness diversity\n            fitness_diversity = np.std(fitness) / (np.mean(fitness) + 1e-6)\n            adjusted_island_size = max(2, int(self.island_size * (1 + fitness_diversity)))\n            self.num_islands = max(1, self.population_size // adjusted_island_size)\n            \n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:adjusted_island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*adjusted_island_size:(island+1)*adjusted_island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (fitness_diversity)\n            self.mutation_factor = 0.5 + 0.3 * (1 - fitness_diversity)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 70, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05601 with standard deviation 0.05371.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.129291971785934, 0.12360343436008026, 0.13248491398621387, 0.03927115451888996, 0.039657802156941924, 0.03908734278605963, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "cbd80f52-c1c3-4a14-87d7-dbe545ae5763", "fitness": -Infinity, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration-exploitation balance by introducing adaptive mutation factor and selective crossover based on fitness percentile.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution, fitness):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        fitness_percentile = np.percentile(fitness, 25)\n        dynamic_mutation_factor = self.mutation_factor * (fitness[target_idx] / (fitness_percentile + 1e-6))\n        mutant = population[a] + dynamic_mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant, fitness):\n        fitness_percentile = np.percentile(fitness, 75)\n        dynamic_crossover_rate = self.crossover_rate * (fitness[target] / (fitness_percentile + 1e-6))\n        cross_points = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution, fitness)\n                trial = self.crossover(population[i], mutant, fitness)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island * self.island_size:(island + 1) * self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 71, "feedback": "An exception occurred: IndexError('arrays used as indices must be of integer (or boolean) type').", "error": "IndexError('arrays used as indices must be of integer (or boolean) type')", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "21a1a0f9-8736-4fcb-9c12-6dc998e6311a", "fitness": 0.05981737554337426, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration-exploitation balance by adjusting island size dynamically based on fitness diversity.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                self.island_size = max(1, int(self.population_size * np.std(fitness) / (np.mean(fitness) + 1e-6))) #changed line\n                self.num_islands = max(1, self.population_size // self.island_size) #changed line\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 72, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05982 with standard deviation 0.05742.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.14861346043070445, 0.1360532165718148, 0.126132092910331, 0.040581023396974114, 0.042256812227086105, 0.04405310768679116, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5ed57cf9-5e19-48b7-a66d-8b7e2d5f55fc", "fitness": 0.0558098806833518, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration by incorporating adaptive mutation scaling and elite-guided migration to improve global search capabilities.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + np.random.uniform(0.5, 1.0) * (population[b] - population[c])  # changed line\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.6:  # changed line\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            # Elite-based mutation factor adjustment\n            self.mutation_factor *= 1.0 + 0.1 * ((self.global_best_fitness - np.min(fitness)) / (np.max(fitness) + 1e-6))  # changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 73, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05581 with standard deviation 0.05427.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.1333103412797545, 0.12930124162960344, 0.12550714524392748, 0.03793026145078737, 0.03734497348775667, 0.038228296391670025, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "cc78ae6c-3d94-48c3-a1df-9f84603b3ff3", "fitness": 0.057518820357156136, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance adaptability by refining dynamic mutation factor scaling based on fitness spread, improving convergence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.std(fitness) + 1e-6)) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 74, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05752 with standard deviation 0.05529.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13020244461764474, 0.1374467678815694, 0.12879008333279063, 0.040990325013806395, 0.036959840890041784, 0.042613254811885604, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "783734db-8d73-46d1-9f82-a5b9781f75bf", "fitness": 0.05712692379551941, "name": "ImprovedAdaptiveHierarchicalBBO_DEM", "description": "Implement hierarchical multi-population dynamics with adaptive migration to enhance convergence by exploiting diverse search strategies.", "code": "import numpy as np\n\nclass ImprovedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population with diverse spread\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Hierarchical multi-population dynamics with adaptive migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.02 * (1 + np.abs(self.global_best_fitness - fitness[idx]) / (fitness[idx] + 1e-6)))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover and mutation with more sensitivity to fitness variance\n            fitness_variance = np.std(fitness) / (np.mean(fitness) + 1e-6)\n            self.crossover_rate = 0.7 + 0.3 * fitness_variance\n            self.mutation_factor = 0.5 + 0.3 * (1 - fitness_variance)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 75, "feedback": "The algorithm ImprovedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05713 with standard deviation 0.05467.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13409465161612366, 0.12341577586810826, 0.13465776599126267, 0.04303601992217654, 0.03759087070383005, 0.04068056339150683, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "87f57953-131b-4ac0-ad22-88079c8333bf", "fitness": 0.05729308955664093, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by dynamically adjusting mutation strength based on population diversity and improve exploration using adaptive migration strength.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        diversity_factor = np.std(population, axis=0) / (np.mean(population, axis=0) + 1e-6)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c]) * diversity_factor\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.05 + 0.01 * np.std(population, axis=0))  # changed line\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6)) \n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05729 with standard deviation 0.05359.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12496951605263718, 0.1267234986861363, 0.13482933811099507, 0.03779738131533583, 0.04566473718589237, 0.044986667992104934, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "dfb39903-e8c9-46e7-931f-b5277622d295", "fitness": 0.05636860555527044, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance algorithm performance by fine-tuning the mutation factor adaptation based on the convergence rate.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (np.mean(fitness) / (np.std(fitness) + 1e-6)) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 77, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05637 with standard deviation 0.05396.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13260249922598244, 0.12607665297135984, 0.12872942076507987, 0.04059059996272074, 0.04152275038626718, 0.037128860019357224, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "44c2234b-49b1-49f2-8fc8-4016842d040e", "fitness": 0.05714094670800372, "name": "EnhancedAdaptiveBBO_DEM", "description": "Enhance adaptability by integrating dynamic parameter adjustment and hybrid island migration strategies for improved diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Hybrid Migration Strategy with Leader Influence\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    leader = population[best_idx] if np.random.rand() < 0.5 else population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = leader + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedAdaptiveBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05714 with standard deviation 0.05643.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13277520033403045, 0.1311012324792541, 0.13809791460163712, 0.0358169770640403, 0.03827060047821884, 0.03753992874818601, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "78721d4c-92a4-4c58-86cb-e2779849610d", "fitness": 0.057518997454851756, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance diversity and convergence by incorporating adaptive population variance control.  ", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Enhanced diversity control\n            population_mean = np.mean(population, axis=0)\n            population_std = np.std(population, axis=0)\n            population = population + np.random.normal(0, population_std / 10, population.shape) #Changed line\n\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6)) \n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 79, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05752 with standard deviation 0.05592.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.1275991370373234, 0.13738066999221588, 0.13485529873909685, 0.03888507798565821, 0.039184221991453216, 0.039099904681251574, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "eb7664a7-6b4a-4acd-a60b-77ad90bfa8b4", "fitness": 0.05628206141665932, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance algorithm performance by introducing adaptive mutation strategies based on population diversity and convergence improvement with adaptive elitism.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution, diversity):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 + diversity)\n        mutant = population[a] + adaptive_mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            diversity = np.std(population, axis=0).mean()\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution, diversity)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with adaptive elitism\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Adaptive crossover and mutation rates\n            self.crossover_rate = 0.7 + 0.3 * (diversity / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - diversity / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05628 with standard deviation 0.05416.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.135321826194566, 0.12574913934611565, 0.12710745161444548, 0.04047012632851288, 0.03673417734428541, 0.04048916525534174, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "8e07e9b0-a6f4-4f5f-8735-d4b181435f2b", "fitness": 0.0570843014218361, "name": "AdaptiveHierarchicalBBO_SA", "description": "Enhance convergence by integrating self-adaptive parameter tuning and a probabilistic island model for dynamic resource allocation.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adaptive_parameters(self, fitness):\n        diversity = np.std(fitness) / (np.mean(fitness) + 1e-6)\n        self.crossover_rate = 0.6 + 0.4 * diversity\n        self.mutation_factor = 0.6 + 0.4 * (1 - diversity)\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Probabilistic Island Model\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[np.random.randint(len(elites))]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n                            \n                            if budget_spent >= self.budget:\n                                break\n\n            # Update parameters dynamically\n            self.adaptive_parameters(fitness)\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 81, "feedback": "The algorithm AdaptiveHierarchicalBBO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05708 with standard deviation 0.05316.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12551762633776298, 0.12960985275750725, 0.1288221568936775, 0.04017970506218993, 0.03999986410610068, 0.048962840972619825, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "bf633698-3651-4f7b-91c6-6d1c1397620b", "fitness": 0.056839334231296244, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence precision by incorporating self-adaptive mutation strategies and probabilistic environmental selection.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.mutation_strategy_prob = 0.5\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        if np.random.rand() < self.mutation_strategy_prob:\n            mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        else:\n            mutant = best_solution + self.mutation_factor * (population[a] - population[b])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with probabilistic environmental selection\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates and improve mutation strategy dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6)) \n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_strategy_prob = 0.5 + 0.5 * (fitness[best_idx] / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05684 with standard deviation 0.05372.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12875500596854728, 0.13061155655790002, 0.12764277478843988, 0.04216606199941286, 0.03960423656223333, 0.0421077055384661, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "43e374d4-3b2e-475e-84a6-c4b7bf75d6ac", "fitness": 0.05533953279682022, "name": "EnhancedAdaptiveBBO_DEM", "description": "Enhance convergence by incorporating adaptive mutation strategies based on population diversity, while maintaining a dynamic crossover rate.", "code": "import numpy as np\n\nclass EnhancedAdaptiveBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.base_mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.diversity_threshold = 1e-5\n\n    def mutation(self, target_idx, population):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutation_factor = self.base_mutation_factor + np.random.rand() * (1 - self.base_mutation_factor)\n        mutant = population[a] + mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            # Calculate population diversity\n            population_diversity = np.mean(np.std(population, axis=0))\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Dynamic BBO migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover and mutation rates dynamically\n            self.crossover_rate = 0.5 + 0.5 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.base_mutation_factor = 0.7 + 0.3 * (population_diversity / (self.dim * (self.bounds.ub - self.bounds.lb).mean()) + self.diversity_threshold)\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedAdaptiveBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05534 with standard deviation 0.05271.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12537170971792022, 0.1258167846258047, 0.12778462039376204, 0.042456947392691124, 0.03817679500416449, 0.03778227137037271, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "62ffef47-5362-40cb-88a4-e14aba157afc", "fitness": -Infinity, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration and exploitation balance by adapting island migration frequency based on convergence speed and fitness improvement.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.previous_best_fitness = float('inf')\n        self.migration_frequency = 5\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with adaptive migration frequency\n            if budget_spent < self.budget and budget_spent % self.migration_frequency == 0:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            fitness_improvement = abs(self.previous_best_fitness - self.global_best_fitness)\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.migration_frequency = max(2, int(10 * (fitness_improvement / (1 + self.global_best_fitness))))\n\n            self.previous_best_fitness = self.global_best_fitness\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 84, "feedback": "An exception occurred: OverflowError('cannot convert float infinity to integer').", "error": "OverflowError('cannot convert float infinity to integer')", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "0a30bbd9-1a52-441b-b36d-e6a5d48842b6", "fitness": 0.05914519701260057, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Refined AdaptiveHierarchicalBBO_DEM with enhanced mutation strategy based on best individual influence.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        best_influence = self.mutation_factor * (best_solution - population[a]) # changed line\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c]) + best_influence # changed line\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 85, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05915 with standard deviation 0.05669.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.15036301415965903, 0.12502438441698505, 0.12968331346466633, 0.04445037703943433, 0.04240330661605585, 0.03971571074993785, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "ce3d1b74-19f1-4f4b-aeb1-efecd6bcf49c", "fitness": 0.05687542539338106, "name": "AdaptiveTemperatureBBO", "description": "Improve adaptability by incorporating a temperature-controlled mutation factor and iterative elitism to accelerate convergence while maintaining diversity.", "code": "import numpy as np\n\nclass AdaptiveTemperatureBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.temperature = 1.0\n        self.temperature_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.temperature * self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Iterative elitism to enhance performance\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for elite in elites:\n                    if np.random.rand() < 0.5:\n                        migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[elite]))\n                        population[elite] = best_solution + migration_strength\n                        population[elite] = np.clip(population[elite], self.bounds.lb, self.bounds.ub)\n                        fitness[elite] = func(population[elite])\n                        budget_spent += 1\n\n                        if budget_spent >= self.budget:\n                            break\n\n            # Update rates dynamically with temperature decay\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.temperature *= self.temperature_decay\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 86, "feedback": "The algorithm AdaptiveTemperatureBBO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05688 with standard deviation 0.05322.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12516527872533612, 0.13094750597212546, 0.12801493159310406, 0.03921612785271367, 0.04414227112704494, 0.043726046603438595, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "fd8958e5-8a0f-486f-9a63-f5de233d80c3", "fitness": 0.05587838355725546, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance the exploration by dynamically adjusting the mutation factor based on the best solution's fitness change rate.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - abs(self.global_best_fitness - fitness[best_idx]) / (self.global_best_fitness + 1e-6)) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 87, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05588 with standard deviation 0.05324.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13095247097562568, 0.12563437124121624, 0.126089167012565, 0.03749501058427451, 0.03977884735799908, 0.042288918176951906, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "5c96c229-c8ce-4d6c-a29e-45a6f35d6a1a", "fitness": 0.05704563312466956, "name": "CooperativeAdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by integrating cooperative coevolution and adapting mutation strategies based on population diversity.", "code": "import numpy as np\n\nclass CooperativeAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.cooperative_factor = 0.2\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def cooperative_evolution(self, population, fitness):\n        sorted_indices = np.argsort(fitness)\n        elite_group = population[sorted_indices[:self.island_size]]\n        for idx in range(self.population_size):\n            if np.random.rand() < self.cooperative_factor:\n                elite_idx = np.random.choice(self.island_size)\n                diff = np.random.normal(0, 0.1, self.dim)\n                population[idx] = elite_group[elite_idx] + diff\n                population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n        return population\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Apply cooperative evolution\n            population = self.cooperative_evolution(population, fitness)\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 88, "feedback": "The algorithm CooperativeAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05705 with standard deviation 0.05444.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13002402918855716, 0.12801194916069603, 0.13319648957949637, 0.041313492060619406, 0.04057622577407727, 0.03962184569191307, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "cef0be5d-709e-461e-90d8-d2f00907b996", "fitness": 0.05643546509905368, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration and exploitation balance by integrating dynamic island-based migration and adaptive mutation scaling based on population diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Island-based migration with adaptive mutation scaling\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            diversity_scale = np.std(population, axis=0) / (np.mean(population, axis=0) + 1e-6)\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx])) * diversity_scale\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update crossover rate and mutation factor based on fitness diversity\n            fitness_std = np.std(fitness)\n            fitness_mean = np.mean(fitness)\n            self.crossover_rate = 0.7 + 0.3 * (fitness_std / (fitness_mean + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - fitness_std / (fitness_mean + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedAdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05644 with standard deviation 0.05403.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13270621234413227, 0.12878401189864697, 0.12648425159224508, 0.041311874712594454, 0.039721493746669556, 0.03824467493052808, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "bcd9048b-b19b-4e69-bd1d-a16ecbcd936b", "fitness": 0.05703246152024047, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance performance by integrating adaptive mutation scaling with weighted fitness feedback.  ", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically with weighted feedback\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor *= (1 - 0.5 * (self.global_best_fitness / (np.min(fitness) + 1e-6))) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 90, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05703 with standard deviation 0.05342.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13025856611919218, 0.12771253572706287, 0.1275674033658719, 0.040949637174673814, 0.04024969640668674, 0.04588764822200997, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c2d474f9-95fd-4961-ae7f-210d171d7e56", "fitness": -Infinity, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance exploration by integrating adaptive population resizing based on fitness diversity.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates and population size dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6)) \n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.population_size = int(50 + 10 * (np.std(fitness) / (np.mean(fitness) + 1e-6))) #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 91, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "58fbd618-641e-47e0-9b98-97bd06c275ae", "fitness": 0.05881559714639511, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce adaptive mutation strength and selective migration to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_mutation_factor = self.mutation_factor * (1 - np.std(population) / (np.mean(population) + 1e-6))\n        mutant = population[a] + adaptive_mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Selective Biogeography-Based Optimization (BBO) with adaptive migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    if fitness[elites[island % len(elites)]] < self.global_best_fitness:\n                        emigrant = population[elites[island % len(elites)]]\n                        for idx in island_indices:\n                            if np.random.rand() < 0.5:\n                                migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                                population[idx] = emigrant + migration_strength\n                                population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                                fitness[idx] = func(population[idx])\n                                budget_spent += 1\n\n                                if budget_spent >= self.budget:\n                                    break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 92, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05882 with standard deviation 0.05830.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.15579878959307036, 0.1274866720039739, 0.12917239071270492, 0.03750617984504745, 0.04106360388650376, 0.03764607160958888, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "a9b98691-e72a-4260-a115-6abd3412f21f", "fitness": 0.05601979350062801, "name": "AdvancedParallelIslandsBBO", "description": "Introduce multi-layered parallel island evolution with adaptive learning rates to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedParallelIslandsBBO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Multi-layered parallel island evolution\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            emigrant = population[elites[np.random.randint(0, len(elites))]]\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Adaptive learning rates based on local variance\n            fitness_variance = np.var(fitness)\n            self.crossover_rate = 0.7 + 0.3 * (fitness_variance / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - fitness_variance / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 93, "feedback": "The algorithm AdvancedParallelIslandsBBO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05602 with standard deviation 0.05370.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.12774725120517405, 0.13319897496075794, 0.1244114854971029, 0.03979896259881144, 0.04083150834227389, 0.03752329223486517, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "c2944fc7-4c22-4a63-b459-d801b4c171ee", "fitness": -Infinity, "name": "EnhancedCoevolutionary_DEM", "description": "Improve convergence by introducing cooperative coevolution with dynamic subcomponent allocation based on fitness stagnation.", "code": "import numpy as np\n\nclass EnhancedCoevolutionary_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.stagnation_threshold = 10\n        self.stagnation_counter = 0\n\n    def mutation(self, target_idx, population):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def cooperative_coevolution(self, population, fitness):\n        # Dynamically adjust subcomponent sizes based on stagnation\n        subcomponent_size = max(1, self.dim // max(1, self.num_islands - self.stagnation_counter))\n        new_population = np.copy(population)\n        for idx in range(self.population_size):\n            if idx % subcomponent_size == 0:\n                subcomponent = population[idx:idx+subcomponent_size]\n                local_best_idx = np.argmin(fitness[idx:idx+subcomponent_size])\n                best_solution = subcomponent[local_best_idx]\n                for i in range(subcomponent_size):\n                    mutant = self.mutation(idx + i, population)\n                    trial = self.crossover(population[idx + i], mutant)\n                    trial_fitness = func(trial)\n                    if trial_fitness < fitness[idx + i]:\n                        new_population[idx + i] = trial\n                        fitness[idx + i] = trial_fitness\n                        if trial_fitness < self.global_best_fitness:\n                            self.global_best = trial\n                            self.global_best_fitness = trial_fitness\n        return new_population, fitness\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            prev_best_fitness = self.global_best_fitness\n            population, fitness = self.cooperative_coevolution(population, fitness)\n            \n            if self.global_best_fitness >= prev_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n\n            if self.stagnation_counter > self.stagnation_threshold:\n                self.mutation_factor *= 1.1  # Increase diversity\n                self.stagnation_counter = 0\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 94, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "cdc09f43-cd03-4812-ab9b-7548a1f1f1be", "fitness": 0.05677793189643751, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Introduce a decay factor to the mutation factor to dynamically adjust exploration and exploitation balance over time.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = (0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))) * self.mutation_decay #changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 95, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05678 with standard deviation 0.05427.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.13597226221575165, 0.12812104587548434, 0.12549344159139164, 0.037825361352094355, 0.041073751523936, 0.04184885784261294, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "b16eee70-cb5c-46c1-8277-5e00692ad962", "fitness": -Infinity, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance mutation operation by incorporating a fitness-based adaptive mutation factor for better exploration.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_factor = 1 - (self.global_best_fitness / (1 + np.mean([self.global_best_fitness, self.global_best_fitness - population[target_idx]]))) #changed line\n        mutant = population[a] + adaptive_factor * (population[b] - population[c]) #changed line\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6)) \n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 96, "feedback": "An exception occurred: ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (2,) + inhomogeneous part.').", "error": "ValueError('setting an array element with a sequence. The requested array has an inhomogeneous shape after 1 dimensions. The detected shape was (2,) + inhomogeneous part.')", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "7792209c-3f58-49d0-8c79-da144122a382", "fitness": 0.0591929949285436, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance adaptive strategies by incorporating feedback from convergence trends to finely tune mutation and crossover rates.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.prev_fitness_mean = None\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            fitness_mean = np.mean(fitness)\n            fitness_std = np.std(fitness)\n            if self.prev_fitness_mean is not None:\n                improvement = self.prev_fitness_mean - fitness_mean\n                self.crossover_rate *= 1 + 0.1 * improvement / (fitness_mean + 1e-6)\n            self.crossover_rate = np.clip(self.crossover_rate, 0.5, 1.0)\n            self.mutation_factor = 0.5 + 0.3 * (1 - fitness_std / (fitness_mean + 1e-6))\n            self.prev_fitness_mean = fitness_mean\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 97, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05919 with standard deviation 0.05795.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.14500870753412243, 0.14093086517286602, 0.12695146163190163, 0.03631861913935308, 0.0405263516485449, 0.04233428256343763, 0.00022222222222223476, 0.00022222222222223476, 0.00022222222222223476]}}
{"id": "2116a9f5-fedb-43e2-bb71-581355916e7c", "fitness": -Infinity, "name": "EnhancedAdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by incorporating adaptive island-based learning and diversity preservation mechanisms to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n        self.diversity_factor = 0.1\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def adaptive_island_learning(self, population, fitness, budget_spent, func):\n        sorted_indices = np.argsort(fitness)\n        elites = sorted_indices[:self.island_size]\n        for island in range(self.num_islands):\n            island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n            emigrant = population[elites[island % len(elites)]]\n            for idx in island_indices:\n                if np.random.rand() < 0.5:\n                    migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                    population[idx] = emigrant + migration_strength\n                    population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                    fitness[idx] = func(population[idx])\n                    budget_spent += 1\n                    if budget_spent >= self.budget:\n                        break\n        return budget_spent\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Adaptive island-based learning with diversity preservation\n            budget_spent = self.adaptive_island_learning(population, fitness, budget_spent, func)\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.3 * (1 - np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.diversity_factor = 1 - (np.std(fitness) / (np.mean(fitness) + 1e-6))\n\n            # Preserve diversity by perturbing solutions slightly\n            if budget_spent < self.budget:\n                perturbation = np.random.normal(0, self.diversity_factor, population.shape)\n                population += perturbation\n                population = np.clip(population, self.bounds.lb, self.bounds.ub)\n                fitness = np.array([func(ind) for ind in population])\n                budget_spent += self.population_size\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 98, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {}}
{"id": "a5227ef1-b2bd-4341-9c13-1842af93e1a5", "fitness": 0.06062266666736164, "name": "AdaptiveHierarchicalBBO_DEM", "description": "Enhance convergence by using dynamic mutation factor scaling based on population diversity and fitness improvements.", "code": "import numpy as np\n\nclass AdaptiveHierarchicalBBO_DEM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 50\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.elite_rate = 0.2\n        self.island_size = int(self.population_size * self.elite_rate)\n        self.num_islands = self.population_size // self.island_size\n        self.dynamic_crossover_decay = 0.98\n        self.mutation_decay = 0.99\n        self.global_best = None\n        self.global_best_fitness = float('inf')\n\n    def mutation(self, target_idx, population, best_solution):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant = population[a] + self.mutation_factor * (population[b] - population[c])\n        return np.clip(mutant, self.bounds.lb, self.bounds.ub)\n\n    def crossover(self, target, mutant):\n        cross_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(cross_points):\n            cross_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(cross_points, mutant, target)\n        return trial\n\n    def __call__(self, func):\n        self.bounds = func.bounds\n        budget_spent = 0\n\n        # Initialize population\n        population = np.random.uniform(self.bounds.lb, self.bounds.ub, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_spent += self.population_size\n\n        while budget_spent < self.budget:\n            next_population = np.copy(population)\n            best_idx = np.argmin(fitness)\n            best_solution = population[best_idx]\n\n            if fitness[best_idx] < self.global_best_fitness:\n                self.global_best = best_solution\n                self.global_best_fitness = fitness[best_idx]\n\n            for i in range(self.population_size):\n                mutant = self.mutation(i, population, best_solution)\n                trial = self.crossover(population[i], mutant)\n                trial_fitness = func(trial)\n                budget_spent += 1\n                if trial_fitness < fitness[i]:\n                    next_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if budget_spent >= self.budget:\n                    break\n\n            # Biogeography-Based Optimization (BBO) with dynamic ecosystem migration\n            if budget_spent < self.budget:\n                sorted_indices = np.argsort(fitness)\n                elites = sorted_indices[:self.island_size]\n                for island in range(self.num_islands):\n                    island_indices = sorted_indices[island*self.island_size:(island+1)*self.island_size]\n                    emigrant = population[elites[island % len(elites)]]\n                    for idx in island_indices:\n                        if np.random.rand() < 0.5:\n                            migration_strength = np.random.normal(0, 0.01 + self.global_best_fitness / (1 + fitness[idx]))\n                            population[idx] = emigrant + migration_strength\n                            population[idx] = np.clip(population[idx], self.bounds.lb, self.bounds.ub)\n                            fitness[idx] = func(population[idx])\n                            budget_spent += 1\n\n                            if budget_spent >= self.budget:\n                                break\n\n            # Update rates dynamically\n            self.crossover_rate = 0.7 + 0.3 * (np.std(fitness) / (np.mean(fitness) + 1e-6))\n            self.mutation_factor = 0.5 + 0.5 * (1 - np.std(population) / (np.mean(fitness) + 1e-6))  # Changed line\n\n            population = next_population\n\n        return population[np.argmin(fitness)]", "configspace": "", "generation": 99, "feedback": "The algorithm AdaptiveHierarchicalBBO_DEM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06062 with standard deviation 0.05301.", "error": "", "parent_ids": ["07b9ffa2-e02c-44b2-a7d1-7c2d7c2a73b3"], "operator": null, "metadata": {"aucs": [0.1387002622643455, 0.12967545298680938, 0.12967268352186367, 0.03880060254299722, 0.040846727162793806, 0.03857493819411184, 0.028888888888888853, 0.00022222222222223476, 0.00022222222222223476]}}
