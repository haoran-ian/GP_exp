{"id": "da82257a-e644-4750-9cff-be6ae969d9fd", "fitness": 0.06884332102531038, "name": "AdaptiveSpiralOptimization", "description": "A novel Adaptive Spiral Optimization (ASO) algorithm that dynamically adjusts its search path and radius to efficiently explore the solution space for black box optimization.", "code": "import numpy as np\n\nclass AdaptiveSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        angle_step = np.pi / 4\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.9\n            else:\n                # Increase exploration\n                radius *= 1.1\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, (self.upper_bound - self.lower_bound) * 0.01)\n            radius = min(radius, (self.upper_bound - self.lower_bound) * 0.5)\n\n        return best_position, best_value", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06884 with standard deviation 0.06091.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.14919796150337372, 0.1481159353978454, 0.1483234233788886, 0.0007195492880950338, 0.0007070741581228779, 0.0007095271848607254, 0.05731328502536359, 0.05724484683835562, 0.057258286452887774]}}
{"id": "95b94b0f-4a9b-44f4-a4ab-85a395ee6530", "fitness": 0.06927806138013066, "name": "EnhancedAdaptiveSpiralOptimization", "description": "An enhanced Adaptive Spiral Optimization (EASO) algorithm that integrates dynamic angle adjustments and enhanced boundary management for improved exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        angle_step = np.pi / 8  # Changed angle step for finer granularity\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds and adjust if necessary\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # Slightly more aggressive contraction\n            else:\n                # Increase exploration\n                radius *= 1.05  # Slightly more conservative expansion\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, (self.upper_bound - self.lower_bound) * 0.01)\n            radius = min(radius, (self.upper_bound - self.lower_bound) * 0.5)\n\n        return best_position, best_value", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedAdaptiveSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06928 with standard deviation 0.06143.", "error": "", "parent_ids": ["da82257a-e644-4750-9cff-be6ae969d9fd"], "operator": null, "metadata": {"aucs": [0.15045694978909252, 0.14802770632788997, 0.15082492768315037, 0.0007335733038392744, 0.0007060263121771992, 0.0007334214961772778, 0.05739035661286107, 0.057239107313172166, 0.057390483582816176]}}
{"id": "5868d0d7-aef6-49f4-9163-3f98887d8ed0", "fitness": 0.06874877188798306, "name": "EnhancedAdaptiveSpiralOptimization", "description": "Enhanced Spiral Optimization with Adaptive Memory Integrating memory-based search refinement and dynamic spiral control for superior convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        angle_step = np.pi / 8  # Changed angle step for finer granularity\n        memory = [best_position]\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n\n            # Introduce memory-based refinement\n            if len(memory) > 1:\n                direction = np.mean(memory, axis=0) - best_position\n                direction /= np.linalg.norm(direction)\n\n            candidate_position = best_position + radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds and adjust if necessary\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # Slightly more aggressive contraction\n                memory.append(candidate_position)\n                if len(memory) > 5:\n                    memory.pop(0)\n            else:\n                # Increase exploration\n                radius *= 1.05  # Slightly more conservative expansion\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, (self.upper_bound - self.lower_bound) * 0.01)\n            radius = min(radius, (self.upper_bound - self.lower_bound) * 0.5)\n\n        return best_position, best_value", "configspace": "", "generation": 2, "feedback": "The algorithm EnhancedAdaptiveSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06875 with standard deviation 0.06079.", "error": "", "parent_ids": ["95b94b0f-4a9b-44f4-a4ab-85a395ee6530"], "operator": null, "metadata": {"aucs": [0.14854268250275993, 0.1481773394722008, 0.14812514922956999, 0.0007121051632404951, 0.0007078010899143061, 0.0007071828854963158, 0.05727241479986189, 0.05724882925623609, 0.05724544259256781]}}
{"id": "2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd", "fitness": 0.06963300659813962, "name": "AdvancedSpiralOptimization", "description": "An Advanced Spiral Optimization algorithm that incorporates dynamic inertia weight and self-adaptive radius control for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 3, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06963 with standard deviation 0.06189.", "error": "", "parent_ids": ["95b94b0f-4a9b-44f4-a4ab-85a395ee6530"], "operator": null, "metadata": {"aucs": [0.14807755668515776, 0.15549966783984392, 0.14873844497673439, 0.0007066186387237883, 0.0007808642525871656, 0.0007143801842440789, 0.05724235166961589, 0.057652284568542544, 0.057284890567807056]}}
{"id": "b7755086-f0fa-45eb-960d-fa27eab337b6", "fitness": 0.06886708156836004, "name": "RefinedSpiralOptimization", "description": "A Refined Spiral Optimization algorithm with dynamic learning rate adjustment and adaptive perturbation for improved convergence efficiency.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.05  # Initial learning rate\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - 0.05)  # Decrease inertia for exploitation\n                learning_rate = max(0.01, learning_rate * 0.95)  # Lower learning rate for finer adjustments\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + 0.01)  # Increase inertia for exploration\n                learning_rate = min(0.1, learning_rate * 1.05)  # Increase learning rate for broader search\n\n            # Adaptive perturbation\n            perturbation = np.random.normal(0, learning_rate, self.dim)\n            best_position = np.clip(best_position + perturbation, self.lower_bound, self.upper_bound)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 4, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06887 with standard deviation 0.06093.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.149084291868266, 0.1480960492420017, 0.14865535087058213, 0.0007183389625192715, 0.0007068371399818751, 0.0007133645918998566, 0.057306616873559646, 0.05724354883106875, 0.05727933573536115]}}
{"id": "9e43f28f-54cc-46c5-8fc9-78896e7aef01", "fitness": 0.06888949275818651, "name": "AdvancedSpiralOptimization", "description": "Advanced Spiral Optimization with refined adaptive decomposition for improved convergence.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.05  # Slightly less aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 5, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06889 with standard deviation 0.06096.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.14938990218693338, 0.14821867957548884, 0.1484169565629575, 0.0007214356682212486, 0.0007082892691382403, 0.000710628065058283, 0.05732372006225561, 0.05725150405243784, 0.0572643193811877]}}
{"id": "2640ea0f-6620-4f04-899c-2a76199addb6", "fitness": 0.06963300659813962, "name": "AdvancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive dynamic step size and randomness control to improve convergence speed and accuracy.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        dynamic_step_control = 0.5  # Added dynamic step control factor\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - 0.05)  # Decrease inertia for exploitation\n                dynamic_step_control *= 0.9  # Decrease dynamic step for better accuracy\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + 0.01)  # Increase inertia for exploration\n                dynamic_step_control *= 1.1  # Increase dynamic step for broader search\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 6, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06963 with standard deviation 0.06189.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.14807755668515776, 0.15549966783984392, 0.14873844497673439, 0.0007066186387237883, 0.0007808642525871656, 0.0007143801842440789, 0.05724235166961589, 0.057652284568542544, 0.057284890567807056]}}
{"id": "96e99bff-2e34-4452-9205-ecce32c0b961", "fitness": 0.06884810322940299, "name": "AdvancedSpiralOptimization", "description": "An Enhanced Spiral Optimization algorithm integrating adaptive angle control and dynamic radius adjustment for improved convergence efficiency.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, np.pi)  # Reduced angle for controlled exploration\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.7  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - 0.07)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.2  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + 0.02)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 7, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06885 with standard deviation 0.06091.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.1482029432684624, 0.14849219089060994, 0.1489812284290245, 0.0007081045498062988, 0.0007115027062979395, 0.0007171673657946354, 0.057250491625012945, 0.05726911567114301, 0.0573001845584753]}}
{"id": "419237ba-bd8b-4bac-8cd9-b03c5a654b84", "fitness": 0.06862583111427573, "name": "EnhancedAdaptiveSpiralOptimization", "description": "An Enhanced Adaptive Spiral Optimization algorithm that employs dynamic spiral angle modulation and adaptive step-size control to optimize exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n\n        spiral_angle = np.pi / 4  # Initial angle for spiral\n        angle_modulation_rate = 0.1  # Rate for changing the spiral angle\n\n        while evaluations < self.budget:\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            spiral_step = inertia_weight * radius * np.cos(spiral_angle) * direction\n            candidate_position = best_position + spiral_step\n\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.85\n                inertia_weight = max(0.4, inertia_weight - 0.05)\n                spiral_angle -= angle_modulation_rate  # Reduce angle for finer exploitation\n            else:\n                radius *= 1.15\n                inertia_weight = min(0.9, inertia_weight + 0.01)\n                spiral_angle += angle_modulation_rate  # Increase angle for broader exploration\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n            spiral_angle = np.clip(spiral_angle, 0, np.pi / 2)  # Keep angle within sensible limits\n\n        return best_position, best_value", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedAdaptiveSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06863 with standard deviation 0.06065.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.14794546620470816, 0.14793735512024953, 0.14793474023851683, 0.0007050470350956628, 0.0007049502953102582, 0.0007049191029012691, 0.057233744126218844, 0.057233214359661, 0.05723304354582004]}}
{"id": "cb1af4f9-8da0-424b-bc44-9185adaaae56", "fitness": 0.06866510974183498, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization integrating adaptive learning rates and opposition-based learning to improve exploration and convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # Adaptive learning rate\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution using opposition-based learning\n            opposite_position = self.lower_bound + self.upper_bound - best_position\n            candidate_position = best_position + inertia_weight * radius * np.random.normal(0, 1, self.dim)\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            opposite_position = np.clip(opposite_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate both positions\n            candidate_value = func(candidate_position)\n            opposite_value = func(opposite_position)\n            evaluations += 2\n\n            # Select the better candidate\n            if candidate_value < best_value and candidate_value < opposite_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - 0.05)\n                learning_rate = min(0.2, learning_rate + 0.01)\n            elif opposite_value < best_value:\n                best_position = opposite_position\n                best_value = opposite_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - 0.05)\n                learning_rate = min(0.2, learning_rate + 0.01)\n            else:\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + 0.01)\n                learning_rate = max(0.05, learning_rate - 0.005)\n\n            # Ensure radius stays within bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06867 with standard deviation 0.06069.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.1479791767170724, 0.14806729656721918, 0.14809934012155357, 0.0007054486632264156, 0.0007064962410711084, 0.0007068705932975483, 0.05723594364971196, 0.05724168140315955, 0.05724373372020308]}}
{"id": "cf0c688d-788e-46a1-8249-a0af3565b109", "fitness": 0.06906080153057768, "name": "AdvancedSpiralOptimization", "description": "An Advanced Spiral Optimization algorithm with a refined adaptive adjustment strategy for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.78  # More aggressive contraction for better solutions\n                inertia_weight = max(0.5, inertia_weight - 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.15  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 10, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06906 with standard deviation 0.06117.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.1487574614816034, 0.15007059894781904, 0.14863564015485153, 0.000714585930996714, 0.0007285306884259324, 0.0007131909107508383, 0.057286023280274545, 0.05736281514968544, 0.057278367230791716]}}
{"id": "647aae58-b029-47d4-8fa2-72c3f86f655d", "fitness": 0.06876107945487536, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization using adaptive learning rates and levy flight perturbation for improved global search capabilities.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def levy_flight(self, L):\n        u = np.random.normal(0, 1, size=L)\n        v = np.random.normal(0, 1, size=L)\n        step = u / np.abs(v)**(1/3)\n        return step\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.5\n\n        while evaluations < self.budget:\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            if np.random.rand() < 0.3:\n                perturbation = self.levy_flight(self.dim)\n                candidate_position += learning_rate * perturbation\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - 0.05)\n            else:\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + 0.01)\n\n            learning_rate *= 0.99\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06876 with standard deviation 0.06081.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.14848519609207234, 0.14817995755172164, 0.1482830317833046, 0.0007114045695756355, 0.0007078303711403056, 0.0007090500259537835, 0.05726858243722022, 0.0572489901711829, 0.0572556720917069]}}
{"id": "490833a6-4234-460a-9d68-0fe555cdf4ed", "fitness": 0.068857100887961, "name": "EnhancedSpiralOptimization", "description": "An Enhanced Spiral Optimization algorithm with dynamic inertia weight, adaptive radius control, and opposition-based learning for improved convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def opposition_based_learning(self, position):\n        return self.lower_bound + self.upper_bound - position\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Generate opposition-based solution\n            opposite_position = self.opposition_based_learning(candidate_position)\n            opposite_position = np.clip(opposite_position, self.lower_bound, self.upper_bound)\n            opposite_value = func(opposite_position)\n            evaluations += 1\n\n            # Check if the opposite solution is better\n            if opposite_value < candidate_value:\n                candidate_position, candidate_value = opposite_position, opposite_value\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06092.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.14841326997956095, 0.1489703844544975, 0.14836824418044625, 0.0007105614075695321, 0.0007170102488986974, 0.0007100405911807384, 0.05726396089423036, 0.05729933214430882, 0.057261104090956194]}}
{"id": "22ed3448-d12a-4720-a168-4b8fa7936d69", "fitness": 0.06897161395852625, "name": "AdvancedSpiralOptimization", "description": "A Fine-tuned Advanced Spiral Optimization algorithm with improved adaptive radius control for better convergence.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.7  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 13, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06897 with standard deviation 0.06106.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.14844211202345847, 0.14842184774628886, 0.14984845121190582, 0.0007108974087317588, 0.0007106853025918847, 0.000726827470035607, 0.05726580319948149, 0.05726463314523522, 0.057353268119007095]}}
{"id": "5b89482a-25b0-4dd0-9cbf-a475aca04a95", "fitness": 0.06884616320647191, "name": "AdvancedSpiralOptimization", "description": "Enhanced Spiral Optimization with Adaptive Diversity and Dynamic Inertia for improved convergence and solution quality.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        stagnation_counter = 0  # New: Counter for stagnation\n\n        while evaluations < self.budget:\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - 0.05)\n                stagnation_counter = 0  # Reset on improvement\n            else:\n                radius *= 1.05  # Adjusted: Softer expansion\n                inertia_weight = min(0.9, inertia_weight + 0.02)  # Adjusted: Faster increase\n                stagnation_counter += 1\n\n            if stagnation_counter > 10:  # New: Adaptive change after stagnation\n                radius *= 1.2  # New: Increase exploration\n                inertia_weight = 0.9  # New: Reset inertia\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 14, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06885 with standard deviation 0.06091.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.1480773979084341, 0.1491504080550441, 0.14843958971183646, 0.000706616277344807, 0.0007179320971325565, 0.0007108683442103025, 0.057242338875016396, 0.05730467386330462, 0.05726564372592391]}}
{"id": "4b756215-b463-4ef4-bd4c-eb112cdf286b", "fitness": 0.08409384380278352, "name": "AdvancedSpiralOptimization", "description": "A dynamic spiral optimization algorithm enhanced with a learning rate parameter for improved convergence speed and solution quality.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 15, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08409 with standard deviation 0.08710.", "error": "", "parent_ids": ["2a7b10b6-b2c8-4d0e-a2fa-b56e23cde5dd"], "operator": null, "metadata": {"aucs": [0.27323881704901243, 0.14814272074599832, 0.15873374387817163, 0.0010108666792884025, 0.000707392293276321, 0.0008137330250014285, 0.05911708747069555, 0.057246589401568126, 0.05783364368203947]}}
{"id": "c56bc2fb-301d-4967-8cbd-f6433aa094a0", "fitness": 0.0692926792245451, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with Adaptive Momentum for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # Learning rate parameter\n        momentum = 0.9  # Initial momentum\n        momentum_decay = 0.995  # Decay rate for momentum\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            momentum *= momentum_decay\n            candidate_position = best_position + momentum * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                momentum = max(0.4, momentum - learning_rate * 0.05)  # Decrease momentum for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                momentum = min(0.9, momentum + learning_rate * 0.01)  # Increase momentum for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06929 with standard deviation 0.06146.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.14821043541962065, 0.1483724005311483, 0.15283565761161155, 0.0007081938650859154, 0.0007101046072497397, 0.0007582815831304046, 0.05725098074681856, 0.05726145049918041, 0.057526608157060344]}}
{"id": "34d65824-8a7e-4d94-b9e4-879ed757e6b4", "fitness": 0.06957632856372473, "name": "AdvancedSpiralOptimization", "description": "An enhanced spiral optimization incorporating adaptive learning rates and angular momentum to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n\n        # Additional parameters\n        angular_momentum = 0.5  # New angular momentum to influence direction\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi) + angular_momentum  # Adjusted with angular momentum\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * (np.cos(angle) + np.sin(angle)) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n                angular_momentum *= 0.9  # Reduce momentum for convergence\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n                angular_momentum *= 1.1  # Increase momentum for better outward spirals\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 17, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06958 with standard deviation 0.06181.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.14873657518800953, 0.14868387617667966, 0.15438760483182157, 0.0007142532628788834, 0.0007137509303775103, 0.0007736574636452165, 0.05728422431672875, 0.05728143843302358, 0.05761157647035786]}}
{"id": "4c38051b-f3bd-4be8-abd4-9267c6681f06", "fitness": 0.07676394551453135, "name": "AdaptiveSpiralOptimization", "description": "An adaptively compressing spiral optimization algorithm that dynamically adjusts learning rates and inertia weights based on the improvement rate to accelerate convergence and enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1\n\n        # Adaptive parameters\n        improvement_rate = 0.0\n        improvement_threshold = 0.05\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Calculate improvement rate\n            if candidate_value < best_value:\n                improvement_rate = (best_value - candidate_value) / abs(best_value)\n                best_position = candidate_position\n                best_value = candidate_value\n\n            # Check if the candidate is better\n            if improvement_rate > improvement_threshold:\n                # Adaptive adjustments for significant improvement\n                radius *= 0.7\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.1)\n            else:\n                # Expand search for slow improvement\n                radius *= 1.05\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 18, "feedback": "The algorithm AdaptiveSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07676 with standard deviation 0.06679.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.14822983562640313, 0.18727428219215236, 0.1483903563597505, 0.0007084228432383544, 0.004167961858636993, 0.0007103098789260631, 0.05725223538247437, 0.08687952829825307, 0.057262577190947295]}}
{"id": "7856900f-9dbb-4721-a7eb-8a99bb466b5f", "fitness": 0.06912575174510122, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization utilizing adaptive learning rates and dynamic inertia control for improved convergence.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        initial_learning_rate = 0.1\n        learning_rate = initial_learning_rate\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                learning_rate *= 0.95  # Reduce learning rate slightly to focus on exploitation\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                learning_rate = min(initial_learning_rate, learning_rate * 1.05)  # Increase learning rate for exploration\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06913 with standard deviation 0.06125.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.1482728591244541, 0.14817054425932308, 0.15157559397447062, 0.0007089197667011771, 0.0007077207497471205, 0.0007440965026683788, 0.057254961326882015, 0.05724838909016072, 0.05744868091150379]}}
{"id": "886af174-67ed-4a05-a817-17329d68860a", "fitness": 0.06876425451557446, "name": "EnhancedSpiralOptimization", "description": "An improved spiral optimization algorithm that uses dynamic learning rates and adaptive spiral angles for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        initial_learning_rate = 0.1  # Initial learning rate\n        angle_increment = np.pi / 4  # Initial angle increment\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * (np.cos(angle) + np.sin(angle_increment)) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - initial_learning_rate * 0.05)  # Decrease inertia for exploitation\n                angle_increment *= 0.9  # Reduce angle increment for finer exploration\n                \n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + initial_learning_rate * 0.01)  # Increase inertia for exploration\n                angle_increment *= 1.1  # Increase angle increment for broader exploration\n\n            # Update learning rate dynamically based on performance\n            initial_learning_rate = max(0.01, initial_learning_rate * (0.95 if candidate_value < best_value else 1.05))\n\n            # Ensure radius and angle increment remain within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n            angle_increment = min(np.pi, max(angle_increment, np.pi / 8))\n\n        return best_position, best_value", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06876 with standard deviation 0.06081.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.1481687001657227, 0.14839218965505585, 0.1484153908168323, 0.0007076989247675192, 0.0007103350530641706, 0.0007103144849546217, 0.05724826952215578, 0.057262714082708666, 0.05726267793490847]}}
{"id": "9f1d4ac8-f7f3-4a89-9823-d44357208ba0", "fitness": 0.08409384380278352, "name": "RefinedSpiralOptimization", "description": "Adaptive Spiral Optimization with Dynamic Learning Rate and Momentum for Enhanced Exploration and Exploitation.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  \n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1\n        momentum = 0.0\n\n        while evaluations < self.budget:\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction + momentum\n\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n                momentum = 0.9 * momentum + 0.1 * (candidate_position - best_position)\n            else:\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n                momentum = 0.5 * momentum\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 21, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08409 with standard deviation 0.08710.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.27323881704901243, 0.14814272074599832, 0.15873374387817163, 0.0010108666792884025, 0.000707392293276321, 0.0008137330250014285, 0.05911708747069555, 0.057246589401568126, 0.05783364368203947]}}
{"id": "c349b9ca-c113-40f4-bd0a-d4c4128a5f67", "fitness": 0.08409384380278352, "name": "EnhancedSpiralOptimization", "description": "A multi-phase spiral optimization algorithm with dynamic inertia and adaptive radius adjustment for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # Learning rate parameter\n        phase_change_threshold = 0.5 * self.budget  # Change phase after half evaluations\n\n        while evaluations < self.budget:\n            # Check phase\n            if evaluations > phase_change_threshold:\n                learning_rate = 0.05  # Reduced learning rate in exploitation phase\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08409 with standard deviation 0.08710.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.27323881704901243, 0.14814272074599832, 0.15873374387817163, 0.0010108666792884025, 0.000707392293276321, 0.0008137330250014285, 0.05911708747069555, 0.057246589401568126, 0.05783364368203947]}}
{"id": "730ea50c-3d35-4cb5-ae05-afe98556ba37", "fitness": 0.0687643666346524, "name": "AdvancedSpiralOptimization", "description": "Enhanced spiral optimization with adaptive learning rate and dynamic radius adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1\n\n        while evaluations < self.budget:\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.9  # Slightly less aggressive contraction\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.03)  # More gradual decrease\n            else:\n                radius *= 1.05  # Slightly less aggressive expansion\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)  # More gradual increase\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 23, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06876 with standard deviation 0.06081.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.14803150770449658, 0.14817125890915572, 0.1487730188293095, 0.0007060717183919873, 0.0007077283150006553, 0.0007147903118639443, 0.05723935594644214, 0.05724843079955766, 0.057287137177653324]}}
{"id": "c54b69ac-c155-4ab1-9bea-ce9a5fba790e", "fitness": 0.0688118318953514, "name": "EnhancedSpiralOptimization", "description": "An enhanced spiral optimization algorithm incorporating adaptive learning and directional boosts for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n        boost_factor = 1.2  # Boost factor for exploration\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= boost_factor  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Adaptive learning rate adjustment\n            if evaluations % 10 == 0:  # Adjust learning rate every 10 evaluations\n                learning_rate = 0.05 + 0.05 * np.random.rand()\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06881 with standard deviation 0.06087.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.14889311032143282, 0.14839513920397418, 0.1480849863356617, 0.0007161502721224622, 0.0007103182263472618, 0.000706706711960825, 0.05729460502822947, 0.05726263682360799, 0.05724283413482589]}}
{"id": "faaa0c62-ecab-4752-8acc-4cbd7ea253af", "fitness": 0.06947915459359849, "name": "AdvancedSpiralOptimization", "description": "Introduced dynamic learning rate adjustment based on solution improvement to refine convergence speed and accuracy.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n                learning_rate = max(0.05, learning_rate * 0.95)  # Decrease learning rate for better solutions\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 25, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06948 with standard deviation 0.06170.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.15470182000596333, 0.14810342470525317, 0.148188806348016, 0.0007774625270109414, 0.0007069254491416377, 0.0007079364428896895, 0.05763241264568164, 0.057244032329073935, 0.057249570889356005]}}
{"id": "41e3a07c-41f0-43c4-b718-af3fc253afb4", "fitness": 0.06867901695828672, "name": "HybridSpiralParticleSwarm", "description": "A hybrid spiral and particle swarm optimization algorithm combining spiral dynamics with a swarm-based social learning strategy for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridSpiralParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        n_particles = 10\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (n_particles, self.dim))\n        velocities = np.zeros((n_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_values = np.array([func(p) for p in personal_best_positions])\n        global_best_idx = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_idx]\n        global_best_value = personal_best_values[global_best_idx]\n        evaluations += n_particles\n\n        # Spiral and PSO parameters\n        inertia_weight = 0.9\n        learning_rate = 0.1\n        cognitive_coeff = 2.0\n        social_coeff = 2.0\n\n        while evaluations < self.budget:\n            for i in range(n_particles):\n                # Spiral dynamic adjustment\n                angle = np.random.uniform(0, 2 * np.pi)\n                direction = np.random.normal(0, 1, self.dim)\n                direction /= np.linalg.norm(direction)\n                spiral_adjustment = inertia_weight * np.cos(angle) * direction\n\n                # Particle Swarm Optimization velocity update\n                r1, r2 = np.random.rand(2)\n                cognitive_component = cognitive_coeff * r1 * (personal_best_positions[i] - positions[i])\n                social_component = social_coeff * r2 * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n\n                # Update position\n                candidate_position = positions[i] + velocities[i] + spiral_adjustment\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n                # Evaluate the candidate solution\n                candidate_value = func(candidate_position)\n                evaluations += 1\n\n                # Update personal and global bests\n                if candidate_value < personal_best_values[i]:\n                    personal_best_positions[i] = candidate_position\n                    personal_best_values[i] = candidate_value\n\n                    if candidate_value < global_best_value:\n                        global_best_position = candidate_position\n                        global_best_value = candidate_value\n\n            # Adaptive inertia weight adjustment\n            inertia_weight = max(0.4, inertia_weight - learning_rate * 0.01)\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 26, "feedback": "The algorithm HybridSpiralParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06868 with standard deviation 0.06071.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.1482762584188052, 0.14795128076023767, 0.1480349515074587, 0.0007088932369165857, 0.0007051163695929175, 0.0007061127513829923, 0.05725483509564444, 0.057234123820367855, 0.05723958066417412]}}
{"id": "2a4dd7e2-e0f8-4301-a015-8f807aebeea5", "fitness": 0.06878325269051686, "name": "AdvancedSpiralOptimization", "description": "An enhanced dynamic spiral optimization algorithm with updated inertia weight decay for improved convergence.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.1)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 27, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06878 with standard deviation 0.06083.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.14876117180161152, 0.14808557355401797, 0.1482872500802892, 0.000714591277116261, 0.0007067129513270709, 0.0007090994491467661, 0.057286063574846446, 0.05724286852323446, 0.057255943003062026]}}
{"id": "5cf264cd-bfba-4bf4-9a84-56c15d6335e8", "fitness": 0.06969968962858934, "name": "EnhancedSpiralOptimization", "description": "A spiral optimization algorithm enhanced with adaptive learning and dynamic boundary adjustments for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n        \n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n\n        def dynamic_bound_adjustment(position):\n            # Dynamically adjust boundaries based on current best position\n            diff = (self.upper_bound - self.lower_bound) * 0.1\n            lower_dynamic = np.maximum(self.lower_bound, position - diff)\n            upper_dynamic = np.minimum(self.upper_bound, position + diff)\n            return lower_dynamic, upper_dynamic\n\n        while evaluations < self.budget:\n            # Adjust bounds dynamically\n            lower_dynamic, upper_dynamic = dynamic_bound_adjustment(best_position)\n            \n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within dynamically adjusted bounds\n            candidate_position = np.clip(candidate_position, lower_dynamic, upper_dynamic)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.75  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.2  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06970 with standard deviation 0.06197.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.1480785604128646, 0.14954906956638858, 0.15523798865913097, 0.0007066308469586557, 0.0007235601904814759, 0.0007794488011491074, 0.05724241845464062, 0.057335299578951116, 0.05764423014673892]}}
{"id": "ca6f28f8-6ff2-43fe-9517-79f192036838", "fitness": 0.07011043936914264, "name": "AdvancedSpiralOptimization", "description": "Enhanced dynamic spiral optimization incorporating adaptive learning rate and dynamic boundary adjustments for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n        adapt_rate = 0.05  # Adaptive learning rate adjustment\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n                learning_rate *= (1 - adapt_rate)  # Decrease learning rate adaptively\n            else:\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n                learning_rate *= (1 + adapt_rate)  # Increase learning rate adaptively\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 29, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07011 with standard deviation 0.06245.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.15304669327543285, 0.1483650319455151, 0.15489291360511392, 0.000761128435466385, 0.0007097986493619368, 0.0007784299084939716, 0.057542124321243615, 0.05725983250617539, 0.05763800167548061]}}
{"id": "f4000159-90fc-4e5b-bfe8-6f94c2148eac", "fitness": 0.06875470462593254, "name": "EnhancedSpiralOptimization", "description": "An enhanced spiral optimization algorithm with adaptive inertia weight adjustment and radius control for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.05  # Adjusted learning rate parameter\n\n        # Additional adaptive parameters\n        inertia_decay = 0.99  # Decay factor for inertia weight\n        radius_growth = 1.05  # Growth factor for radius\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight *= inertia_decay  # Adaptive decay for exploitation\n            else:\n                # Increase exploration\n                radius *= radius_growth  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06875 with standard deviation 0.06080.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.14840628844452086, 0.14804826927207648, 0.14844034282467522, 0.0007104834748568045, 0.0007062710505514325, 0.0007108993102588057, 0.05726353255955674, 0.05724044770037107, 0.0572658069965255]}}
{"id": "7fe7865e-6d47-4038-bb5e-138a1e5af915", "fitness": 0.069152539295545, "name": "AdvancedSpiralOptimization", "description": "An enhanced spiral optimization algorithm utilizing adaptive learning rates and dynamic parameter adjustment for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n\n        adaptive_lr = lambda evals: 0.1 + 0.05 * (1 - evals / self.budget)  # Adaptive learning rate\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - adaptive_lr(evaluations) * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + adaptive_lr(evaluations) * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 31, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06915 with standard deviation 0.06127.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.14910344969958278, 0.1492796595079675, 0.14984295551918947, 0.0007186078011361952, 0.000720624258347069, 0.0007268676638741978, 0.057308077981565786, 0.057319144740867634, 0.05735346648737438]}}
{"id": "82900fe3-800f-4cd0-96f7-38c0af4bca9c", "fitness": 0.08409384380278352, "name": "EnhancedSpiralOptimization", "description": "A multi-phase spiral optimization algorithm incorporating adaptive learning rates and dynamic exploration-exploitation balance for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # New learning rate parameter\n\n        # Dynamic factors\n        phase_switch_threshold = self.budget // 3  # Switch phases after one-third of evaluations\n        contraction_factor = 0.8\n        expansion_factor = 1.1\n\n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= contraction_factor  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= expansion_factor  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n            # Adaptive phase switching\n            if evaluations % phase_switch_threshold == 0:\n                # Switch contraction and expansion factors for a refined search\n                contraction_factor *= 0.95  # Slow down contraction to refine search\n                expansion_factor *= 1.05  # Slow down expansion for controlled exploration\n\n        return best_position, best_value", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08409 with standard deviation 0.08710.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.27323881704901243, 0.14814272074599832, 0.15873374387817163, 0.0010108666792884025, 0.000707392293276321, 0.0008137330250014285, 0.05911708747069555, 0.057246589401568126, 0.05783364368203947]}}
{"id": "8e4cdf25-2faf-4314-acfe-6268e98686f1", "fitness": 0.06868657484388481, "name": "EnhancedSpiralOptimization", "description": "A modified spiral optimization algorithm incorporating adaptive multi-scale perturbations and dynamic inertia adjustment to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate = 0.1  # Learning rate parameter\n        scale_factor = 0.2  # Scale factor for multi-scale perturbations\n\n        def adaptive_perturbation(position, scale):\n            perturbation = np.random.normal(0, scale, self.dim)\n            return np.clip(position + perturbation, self.lower_bound, self.upper_bound)\n        \n        while evaluations < self.budget:\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Apply multi-scale perturbations\n            candidate_position = adaptive_perturbation(candidate_position, scale_factor * radius)\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06869 with standard deviation 0.06072.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.1480207487931109, 0.14829773912137678, 0.14800674207632536, 0.0007059433726988029, 0.0007092206357600661, 0.0007057769819467374, 0.05723865310755116, 0.05725660778415198, 0.057237741722041546]}}
{"id": "1b6aad2c-fe8e-42c6-a39a-813023b4ce9e", "fitness": 0.10495914812120434, "name": "EnhancedSpiralOptimization", "description": "An adaptive spiral optimization with variable learning rates and dynamic exploration-exploitation balance to enhance global search capabilities and convergence precision.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10496 with standard deviation 0.13930.", "error": "", "parent_ids": ["4b756215-b463-4ef4-bd4c-eb112cdf286b"], "operator": null, "metadata": {"aucs": [0.1510751321909376, 0.14817136917047646, 0.4677518952304456, 0.0007405739333903316, 0.0007077317968325891, 0.0012176901722208422, 0.05742879694940772, 0.057248449232723986, 0.060290694414403934]}}
{"id": "426f19eb-8ef0-4ef4-9ad6-953a0f26d40e", "fitness": 0.06904772266377245, "name": "HybridSpiralOptimization", "description": "Hybrid Adaptive Spiral Optimization integrating random perturbation and adaptive learning rate modulation to dynamically balance exploration and exploitation, enhancing global convergence.", "code": "import numpy as np\n\nclass HybridSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.15  # Adjusted base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.sin(angle) * direction\n\n            # Introduce random perturbations\n            perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n            candidate_position += perturbation\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.75  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.07)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.15  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.015)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 35, "feedback": "The algorithm HybridSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06905 with standard deviation 0.06115.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.15050982316760475, 0.1483736850772599, 0.1484663666873841, 0.0007344534118761681, 0.0007101110170767422, 0.0007111691325254466, 0.05739511112572093, 0.05726148816168908, 0.0572672961928149]}}
{"id": "d21e0bab-c7f4-4dc5-b2b4-901c8ecfc5a9", "fitness": 0.07006042705699325, "name": "EnhancedSpiralOptimization", "description": "Refined spiral optimization with enhanced inertia weight and radius adjustments for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.75  # More aggressive contraction for better solutions\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.15  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07006 with standard deviation 0.06246.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14829734687347973, 0.15945447727980044, 0.14823645018601006, 0.0007092119753187021, 0.0008105324714253737, 0.0007084973580200327, 0.05725656151532088, 0.057818121136561484, 0.05725264471700253]}}
{"id": "a8e1c9ac-95ee-4c9c-b89e-5e1cfc539160", "fitness": 0.07253610968740848, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with stochastic perturbations and adaptive radius scaling to improve exploration-exploitation balance and convergence.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral with stochastic perturbation\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Added stochastic perturbation\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction + perturbation\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # Slightly less aggressive contraction\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                # Increase exploration\n                radius *= 1.15  # Slightly more aggressive expansion\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07254 with standard deviation 0.06620.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14847038418895264, 0.14822537565781935, 0.18122207571795013, 0.0007112175673193999, 0.0007083700446109953, 0.0008609537219615992, 0.057267561346128426, 0.057251946130730924, 0.058107102811202904]}}
{"id": "cf77856a-ad13-44a9-9291-c72ecf89e24c", "fitness": 0.06902773915456092, "name": "EnhancedSpiralOptimization", "description": "A refined spiral optimization algorithm employing dynamic learning rate adjustments and adaptive spiral contraction for enhanced convergence speed.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (2 * evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.7  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06903 with standard deviation 0.06113.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1481772240925141, 0.14891662711823228, 0.15008878585887786, 0.0007077788895237802, 0.0007163596907531211, 0.000729649413657607, 0.057248713540742346, 0.05729577135865982, 0.05736874242808743]}}
{"id": "7a5592e2-3eb7-47de-a181-36cc5d737d49", "fitness": 0.06944367018647692, "name": "EnhancedSpiralOptimization", "description": "Refined Spiral Optimization with strategic perturbation and dynamic neighborhood radius for enhanced convergence and search exploration.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        perturbation_factor = 0.1  # Additional perturbation factor\n        dynamic_radius_factor = 1.2  # Dynamic adjustment factor for radius\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Perturbation to enhance exploration\n            perturbation = np.random.normal(0, perturbation_factor, self.dim)\n            candidate_position += perturbation\n\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= dynamic_radius_factor  # Use dynamic adjustment\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06944 with standard deviation 0.06165.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1481512575367544, 0.15452249819016328, 0.1480224764721294, 0.0007074932250884514, 0.0007755500601274168, 0.0007059637686215314, 0.05724714238387907, 0.057621885181507904, 0.057238764860020774]}}
{"id": "1a1693b2-e1df-4845-b34b-293232b63b49", "fitness": 0.0688988347593848, "name": "RefinedSpiralOptimization", "description": "Introducing spiral variance adaptation and directional diversity to enhance the adaptability and convergence speed of Enhanced Spiral Optimization.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate and inertia dynamically\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            inertia_weight = 0.9 - 0.5 * (evaluations / self.budget)\n\n            # Introduce spiral variance by generating multiple candidates\n            num_candidates = 3\n            candidate_positions = []\n            candidate_values = []\n\n            for _ in range(num_candidates):\n                angle = np.random.uniform(0, 2 * np.pi)\n                direction = np.random.normal(0, 1, self.dim)\n                direction /= np.linalg.norm(direction)\n                candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_value = func(candidate_position)\n                candidate_positions.append(candidate_position)\n                candidate_values.append(candidate_value)\n                evaluations += 1\n            \n            # Select the best candidate\n            best_candidate_idx = np.argmin(candidate_values)\n            candidate_position = candidate_positions[best_candidate_idx]\n            candidate_value = candidate_values[best_candidate_idx]\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 40, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06890 with standard deviation 0.06097.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14845152965498432, 0.1483481240035357, 0.14930215534690172, 0.0007110244766653784, 0.0007098156816897072, 0.0007207303329750392, 0.05726649479750834, 0.057259868099650446, 0.057319770440552587]}}
{"id": "68356817-986f-46c4-8e9d-3288d84a7160", "fitness": 0.08411318866884711, "name": "RefinedSpiralOptimization", "description": "Refinement of EnhancedSpiralOptimization with multi-directional exploration and adaptive learning rates for enhanced convergence and solution precision.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically for exploration-exploitation balance\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget)**2)\n\n            # Multi-directional exploration\n            num_directions = 3\n            for _ in range(num_directions):\n                # Generate a new candidate solution on the spiral\n                angle = np.random.uniform(0, 2 * np.pi)\n                direction = np.random.normal(0, 1, self.dim)\n                direction /= np.linalg.norm(direction)\n                candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n                # Ensure candidate is within bounds\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n                # Evaluate the candidate solution\n                candidate_value = func(candidate_position)\n                evaluations += 1\n\n                # Check if the candidate is better\n                if candidate_value < best_value:\n                    best_position = candidate_position\n                    best_value = candidate_value\n                    # Adaptive adjustments\n                    radius *= 0.8  # More aggressive contraction for better solutions\n                    inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n                else:\n                    # Increase exploration\n                    radius *= 1.1  # More aggressive expansion for worse solutions\n                    inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n                # Ensure radius remains within sensible bounds\n                radius = max(radius, min_radius)\n                radius = min(radius, max_radius)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, best_value", "configspace": "", "generation": 41, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08411 with standard deviation 0.08711.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.2732393432428367, 0.14814272692492814, 0.15887331203834687, 0.0010140892283313496, 0.000707392366562809, 0.0008148332775786971, 0.05914062997281466, 0.057246589802836145, 0.05783978116538857]}}
{"id": "164c0294-3e6c-407d-a447-d3fde4f83560", "fitness": 0.06882552484659603, "name": "EnhancedSpiralOptimizationV2", "description": "A refined spiral optimization algorithm incorporating chaotic maps for enhanced exploration and adaptive inertia weight adjustments based on the search progress for improved convergence and precision.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.05  # Reduced base learning rate for finer adjustments\n\n        # Chaotic map initialization (Logistic map)\n        logistic_map = np.random.uniform()\n        chaos_factor = 3.9  # Chaotic parameter for logistic map\n\n        while evaluations < self.budget:\n            # Chaotic map update\n            logistic_map = chaos_factor * logistic_map * (1 - logistic_map)\n\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Update inertia weight dynamically\n            inertia_weight = 0.9 - (0.5 * (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Influence of chaotic map\n            candidate_position += chaos_factor * (logistic_map - 0.5) * (candidate_position - best_position)\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # Aggressive contraction for better solutions\n            else:\n                # Increase exploration\n                radius *= 1.05  # Gentle expansion for worse solutions\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06883 with standard deviation 0.06088.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14859396980453687, 0.14857687825199928, 0.14831667014557726, 0.0007126969170395681, 0.0007124176902444379, 0.0007094441489502445, 0.05727566113434779, 0.05727415307419281, 0.057257832452475954]}}
{"id": "302a7164-2518-4cb0-9549-11393db1fd44", "fitness": 0.06879108477894175, "name": "EnhancedSpiralOptimization", "description": "A refined spiral optimization with adaptive radius scaling and inertia to enhance solution precision.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.2  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06879 with standard deviation 0.06084.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14845736085329841, 0.1482100181548347, 0.14853173614367887, 0.0007111023663292082, 0.000708186119226295, 0.0007119466426286358, 0.05726691896387337, 0.05725093913820822, 0.05727155462839806]}}
{"id": "72dc120c-1108-4797-9b14-9f516048eb60", "fitness": 0.0690880876577446, "name": "HybridSpiralDifferentialEvolution", "description": "A hybrid spiral and differential evolution algorithm with adaptive component weighting and dynamic population diversity management to enhance solution quality and convergence speed.", "code": "import numpy as np\n\nclass HybridSpiralDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.cr = 0.9  # Crossover rate for differential evolution\n        self.f = 0.8   # Differential weight\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        evaluations = self.population_size\n        best_index = np.argmin(fitness)\n        best_position = population[best_index]\n        best_value = fitness[best_index]\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        inertia_weight = 0.9\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = population[indices]\n                mutant = x1 + self.f * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                trial = np.where(np.random.rand(self.dim) < self.cr, mutant, population[i])\n                \n                # Spiral exploration\n                angle = np.random.uniform(0, 2 * np.pi)\n                direction = np.random.normal(0, 1, self.dim)\n                direction /= np.linalg.norm(direction)\n                spiral_candidate = population[i] + inertia_weight * radius * np.cos(angle) * direction\n                spiral_candidate = np.clip(spiral_candidate, self.lower_bound, self.upper_bound)\n                \n                # Evaluate both candidates\n                trial_value = func(trial)\n                spiral_value = func(spiral_candidate)\n                evaluations += 2\n\n                # Choose the best among current, trial, and spiral\n                if trial_value < fitness[i] and trial_value < spiral_value:\n                    population[i] = trial\n                    fitness[i] = trial_value\n                elif spiral_value < fitness[i]:\n                    population[i] = spiral_candidate\n                    fitness[i] = spiral_value\n\n                # Update global best\n                if fitness[i] < best_value:\n                    best_position = population[i]\n                    best_value = fitness[i]\n                    radius *= 0.8  # Contract radius on improvement\n                    inertia_weight = max(0.4, inertia_weight - 0.01)\n                else:\n                    radius *= 1.1  # Expand radius for exploration\n                    inertia_weight = min(0.9, inertia_weight + 0.01)\n\n                # Ensure radius remains within sensible bounds\n                radius = max(radius, min_radius)\n                radius = min(radius, max_radius)\n\n                if evaluations >= self.budget:\n                    break\n\n        return best_position, best_value", "configspace": "", "generation": 44, "feedback": "The algorithm HybridSpiralDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06909 with standard deviation 0.06121.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14816396620162742, 0.14810906950971703, 0.15143099926771175, 0.0007076425809352527, 0.0007069857221615461, 0.00074241216473514, 0.05724796093709972, 0.05724436444709868, 0.05743938808861482]}}
{"id": "f7ec11ee-763f-4866-a544-302d3eaafc6f", "fitness": 0.06958956096541428, "name": "EnhancedSpiralOptimizationV2", "description": "An adaptive spiral optimization with dynamic inertia and learning rate adjustments targeting improved convergence speed and precision through strategic spiral path curvatures.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate and inertia dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05) if evaluations < self.budget / 2 else min(0.9, inertia_weight + learning_rate * 0.01)\n\n            # Generate a new candidate solution on the spiral path with exponential decay\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * (radius * np.cos(angle) * np.exp(-0.5 * evaluations / self.budget)) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n                radius *= 0.8  # More aggressive contraction for better solutions\n            else:\n                # Increase exploration\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06959 with standard deviation 0.06180.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14890918036401113, 0.15191758634033203, 0.15107502184683375, 0.0007162536995799496, 0.0007487997443810235, 0.0007406272824274085, 0.05729519609752165, 0.05747430846482626, 0.05742907484881532]}}
{"id": "22fb7140-5f42-4ded-ba71-0dc278d9e14c", "fitness": 0.06934354702391182, "name": "RefinedSpiralOptimization", "description": "A multi-phase spiral optimization strategy incorporating mutation-based diversification for early exploration and intensified convergence using dynamic contraction in later stages.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Dynamic adjustment for multi-phase strategy\n            phase_ratio = evaluations / self.budget\n            if phase_ratio < 0.5:\n                # Early phase: focus on exploration with mutation\n                mutation_factor = np.random.uniform(0.9, 1.1)\n                learning_rate = base_learning_rate * mutation_factor\n            else:\n                # Later phase: focus on exploitation\n                learning_rate = base_learning_rate * (1 - phase_ratio)\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Apply mutation for further diversification in early exploration\n            if phase_ratio < 0.5:\n                candidate_position += np.random.normal(0, 0.1, self.dim)\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 46, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06934 with standard deviation 0.06152.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14929492693280866, 0.1482069191775094, 0.1523488751492309, 0.0007201643048877493, 0.0007081496559215861, 0.0007521694483672015, 0.05731679419910607, 0.057250739308077114, 0.05749318503929779]}}
{"id": "07163c46-bcea-42a7-88b6-97fd276f25ea", "fitness": 0.06942709853536724, "name": "EnhancedSpiralOptimization", "description": "A refined spiral optimization incorporating adaptive radius decay and scaled inertia adjustments for enhanced convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # Slightly less aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.04)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.05  # Reduced expansion rate for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06943 with standard deviation 0.06162.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.15000486320450934, 0.15247055514301733, 0.14810525925499451, 0.000728181666279637, 0.0007485902231137986, 0.0007069461323444548, 0.057360822479168294, 0.057474522769914604, 0.05724414594496319]}}
{"id": "c8880d01-34b6-43ef-93b7-fb58baaabc5b", "fitness": 0.0688413496589316, "name": "EnhancedSpiralOptimizationV2", "description": "An enhanced spiral optimization with stochastic perturbations and learning rate adaptation to further improve exploration-exploitation balance and convergence accuracy.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral with stochastic perturbation\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            perturbation = np.random.uniform(-0.1, 0.1, self.dim) * learning_rate  # Stochastic perturbation\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction + perturbation\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06884 with standard deviation 0.06090.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14937382953063405, 0.14807191609196724, 0.14817749104693412, 0.0007212151036624093, 0.000706551540209488, 0.0007078023483191309, 0.057322520788053444, 0.05724198417268278, 0.05724883630792177]}}
{"id": "33f556c5-1e9c-4727-9bf3-85049d90f5d8", "fitness": 0.06925239986210602, "name": "EnhancedSpiralOptimizationV2", "description": "Adaptive Spiral Optimization with Dynamic Constriction Factor for Enhanced Exploitation and Exploration Balance", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better and adapt the spiral parameters\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= np.exp(-learning_rate)  # Exponential decay for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                radius *= np.exp(learning_rate)  # Exponential growth for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06925 with standard deviation 0.06140.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1494725262179062, 0.15099794641109754, 0.14860584775441044, 0.0007226441905907599, 0.0007379922264604266, 0.0007128429311172857, 0.057330283411755834, 0.05741505612205566, 0.05727645949355997]}}
{"id": "4dec7a60-a66e-449b-86a3-c89244db0f48", "fitness": 0.06905468388830761, "name": "DynamicSpiralOptimization", "description": "A dynamic spiral optimization with adaptive neighborhood search and convergence acceleration using adaptive inertia and learning rates for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass DynamicSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n\n                radius *= 0.7  # More aggressive contraction\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.1)  # Decrease inertia faster\n            else:\n                radius *= 1.2  # More aggressive expansion\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)  # Increase inertia more gently\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 50, "feedback": "The algorithm DynamicSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06905 with standard deviation 0.06116.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1503780045493981, 0.1488886534890126, 0.14814749691723994, 0.0007318721960160035, 0.0007161238432797923, 0.0007074462981090379, 0.05738121871362256, 0.05729445298722102, 0.05724688600086947]}}
{"id": "2441c369-4820-4dcc-8efd-9af993807669", "fitness": 0.06914093214494321, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with Adaptive Curvature Control to dynamically adjust spiral parameters for improved convergence and optimization performance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Adaptive curvature control: adjust angle range based on evaluation progress\n            max_angle = np.pi * (1 - (evaluations / self.budget))\n            min_angle = max_angle * 0.5\n            angle = np.random.uniform(min_angle, max_angle)\n\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06914 with standard deviation 0.06126.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1503875430384113, 0.14822600126980812, 0.1495179224441685, 0.0007329371973988641, 0.000708376071912431, 0.0007232456365753315, 0.05738682247267268, 0.057251979556730004, 0.05733356161681169]}}
{"id": "f7454eb4-c151-475c-af81-6ab87d3c512d", "fitness": 0.06967938478155326, "name": "EnhancedSpiralOptimizationV2", "description": "A multi-phase spiral optimization that dynamically adapts exploration and exploitation phases based on stagnation detection and includes a diversity boost mechanism for escaping local optima.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        stagnation_counter = 0\n        stagnation_threshold = 10\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n                stagnation_counter = 0\n            else:\n                stagnation_counter += 1\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            if stagnation_counter >= stagnation_threshold:\n                radius = (self.upper_bound - self.lower_bound) / 2\n                best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                best_value = func(best_position)\n                evaluations += 1\n                stagnation_counter = 0\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06968 with standard deviation 0.06193.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14806195334915928, 0.14983108690862712, 0.1547756627710548, 0.0007064332951893793, 0.0007268293198877673, 0.0007787184242511458, 0.05724133646915708, 0.05735322925693964, 0.057639213239713105]}}
{"id": "a3c26561-cea9-436e-9b2f-4e502418abc4", "fitness": 0.0690243314827385, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive step size and dynamic inertia adjustment to boost convergence.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)  # Increase inertia for exploration\n                radius += np.random.uniform(0, 0.1)  # Randomize step size for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06902 with standard deviation 0.06113.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.15073637520011673, 0.14827930355986885, 0.14814142348615134, 0.0007365938078949252, 0.0007090046613953405, 0.0007073767374800033, 0.05740697772450831, 0.05725542392845617, 0.057246504238774754]}}
{"id": "9206ba92-c633-40f0-97d2-71f219c1ba97", "fitness": 0.06902808487681632, "name": "EnhancedSpiralOptimizationV2", "description": "An adaptive spiral optimization with enhanced stochastic selection and dynamic parameter tuning to improve convergence precision and robustness across diverse optimization landscapes.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate multiple candidate solutions for better exploration\n            num_candidates = 5\n            candidates = []\n            candidate_values = []\n\n            for _ in range(num_candidates):\n                angle = np.random.uniform(0, 2 * np.pi)\n                direction = np.random.normal(0, 1, self.dim)\n                direction /= np.linalg.norm(direction)\n                candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n                # Ensure candidate is within bounds\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_value = func(candidate_position)\n                evaluations += 1\n\n                candidates.append(candidate_position)\n                candidate_values.append(candidate_value)\n\n                # Stop if budget exceeded\n                if evaluations >= self.budget:\n                    break\n\n            # Select the best candidate from the generated ones\n            min_value_index = np.argmin(candidate_values)\n            best_candidate_position = candidates[min_value_index]\n            best_candidate_value = candidate_values[min_value_index]\n\n            # Check if the best candidate is an improvement\n            if best_candidate_value < best_value:\n                best_position = best_candidate_position\n                best_value = best_candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06903 with standard deviation 0.06113.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1484788937158953, 0.14873368261573228, 0.14997086607096655, 0.000711347583617683, 0.0007143362109044427, 0.0007284755847991597, 0.057268265179705846, 0.057284646090600466, 0.05736225083912516]}}
{"id": "197dc236-fd7e-4ec1-907a-70f40c9ab152", "fitness": 0.06851008555243933, "name": "MultiStartSpiralOptimization", "description": "Introducing a multi-start adaptive spiral optimization with stochastic restart to enhance global search diversity and local convergence speed.", "code": "import numpy as np\n\nclass MultiStartSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        global_best_position = None\n        global_best_value = float('inf')\n\n        # Parameters\n        num_starts = 5  # Number of multi-start attempts\n        radius_decay = 0.9\n        inertia_weight_decay = 0.95\n        base_learning_rate = 0.1\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        \n        for _ in range(num_starts):\n            # Initialize variables for each start\n            best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            best_value = func(best_position)\n            evaluations += 1\n            radius = max_radius\n            inertia_weight = 0.9\n            \n            # Optimization loop\n            while evaluations < self.budget / num_starts:\n                learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n                angle = np.random.uniform(0, 2 * np.pi)\n                direction = np.random.normal(0, 1, self.dim)\n                direction /= np.linalg.norm(direction)\n                candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_value = func(candidate_position)\n                evaluations += 1\n\n                if candidate_value < best_value:\n                    best_position = candidate_position\n                    best_value = candidate_value\n                    radius *= radius_decay\n                    inertia_weight *= inertia_weight_decay\n                else:\n                    radius /= radius_decay\n                    inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n                radius = max(radius, min_radius)\n                radius = min(radius, max_radius)\n\n            if best_value < global_best_value:\n                global_best_position = best_position\n                global_best_value = best_value\n\n        return global_best_position, global_best_value", "configspace": "", "generation": 55, "feedback": "The algorithm MultiStartSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06851 with standard deviation 0.06077.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14782247365033618, 0.14787447480826232, 0.1483153577087184, 0.00048372309542721315, 0.0004843414365366394, 0.0004895437030492111, 0.05702852569780947, 0.05703191240896377, 0.05706041746285073]}}
{"id": "023ff050-bee7-4845-80db-4bd76f573aba", "fitness": 0.06878879957931786, "name": "EnhancedSpiralOptimizationV2", "description": "A dynamic spiral optimization algorithm with adaptive inertia and stochastic perturbation for enhanced exploration-exploitation balance and improved convergence precision.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral with stochastic perturbation\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            perturbation = np.random.normal(0, 0.1, self.dim)  # Add stochastic perturbation\n            candidate_position = (best_position + \n                                  inertia_weight * radius * np.cos(angle) * direction +\n                                  perturbation)\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06879 with standard deviation 0.06084.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14829587293879665, 0.14866359430566445, 0.14822064847212824, 0.0007092012214883203, 0.0007134822594533352, 0.000708308908311639, 0.0572565006397282, 0.05727997474892721, 0.05725161271936263]}}
{"id": "239497d6-85a6-4752-a755-bf40ab0e2008", "fitness": 0.06874022809927027, "name": "EnhancedSpiralOptimization", "description": "An adaptive spiral optimization with slightly reduced inertia weight to enhance convergence precision.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.85  # Initial inertia weight (reduced from 0.9)\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06874 with standard deviation 0.06078.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14806514551084005, 0.14850416384492282, 0.1482045251861922, 0.0007064713725317695, 0.0007116357471664836, 0.0007081235521986251, 0.05724154498702305, 0.057269847045806954, 0.0572505956467505]}}
{"id": "04100de4-6b2d-4708-848f-a430e5f72e52", "fitness": 0.06907301699513041, "name": "EnhancedSpiralOptimization", "description": "An enhanced spiral optimization with adaptive dynamic parameters for improved convergence and search efficiency.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.03)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.05  # Less aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06907 with standard deviation 0.06118.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.15059044039905212, 0.14886022157578305, 0.14811824001389517, 0.0007341546784254138, 0.0007157580810441821, 0.0007071004184928675, 0.05739378932767414, 0.05729245745782663, 0.05724499100398017]}}
{"id": "bab7a825-170d-4b15-b942-a3a45ed5554f", "fitness": 0.0687899399336299, "name": "EnhancedSpiralOptimization", "description": "A spiral optimization algorithm incorporating adaptive momentum and multi-scale search for improved convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n        momentum = np.zeros(self.dim)  # Momentum term for adaptive direction\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            momentum = 0.9 * momentum + direction  # Update momentum\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * momentum\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Multi-scale search adaptation\n            if evaluations % 50 == 0 and evaluations < self.budget * 0.9:\n                radius = np.random.uniform(min_radius, max_radius)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06879 with standard deviation 0.06084.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14884651442893027, 0.1481287231151558, 0.14821489910366714, 0.0007155602847156439, 0.0007072244352368529, 0.0007082413405395949, 0.057291383840424204, 0.05724567044201789, 0.05725124241198176]}}
{"id": "aeab1698-06d5-49b8-92ce-2b5fb675b54b", "fitness": 0.0687915694068196, "name": "EnhancedSpiralOptimization", "description": "Introduce adaptive angle perturbation for improved exploration-exploitation balance in spiral optimization.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi) + np.pi * np.exp(-evaluations / self.budget)  # Adaptive angle\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06879 with standard deviation 0.06084.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14843634040066267, 0.14840239152829615, 0.14836459566252058, 0.0007108576858093629, 0.00071039929331429, 0.0007099999519731837, 0.057265577290779746, 0.05726308215176812, 0.05726088069625235]}}
{"id": "f56ec599-66ef-4d46-8d7d-c201dc16a0c1", "fitness": 0.06867948222724163, "name": "EnhancedSpiralOptimization", "description": "An improved spiral optimization with adaptive inertia and radius adjustments, leveraging a diversity mechanism for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.35, inertia_weight - learning_rate * 0.06)  # Slightly more adaptive inertia\n            else:\n                radius *= 1.15  # Slightly more aggressive expansion\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.015)  # Slightly more adaptive inertia\n\n            # Diversity mechanism to escape local optima\n            if np.random.rand() < 0.1: \n                best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Re-initialize position\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06868 with standard deviation 0.06071.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1480712643663833, 0.1480754976912836, 0.14811911942008038, 0.0007065421042820041, 0.0007065945682050989, 0.0007071124999165068, 0.05724193298597369, 0.05724221971154153, 0.05724505669750857]}}
{"id": "3719a494-41ea-401a-8f72-4ec65843075a", "fitness": 0.06914973736614675, "name": "EnhancedSpiralOptimization", "description": "EnhancedSpiralOptimization with reduced inertia weight decrement for more stable exploitation.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.04)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06915 with standard deviation 0.06127.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14811513951256394, 0.15018110934340834, 0.14990898887455673, 0.0007070649901880222, 0.0007306455240227994, 0.0007276922706560551, 0.05724479653690917, 0.05737422596613806, 0.05735797327687764]}}
{"id": "b9ad6824-678b-4e0a-be65-06d43ab62581", "fitness": 0.10495914812120434, "name": "MultiPhaseSpiralOptimization", "description": "Leverage a multi-phase spiral with adaptive radius contraction and variable learning rates for enhanced exploration and rapid convergence.", "code": "import numpy as np\n\nclass MultiPhaseSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9 \n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        # Divide the budget into phases for adaptive strategy\n        phase1_ratio = 0.3  # Initial exploration phase\n        phase2_ratio = 0.7  # Focused exploitation phase\n        phase1_budget = int(self.budget * phase1_ratio)\n        phase2_budget = self.budget - phase1_budget\n\n        # Phase 1: Exploration with larger search radius\n        while evaluations < phase1_budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        # Phase 2: Exploitation with a focus on converging to the best solution\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (0.5 - (evaluations / (2 * self.budget)))\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.7\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= 1.05\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 63, "feedback": "The algorithm MultiPhaseSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10496 with standard deviation 0.13930.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1510751321909376, 0.14817136917047646, 0.4677518952304456, 0.0007405739333903316, 0.0007077317968325891, 0.0012176901722208422, 0.05742879694940772, 0.057248449232723986, 0.060290694414403934]}}
{"id": "72be95ce-9c3b-4656-b697-a5e94d64042b", "fitness": 0.06927334179788436, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive decay and stochastic perturbation to improve convergence efficiency and robustness.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Add a small stochastic perturbation\n            stochastic_perturbation = np.random.normal(0, 0.01, self.dim)\n            candidate_position += stochastic_perturbation\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # Adjust contraction rate\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.06)  # Modify inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.15  # Adjust expansion rate\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.015)  # Modify inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06927 with standard deviation 0.06144.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.15297057426331284, 0.1481437071911228, 0.1481466316090323, 0.0007591762245904299, 0.0007074017777817243, 0.0007074364062098493, 0.0575316749891176, 0.05724664200822005, 0.05724683171157163]}}
{"id": "7fadabf4-3ea2-44d9-b0d1-bb9c323c58f0", "fitness": 0.06891631669210156, "name": "EnhancedSpiralOptimizationV2", "description": "A dynamic spiral optimization using adaptive radius decay and non-linear inertia adjustments for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.7  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Non-linear decrease for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.2  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate ** 2 * 0.01)  # Non-linear increase for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06892 with standard deviation 0.06099.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1485648454366415, 0.1482853700736818, 0.14939774344663925, 0.0007123205204815353, 0.0007090713733431953, 0.0007219052086384625, 0.05727360816440763, 0.05725579088833199, 0.057326195116748635]}}
{"id": "0895b79f-d7db-4618-b968-ef4cd9ff3964", "fitness": 0.06903574605581614, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with Adaptive Spiral Compression and Repulsion for Improved Exploration-Exploitation Balance", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n        compression_factor = 0.7  # Factor to compress spiral for better solutions\n        repulsion_factor = 1.2  # Factor to expand spiral for worse solutions\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= compression_factor  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= repulsion_factor  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06904 with standard deviation 0.06114.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14822150142865442, 0.1495257653272256, 0.1495001852810337, 0.0007083223874995159, 0.00072344596827012, 0.0007231537855290071, 0.057251685571938604, 0.05733462921286403, 0.057333025539330285]}}
{"id": "0715df51-2977-4e8f-83f4-4bbed61edbf2", "fitness": 0.10495914812120434, "name": "RefinedSpiralOptimization", "description": "A refined spiral optimization with adaptive inertia based on success ratio and dynamic learning rate adjustments for improved convergence and exploitation.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        # Adaptive success ratio tracking\n        success_count = 0\n        attempt_count = 0\n        success_ratio_window = 100  # Window size for success ratio tracking\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n            attempt_count += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                success_count += 1\n                # Adaptive adjustments\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                # Increase exploration\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n            # Adjust inertia based on success ratio\n            if attempt_count >= success_ratio_window:\n                success_ratio = success_count / attempt_count\n                if success_ratio < 0.2:\n                    inertia_weight = min(0.9, inertia_weight + learning_rate * 0.05)\n                elif success_ratio > 0.5:\n                    inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n\n                # Reset counters\n                success_count = 0\n                attempt_count = 0\n\n        return best_position, best_value", "configspace": "", "generation": 67, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10496 with standard deviation 0.13930.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1510751321909376, 0.14817136917047646, 0.4677518952304456, 0.0007405739333903316, 0.0007077317968325891, 0.0012176901722208422, 0.05742879694940772, 0.057248449232723986, 0.060290694414403934]}}
{"id": "5fea2a3a-d22d-4e86-818b-880cde1fe962", "fitness": 0.06890872959682731, "name": "RefinedSpiralOptimization", "description": "An enhanced adaptive spiral optimization introducing chaotic maps and dynamic boundary constraints to improve exploration and exploitation balance for better convergence.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        initial_radius = (self.upper_bound - self.lower_bound) / 2\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n        inertia_weight = 0.9\n\n        # Chaos-based randomization\n        chaos_factor = np.random.uniform()\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate using chaotic map\n            angle = 2 * np.pi * chaos_factor\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            radius = initial_radius * np.sqrt(1 - evaluations / self.budget)\n\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Dynamic boundary control\n            candidate_position = np.clip(candidate_position, \n                                         self.lower_bound + (self.upper_bound - self.lower_bound) * 0.1, \n                                         self.upper_bound - (self.upper_bound - self.lower_bound) * 0.1)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                initial_radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                initial_radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            initial_radius = max(initial_radius, min_radius)\n            initial_radius = min(initial_radius, max_radius)\n\n            # Update chaos factor for next iteration\n            chaos_factor = (chaos_factor * 3.9 * (1 - chaos_factor)) % 1\n\n        return best_position, best_value", "configspace": "", "generation": 68, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06891 with standard deviation 0.06098.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14825617177324635, 0.1494494436680901, 0.14847920986512186, 0.0007087343949349068, 0.000722498147778472, 0.000711267451549924, 0.0572539422522762, 0.05732944896825942, 0.057267849850188624]}}
{"id": "c320606b-8a86-4801-bded-8018ec96a66a", "fitness": 0.06877096391151531, "name": "EnhancedSpiralOptimizationV2", "description": "An adaptive spiral optimization with multi-scale perturbations and learning rate annealing to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n        learning_rate_decay = 0.995  # Gradual decay of learning rate\n        perturbation_factor = 0.1  # Factor for small-scale perturbations\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            # Add small-scale perturbations for local refinement\n            perturbation = np.random.uniform(-perturbation_factor, perturbation_factor, self.dim)\n            candidate_position += perturbation\n\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n            # Apply learning rate annealing\n            base_learning_rate *= learning_rate_decay\n\n        return best_position, best_value", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedSpiralOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06877 with standard deviation 0.06082.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1487320209034554, 0.14819902569476429, 0.14810134515211482, 0.0007140509364053083, 0.0007080572584873268, 0.0007068987628318091, 0.0572831569441431, 0.0572502328115404, 0.05724388673989533]}}
{"id": "0f9be99a-e8e6-41cd-a4a1-427839c38e44", "fitness": 0.06992553755901734, "name": "AdvancedSpiralOptimization", "description": "A multi-strategy adaptive spiral optimization incorporating quasi-random sampling and dynamic parameter tuning to enhance search diversity and convergence rate.", "code": "import numpy as np\n\nclass AdvancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        phi = (1 + np.sqrt(5)) / 2  # Golden ratio for quasi-random sampling\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # More aggressive contraction for better solutions\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Use quasi-random sampling to enhance diversity\n            quasi_random_shift = (phi - 1) * (evaluations % phi)\n            candidate_position = candidate_position + quasi_random_shift * (np.random.uniform(-1, 1, self.dim))\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 70, "feedback": "The algorithm AdvancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06993 with standard deviation 0.06224.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.15056386539063693, 0.1485783296575789, 0.1556303299028532, 0.0007337895305685738, 0.0007125101651249688, 0.0007826277602827059, 0.05739178893267616, 0.057274638498159725, 0.05766195819327491]}}
{"id": "41c03ca8-9266-4b1f-9df4-f287035baa43", "fitness": 0.06929684062833333, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive inertia weight scaling for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.1)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06930 with standard deviation 0.06148.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.15286803055788212, 0.14827909902856828, 0.14837749121681088, 0.0007465232459805682, 0.0007090010858300522, 0.0007101636591027027, 0.05746407782778906, 0.05725540467007706, 0.057261774362959206]}}
{"id": "9e375f1e-ba52-4f4f-8f87-853f6adbd105", "fitness": 0.06886003103583375, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive learning and resilience to stagnation by introducing memory-based exploration and exploitation dynamics.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        # Additional parameters for memory-based dynamics\n        recent_best_positions = [best_position]\n        memory_size = 5\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            memory_adjustment = np.mean(recent_best_positions, axis=0)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction + 0.1 * (memory_adjustment - best_position)\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n                recent_best_positions.append(best_position)  # Update memory\n                if len(recent_best_positions) > memory_size:\n                    recent_best_positions.pop(0)\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06092.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14875022543293426, 0.1484257724460445, 0.1485999695606186, 0.0007144775938154879, 0.0007107304059013053, 0.0007127629127930968, 0.057285436190024686, 0.05726488063687474, 0.057276024143497084]}}
{"id": "7188b013-887f-408e-a058-7b95be259cc8", "fitness": -Infinity, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive perturbation and memory-driven learning for improved convergence and solution diversity.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n        \n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        # Memory of past best positions\n        memory = [best_position]\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            perturbation = np.random.choice(memory) * np.random.uniform(-0.05, 0.05, self.dim)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction + perturbation\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                memory.append(best_position)  # Update memory with new best\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n            else:\n                # Increase exploration\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 73, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {}}
{"id": "66e0912d-4a3d-4dd4-a852-bffa75d00a6d", "fitness": 0.07020049724214926, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive directional adjustment to refine search dynamics.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.85  # More balanced contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07020 with standard deviation 0.06264.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14816025518380216, 0.14839507415762876, 0.16056993248500295, 0.0007075964673640689, 0.0007103628376144977, 0.0008294746826440491, 0.05724770895065634, 0.05726286816452941, 0.05792120225010111]}}
{"id": "0f71ab03-7c9b-4afe-bc4c-be37dcab01dc", "fitness": -Infinity, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with Dynamic Boundary Adaptation and Velocity Perturbation for Improved Convergence and Stability.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            velocity = inertia_weight * radius * np.cos(angle) * direction\n            perturbation = np.random.normal(0, 0.1, self.dim)  # Added perturbation\n            candidate_position = best_position + velocity + perturbation\n\n            # Ensure candidate is within dynamic bounds\n            dynamic_lower_bound = max(self.lower_bound, best_position - radius)\n            dynamic_upper_bound = min(self.upper_bound, best_position + radius)\n            candidate_position = np.clip(candidate_position, dynamic_lower_bound, dynamic_upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 75, "feedback": "An exception occurred: ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()').", "error": "ValueError('The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()')", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {}}
{"id": "0acbc60f-0f43-4eac-85e6-5d6fd094b372", "fitness": 0.06903058686038815, "name": "AdaptiveContractionSpiralOptimization", "description": "The Adaptive Contraction Spiral Optimization refines the exploitation-exploration balance by dynamically adjusting the spiral's contraction rate based on recent performance for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveContractionSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        # Initialize adaptive contraction control variables\n        contraction_factor = 0.8\n        expansion_factor = 1.1\n        consecutive_bad_steps = 0\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= contraction_factor  # Contract the spiral more for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n                consecutive_bad_steps = 0  # Reset the count of consecutive bad steps\n            else:\n                # Increase exploration\n                radius *= expansion_factor  # Expand the spiral for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n                consecutive_bad_steps += 1\n\n            # Adjust contraction and expansion factors based on consecutive bad steps\n            if consecutive_bad_steps > 5:\n                contraction_factor = max(0.7, contraction_factor - 0.05)\n                expansion_factor = min(1.2, expansion_factor + 0.05)\n            else:\n                contraction_factor = 0.8\n                expansion_factor = 1.1\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveContractionSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06903 with standard deviation 0.06113.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1500411975603353, 0.14817136917047646, 0.14899561883774448, 0.0007289537561480097, 0.0007077317968325891, 0.0007171026860950391, 0.057364963883007936, 0.057248449232723986, 0.05729989482012954]}}
{"id": "002b8e04-0688-49c7-b7eb-43102172fe45", "fitness": 0.06908779924814196, "name": "EnhancedSpiralOptimization", "description": "A refined spiral optimization that introduces adaptive mutation and elitism for enhanced convergence and diversity maintenance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n        elite_position = best_position # Elite individual\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration and mutation\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n                mutation = np.random.normal(0, 0.1, self.dim)  # Introduce mutation\n                candidate_position += mutation\n\n            # Introduce elitism\n            if candidate_value < func(elite_position):\n                elite_position = candidate_position\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return elite_position, func(elite_position) # Return elite", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06909 with standard deviation 0.06120.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1480161323670035, 0.1504663911852836, 0.14920635901817492, 0.0007058888223872017, 0.0007333998589577062, 0.0007197663690837741, 0.057238354229391275, 0.05738945932142914, 0.05731444206156655]}}
{"id": "9b5016ca-ff76-4ac3-b9bf-772588dc61b8", "fitness": 0.06878858532281332, "name": "MultiSpiralOptimization", "description": "A multi-spiral colocated exploration strategy enhancing cooperative dynamics between spirals for improved search efficiency and solution quality.", "code": "import numpy as np\n\nclass MultiSpiralOptimization:\n    def __init__(self, budget, dim, num_spirals=3):\n        self.budget = budget\n        self.dim = dim\n        self.num_spirals = num_spirals\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        spirals = [np.random.uniform(self.lower_bound, self.upper_bound, self.dim) for _ in range(self.num_spirals)]\n        spiral_values = [func(s) for s in spirals]\n        evaluations += self.num_spirals\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            for i in range(self.num_spirals):\n                angle = np.random.uniform(0, 2 * np.pi)\n                direction = np.random.normal(0, 1, self.dim)\n                direction /= np.linalg.norm(direction)\n                candidate_position = spirals[i] + inertia_weight * radius * np.cos(angle) * direction\n\n                candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                candidate_value = func(candidate_position)\n                evaluations += 1\n\n                if candidate_value < spiral_values[i]:\n                    spirals[i] = candidate_position\n                    spiral_values[i] = candidate_value\n                    if candidate_value < best_value:\n                        best_position = candidate_position\n                        best_value = candidate_value\n                    radius *= 0.8\n                    inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n                else:\n                    radius *= 1.1\n                    inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 78, "feedback": "The algorithm MultiSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06879 with standard deviation 0.06084.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1483526657896922, 0.14857165379778858, 0.1482537658300701, 0.0007098715700546432, 0.0007124344914826164, 0.0007087039230230241, 0.05726017365485936, 0.0572742229547073, 0.057253775893642]}}
{"id": "63615bad-1e10-4194-b8b9-e7b727465a95", "fitness": 0.06876438872630866, "name": "ImprovedSpiralOptimization", "description": "Improved Spiral Optimization with adaptive chaos-driven perturbations to enhance search space exploration and convergence precision.", "code": "import numpy as np\n\nclass ImprovedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral and chaos parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n        chaos_factor = 0.1  # Chaos factor for perturbation\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            chaos_perturbation = chaos_factor * (np.random.rand() - 0.5)\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction + chaos_perturbation\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 79, "feedback": "The algorithm ImprovedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06876 with standard deviation 0.06081.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14834266298387289, 0.14812698235418365, 0.14850617658263698, 0.0007097503261808136, 0.000707203725039407, 0.0007116625125426213, 0.05725951026312681, 0.0572455570143231, 0.05726999277487166]}}
{"id": "716cebbd-d5ad-46e1-832d-bba5fe19192a", "fitness": 0.06878764657775295, "name": "EnhancedSpiralOptimization", "description": "Improved Spiral Optimization with Adaptive Radius and Feedback Mechanism for Enhanced Convergence.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        stagnation_counter = 0  # Counter for detecting stagnation\n        max_stagnation = 10  # Maximum stagnation threshold\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n                stagnation_counter = 0  # Reset stagnation counter\n            else:\n                # Increase exploration\n                radius *= 1.05  # Slower expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n                stagnation_counter += 1  # Increment stagnation counter\n\n            # Adaptive radius reduction in case of stagnation\n            if stagnation_counter >= max_stagnation:\n                radius *= 0.9  # Reduce radius to focus on a new search area\n                stagnation_counter = 0  # Reset stagnation counter\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06879 with standard deviation 0.06084.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.1480214545945412, 0.14840232323003344, 0.14874695804311922, 0.0007059518965575329, 0.000710434479874178, 0.0007144501058060637, 0.057238699754924016, 0.05726326471855425, 0.05728528237636665]}}
{"id": "3ade658b-a647-487c-97ee-4df58ecbc79e", "fitness": 0.06886487162516515, "name": "HybridSpiralSwarmOptimization", "description": "A Hybrid Spiral-Swarm Optimization integrating particle swarm dynamics into spiral search for enhanced convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass HybridSpiralSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        # Particle swarm parameters\n        particle_velocity = np.random.uniform(-1, 1, self.dim)\n        personal_best_position = best_position\n        personal_best_value = best_value\n        global_best_position = best_position\n        global_best_value = best_value\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            spiral_position = personal_best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure spiral position is within bounds\n            spiral_position = np.clip(spiral_position, self.lower_bound, self.upper_bound)\n\n            # Update particle velocity and position\n            r1, r2 = np.random.rand(), np.random.rand()\n            particle_velocity = (inertia_weight * particle_velocity\n                                + r1 * (personal_best_position - spiral_position)\n                                + r2 * (global_best_position - spiral_position))\n            particle_position = spiral_position + particle_velocity\n\n            # Ensure particle position is within bounds\n            particle_position = np.clip(particle_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(particle_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = particle_position\n                best_value = candidate_value\n\n                # Update global best\n                if candidate_value < global_best_value:\n                    global_best_position = particle_position\n                    global_best_value = candidate_value\n\n                # Update personal best\n                if candidate_value < personal_best_value:\n                    personal_best_position = particle_position\n                    personal_best_value = candidate_value\n\n                # Adaptive adjustments\n                radius *= 0.8  # More aggressive contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.1  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)  # Increase inertia for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 81, "feedback": "The algorithm HybridSpiralSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06886 with standard deviation 0.06093.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14818278835358056, 0.14856732268617978, 0.1490692884783852, 0.0007078638271883486, 0.0007123900917503923, 0.0007177162393577907, 0.05724917347696179, 0.05727397772026843, 0.057303323752814106]}}
{"id": "7a4555a2-d701-4b4b-b6cd-9fd39f4b60e1", "fitness": 0.07618973135021445, "name": "EnhancedSpiralOptimizationPlus", "description": "An enhanced spiral optimization with adaptive momentum and phase shift to improve convergence speed and precision.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimizationPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        # Adaptive momentum and phase shift\n        momentum = 0.5\n        phase_shift = np.random.uniform(0, 2 * np.pi)\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            \n            # Generate a new candidate solution on the spiral with adaptive momentum\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle + phase_shift) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Adaptive adjustments\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.05)\n                momentum = min(0.9, momentum + 0.1)  # Increase momentum for successful moves\n                phase_shift = (phase_shift + np.pi / 4) % (2 * np.pi)  # Introduce dynamic phase shift\n            else:\n                radius *= 1.1\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.01)\n                momentum = max(0.1, momentum - 0.05)  # Decrease momentum for unsuccessful moves\n                phase_shift = (phase_shift - np.pi / 4) % (2 * np.pi)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedSpiralOptimizationPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07619 with standard deviation 0.07138.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.2009468429159449, 0.14906753669821637, 0.15946753658409163, 0.0009499658048213178, 0.0007181078333471369, 0.000813294972500489, 0.05860609727667809, 0.057305359747729545, 0.05783284031860059]}}
{"id": "62c428b8-ee16-4ef2-bf44-6f5c8c048e94", "fitness": 0.06888774576201462, "name": "RefinedSpiralOptimization", "description": "A refined spiral optimization with adaptive radius control and inertia variation to enhance local and global search efficiency simultaneously.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            # Dynamic learning rate\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.7  # Faster contraction for better solutions\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.07)  # Steeper decrease for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.15  # Faster expansion for worse solutions\n                inertia_weight = min(0.9, inertia_weight + learning_rate * 0.02)  # Steeper increase for exploration\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 83, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06889 with standard deviation 0.06096.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.14960059890447086, 0.14810645110484433, 0.1483036460433147, 0.0007239828744570742, 0.0007069602946656595, 0.0007092746959992402, 0.057337665936122995, 0.05724422351475389, 0.05725690848950282]}}
{"id": "6d55d01c-748a-4d68-8911-52f184ff4c62", "fitness": 0.3246274982788766, "name": "ImprovedSpiralOptimization", "description": "An Improved Spiral Optimization algorithm with adaptive inertia and dynamic convergence pressure to enhance exploration and intensification through multi-phase convergence.", "code": "import numpy as np\n\nclass ImprovedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.75  # More aggressive contraction for better solutions\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.04)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.2  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.02)  # Increase inertia for exploration\n\n            # Adaptive inertia weight and convergence pressure balance\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.5) * inertia_weight\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 84, "feedback": "The algorithm ImprovedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32463 with standard deviation 0.40615.", "error": "", "parent_ids": ["1b6aad2c-fe8e-42c6-a39a-813023b4ce9e"], "operator": null, "metadata": {"aucs": [0.9844704925347135, 0.8630127895484627, 0.8377162344849178, 0.0028735081616880764, 0.004057826149664434, 0.0026163491440786, 0.07143736819710489, 0.0841210860845123, 0.07134183020474705]}}
{"id": "481c8b1e-fb74-40a3-8639-95cdbe4c257d", "fitness": 0.07115847931595713, "name": "ImprovedSpiralOptimization", "description": "Enhanced Spiral Optimization with chaotic initialization and dynamic perturbation for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        # Chaotic initialization for diversification\n        best_position = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.dim)**2\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            \n            # Dynamic perturbation inspired by chaos theory\n            perturbation = (np.random.rand(self.dim) - 0.5) * (self.upper_bound - self.lower_bound) * 0.01\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction + perturbation\n            \n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.75\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.04)\n            else:\n                radius *= 1.2\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.02)\n\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.5) * inertia_weight\n            \n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 85, "feedback": "The algorithm ImprovedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07116 with standard deviation 0.06380.", "error": "", "parent_ids": ["6d55d01c-748a-4d68-8911-52f184ff4c62"], "operator": null, "metadata": {"aucs": [0.14832077365554985, 0.1601679006557386, 0.1568374151774078, 0.0007094924603505692, 0.0008219827158590931, 0.0007800572401326367, 0.057258097200778124, 0.05788052939803734, 0.05765006533976014]}}
{"id": "6c238340-4fb8-40b0-a314-b0b4bf84fe77", "fitness": 0.2413188172186718, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive multi-phase search dynamics for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        # New adaptive parameters\n        adaptive_phase_switch = 0.5  # Controls phase change\n        exploitation_weight = 0.6  # Determining factor for exploitation enhancement\n\n        while evaluations < self.budget:\n            # Dynamic adjustment of learning rate\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n\n            # Adaptive multi-phase dynamics\n            phase_factor = 1 if evaluations < self.budget * adaptive_phase_switch else exploitation_weight\n            candidate_position = best_position + phase_factor * inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Aggressive contraction for better solutions\n                radius *= 0.7\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.06)  # Decrease inertia more significantly\n            else:\n                # Increase exploration\n                radius *= 1.3  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.03)  # Increase inertia\n\n            # Adaptive inertia and convergence pressure balance\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight *= (0.9 - convergence_pressure * 0.5)\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24132 with standard deviation 0.30465.", "error": "", "parent_ids": ["6d55d01c-748a-4d68-8911-52f184ff4c62"], "operator": null, "metadata": {"aucs": [0.4821267357290574, 0.22857899866326292, 0.970731890577267, 0.002138916131786628, 0.0009876445322273275, 0.00647981683584431, 0.06988348946743483, 0.058828393187220884, 0.35211346984394454]}}
{"id": "96a1aa1e-b4be-4dde-b492-d7e46a534c4e", "fitness": 0.28029452630474716, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with Stochastic Guidance integrates adaptive stochastic perturbations and a probabilistic convergence strategy to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        # Stochastic guidance parameters\n        stochastic_factor = 0.1  # Initial stochastic factor\n\n        while evaluations < self.budget:\n            # Adjust learning rate and stochastic factor dynamically\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            stochastic_adjustment = stochastic_factor * np.random.uniform(-1, 1, self.dim)\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction + stochastic_adjustment\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.75  # More aggressive contraction for better solutions\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.04)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.2  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.02)  # Increase inertia for exploration\n\n            # Adaptive inertia weight and convergence pressure balance\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.5) * inertia_weight\n\n            # Adjust stochastic factor as budget diminishes\n            stochastic_factor *= (0.9 + 0.1 * np.random.rand())\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28029 with standard deviation 0.35581.", "error": "", "parent_ids": ["6d55d01c-748a-4d68-8911-52f184ff4c62"], "operator": null, "metadata": {"aucs": [0.6779088112419827, 0.896514447632916, 0.7559483066236115, 0.0015011179793519291, 0.0016268060800110895, 0.001627429951209125, 0.062039475302415825, 0.06272115855303173, 0.06276318337819486]}}
{"id": "0ab25bd8-1173-489b-8930-e4260adfd264", "fitness": 0.30456965008872117, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with Dynamic Feedback Strategy to balance exploration and exploitation by adapting spiral parameters based on success rates.  ", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        success_counter = 0  # Track successful updates\n\n        while evaluations < self.budget:\n            # Dynamic learning rate based on success\n            dynamic_lr = base_learning_rate * (1 + success_counter / self.budget)\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                success_counter += 1  # Increment success\n                radius *= 0.75  # Contract radius\n                inertia_weight = max(0.3, inertia_weight - dynamic_lr * 0.05)  # Decrease inertia\n            else:\n                success_counter = max(0, success_counter - 1)  # Decrease success counter\n                radius *= 1.1  # Expand radius slightly for exploration\n                inertia_weight = min(0.95, inertia_weight + dynamic_lr * 0.03)  # Increase inertia\n\n            # Adjust inertia weight and convergence pressure\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.5) * inertia_weight\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30457 with standard deviation 0.38846.", "error": "", "parent_ids": ["6d55d01c-748a-4d68-8911-52f184ff4c62"], "operator": null, "metadata": {"aucs": [0.9606157521319463, 0.9551296280170397, 0.5822099499350109, 0.0014895819825017087, 0.0051983179391210665, 0.0027692005542357956, 0.061789422877579714, 0.09822472067963428, 0.07370027668142154]}}
{"id": "2996e59a-c4d4-4022-b05c-bdba181dbde2", "fitness": 0.06939136832132392, "name": "ImprovedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive spiral radius and stochastic perturbation for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        # Initialize variables\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        # Spiral parameters\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9  # Initial inertia weight\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1  # Base learning rate\n\n        while evaluations < self.budget:\n            # Adjust learning rate dynamically based on evaluations ratio\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n\n            # Generate a new candidate solution on the spiral\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            # Introduce stochastic perturbation for diversification\n            perturbation = np.random.normal(0, 0.1, self.dim)\n            candidate_position += perturbation\n\n            # Ensure candidate is within bounds\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n\n            # Evaluate the candidate solution\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Check if the candidate is better\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                # Adaptive adjustments\n                radius *= 0.75  # More aggressive contraction for better solutions\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.04)  # Decrease inertia for exploitation\n            else:\n                # Increase exploration\n                radius *= 1.2  # More aggressive expansion for worse solutions\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.02)  # Increase inertia for exploration\n\n            # Adaptive inertia weight and convergence pressure balance\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.5) * inertia_weight\n\n            # Ensure radius remains within sensible bounds\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 89, "feedback": "The algorithm ImprovedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06939 with standard deviation 0.06156.", "error": "", "parent_ids": ["6d55d01c-748a-4d68-8911-52f184ff4c62"], "operator": null, "metadata": {"aucs": [0.15142010080336166, 0.15004060387627083, 0.1487723605132356, 0.0007442465330023129, 0.0007290313968794093, 0.0007147340269568758, 0.057449026762001365, 0.05736536833155936, 0.05728684264864792]}}
{"id": "b26654df-8af7-4e3e-8194-48c49643d3eb", "fitness": 0.39970800393366895, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive spiral repositioning and convergence tuning based on dynamic feedback to balance exploration and exploitation efficiently.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            \n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.7\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= 1.3\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.03)\n\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.6) * inertia_weight\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39971 with standard deviation 0.39157.", "error": "", "parent_ids": ["6d55d01c-748a-4d68-8911-52f184ff4c62"], "operator": null, "metadata": {"aucs": [0.8829040403944781, 0.9354258976471129, 0.5933326349687672, 0.01624497993690799, 0.0026883897755834996, 0.0024673651783458928, 0.8690987852495717, 0.22521064947629088, 0.06999929277596229]}}
{"id": "8d61cb0d-e236-4b8f-8350-3c436b949aae", "fitness": 0.1704143355077603, "name": "EnhancedSpiralOptimization", "description": "Improved Spiral Optimization with dynamic inertia and adaptive boundary expansion for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n\n        # Adjusted learning rate strategy to dynamically vary with budget and performance\n        initial_learning_rate = 0.2\n\n        while evaluations < self.budget:\n            learning_rate = initial_learning_rate * np.exp(-evaluations / (self.budget / 2))\n            \n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n\n            # Adaptive boundary expansion\n            dynamic_bound = self.lower_bound - (5.0 * evaluations / self.budget)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            candidate_position = np.clip(candidate_position, dynamic_bound, self.upper_bound)\n\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.65  # Slightly more aggressive contraction\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.07)\n            else:\n                radius *= 1.2\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.05)\n\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.6) * inertia_weight\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17041 with standard deviation 0.24167.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.1566849250907255, 0.46189802923408596, 0.7338558406395157, 0.0007956577542089782, 0.0010425752179417103, 0.0013843391607574196, 0.057733295339233215, 0.05913080228452716, 0.06120355484884732]}}
{"id": "dec60a78-c381-4052-af9b-7f86676ec4bb", "fitness": 0.07239427290651354, "name": "EnhancedSpiralOptimization", "description": "Refined Spiral Optimization with adaptive learning rate and dynamic boundary adaptation to enhance efficiency and precision.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * np.exp(-(evaluations / self.budget))\n            \n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.7\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= 1.3\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.03)\n\n            self.lower_bound += (best_position - self.lower_bound) * 0.01 \n            self.upper_bound -= (self.upper_bound - best_position) * 0.01\n            \n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07239 with standard deviation 0.06536.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.16796867672319693, 0.15379651027973917, 0.1540355967005831, 0.000872575573583112, 0.0007674978060998594, 0.0007706391541675295, 0.05816456865126285, 0.05757762040798131, 0.05759477086200804]}}
{"id": "cd643504-d3a3-4756-8abe-2b3983e98686", "fitness": 0.30640374824865046, "name": "ImprovedEnhancedSpiralOptimization", "description": "Improved Enhanced Spiral Optimization with dynamic learning rate adjustment and adaptive inertia based on swarm diversity to amplify convergence and exploration balance.", "code": "import numpy as np\n\nclass ImprovedEnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        # Initialize swarm for diversity tracking\n        swarm = [best_position]\n        swarm_size = 5  # Track last 5 positions for diversity\n\n        while evaluations < self.budget:\n            diversity = np.std(swarm, axis=0).mean()  # Calculate diversity based on swarm positions\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget)) * (1 + diversity)\n            \n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.7\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= 1.3\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.03)\n\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.6) * inertia_weight\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n            # Update swarm diversity\n            swarm.append(best_position)\n            if len(swarm) > swarm_size:\n                swarm.pop(0)\n\n        return best_position, best_value", "configspace": "", "generation": 93, "feedback": "The algorithm ImprovedEnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30640 with standard deviation 0.38568.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.8820664671191294, 0.8616496221796461, 0.80589360814521, 0.0016225078757864386, 0.0012990090222655404, 0.003478204317813316, 0.06265827828317194, 0.06064989250123165, 0.07831614479359972]}}
{"id": "8057a4eb-1fc7-495b-a195-a444cd0be4f9", "fitness": 0.07489209904010234, "name": "RefinedSpiralOptimization", "description": "Refined Spiral Optimization with adaptive multi-phase exploration-exploitation balance by dynamically adjusting radius and inertia based on convergence feedback.", "code": "import numpy as np\n\nclass RefinedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        exploration_phase = True\n\n        while evaluations < self.budget:\n            convergence_pressure = 1 - evaluations / self.budget\n            learning_rate = base_learning_rate * convergence_pressure\n\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                if exploration_phase:\n                    radius *= 0.8\n                    inertia_weight = max(0.4, inertia_weight - learning_rate * 0.1)\n                else:\n                    radius *= 0.7\n                    inertia_weight = max(0.3, inertia_weight - learning_rate * 0.05)\n            else:\n                if exploration_phase:\n                    radius *= 1.4\n                    inertia_weight = min(0.95, inertia_weight + learning_rate * 0.07)\n                else:\n                    radius *= 1.2\n                    inertia_weight = min(0.9, inertia_weight + learning_rate * 0.03)\n\n            if evaluations >= self.budget // 2:\n                exploration_phase = False\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 94, "feedback": "The algorithm RefinedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07489 with standard deviation 0.06994.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.150264215475149, 0.1482233613232279, 0.19986863759694706, 0.0007305312538393727, 0.000708341046431693, 0.0009575418773294375, 0.05737387371445568, 0.05725178877351755, 0.05865060030002334]}}
{"id": "2742e9e7-3e6b-464a-9b38-51064c7b593e", "fitness": 0.06894319660830968, "name": "DynamicAdaptiveSpiralOptimization", "description": "Dynamic Adaptive Spiral Optimization (DASO) leverages adaptive momentum and region contraction to improve convergence speed and solution accuracy by dynamically adjusting exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicAdaptiveSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        learning_rate_decay = 0.99\n        momentum = 0.9\n        velocity = np.zeros(self.dim)\n\n        while evaluations < self.budget:\n            # Dynamic learning rate decreases over time\n            learning_rate = (0.1 / (1 + (evaluations / self.budget) * learning_rate_decay))\n            \n            # Generate a candidate solution using spiral dynamics\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            velocity = momentum * velocity + learning_rate * radius * np.cos(angle) * direction\n            candidate_position = best_position + velocity\n            \n            # Boundary check\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            # Update best position if a better solution is found\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.7  # Contraction\n            else:\n                radius *= 1.2  # Expansion\n\n            # Adjust momentum dynamically based on the number of evaluations\n            momentum = 0.9 * (1 - evaluations / self.budget) + 0.1\n\n            # Ensure radius stays within the specified bounds\n            radius = np.clip(radius, min_radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 95, "feedback": "The algorithm DynamicAdaptiveSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06894 with standard deviation 0.06102.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.1489111951425397, 0.14919300515512968, 0.14836976097478327, 0.00071633978948904, 0.0007193353231745858, 0.0007100692230059824, 0.05729565050151397, 0.057312155504305795, 0.05726125786084513]}}
{"id": "6fc79f10-4b9e-462f-84e0-33d67532f647", "fitness": 0.2274093665529742, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive radius scaling and diversified exploration strategies to improve exploitation and convergence.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            \n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8 # Change: Adjusted scaling factor for convergence\n                inertia_weight = max(0.4, inertia_weight - learning_rate * 0.06) # Change: Increased learning influence\n            else:\n                radius *= 1.2 # Change: Adjusted scaling factor for exploration\n                inertia_weight = min(0.92, inertia_weight + learning_rate * 0.04) # Change: Increased learning influence\n\n            if evaluations % (self.budget // 10) == 0: # Change: Introduce periodic diversification\n                radius = np.random.uniform(min_radius, max_radius)\n                \n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.5) * inertia_weight # Change: Adjusted pressure factor\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22741 with standard deviation 0.32215.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.9854203633400908, 0.30249665313005303, 0.5706335909152713, 0.0016837141834279423, 0.0011190566743872754, 0.0014000712349039324, 0.06302035475164969, 0.059601931837151345, 0.06130856290983244]}}
{"id": "49b928de-b6bc-44d4-b4c0-da0f8f568c5b", "fitness": 0.3767259045057663, "name": "DynamicInertiaSpiralOptimization", "description": "Dynamic Inertia Spiral Optimization with adaptive convergence pressure tuning to enhance exploration-exploitation balance through inertia weight and radius modulation.", "code": "import numpy as np\n\nclass DynamicInertiaSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            \n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.7\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.05)\n            else:\n                radius *= 1.3\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.03)\n\n            convergence_pressure = 1 - (evaluations / self.budget) ** 2\n            inertia_weight = (0.9 - convergence_pressure * 0.6) * inertia_weight\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 97, "feedback": "The algorithm DynamicInertiaSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37673 with standard deviation 0.36561.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.894112476621584, 0.8644354980348034, 0.8373081354686507, 0.0012132944353109298, 0.001643888284251771, 0.3089145968743401, 0.060130752221891015, 0.06280833225139881, 0.35996616635966605]}}
{"id": "6bb2ab47-e108-415d-b200-e5179c8080ef", "fitness": 0.07212199115266994, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with dynamic neighborhood search and adaptive learning rates for improved convergence.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + radius * np.cos(angle) * direction\n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= 0.8\n                inertia_weight = max(0.3, inertia_weight - learning_rate * 0.08)\n            else:\n                radius *= 1.2\n                inertia_weight = min(0.95, inertia_weight + learning_rate * 0.05)\n\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.6) * inertia_weight\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n            \n            # Introducing dynamic neighborhood search\n            if evaluations % int(self.budget * 0.1) == 0:\n                local_position = best_position + np.random.uniform(-0.1, 0.1, self.dim) * radius\n                local_position = np.clip(local_position, self.lower_bound, self.upper_bound)\n                local_value = func(local_position)\n                evaluations += 1\n                if local_value < best_value:\n                    best_position = local_position\n                    best_value = local_value\n\n        return best_position, best_value", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07212 with standard deviation 0.06539.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.1490540602822864, 0.17617331139963288, 0.1485457263634702, 0.0007178466487641755, 0.0009149173875282468, 0.0007121156488402169, 0.057303957224721924, 0.05840350592728749, 0.05727247949149794]}}
{"id": "ab532863-6165-4384-aeed-f185f4e1542e", "fitness": 0.06862499663056496, "name": "EnhancedSpiralOptimization", "description": "Enhanced Spiral Optimization with adaptive memory and chaotic maps for dynamic parameter control to improve exploration and convergence balance.", "code": "import numpy as np\n\nclass EnhancedSpiralOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        evaluations = 0\n        best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        best_value = func(best_position)\n        evaluations += 1\n\n        radius = (self.upper_bound - self.lower_bound) / 2\n        inertia_weight = 0.9\n        min_radius = (self.upper_bound - self.lower_bound) * 0.01\n        max_radius = (self.upper_bound - self.lower_bound) * 0.5\n        base_learning_rate = 0.1\n\n        memory = best_position\n        chaotic_param = 0.7\n\n        while evaluations < self.budget:\n            learning_rate = base_learning_rate * (1 - (evaluations / self.budget))\n            \n            angle = np.random.uniform(0, 2 * np.pi)\n            direction = np.random.normal(0, 1, self.dim)\n            direction /= np.linalg.norm(direction)\n            candidate_position = best_position + inertia_weight * radius * np.cos(angle) * direction\n            \n            candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n            candidate_value = func(candidate_position)\n            evaluations += 1\n\n            if candidate_value < best_value:\n                best_position = candidate_position\n                best_value = candidate_value\n                radius *= chaotic_param\n                memory = candidate_position\n                chaotic_param -= 0.01\n            else:\n                radius *= 1.3\n                chaotic_param = chaotic_param * (1 + 0.05 * np.random.rand())\n\n            convergence_pressure = 1 - evaluations / self.budget\n            inertia_weight = (0.9 - convergence_pressure * 0.6) * inertia_weight\n\n            radius = max(radius, min_radius)\n            radius = min(radius, max_radius)\n\n        return best_position, best_value", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedSpiralOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06862 with standard deviation 0.06064.", "error": "", "parent_ids": ["b26654df-8af7-4e3e-8194-48c49643d3eb"], "operator": null, "metadata": {"aucs": [0.1479441816173528, 0.14793430320907164, 0.1479321049626604, 0.000705031715481641, 0.0007049138894574813, 0.0007048876648978464, 0.057233660232871575, 0.05723301499624678, 0.05723287138704447]}}
