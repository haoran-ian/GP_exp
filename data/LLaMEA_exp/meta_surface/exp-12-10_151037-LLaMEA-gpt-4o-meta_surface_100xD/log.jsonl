{"id": "c0e5f95a-8594-4793-bd60-325b599e86c1", "fitness": 0.4138441897248371, "name": "AdaptiveSwarmOptimization", "description": "Inspired by an adaptive swarm intelligence model, this algorithm balances exploration and exploitation by dynamically adjusting particles' learning strategies based on performance feedback.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Adaptive inertia weight adjustment\n                self.inertia_weight = max(0.4, self.inertia_weight * (1 - eval_count / self.budget))\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41384 with standard deviation 0.38291.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.9475728211343721, 0.22624932702683775, 0.0677104210133016]}}
{"id": "1b6bd6be-a6b4-4f0e-9b69-d4d9243f4070", "fitness": 0.41388012059781615, "name": "AdaptiveSwarmOptimization", "description": "Improved by introducing a dynamic cognitive coefficient to further balance exploration and exploitation based on iteration progress.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = 1.5 * (1 - eval_count / self.budget) + 1.0 * (eval_count / self.budget)  # Adjusted cognitive coefficient\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Adaptive inertia weight adjustment\n                self.inertia_weight = max(0.4, self.inertia_weight * (1 - eval_count / self.budget))\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41388 with standard deviation 0.38289.", "error": "", "parent_ids": ["c0e5f95a-8594-4793-bd60-325b599e86c1"], "operator": null, "metadata": {"aucs": [0.9475728211343721, 0.2262958150948834, 0.06777172556419264]}}
{"id": "e6973905-7797-43dc-8841-6a9f4af6a9cc", "fitness": 0.3629110574907233, "name": "AdaptiveSwarmOptimizationImproved", "description": "Adaptive Swarm Optimization with nonlinear inertia and cognitive coefficient decay for balanced exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimizationImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear cognitive coefficient decay\n                cognitive_coeff = 2.5 * (1 - (eval_count / self.budget)**2) + 0.5 * ((eval_count / self.budget)**2)\n                cognitive_velocity = cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = 1.5 * r2 * (self.gbest_position - self.positions[i])\n                \n                # Nonlinear inertia weight adjustment\n                inertia_weight = 0.9 - (0.5 * ((eval_count / self.budget)**2))\n                \n                self.velocities[i] = (inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveSwarmOptimizationImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36291 with standard deviation 0.29548.", "error": "", "parent_ids": ["1b6bd6be-a6b4-4f0e-9b69-d4d9243f4070"], "operator": null, "metadata": {"aucs": [0.10096051936318695, 0.7758429004400724, 0.21192975266891045]}}
{"id": "b1d52ece-78fa-4e03-a7ae-03a11113466b", "fitness": 0.37864976899141506, "name": "EnhancedSwarmOptimization", "description": "Enhanced exploration and exploitation by introducing a mutation mechanism to diversify search and improve convergence.  ", "code": "import numpy as np\n\nclass EnhancedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.mutation_rate = 0.1\n        self.mutation_strength = 0.1\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = 1.5 * (1 - eval_count / self.budget) + 1.0 * (eval_count / self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.inertia_weight = max(0.4, self.inertia_weight * (1 - eval_count / self.budget))\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n\n                if np.random.random() < self.mutation_rate:\n                    mutation = np.random.normal(0, self.mutation_strength, self.dim)\n                    self.velocities[i] += mutation\n\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37865 with standard deviation 0.38419.", "error": "", "parent_ids": ["1b6bd6be-a6b4-4f0e-9b69-d4d9243f4070"], "operator": null, "metadata": {"aucs": [0.14602310619069092, 0.9201910926620606, 0.06973510812149364]}}
{"id": "ab526fbc-2279-440d-a0dc-faa6dd0f2285", "fitness": 0.6666283469964501, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Enhanced AdaptiveSwarmOptimization by integrating a nonlinear dynamic cognitive coefficient and inertia weight adjustment based on exponential decay for better convergence control.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear dynamic cognitive coefficient\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Exponential decay for inertia weight\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 4, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66663 with standard deviation 0.36426.", "error": "", "parent_ids": ["1b6bd6be-a6b4-4f0e-9b69-d4d9243f4070"], "operator": null, "metadata": {"aucs": [0.15153547990888627, 0.9304027757515596, 0.9179467853289047]}}
{"id": "61844cfa-301c-4a3d-80fd-d32b83bf42b5", "fitness": 0.3293950723974965, "name": "ImprovedDynamicSwarmOptimization", "description": "Improved Dynamic Swarm Optimization by integrating adaptive inertia, cognitive, and social coefficients based on diversity and evaluation progress for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass ImprovedDynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.initial_cognitive_coeff = 2.0\n        self.final_cognitive_coeff = 0.5\n        self.initial_social_coeff = 0.5\n        self.final_social_coeff = 2.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n\n                # Adaptive inertia weight based on diversity\n                diversity = np.std(self.positions, axis=0).mean()\n                inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - eval_count/self.budget)\n                \n                # Adaptive cognitive coefficient\n                cognitive_coeff = self.final_cognitive_coeff + (self.initial_cognitive_coeff - self.final_cognitive_coeff) * diversity / (diversity + 1e-9)\n                \n                # Adaptive social coefficient\n                social_coeff = self.final_social_coeff + (self.initial_social_coeff - self.final_social_coeff) * (1 - diversity / (diversity + 1e-9))\n\n                cognitive_velocity = cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.velocities[i] = (inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 5, "feedback": "The algorithm ImprovedDynamicSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32940 with standard deviation 0.34142.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.1011575914045666, 0.8120060818258101, 0.0750215439621128]}}
{"id": "12582f59-096c-4eb2-84ad-e6213bab4cf2", "fitness": 0.48745426339753495, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Enhanced AdaptiveSwarmOptimization by dynamically adjusting the social coefficient based on the remaining budget to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                \n                # Dynamically adjust the social coefficient\n                self.social_coeff = 1.5 * (eval_count / self.budget)\n                \n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48745 with standard deviation 0.23365.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.5195179302706224, 0.7562331612521657, 0.18661169866981675]}}
{"id": "ce6d4be4-0c64-45b5-826d-285876cf28eb", "fitness": 0.10551048779624927, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Refined Enhanced AdaptiveSwarmOptimization by adjusting social coefficient dynamically using a sinusoidal function for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear dynamic cognitive coefficient\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n\n                # Sinusoidal adjustment for social coefficient\n                self.social_coeff = 1.5 + 0.5 * np.sin(2 * np.pi * eval_count / self.budget)\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Exponential decay for inertia weight\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10551 with standard deviation 0.03347.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.15253120774624984, 0.07728779442873224, 0.08671246121376575]}}
{"id": "53ea9962-f58b-442f-b736-14e420872d64", "fitness": 0.05583596223459575, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Enhanced Adaptive Swarm Optimization by incorporating a self-adjusting hybrid velocity component based on local convergence rate for improved adaptability in diverse search spaces.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.hybrid_coeff = 0.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            local_convergence_rate = np.zeros(self.population_size)\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    local_convergence_rate[i] = abs(self.pbest_scores[i] - score)\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                hybrid_velocity = self.hybrid_coeff * r3 * local_convergence_rate[i] * (bounds.ub - bounds.lb)\n\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity + hybrid_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05584 with standard deviation 0.00971.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.06954742936991631, 0.048263733140010645, 0.04969672419386029]}}
{"id": "c2ff0935-d2f2-4287-9a11-36ec37ac4785", "fitness": 0.15441492248721697, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Modified EnhancedAdaptiveSwarmOptimization by introducing nonlinear dynamic social coefficient and diversity-based inertia adjustment to improve convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear dynamic cognitive coefficient\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                # Nonlinear dynamic social coefficient\n                self.social_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Diversity-based inertia adjustment\n                position_diversity = np.std(self.positions, axis=0).mean()\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget) * (1 + position_diversity)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15441 with standard deviation 0.01223.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.15196425271258152, 0.14080955114161786, 0.1704709636074515]}}
{"id": "f1141114-eca3-4654-80c9-59e5b033a187", "fitness": 0.4049930485991544, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Enhanced AdaptiveSwarmOptimization by introducing a time-varying social coefficient for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear dynamic cognitive coefficient\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                \n                # Time-varying social coefficient\n                self.social_coeff = 1.5 + 0.5 * (1 - eval_count / self.budget)\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Exponential decay for inertia weight\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40499 with standard deviation 0.40435.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.16850204724333617, 0.974129956283478, 0.07234714227064898]}}
{"id": "756aba8e-97af-4db9-ace2-cf504d5a4a4c", "fitness": 0.2596902663319281, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Enhanced Adaptive Swarm Optimization with dynamic population resizing and mutation operator for diversity maintenance and improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 30\n        self.population_size = self.initial_population_size\n        self.inertia_weight = 0.9\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.mutation_probability = 0.1\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Nonlinear dynamic cognitive coefficient\n                self.cognitive_coeff = 1.5 * np.exp(-0.005 * eval_count/self.budget)\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Exponential decay for inertia weight\n                self.inertia_weight = 0.9 * np.exp(-0.005 * eval_count/self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n                # Mutation to maintain diversity\n                if np.random.random() < self.mutation_probability:\n                    mutation = np.random.normal(0, 0.1, self.dim)\n                    self.positions[i] = np.clip(self.positions[i] + mutation, bounds.lb, bounds.ub)\n\n            # Dynamic population resizing strategy\n            self.population_size = int(self.initial_population_size * (1 - eval_count/self.budget))\n            self.population_size = max(1, self.population_size)  # Ensure at least one individual\n\n            self.positions = self.positions[:self.population_size]\n            self.velocities = self.velocities[:self.population_size]\n            self.pbest_positions = self.pbest_positions[:self.population_size]\n            self.pbest_scores = self.pbest_scores[:self.population_size]\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25969 with standard deviation 0.21502.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.16120550841396142, 0.5580784060510338, 0.059786884530789175]}}
{"id": "7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9", "fitness": 0.7589033654809804, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Improve AdaptiveSwarmOptimization by implementing a dynamic evolutionary factor and utilizing a diversity-enhancing mechanism to maintain exploration and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Dynamic cognitive coefficient with linear decrease\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Linear decay for inertia weight\n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n            \n            # Diversity-enhancing mechanism\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75890 with standard deviation 0.02215.", "error": "", "parent_ids": ["ab526fbc-2279-440d-a0dc-faa6dd0f2285"], "operator": null, "metadata": {"aucs": [0.7528854959912046, 0.7885325813545299, 0.7352920190972068]}}
{"id": "d7a9d050-e4d2-4e69-9726-733980d1325d", "fitness": -Infinity, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Introducing a dynamic population size adjustment to maintain diversity and enhance convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Dynamic cognitive coefficient with linear decrease\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Linear decay for inertia weight\n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n            \n            # Diversity-enhancing mechanism with dynamic population size\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.population_size = min(50, self.population_size + 1)\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 13, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {}}
{"id": "4118323b-f099-466f-af32-9124ed0a8f7e", "fitness": 0.32731529406430965, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Introduce a randomized local search step to enhance exploration when diversity drops below a critical level.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Dynamic cognitive coefficient with linear decrease\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Linear decay for inertia weight\n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n            \n            # Diversity-enhancing mechanism\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                # Introduce a local random search step to enhance exploration.\n                self.positions += np.random.uniform(-0.1, 0.1, self.positions.shape) \n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32732 with standard deviation 0.25329.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.1871811849098307, 0.6828764115963799, 0.11188828568671827]}}
{"id": "cb441739-dc0c-4b0c-b45d-ebd5a74d32e3", "fitness": 0.437547734329289, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Introduce boundary reflection and adaptive velocity scaling in EnhancedAdaptiveSwarmOptimization to enhance exploration and convergence control.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Dynamic cognitive coefficient with linear decrease\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Linear decay for inertia weight\n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                adaptive_velocity_scaling = np.clip(self.inertia_weight + np.std(self.positions) / (bounds.ub - bounds.lb).mean(), 0.1, 1.0)\n                \n                self.velocities[i] = (adaptive_velocity_scaling * (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity))\n                self.positions[i] += self.velocities[i]\n                \n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < bounds.lb, bounds.lb + (bounds.lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > bounds.ub, bounds.ub - (self.positions[i] - bounds.ub), self.positions[i])\n            \n            # Diversity-enhancing mechanism\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43755 with standard deviation 0.37625.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.09781010496639708, 0.9620700904292443, 0.2527630075922255]}}
{"id": "f059b9ce-e889-41c0-9198-7fd04da3d2d4", "fitness": 0.7230569199522418, "name": "EnhancedLevyAdaptiveSwarmOptimization", "description": "Improve EnhancedAdaptiveSwarmOptimization by integrating Levy flights to enhance exploration, promoting better exploration-exploitation balance and avoiding local minima.", "code": "import numpy as np\n\nclass EnhancedLevyAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.alpha = 0.01  # Levy flight step size\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def levy_flight(self):\n        # Levy flight calculation using Mantegna's algorithm\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn(self.dim) * sigma\n        v = np.random.randn(self.dim)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            # Levy flight application to improve exploration\n            if eval_count < self.budget:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # 30% chance to apply Levy flight\n                        levy_step = self.alpha * self.levy_flight()\n                        self.positions[i] = np.clip(self.positions[i] + levy_step, bounds.lb, bounds.ub)\n\n            # Diversity-enhancing mechanism\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 16, "feedback": "The algorithm EnhancedLevyAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72306 with standard deviation 0.33701.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.24652954432932062, 0.954219446128401, 0.9684217693990039]}}
{"id": "a906ba5b-2e39-4460-9359-a8b1f5793ed5", "fitness": 0.4277934594810711, "name": "ChaosEnhancedAdaptiveSwarmOptimization", "description": "Implement a nonlinear inertia weight decay and incorporate a chaos-based exploration mechanism to further enhance exploration and convergence rates.", "code": "import numpy as np\n\nclass ChaosEnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        chaos_factor = 0.7  # Initial chaos factor\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Nonlinear decay for inertia weight\n                self.inertia_weight = self.inertia_weight_end + (\n                    self.inertia_weight_start - self.inertia_weight_end\n                ) * ((self.budget - eval_count) / self.budget) ** 2\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n            \n            # Chaos-based exploration mechanism\n            for j in range(self.population_size):\n                if np.random.random() < chaos_factor:\n                    chaos_factor = 4 * chaos_factor * (1 - chaos_factor)  # Logistic map\n                    self.positions[j] = np.clip(\n                        self.positions[j] + chaos_factor * np.random.uniform(-1, 1, self.dim),\n                        bounds.lb, bounds.ub\n                    )\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 17, "feedback": "The algorithm ChaosEnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42779 with standard deviation 0.36526.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.1651057128316289, 0.1739451760357461, 0.9443294895758385]}}
{"id": "8c29afb4-e413-4339-b9f9-8a5438b2047e", "fitness": 0.40663145815783025, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Improved dynamic adjustment of the inertia weight to enhance convergence performance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.95  # Adjusted start value\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                # Dynamic cognitive coefficient with linear decrease\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Linear decay for inertia weight\n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n            \n            # Diversity-enhancing mechanism\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 18, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40663 with standard deviation 0.33042.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.16214626336343463, 0.8737394962839874, 0.18400861482606867]}}
{"id": "10ed5bb4-204b-4d67-b993-12d01464706e", "fitness": 0.30382867945847664, "name": "EnhancedAdaptiveSwarmWithRestarts", "description": "Introduce Adaptive Velocity Control and Randomized Restart to Enhance Adaptive Swarm with balanced exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmWithRestarts:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.restart_threshold = 0.05\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                adaptive_velocity = self.inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity\n                self.velocities[i] = adaptive_velocity\n                self.positions[i] = np.clip(self.positions[i] + adaptive_velocity, bounds.lb, bounds.ub)\n            \n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                if np.random.random() < self.restart_threshold:\n                    self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedAdaptiveSwarmWithRestarts got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30383 with standard deviation 0.23912.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.15883804076784158, 0.640899885874669, 0.11174811173291932]}}
{"id": "10ea3b4c-65ec-4040-99c6-c334fb380001", "fitness": 0.3430995488094976, "name": "AdaptiveLearningSwarmOptimization", "description": "Introduce an adaptive learning factor based on swarm performance and a non-linear inertia weight decay to enhance exploration-exploitation balance in swarm optimization.", "code": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_base = 2.5\n        self.social_coeff_base = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            mean_score = np.mean(self.pbest_scores)\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n\n                # Adaptive learning factor influenced by swarm performance\n                self.cognitive_coeff = self.cognitive_coeff_base * (self.pbest_scores[i] / mean_score)\n                self.social_coeff = self.social_coeff_base * (self.gbest_score / mean_score)\n                \n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Non-linear decay for inertia weight\n                self.inertia_weight = self.inertia_weight_end + \\\n                    (self.inertia_weight_start - self.inertia_weight_end) * \\\n                    np.exp(-5 * eval_count / self.budget)\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n            \n            # Diversity-enhancing mechanism with adaptive threshold\n            diversity = np.std(self.positions, axis=0)\n            adaptive_threshold = 0.1 * (bounds.ub - bounds.lb).mean() * np.exp(-eval_count / self.budget)\n            if np.mean(diversity) < adaptive_threshold:\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 20, "feedback": "The algorithm AdaptiveLearningSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34310 with standard deviation 0.26465.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.7147478290653866, 0.1189560681716264, 0.19559474919147968]}}
{"id": "685102a2-2569-4ccc-bf47-cd27303d26d5", "fitness": 0.12887622773180285, "name": "CooperativeMultiSwarmOptimization", "description": "Introduce a cooperative multi-swarm strategy with adaptive learning rates to improve exploration and exploitation balance for enhanced convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.num_swarms = 3\n        self.swarm_size = self.population_size // self.num_swarms\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for swarm_index in range(self.num_swarms):\n                gbest_swarm_position = None\n                gbest_swarm_score = np.inf\n\n                for i in range(swarm_index * self.swarm_size, (swarm_index + 1) * self.swarm_size):\n                    score = func(self.positions[i])\n                    eval_count += 1\n                    if score < self.pbest_scores[i]:\n                        self.pbest_scores[i] = score\n                        self.pbest_positions[i] = self.positions[i].copy()\n                    if score < gbest_swarm_score:\n                        gbest_swarm_score = score\n                        gbest_swarm_position = self.positions[i].copy()\n\n                if gbest_swarm_score < self.gbest_score:\n                    self.gbest_score = gbest_swarm_score\n                    self.gbest_position = gbest_swarm_position\n\n                for i in range(swarm_index * self.swarm_size, (swarm_index + 1) * self.swarm_size):\n                    r1, r2 = np.random.random(), np.random.random()\n                    self.cognitive_coeff = (\n                        self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                    )\n                    cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                    social_velocity = self.social_coeff * r2 * (gbest_swarm_position - self.positions[i])\n\n                    self.inertia_weight = (\n                        self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                    )\n\n                    self.velocities[i] = (self.inertia_weight * self.velocities[i]\n                                          + cognitive_velocity + social_velocity)\n                    self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            # Diversity-enhancing mechanism\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 21, "feedback": "The algorithm CooperativeMultiSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12888 with standard deviation 0.01421.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.14889670480641548, 0.11730958070959074, 0.12042239767940233]}}
{"id": "1b29fa1c-dfe4-4c0f-a6f0-5ca0295c7478", "fitness": 0.7485189050412453, "name": "EnhancedAdaptiveSwarmOptimizationV2", "description": "Integrate a multi-modal memory mechanism and adaptive velocity adjustment based on swarm diversity to enhance exploration-exploitation balance in swarm optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimizationV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.multi_modal_memory = []\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n            \n            # Dynamic adjustment based on swarm diversity\n            diversity = np.std(self.positions, axis=0)\n            average_diversity = np.mean(diversity)\n            if average_diversity < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n                # Update multi-modal memory\n                if len(self.multi_modal_memory) < 5:  # Store up to 5 best positions\n                    self.multi_modal_memory.append(self.gbest_position.copy())\n                else:\n                    worst_index = max(range(len(self.multi_modal_memory)), key=lambda idx: func(self.multi_modal_memory[idx]))\n                    self.multi_modal_memory[worst_index] = self.gbest_position.copy()\n\n            if eval_count >= self.budget:\n                break\n        \n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimizationV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74852 with standard deviation 0.02791.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.7420170988899293, 0.785483530322463, 0.7180560859113435]}}
{"id": "af9d5ac1-60f1-4802-8005-fd24732d8f0c", "fitness": 0.4654621566851363, "name": "HybridAdaptiveSwarmOptimization", "description": "Introduce a self-adaptive mechanism for inertia weight and hybridize with a local search strategy for improved exploration-exploitation balance and convergence speed.", "code": "import numpy as np\n\nclass HybridAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                \n                # Self-adaptive inertia weight based on performance\n                if score < self.gbest_score:\n                    self.inertia_weight = self.inertia_weight_end\n                else:\n                    self.inertia_weight = self.inertia_weight_start\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n            \n            # Diversity-enhancing mechanism\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n            \n            # Hybridize with a local search\n            if eval_count % 100 == 0:\n                for j in range(self.population_size):\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = np.clip(self.positions[j] + perturbation, bounds.lb, bounds.ub)\n                    candidate_score = func(candidate_position)\n                    eval_count += 1\n                    if candidate_score < self.pbest_scores[j]:\n                        self.pbest_scores[j] = candidate_score\n                        self.pbest_positions[j] = candidate_position.copy()\n                    if candidate_score < self.gbest_score:\n                        self.gbest_score = candidate_score\n                        self.gbest_position = candidate_position.copy()\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 23, "feedback": "The algorithm HybridAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46546 with standard deviation 0.26032.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.17569087747868306, 0.4136852032452789, 0.8070103893314469]}}
{"id": "cb68dbc9-7e71-48c4-a203-feee71913f80", "fitness": -Infinity, "name": "EnhancedAdaptiveMultiSwarmOptimization", "description": "Introduce a dynamic multi-swarm strategy with inter-swarm communication to enhance exploration and exploitation balance in the adaptive swarm optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveMultiSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.num_swarms = 3\n        self.swarm_size = self.population_size // self.num_swarms\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_positions = [None] * self.num_swarms\n        self.gbest_scores = np.full(self.num_swarms, np.inf)\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n\n                swarm_id = i // self.swarm_size\n                if score < self.gbest_scores[swarm_id]:\n                    self.gbest_scores[swarm_id] = score\n                    self.gbest_positions[swarm_id] = self.positions[i].copy()\n\n                r1, r2 = np.random.random(), np.random.random()\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                \n                # Choose gbest from current or neighboring swarm for inter-swarm communication\n                neighbor_swarm_id = (swarm_id + 1) % self.num_swarms\n                if np.random.random() < 0.5:\n                    gbest_position = self.gbest_positions[swarm_id]\n                else:\n                    gbest_position = self.gbest_positions[neighbor_swarm_id]\n                    \n                social_velocity = self.social_coeff * r2 * (gbest_position - self.positions[i])\n\n                self.inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n                \n                self.velocities[i] = (self.inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        best_swarm_id = np.argmin(self.gbest_scores)\n        return self.gbest_positions[best_swarm_id], self.gbest_scores[best_swarm_id]", "configspace": "", "generation": 24, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {}}
{"id": "15fb3d9b-86bc-4557-ae2a-2fd0fff7b3f1", "fitness": 0.7976916595629405, "name": "EnhancedLocalSwarmOptimization", "description": "Introduce adaptive neighborhood search replacing global information with local search inspired by swarm intelligence to enhance exploitation while maintaining diversity.", "code": "import numpy as np\n\nclass EnhancedLocalSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.local_coeff = 1.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n\n                # Find local best position in a small neighborhood\n                neighbors = np.random.choice(self.population_size, size=5, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = (inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity + local_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedLocalSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79769 with standard deviation 0.19791.", "error": "", "parent_ids": ["7f6ba766-fbc4-4ec7-bea7-ebe192dbb8c9"], "operator": null, "metadata": {"aucs": [0.924747518878918, 0.9501443029879338, 0.5181831568219697]}}
{"id": "02ea5b2b-080f-4aa7-a06b-6695ac93e152", "fitness": 0.8889343987483577, "name": "EnhancedLocalSwarmOptimization", "description": "Enhance swarm diversity by adjusting local neighborhood size dynamically to improve search exploration.", "code": "import numpy as np\n\nclass EnhancedLocalSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff = 1.5\n        self.local_coeff = 1.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = (\n                    self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                )\n                inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                )\n\n                # Find local best position in a small neighborhood with dynamic size\n                neighbors_size = int(max(2, 5 - 3 * (eval_count / self.budget)))  # Line changed for dynamic neighborhood\n                neighbors = np.random.choice(self.population_size, size=neighbors_size, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = (inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity + local_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedLocalSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.88893 with standard deviation 0.10278.", "error": "", "parent_ids": ["15fb3d9b-86bc-4557-ae2a-2fd0fff7b3f1"], "operator": null, "metadata": {"aucs": [0.744170675154258, 0.9500570911797405, 0.9725754299110743]}}
{"id": "36b614c9-01ce-4f15-ae68-3778fb7a284e", "fitness": 0.6011655219126463, "name": "AdaptiveDiversitySwarmOptimization", "description": "Introduce adaptive inertia weight and learning rates based on population diversity to enhance convergence in diverse search spaces.", "code": "import numpy as np\n\nclass AdaptiveDiversitySwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff = 2.0\n        self.social_coeff = 2.0\n        self.local_coeff = 1.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n\n                # Adjust inertia weight based on diversity\n                diversity = np.std(self.positions, axis=0)\n                avg_diversity = np.mean(diversity)\n                max_diversity = (bounds.ub - bounds.lb).mean()\n                inertia_weight = (\n                    self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (avg_diversity / max_diversity)\n                )\n\n                # Find local best position in a small neighborhood\n                neighbors_size = int(max(2, 5 - 3 * (eval_count / self.budget)))\n                neighbors = np.random.choice(self.population_size, size=neighbors_size, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = (inertia_weight * self.velocities[i] \n                                      + cognitive_velocity + social_velocity + local_velocity)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            # Reintroduce diversity if stagnation is detected\n            if avg_diversity < 0.1 * max_diversity:\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 27, "feedback": "The algorithm AdaptiveDiversitySwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60117 with standard deviation 0.33600.", "error": "", "parent_ids": ["02ea5b2b-080f-4aa7-a06b-6695ac93e152"], "operator": null, "metadata": {"aucs": [0.14454308598066334, 0.9433380037900144, 0.715615475967261]}}
{"id": "e5221962-823f-4566-ac3f-6d54c4c0fbe4", "fitness": 0.9486252807925729, "name": "AdaptiveSwarmOptimization", "description": "Introduce adaptive learning rates for cognitive and social coefficients based on performance to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff_start = 1.5\n        self.social_coeff_end = 0.5\n        self.local_coeff = 1.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                self.social_coeff = self.social_coeff_start - (self.social_coeff_start - self.social_coeff_end) * (eval_count / self.budget)\n                inertia_weight = self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n\n                neighbors_size = int(max(2, 5 - 3 * (eval_count / self.budget)))\n                neighbors = np.random.choice(self.population_size, size=neighbors_size, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + local_velocity\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 28, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94863 with standard deviation 0.02017.", "error": "", "parent_ids": ["02ea5b2b-080f-4aa7-a06b-6695ac93e152"], "operator": null, "metadata": {"aucs": [0.9232433212869039, 0.9500570911797405, 0.9725754299110743]}}
{"id": "72463272-6406-4da8-b5ed-eb86bf9011ff", "fitness": -Infinity, "name": "AdaptiveSwarmOptimization", "description": "Introduce an adaptive local coefficient and a mutation mechanism for positions to enhance exploration and maintain diversity.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff_start = 1.5\n        self.social_coeff_end = 0.5\n        self.local_coeff_start = 1.0\n        self.local_coeff_end = 0.3\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                self.social_coeff = self.social_coeff_start - (self.social_coeff_start - self.social_coeff_end) * (eval_count / self.budget)\n                inertia_weight = self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n                self.local_coeff = self.local_coeff_start - (self.local_coeff_start - self.local_coeff_end) * (eval_count / self.budget)\n\n                neighbors_size = int(max(2, 5 - 3 * (eval_count / self.budget)))\n                neighbors = np.random.choice(self.population_size, size=neighbors_size, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + local_velocity\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                mutation_prob = 0.1  # Introduce mutation mechanism\n                mutate_mask = np.random.rand(self.population_size, self.dim) < mutation_prob\n                self.positions[mutate_mask] = np.random.uniform(bounds.lb, bounds.ub, size=self.positions[mutate_mask].shape)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 29, "feedback": "An exception occurred: ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (138,) and arg 1 with shape (45,).').", "error": "ValueError('shape mismatch: objects cannot be broadcast to a single shape.  Mismatch is between arg 0 with shape (138,) and arg 1 with shape (45,).')", "parent_ids": ["e5221962-823f-4566-ac3f-6d54c4c0fbe4"], "operator": null, "metadata": {}}
{"id": "519de4d9-9e98-4e82-a3a8-c23d38ddcda3", "fitness": 0.9486252807925729, "name": "EnhancedSwarmOptimization", "description": "Enhance swarm diversity and convergence by introducing dynamic neighborhood topologies and adaptive mutation based on convergence speed.", "code": "import numpy as np\n\nclass EnhancedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff_start = 1.5\n        self.social_coeff_end = 0.5\n        self.local_coeff = 1.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                self.social_coeff = self.social_coeff_start - (self.social_coeff_start - self.social_coeff_end) * (eval_count / self.budget)\n                inertia_weight = self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n\n                neighbors_size = int(max(2, 5 - 3 * (eval_count / self.budget)))\n                neighbors = np.random.choice(self.population_size, size=neighbors_size, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + local_velocity\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                mutation_strength = (self.gbest_score / np.mean(self.pbest_scores)) * (1.0 - eval_count / self.budget)\n                self.positions += mutation_strength * np.random.uniform(-1, 1, self.positions.shape)\n                self.positions = np.clip(self.positions, bounds.lb, bounds.ub)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94863 with standard deviation 0.02017.", "error": "", "parent_ids": ["e5221962-823f-4566-ac3f-6d54c4c0fbe4"], "operator": null, "metadata": {"aucs": [0.9232433212869039, 0.9500570911797405, 0.9725754299110743]}}
{"id": "a2275e70-dddf-4070-aea3-e489948e0b71", "fitness": 0.7041222296608574, "name": "AdaptiveSwarmOptimization", "description": "Introduce a mechanism to occasionally perturb the global best position slightly for increased exploration without affecting convergence stability.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff_start = 1.5\n        self.social_coeff_end = 0.5\n        self.local_coeff = 1.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                self.social_coeff = self.social_coeff_start - (self.social_coeff_start - self.social_coeff_end) * (eval_count / self.budget)\n                inertia_weight = self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n\n                neighbors_size = int(max(2, 5 - 3 * (eval_count / self.budget)))\n                neighbors = np.random.choice(self.population_size, size=neighbors_size, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + local_velocity\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            # Introduce slight perturbation to gbest position for exploration\n            if eval_count % 10 == 0:\n                self.gbest_position += np.random.uniform(-0.01, 0.01, self.dim)\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70412 with standard deviation 0.17474.", "error": "", "parent_ids": ["e5221962-823f-4566-ac3f-6d54c4c0fbe4"], "operator": null, "metadata": {"aucs": [0.550037309852458, 0.9484736539197123, 0.6138557252104017]}}
{"id": "2c062017-e4fa-45c5-9623-1270997d3d90", "fitness": 0.6829410573704546, "name": "EnhancedAdaptiveSwarmOptimization", "description": "Combine adaptive learning rates with diversity preservation through random reinitialization and differential evolution-inspired mutation to enhance exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff_start = 1.5\n        self.social_coeff_end = 0.5\n        self.local_coeff = 1.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n        self.mutation_factor = 0.5\n        self.crossover_ratio = 0.7\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                self.social_coeff = self.social_coeff_start - (self.social_coeff_start - self.social_coeff_end) * (eval_count / self.budget)\n                inertia_weight = self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n\n                neighbors_size = int(max(2, 5 - 3 * (eval_count / self.budget)))\n                neighbors = np.random.choice(self.population_size, size=neighbors_size, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + local_velocity\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n                # Differential evolution-inspired mutation\n                if np.random.rand() < self.crossover_ratio:\n                    a, b, c = np.random.choice(self.population_size, 3, replace=False)\n                    mutant_vector = self.positions[a] + self.mutation_factor * (self.positions[b] - self.positions[c])\n                    self.positions[i] = np.clip(mutant_vector, bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.68294 with standard deviation 0.35096.", "error": "", "parent_ids": ["e5221962-823f-4566-ac3f-6d54c4c0fbe4"], "operator": null, "metadata": {"aucs": [0.18803360273244674, 0.8978154844591246, 0.9629740849197923]}}
{"id": "6335d478-e237-4ba9-8970-8a7ae291f6a2", "fitness": 0.9486252807925729, "name": "AdaptiveSwarmOptimization", "description": "Introduce adaptive inertia weight reset upon stagnation to enhance exploration.", "code": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 30\n        self.inertia_weight_start = 0.9\n        self.inertia_weight_end = 0.4\n        self.cognitive_coeff_start = 2.5\n        self.cognitive_coeff_end = 1.0\n        self.social_coeff_start = 1.5\n        self.social_coeff_end = 0.5\n        self.local_coeff = 1.0\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.positions = None\n        self.pbest_positions = None\n        self.pbest_scores = np.full(self.population_size, np.inf)\n        self.gbest_position = None\n        self.gbest_score = np.inf\n\n    def __call__(self, func):\n        bounds = func.bounds\n        self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n        self.pbest_positions = self.positions.copy()\n\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                score = func(self.positions[i])\n                eval_count += 1\n                if score < self.pbest_scores[i]:\n                    self.pbest_scores[i] = score\n                    self.pbest_positions[i] = self.positions[i].copy()\n                if score < self.gbest_score:\n                    self.gbest_score = score\n                    self.gbest_position = self.positions[i].copy()\n\n                r1, r2, r3 = np.random.random(), np.random.random(), np.random.random()\n                self.cognitive_coeff = self.cognitive_coeff_start - (self.cognitive_coeff_start - self.cognitive_coeff_end) * (eval_count / self.budget)\n                self.social_coeff = self.social_coeff_start - (self.social_coeff_start - self.social_coeff_end) * (eval_count / self.budget)\n                inertia_weight = self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (eval_count / self.budget)\n\n                neighbors_size = int(max(2, 5 - 3 * (eval_count / self.budget)))\n                neighbors = np.random.choice(self.population_size, size=neighbors_size, replace=False)\n                local_best_position = self.pbest_positions[neighbors[np.argmin(self.pbest_scores[neighbors])]]\n\n                cognitive_velocity = self.cognitive_coeff * r1 * (self.pbest_positions[i] - self.positions[i])\n                social_velocity = self.social_coeff * r2 * (self.gbest_position - self.positions[i])\n                local_velocity = self.local_coeff * r3 * (local_best_position - self.positions[i])\n\n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_velocity + social_velocity + local_velocity\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], bounds.lb, bounds.ub)\n\n            diversity = np.std(self.positions, axis=0)\n            if np.mean(diversity) < 0.1 * (bounds.ub - bounds.lb).mean():\n                self.positions = np.random.uniform(bounds.lb, bounds.ub, (self.population_size, self.dim))\n                self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Reset velocities\n\n            if eval_count >= self.budget:\n                break\n\n        return self.gbest_position, self.gbest_score", "configspace": "", "generation": 33, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.94863 with standard deviation 0.02017.", "error": "", "parent_ids": ["e5221962-823f-4566-ac3f-6d54c4c0fbe4"], "operator": null, "metadata": {"aucs": [0.9232433212869039, 0.9500570911797405, 0.9725754299110743]}}
