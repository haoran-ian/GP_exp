{"id": "3aa7a123-c41b-4886-a6b1-2403019d14b7", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm that adaptively balances exploration and exploitation for efficient black-box optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "309812a5-2a74-4dc8-8a57-857431e3f3c8", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhanced the hybrid PSO-DE algorithm by using adaptive parameter tuning to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n            \n            # Adaptive parameter tuning\n            self.c1 = 2.0 - (2.0 - 0.5) * (eval_count / self.budget)  # New line added\n\n        return self.g_best", "configspace": "", "generation": 1, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "16d34b41-421c-4468-bcee-0de3265e55cc", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "A novel hybrid optimization algorithm that slightly increases the cognitive and social coefficients to enhance exploration in a modified PSO and DE framework.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.7  # Cognitive coefficient (increased from 1.5)\n        self.c2 = 1.7  # Social coefficient (increased from 1.5)\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "265d7dd4-652a-490a-b282-e62cd0cac9d7", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhanced HybridPSODE by adjusting the mutation factor for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.9  # Adjusted from 0.8 to 0.9\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "9f5d3f39-3d57-410e-a12a-ac457f70df11", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance exploration by introducing dynamic crossover probability in DE to improve diversity in solution space.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover_prob_dynamic = 0.2 + 0.5 * np.random.rand()  # Changed line\n                crossover = np.random.rand(self.dim) < crossover_prob_dynamic\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "9f657357-74a9-4095-8295-1868e44cb435", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization (PSO) and Differential Evolution (DE) algorithm with an enhanced exploration-exploitation balance through adaptive mutation factor adjustment.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Adaptively adjust mutation factor\n                adaptive_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)\n                mutant = self.pop[a] + adaptive_mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "5fa6e853-13e3-4669-8ef3-e3fa4e4e7c2d", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Improved HybridPSODE algorithm by adjusting the crossover probability to enhance diversity and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9  # Adjusted crossover probability\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "d5a9b838-e914-4d74-8f4c-a1f8e053a13c", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduced velocity inertia to the PSO component of the HybridPSODE algorithm to maintain momentum and improve convergence rate.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n        self.inertia = 0.9  # Added inertia weight\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.inertia * self.vel +  # Applied inertia weight\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "53a4d63f-d1ec-4e10-b1d2-c57c5da6237e", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhanced HybridPSODE with adaptive crossover probability for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                self.crossover_prob = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "629e3cdb-83de-4141-893d-7752bf52567f", "fitness": 0.7033057199457383, "name": "HybridPSODE", "description": "Introducing adaptive velocity control in PSO to dynamically adjust the velocity constraints based on search progress.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.41 on the real problem.", "error": "", "parent_ids": ["3aa7a123-c41b-4886-a6b1-2403019d14b7"], "operator": null, "metadata": {"aucs": [0.9917939931555265, 0.9935969336475616, 0.1245262330341268]}}
{"id": "830eaf4e-30bc-4757-b285-a184d6892605", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Fine-tuning the mutation factor in DE step for balancing exploration and exploitation.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "1491d093-d5e9-436e-90e0-23c1c73eb1d5", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "HybridPSODE with adaptive mutation factor tuned by evaluation count to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            adaptive_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + adaptive_mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 11, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "74f737c2-dac6-48a8-8b7e-3db74a8df7c2", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce inertia weight adjustment in PSO to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            w = 0.5 + (0.9 - 0.5) * (1 - eval_count / self.budget)  # inertia weight adjustment\n            self.vel = (w * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "43691a21-1116-418d-991a-b46c7ff6469e", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Adjust the crossover probability adaptively based on evaluation progress to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < (self.crossover_prob * (1 - eval_count / self.budget))\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 13, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "54b37a02-65fe-4245-acc2-b3202166a028", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Integrate dynamic inertia weight into PSO for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 14, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "f249ecef-68af-4bb7-b08a-5788fa0bc8c1", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Incorporating adaptive cognitive and social coefficients in PSO to enhance convergence by adjusting based on evaluation progress.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Adaptive adjustment of coefficients\n            adaptive_factor = 1 - eval_count / self.budget\n            c1_adaptive = self.c1 * adaptive_factor\n            c2_adaptive = self.c2 * adaptive_factor\n            \n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        c1_adaptive * r1 * (self.p_best - self.pop) +\n                        c2_adaptive * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 15, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "da75ead5-c341-4030-ba18-0961516cfb68", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introducing adaptive inertia weight in PSO to dynamically balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 16, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "fb4af748-ebf0-46ed-8e03-57ffdd9adda1", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Fine-tuning the cognitive and social coefficients adaptively to improve convergence in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 2.0  # Cognitive coefficient (Changed from 1.5 to 2.0)\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 17, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "88ee8221-ff67-4381-8e50-8fbea759e72e", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive mutation factor adjustment in DE based on the search progress to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.8 * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 18, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8981220b-19f9-4187-8bcb-a89fcbd5086b", "fitness": 0.04198322258673167, "name": "HybridPSODE", "description": "Enhanced the velocity control by introducing a dynamic adjustment factor based on fitness improvement to refine PSO's exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            dynamic_factor = 1 + np.mean(self.p_best_scores - scores) / np.std(scores + 1e-10)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget) * dynamic_factor, self.vel_max * (1 - eval_count / self.budget) * dynamic_factor)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.01 on the real problem.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.04948179133305808, 0.023655034250830598, 0.05281284217630633]}}
{"id": "ce715122-4267-4974-adc7-0dd72ef69621", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduced a decreasing inertia weight factor to improve the exploration-exploitation balance in particle velocities.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.7 * eval_count / self.budget)  # New line added\n            self.vel = (inertia_weight * self.vel + \n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 20, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "7aad4c10-1791-4658-9166-1c20ceadff95", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce non-uniform mutation to enhance exploration capability in DE step.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                tau = np.random.rand() * (1 - eval_count / self.budget)  # Non-uniform mutation\n                mutant = self.pop[a] + tau * self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 21, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "47bace7f-3c7f-4367-95ca-fb27d3177895", "fitness": -Infinity, "name": "HybridPSODE", "description": "Introducing a dynamic population size adjustment to enhance diversification and intensification balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Dynamic population size adjustment\n            self.population_size = int(20 + 10 * (1 - eval_count / self.budget))\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 22, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (29,20) (20,20) ').", "error": "ValueError('operands could not be broadcast together with shapes (29,20) (20,20) ')", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {}}
{"id": "b2642f5c-2b76-4b5d-ad19-1c65a6b5312e", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance DE mutation by dynamically adjusting the mutation factor based on search progress.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            dynamic_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)  # Adjusted mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + dynamic_mutation_factor * (self.pop[b] - self.pop[c])  # Use adjusted mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 23, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "54ebfcf8-08e6-49d2-8f4e-74fb1b713144", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance particle attraction by introducing a dynamic inertia weight to balance exploration and exploitation in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.5 + 0.5 * (1 - eval_count / self.budget)\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 24, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "6650c639-3890-42cf-bb5c-8cad7a9957af", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance the mutation factor adaptively in the DE step based on convergence progress for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            self.mutation_factor = 0.8 + 0.2 * (self.g_best_score / np.mean(self.p_best_scores)) # Adapt mutation factor based on convergence\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 25, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "7d647112-f09f-449c-8e95-5482d1009f8e", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive crossover probability in DE step to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            adaptive_crossover_prob = 0.5 + 0.5 * (eval_count / self.budget)  # Adaptive crossover probability\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < adaptive_crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 26, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "1a2fdc17-c451-48f2-8817-9019fa6f94eb", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introducing an elite retention mechanism to retain the best solutions across generations for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n            self.pop[0] = self.g_best  # Retaining the best solution\n\n        return self.g_best", "configspace": "", "generation": 27, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "7cc8671d-9cd5-404a-b949-25650563df34", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Adding dynamic adjustment to the mutation factor in DE based on search progress to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.8 * (1 - eval_count / self.budget)  # Dynamic adjustment\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 28, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "c69bc120-2076-4f7b-bb46-9a1a480c27b0", "fitness": 0.6193062538248911, "name": "HybridPSODE", "description": "Fine-tune the DE crossover probability to allow more exploration by increasing it slightly.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.8  # Fine-tuned crossover probability for better exploration\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.62 with standard deviation 0.37 on the real problem.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.11689915950229957, 0.989203842879899, 0.751815759092475]}}
{"id": "791607c5-19de-453e-880d-ed9dcdf530d1", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive cognitive and social coefficients in HybridPSODE to improve convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n\n            # Introduce adaptive cognitive and social coefficients\n            c1_adaptive = self.c1 * (1 - eval_count / self.budget)\n            c2_adaptive = self.c2 * (eval_count / self.budget)\n\n            self.vel = (self.vel +\n                        c1_adaptive * r1 * (self.p_best - self.pop) +\n                        c2_adaptive * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 30, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3958ff85-b39f-49a7-bffe-e820eb4e0d12", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance strategy by initializing velocities to zero for better convergence at start.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.zeros((self.population_size, self.dim))  # Change: Initialize velocities to zero\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 31, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "a5a3ff12-29a0-45e6-8f23-c5f5b10bab80", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce a dynamic mutation factor in the DE component to enhance exploration capabilities adaptively.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation_factor = self.mutation_factor * (0.5 + 0.5 * (eval_count / self.budget))\n                mutant = self.pop[a] + dynamic_mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 32, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "005d0c23-6300-4fdc-a784-f44c94266d71", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance the balance between exploration and exploitation by adjusting mutation_factor based on search progress.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            self.mutation_factor = 0.5 + 0.3 * (1 - eval_count / self.budget)  # Adjust mutation_factor\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 33, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "38a14bef-6eb6-4524-8ce3-1a5f09eadb37", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance velocity adjustment by implementing a time-varying inertia weight to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - 0.5 * (eval_count / self.budget)  # Adjusted line\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 34, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "7766cbbf-70b4-49c9-99b8-5ba126ec8822", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhanced mutation strategy in DE component to improve diversity and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = np.mean([self.pop[a], self.pop[b], self.pop[c]], axis=0) + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 35, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "7eb74291-4c5d-4acf-959b-090dc8959fcd", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhanced HybridPSODE integrates an adaptive crossover strategy based on individual success rates to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < (self.crossover_prob + (self.p_best_scores[i] / max(self.p_best_scores)))  # Change here\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "449d670c-53d7-4930-97a5-e624ea376614", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introducing stochastic inertia weight adaptation in HybridPSODE to balance exploration and exploitation phases.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.5  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = np.random.uniform(0.5, 0.9)  # Changed line for stochastic inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 37, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "884d24ef-a253-4828-befd-059c73d47020", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhancing HybridPSODE by modifying the cognitive and social coefficients for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 2.0  # Adjusted Cognitive coefficient\n        self.c2 = 2.0  # Adjusted Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 38, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "80f3f74d-fc28-46e5-bba9-03c9a509bd03", "fitness": 0.972317274768881, "name": "HybridPSODE", "description": "Enhance global best influence by slightly increasing the social coefficient in PSO to potentially improve convergence. ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 39, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.97 with standard deviation 0.02 on the real problem.", "error": "", "parent_ids": ["629e3cdb-83de-4141-893d-7752bf52567f"], "operator": null, "metadata": {"aucs": [0.9392516472501015, 0.9945800133579734, 0.9831201636985679]}}
{"id": "0b2bf44c-5fef-4ada-b562-27f10ac818eb", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Utilize adaptive social and cognitive coefficients in PSO for dynamic balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            # Change: Adaptive coefficients based on current iteration\n            self.c1 = 1.5 * (1 - eval_count / self.budget)\n            self.c2 = 1.6 * (eval_count / self.budget)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 40, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "3a00dbc0-88fa-49c3-803e-cb29a5a5888a", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Increase crossover probability in DE to enhance exploration and solution diversity.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.9  # Increased crossover probability\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "b15fe8b4-c1c9-46eb-ba79-837b4cee92f5", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive crossover probability in DE to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < (self.crossover_prob * (1 - eval_count / self.budget))  # Adaptive crossover probability\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 42, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8a96177f-88c1-474f-a6b9-b235820012ad", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Refine the velocity damping factor to improve convergence stability and exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (0.9 * self.vel +  # Changed line for refined damping factor\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 43, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "40051aea-23ee-4985-af42-fc4226cb2a0f", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Slightly adjust the mutation factor in the DE component for a better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 44, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "1e589e6f-bb39-431f-9941-b4368aca81f4", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Slightly increase the mutation factor of the DE component to enhance exploration and improve convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 45, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "b47dd735-efd8-40b1-9fc7-2f9244188e89", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive crossover probability in DE to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            adaptive_crossover_prob = self.crossover_prob * (1 - eval_count / self.budget)  # Adapt crossover probability\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < adaptive_crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 46, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "26a7dff1-090a-44ae-ba43-4e21102cf40c", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Increase cognitive coefficient to improve personal best influence on particle velocity updates.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.7  # Increased cognitive coefficient to 1.7\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 47, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "54c4dad6-1922-4001-ac6a-1c2a7f0584df", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Utilize a dynamic crossover probability based on iteration progress to potentially enhance diversity and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n\n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n\n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n\n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                # Dynamic crossover probability\n                self.crossover_prob = 0.9 - 0.4 * (eval_count / self.budget)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n\n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 48, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "2f034819-6f3d-4e3c-95ca-487d6314252f", "fitness": 0.7143181510508795, "name": "HybridPSODE", "description": "Introduce adaptive velocity scaling in PSO to enhance exploration and exploitation balance over iterations.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            vel_scale = (1 - eval_count / self.budget) * 0.5 + 0.5  # Adaptive velocity scaling\n            self.vel = (self.vel * vel_scale +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max, self.vel_max)\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 49, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.39 on the real problem.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.16482706712908313, 0.9945800133579734, 0.9835473726655819]}}
{"id": "ee427f47-9524-49b5-9cad-6b1542fd784e", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive inertia weight in HybridPSODE to balance exploration and exploitation dynamically.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 50, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "0cae45cd-b60a-42be-b5fc-d6f9297422da", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Slightly increase the crossover probability in the DE component to enhance diversity and exploration capabilities.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.75  # Slightly increased crossover probability\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 51, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "530796ad-a431-46d5-b2fd-b5436e4372b4", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce a time-dependent inertia weight to the PSO component to dynamically balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            w = 0.9 - 0.5 * (eval_count / self.budget)  # Time-dependent inertia weight\n            self.vel = (w * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 52, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "6c0c36d0-8ef4-41e1-9c92-9e0b489bc929", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Slightly increase mutation factor in DE to enhance exploration and potentially discover better solutions.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.85  # Increased mutation factor\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 53, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "1408c853-5449-455e-8a30-568ed0c23ea8", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Increase the crossover probability in the DE step to potentially enhance exploration and diversity in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.8  # Modified crossover probability\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 54, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "2739d019-21d2-422e-879b-070a39076b7e", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce a decay factor for the social coefficient to balance exploration and exploitation in the hybrid PSO-DE algorithm.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            # Change: Introduce decay factor for social coefficient\n            self.c2 = 1.6 * (1 - eval_count / self.budget)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 55, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "be5b5ae3-a7d1-4ff5-8abe-86be042f74c9", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Slightly increase the cognitive coefficient in PSO to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.6  # Cognitive coefficient, slightly increased\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 56, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "39873938-bb28-4b37-b924-30b6161178ce", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce dynamic adjustment of the social coefficient `c2` to balance exploration and exploitation over time.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2_initial = 1.6  # Initial social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Dynamic social coefficient\n            self.c2 = self.c2_initial * (1 - eval_count / self.budget)\n            \n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 57, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "889d5e8c-b3ce-4cf2-a24d-a11d25268663", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce a dynamic mutation factor in DE to improve exploration and convergence balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.vel = (self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + (1 - eval_count / self.budget) * (self.pop[b] - self.pop[c])  # Change here\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 58, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "6b871b72-caf4-42ee-90dd-7c5ae28c3c10", "fitness": 0.9755735341316427, "name": "HybridPSODE", "description": "Introduce adaptive inertia weight to enhance exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 59, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.98 with standard deviation 0.02 on the real problem.", "error": "", "parent_ids": ["80f3f74d-fc28-46e5-bba9-03c9a509bd03"], "operator": null, "metadata": {"aucs": [0.9818937442252589, 0.9961823389581514, 0.948644519211518]}}
{"id": "cab6187f-fa94-4148-b3ce-6ac487723325", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Refine the adaptive inertia weight formula for better exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.3 * eval_count / self.budget)  # Adjusted adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 60, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "526e8d4b-998a-4f8d-bc4a-ae4acd516926", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce dynamic crossover probability to enhance diversity and convergence in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                self.crossover_prob = 0.5 + 0.2 * np.sin(np.pi * eval_count / self.budget)  # Dynamic crossover probability\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 61, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "315375ea-c9b7-4a85-ba9b-76f769b08818", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce a linear decay in the mutation factor to enhance convergence in the HybridPSODE algorithm.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n            # Introducing a linear decay in the mutation factor\n            self.mutation_factor = 0.8 * (1 - eval_count / self.budget)\n\n        return self.g_best", "configspace": "", "generation": 62, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "788af8cc-a2fb-40a1-8455-d47c8dfc3a64", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Slightly adjust the cognitive coefficient to improve individual learning in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.7  # Cognitive coefficient, slightly increased\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 63, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "d700c7d2-d421-4088-9261-18da82ec72c5", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce a dynamic mutation factor in DE to enhance adaptability in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c]) * (1 - eval_count / self.budget)  # Dynamic mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 64, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "4cb94859-840e-4885-8afc-2395dfb402f8", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Fine-tune cognitive coefficient to enhance particle learning in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.6  # Cognitive coefficient, slightly increased\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 65, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "58226ef9-873a-4a43-af77-88ef6024e83f", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance diversity by implementing an adaptive mutation factor based on evaluation progress.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            adaptive_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + adaptive_mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 66, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "9144db75-5099-4d9d-b5b3-f86a26aa35d4", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance adaptive inertia weight effect by increasing its range to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.95 - (0.8 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 67, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8f833bdb-ebfd-4812-9a84-536b8746f26a", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce an adaptive mutation factor to enhance diversity in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + (0.5 + 0.5 * eval_count / self.budget) * (self.pop[b] - self.pop[c])  # Adaptive mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 68, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "edc365bf-09b9-47ab-8fd1-9dd91382c854", "fitness": 0.7037117386187445, "name": "HybridPSODE", "description": "Introduce a decay factor in mutation factor for better convergence in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8  # Mutation factor\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            decay_factor = 1 - (eval_count / self.budget)  # Decay factor for mutation\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * decay_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 69, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.39 on the real problem.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.9678885187284125, 0.9961823389581514, 0.14706435816966934]}}
{"id": "e2cada13-8d02-4a02-86b4-fcebde0489a9", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Incorporate a dynamic mutation factor that adapts based on the evaluation progress to enhance exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + ((1 - eval_count / self.budget) * self.mutation_factor) * (self.pop[b] - self.pop[c])  # Dynamic mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 70, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "ede2d21a-e0f5-4797-9f04-1f881ec26fc3", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Implement an adaptive mutation factor in the DE step to improve convergence in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            adaptive_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + adaptive_mutation_factor * (self.pop[b] - self.pop[c])  # Changed line\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 71, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "fc3f3ef1-f0de-4a55-ac94-d851b8d3a0de", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Fine-tune cognitive and social coefficients to enhance convergence in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.7  # Cognitive coefficient, slightly increased\n        self.c2 = 1.6  # Social coefficient\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 72, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "719b0f48-b13c-4230-b4a9-633f6ab31dae", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Integrate dynamic adjustment of social coefficient in HybridPSODE for improved optimization performance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.c2 = 1.6 - (0.6 * eval_count / self.budget)  # Adjust social coefficient dynamically\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 73, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "195b71b4-1454-4ada-a142-cb80556c87f7", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive mutation factor in the DE component to improve the exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            self.mutation_factor = 0.8 - (0.3 * eval_count / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 74, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8a8f28cb-0642-4b7f-8e20-133cbf037204", "fitness": -Infinity, "name": "HybridPSODE", "description": "Improve global exploration-exploitation by increasing social coefficient slightly.", "code": "class HybridPSODE:\n    def __init__(self, budget, dim):\n        # ... [rest of the code remains unchanged]\n        self.c2 = 1.7  # Social coefficient, slightly increased\n        # ... [rest of the code remains unchanged]", "configspace": "", "generation": 75, "feedback": "An exception occurred: TypeError(\"'HybridPSODE' object is not callable\").", "error": "TypeError(\"'HybridPSODE' object is not callable\")", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {}}
{"id": "851b19ae-f37b-4aa8-8727-e1bf510f5f95", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance global best influence and improve convergence by increasing social coefficient in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.8  # Social coefficient, increased from 1.6\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 76, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8706fa5f-36b3-42ef-8413-2c7aeec71362", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive social coefficient to fine-tune exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        (self.c2 * (0.5 + 0.5 * eval_count / self.budget)) * r2 * (self.g_best - self.pop))  # Adaptive social coefficient\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 77, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "d8e25c38-3c89-495e-a0f4-58c4795502d7", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive mutation factor to balance exploration and exploitation in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + (0.6 + 0.4 * eval_count / self.budget) * (self.pop[b] - self.pop[c])  # Adaptive mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 78, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "a8c82ac4-8483-4711-bcf2-10e2d5026d74", "fitness": 0.7098966092009369, "name": "HybridPSODE", "description": "Refine the strategy by adjusting the cognitive coefficient to improve exploitation in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.3  # Cognitive coefficient, slightly decreased to enhance convergence\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 79, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.39 on the real problem.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.9759479399414668, 0.9931026782109893, 0.16063920945035448]}}
{"id": "a052524a-fca6-4bc9-9c13-ef16a0b1d064", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce dynamic mutation factor scaling to enhance diversity in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            dynamic_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)  # New line: Dynamic mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + dynamic_mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 80, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "65c484e9-4da6-45fd-8a74-dd52d8d21c64", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance global best selection by incorporating an additional criterion based on diversity within the population.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n            if np.std(new_scores) > 0.1 and new_scores[i] < self.g_best_score:  # Add diversity criterion\n                self.g_best_score = new_scores[i]\n                self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 81, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "9b55d542-76b2-4f1d-a096-0c486560e268", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive mutation factor to enhance exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c]) * (1 - eval_count / self.budget)  # Adaptive mutation factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 82, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "b9fa40e4-cf24-43ce-b2de-244725abf87a", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Adjust dynamic crossover probability based on iteration progress to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover_prob_dynamic = 0.3 + 0.4 * (eval_count / self.budget)  # Adjusted line\n                crossover = np.random.rand(self.dim) < crossover_prob_dynamic\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 83, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "d38b037a-3ab1-4ea6-9212-96924c1cb9c2", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance the adaptive inertia weight formula for a smoother transition by adjusting the decay range.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.4 * eval_count / self.budget)  # Adjusted adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 84, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "fc2f17cf-6969-4b55-b38a-6d003911d0b2", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce a dynamic crossover probability for DE to enhance exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                # Dynamic crossover probability\n                self.crossover_prob = 0.7 + 0.2 * (self.g_best_score / np.max(self.p_best_scores))\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 85, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "1531b152-6c30-4bcc-81f6-189574e2b7ac", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Refine the PSO component by dynamically adjusting the social coefficient based on the evaluation count to improve convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.c2 = 1.6 - (0.6 * eval_count / self.budget)  # Dynamically adjusted social coefficient\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 86, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "e35cc3ae-a84d-4bd3-9a42-7847ab8e5295", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance convergence by slightly increasing both cognitive and social coefficients in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.6  # Cognitive coefficient, slightly increased\n        self.c2 = 1.7  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 87, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "1ce2d6f0-fccd-4cf0-906b-5c2ee0abc848", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance global exploration by slightly increasing the cognitive coefficient of the HybridPSODE algorithm.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.6  # Cognitive coefficient, slightly increased\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 88, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "81311e1f-278a-4732-87c1-044db469f3d3", "fitness": 0.7041902190198002, "name": "HybridPSODE", "description": "Adjust the mutation factor in DE dynamically to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                self.mutation_factor = 0.8 - (0.5 * eval_count / self.budget)  # Dynamic mutation factor\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 89, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.39 on the real problem.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.9647183243773094, 0.9961823389581514, 0.15166999372393986]}}
{"id": "74fd6c2f-255f-4e31-8e16-90b46193f59f", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Adjust the mutation factor dynamically to enhance adaptability in exploration and exploitation phases.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            dynamic_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)  # Change line\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + dynamic_mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 90, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "7ff6dd95-67a2-48c3-8f9a-4e5f8e5ad118", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance convergence by adjusting cognitive and social coefficients dynamically based on the current best score.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            self.c1 = 1.5 + (0.5 * (self.g_best_score / np.min(self.p_best_scores)))  # Dynamic adjustment\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 91, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "101cb658-0b99-48a4-ad61-c661efd433fc", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Fine-tune the inertia weight adaptation formula to improve convergence speed in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.4 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 92, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "ba166be4-c2fa-4c03-80d6-d465cc5ad502", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Refine HybridPSODE by utilizing an adaptive mutation factor in the DE step for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            adaptive_mutation = self.mutation_factor * (1 - eval_count / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + adaptive_mutation * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 93, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "c53b1099-70c3-45d9-b128-5fbf25461dc4", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce a dynamic mutation factor that decreases linearly with evaluations to refine exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            current_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + current_mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 94, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "8f03ac5d-d255-4319-9221-c0cad3a16060", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce adaptive mutation factor to enhance the balance between exploration and exploitation in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            adaptive_mutation_factor = 0.8 - (0.4 * eval_count / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + adaptive_mutation_factor * (self.pop[b] - self.pop[c])  # Changed line\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 95, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "12fc1d5e-54fb-4e7c-bc18-a98d3f21c2c6", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Modify the adaptive inertia weight to enhance convergence speed near the end of optimization.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.6 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 96, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "be2dc7be-2c32-4e40-a9df-286b9fd93df3", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Enhance the exploitation phase by reducing the cognitive coefficient of PSO to improve convergence precision.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.3  # Cognitive coefficient, slightly reduced\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 97, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "350e700d-a31e-4cac-9eb3-e979f3bb163b", "fitness": 0.1667166666666666, "name": "HybridPSODE", "description": "Introduce an adaptive mutation factor to further improve exploration-exploitation balance in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.5 * eval_count / self.budget)  # Adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            adaptive_mutation_factor = self.mutation_factor * (1 - eval_count / self.budget)  # Adaptive mutation factor\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + adaptive_mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 98, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.24 on similar problems with similar landscape features.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05, 0.50005, 4.999999999999449e-05, 4.999999999999449e-05]}}
{"id": "da62e9bd-cbbc-4cd2-82ce-4b40b4bcd4bd", "fitness": 0.983903695069516, "name": "HybridPSODE", "description": "Fine-tune adaptive inertia weight calculation to enhance convergence dynamics in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.c1 = 1.5  # Cognitive coefficient\n        self.c2 = 1.6  # Social coefficient, slightly increased\n        self.mutation_factor = 0.8\n        self.crossover_prob = 0.7\n        self.vel_max = (self.upper_bound - self.lower_bound) * 0.2\n        self.pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.vel = np.random.uniform(-self.vel_max, self.vel_max, (self.population_size, self.dim))\n        self.p_best = self.pop.copy()\n        self.p_best_scores = np.full(self.population_size, np.inf)\n        self.g_best = None\n        self.g_best_score = np.inf\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        # Evaluate initial population\n        scores = np.array([func(ind) for ind in self.pop])\n        eval_count += self.population_size\n        \n        # Update personal and global bests\n        for i in range(self.population_size):\n            if scores[i] < self.p_best_scores[i]:\n                self.p_best_scores[i] = scores[i]\n                self.p_best[i] = self.pop[i]\n        \n            if scores[i] < self.g_best_score:\n                self.g_best_score = scores[i]\n                self.g_best = self.pop[i]\n\n        while eval_count < self.budget:\n            # Hybrid step: Perform PSO\n            r1 = np.random.rand(self.population_size, self.dim)\n            r2 = np.random.rand(self.population_size, self.dim)\n            inertia_weight = 0.9 - (0.6 * eval_count / self.budget)  # Modified adaptive inertia weight\n            self.vel = (inertia_weight * self.vel +\n                        self.c1 * r1 * (self.p_best - self.pop) +\n                        self.c2 * r2 * (self.g_best - self.pop))\n            self.vel = np.clip(self.vel, -self.vel_max * (1 - eval_count / self.budget), self.vel_max * (1 - eval_count / self.budget))\n\n            new_pop_pso = self.pop + self.vel\n            new_pop_pso = np.clip(new_pop_pso, self.lower_bound, self.upper_bound)\n\n            # Hybrid step: Perform DE\n            new_pop_de = np.empty_like(self.pop)\n            for i in range(self.population_size):\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.pop[a] + self.mutation_factor * (self.pop[b] - self.pop[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.crossover_prob\n                new_pop_de[i] = np.where(crossover, mutant, self.pop[i])\n\n            # Combine both populations\n            new_pop = (new_pop_pso + new_pop_de) / 2\n            new_pop = np.clip(new_pop, self.lower_bound, self.upper_bound)\n\n            # Evaluate new population\n            new_scores = np.array([func(ind) for ind in new_pop])\n            eval_count += self.population_size\n            \n            # Update personal and global bests\n            for i in range(self.population_size):\n                if new_scores[i] < self.p_best_scores[i]:\n                    self.p_best_scores[i] = new_scores[i]\n                    self.p_best[i] = new_pop[i]\n\n                if new_scores[i] < self.g_best_score:\n                    self.g_best_score = new_scores[i]\n                    self.g_best = new_pop[i]\n\n            self.pop = new_pop\n\n        return self.g_best", "configspace": "", "generation": 99, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.98 with standard deviation 0.01 on the real problem.", "error": "", "parent_ids": ["6b871b72-caf4-42ee-90dd-7c5ae28c3c10"], "operator": null, "metadata": {"aucs": [0.9818937442252589, 0.9961823389581514, 0.9736350020251381]}}
