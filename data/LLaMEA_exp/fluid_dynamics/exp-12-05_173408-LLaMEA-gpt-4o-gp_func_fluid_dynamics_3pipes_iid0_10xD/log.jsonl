{"id": "69159491-e9fc-4dd2-b41e-b287799e2a45", "fitness": -Infinity, "name": "CooperativeMultiSwarmOptimizer", "description": "A multi-swarm cooperative particle optimization algorithm that dynamically adjusts exploration and exploitation through inter-swarm communication to efficiently solve black box optimization problems.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = None\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5\n        c1 = 1.5\n        c2 = 1.5\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 0, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 117, in evaluate_gp_func\n    np.random.seed(rep)\n  File \"<string>\", line 57, in __call__\n  File \"<string>\", line 33, in _update_particles\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n.", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")Traceback (most recent call last):\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 188, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/home/ubuntu/GP_Compare/LLaMEA/llamea/llamea.py\", line 247, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"scripts/5_algorithm_generation.py\", line 117, in evaluate_gp_func\n    np.random.seed(rep)\n  File \"<string>\", line 57, in __call__\n  File \"<string>\", line 33, in _update_particles\nTypeError: unsupported operand type(s) for -: 'NoneType' and 'float'\n", "parent_ids": [], "operator": null, "metadata": {}}
{"id": "d699d62a-7b2b-4146-9672-1d4251940712", "fitness": 0.06362717640284514, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer that initializes the global best position correctly to avoid NoneType errors and improve optimization stability.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5\n        c1 = 1.5\n        c2 = 1.5\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 1, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["69159491-e9fc-4dd2-b41e-b287799e2a45"], "operator": null, "metadata": {"aucs": [0.07850941915238296, 0.056980959944222365, 0.06290763294039536, 0.059621305615746634, 0.053460777994400965, 0.05878303648998573, 0.07050202487144208, 0.06234188516475836, 0.06953754545227175]}}
{"id": "0228a44d-1c67-4fec-bbb1-b8cf963c913a", "fitness": 0.06271871891016517, "name": "CooperativeMultiSwarmOptimizer", "description": "Improved swarm cooperation by enhancing best position sharing among swarms.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5\n        c1 = 1.5\n        c2 = 1.5\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        # Minor change here: use global best directly to attract swarms\n                        if other_swarm_best < self.global_best_value:\n                            self._update_particles(swarm, self.global_best_position)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 2, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["d699d62a-7b2b-4146-9672-1d4251940712"], "operator": null, "metadata": {"aucs": [0.06390280608898069, 0.050374121152707674, 0.06195896087280861, 0.06961581842870301, 0.04887478048896465, 0.057987220926753236, 0.0866778299768024, 0.056522669062262665, 0.06855426319350366]}}
{"id": "180ff821-367d-4a4f-9809-293823088fbd", "fitness": 0.06546025387671552, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer that adjusts the inertia weight dynamically based on evaluations to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.5\n        c2 = 1.5\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 3, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["d699d62a-7b2b-4146-9672-1d4251940712"], "operator": null, "metadata": {"aucs": [0.0707248754646046, 0.05228160357170253, 0.06455448752128645, 0.06563583678515472, 0.057001351396630096, 0.06025890013273394, 0.07980175313303695, 0.06727341252362473, 0.07161006436166562]}}
{"id": "fbca2c2f-e9f2-45b1-bd57-13928a8ab58f", "fitness": 0.06774681327895249, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adjusted cognitive and social coefficients for improved convergence speed.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 4, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["180ff821-367d-4a4f-9809-293823088fbd"], "operator": null, "metadata": {"aucs": [0.06645811966792126, 0.06747607961979074, 0.06623668182613429, 0.06213015785045195, 0.06292354528351407, 0.0613533877803597, 0.07411704114931394, 0.07510962200086868, 0.07391668433221776]}}
{"id": "dd9037ca-edfa-42d4-b7c0-7b3d7e513ce1", "fitness": 0.06534737093654171, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with tweaked inertia weight dynamics for adaptive exploration and exploitation balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.9 - 0.5 * (self.evaluations / self.budget)  # Tweaked inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 5, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["fbca2c2f-e9f2-45b1-bd57-13928a8ab58f"], "operator": null, "metadata": {"aucs": [0.0615554306939925, 0.06487785871569185, 0.05928190516136356, 0.06319415552492802, 0.06062283847908778, 0.0592314753283828, 0.0773669041426096, 0.07181572348115217, 0.07018004690166713]}}
{"id": "78ba7c00-f1bc-4973-8d75-2a495fe2d2a5", "fitness": 0.06683330174110155, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced the cooperation mechanism by slightly increasing the influence of the best swarm positions on others to improve convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, 1.05 * other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 6, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["fbca2c2f-e9f2-45b1-bd57-13928a8ab58f"], "operator": null, "metadata": {"aucs": [0.06239690565840217, 0.059752434804613785, 0.07284801531391738, 0.06081776951295548, 0.05684592040915859, 0.06750085773108183, 0.07218649385004983, 0.06664074145646715, 0.0825105769332678]}}
{"id": "949b4bef-3f22-4a13-a7cd-64d6cde84621", "fitness": 0.06535266576255097, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with adaptive social coefficient for better convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8\n        c2 = 1.2 + 0.3 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 7, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_ids": ["fbca2c2f-e9f2-45b1-bd57-13928a8ab58f"], "operator": null, "metadata": {"aucs": [0.06498065145093124, 0.06513908457061823, 0.06333984935725245, 0.060291605078081956, 0.06082680484167946, 0.0591921005947742, 0.072108857477575, 0.07224537331379499, 0.07004966517825117]}}
{"id": "759d9e45-ef1d-4b04-850a-a6d3e20706b6", "fitness": 0.06477535718740973, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with dynamically adapted social coefficients for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 0.8 + 0.4 * (self.evaluations / self.budget)  # Dynamically adapted social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 8, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["fbca2c2f-e9f2-45b1-bd57-13928a8ab58f"], "operator": null, "metadata": {"aucs": [0.07139477903462377, 0.06304121899065052, 0.05708621316660878, 0.0663342258951577, 0.058900078488116736, 0.05353249843331809, 0.08027359492927788, 0.06989828446606428, 0.06251732128286991]}}
{"id": "e03f74ed-a7c1-402c-86d3-c3f63d997608", "fitness": 0.05582490670165969, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced particle velocity adjustment using adaptive coefficients for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        c3 = 0.3  # New adaptive coefficient based on evaluations\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n            + c3 * (np.random.rand(self.num_particles, self.dim) - 0.5)  # Adaptive component\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 9, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["fbca2c2f-e9f2-45b1-bd57-13928a8ab58f"], "operator": null, "metadata": {"aucs": [0.06028986610978371, 0.05727020730566146, 0.04871670110703996, 0.056394337884818846, 0.05310861959734137, 0.0459010020758307, 0.06636250884121098, 0.061743129092912796, 0.052637788300337385]}}
{"id": "2b13a813-925a-42bf-898f-35da3994aacc", "fitness": 0.0670276768658294, "name": "CooperativeMultiSwarmOptimizer", "description": "An enhanced cooperative multi-swarm optimizer with a dynamic adjustment in social coefficient for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.0 + 0.2 * (self.evaluations / self.budget)  # Dynamic social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 10, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["fbca2c2f-e9f2-45b1-bd57-13928a8ab58f"], "operator": null, "metadata": {"aucs": [0.07549926523426609, 0.06648554168968435, 0.0538301738656215, 0.0699526344333753, 0.06203501910037157, 0.05364194891528684, 0.08539114107522483, 0.07389292589541963, 0.06252044158321457]}}
{"id": "3e78bf94-ca34-47d1-ad8f-e257710f1478", "fitness": 0.07305638552563085, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with enhanced global best update strategy for improved exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 11, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["fbca2c2f-e9f2-45b1-bd57-13928a8ab58f"], "operator": null, "metadata": {"aucs": [0.07185092490823708, 0.078892679106361, 0.07137135294322194, 0.05982565230249992, 0.07088004915071389, 0.06609502175976212, 0.07077463547925844, 0.08693644440619985, 0.0808807096744234]}}
{"id": "6fcaf041-3bb0-4ab9-82a7-b10fa6e89f6f", "fitness": -Infinity, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with dynamic inter-swarm cooperation for improved convergence speed and accuracy.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8\n        c2 = 1.2\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        np.clip(swarm['positions'] += swarm['velocities'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 12, "feedback": "An exception occurred: SyntaxError('invalid syntax', ('<string>', 35, 36, \"        np.clip(swarm['positions'] += swarm['velocities'], self.lower_bound, self.upper_bound, out=swarm['positions'])\\n\")).", "error": "SyntaxError('invalid syntax', ('<string>', 35, 36, \"        np.clip(swarm['positions'] += swarm['velocities'], self.lower_bound, self.upper_bound, out=swarm['positions'])\\n\"))", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {}}
{"id": "b3bf7138-b68f-4487-86fd-e898ff108a4f", "fitness": 0.07065508945866741, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with adaptive learning rate and regional best sharing for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8   \n        c2 = 1.2  \n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        # Adaptive learning rate\n        adaptive_factor = 0.1 * (1 - self.global_best_value / float('inf'))\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Regional best sharing strategy\n                local_best_positions = [swarm['best_positions'][np.argmin(swarm['best_values'])] for swarm in self.swarms]\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            regional_best_pos = local_best_positions[np.argmin([np.min(swarm['best_values']) for swarm in self.swarms])]\n                            self._update_particles(swarm, regional_best_pos)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 13, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06994833860901184, 0.09014184881815679, 0.05737345639318725, 0.06935873851846242, 0.06874047141847983, 0.05137693432043644, 0.08545326321628532, 0.0835799102871424, 0.059922843546844407]}}
{"id": "4b6d8db9-8509-4875-8409-cb176aad1bef", "fitness": 0.06394713731031829, "name": "CooperativeMultiSwarmOptimizer", "description": "An adaptive multi-swarm optimizer with dynamic exploration-exploitation balance for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.4 + 0.5 * (1 - self.evaluations / self.budget)  # Adapted inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.15 * np.random.uniform(-1, 1, self.dim)  # Improved mutation factor\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 14, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06760852269083883, 0.06786653608212201, 0.054765342942855955, 0.06301425286521012, 0.06222502236396521, 0.05117680650833001, 0.07534970083165793, 0.07417370585609184, 0.059344345651792696]}}
{"id": "470abd35-7433-419a-8ad7-887085cc7b9a", "fitness": 0.07305638552563085, "name": "CooperativeMultiSwarmOptimizer", "description": "An adaptive multi-swarm optimizer utilizing diversity-based regrouping for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n        self.regroup_threshold = 0.5  # New threshold for regrouping\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8\n        c2 = 1.2\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def _regroup_swarms(self):\n        for swarm in self.swarms:\n            if np.var(swarm['positions']) < self.regroup_threshold:\n                swarm['positions'] = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n            self._regroup_swarms()\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 15, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07185092490823708, 0.078892679106361, 0.07137135294322194, 0.05982565230249992, 0.07088004915071389, 0.06609502175976212, 0.07077463547925844, 0.08693644440619985, 0.0808807096744234]}}
{"id": "e8d47640-b9e4-4818-8465-c16f80a62026", "fitness": 0.06791169253964162, "name": "CooperativeMultiSwarmOptimizer", "description": "An enhanced cooperative multi-swarm optimizer with improved swarm cooperation for better convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Reduced perturbation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 16, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06693903191429729, 0.07186469695826558, 0.06179579180807082, 0.06242290844065368, 0.0668417870443514, 0.057789650136984005, 0.07449053992800392, 0.08055580533531248, 0.06850502129083536]}}
{"id": "3d5d348e-c431-46ec-81c9-655906560c38", "fitness": 0.0656281935407841, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with improved diversity and convergence using adaptive particle influence and random restarts.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.4 + 0.3 * (1 - self.evaluations / self.budget)  # Adjusted dynamic inertia weight\n        c1 = 1.5  # Reduced cognitive coefficient\n        c2 = 1.5  # Enhanced social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities']\n            + c1 * r1 * (swarm['best_positions'] - swarm['positions'])\n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation and diversity\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n                # Random restarts for diversity\n                if self.evaluations < self.budget and np.random.rand() < 0.05:\n                    restart_particle = np.random.randint(self.num_particles)\n                    swarm['positions'][restart_particle] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 17, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06379584174965713, 0.06411344959094356, 0.06303693885087291, 0.06346412204251384, 0.0598900349764413, 0.058941455838157686, 0.07659246051592161, 0.07116168193725114, 0.0696577563652977]}}
{"id": "45211d30-ffb2-474b-9ec2-b01d364cd461", "fitness": 0.0713784129426409, "name": "CooperativeMultiSwarmOptimizer", "description": "Improve the swarm cooperation by dynamically adjusting towards the best swarm's position for enhanced exploration.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, np.mean([other_swarm['best_positions'][np.argmin(other_swarm['best_values'])], swarm['best_positions'][np.argmin(swarm['best_values'])]], axis=0))  # Modified line\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 18, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.0711242083041076, 0.0853052187601041, 0.05625835151215852, 0.06044899510365476, 0.07823657178894694, 0.05486473052824814, 0.07164572139739134, 0.10007671325003709, 0.06444520583911961]}}
{"id": "9fe8a6b9-e696-4ff4-bb8e-7ab60cb6e254", "fitness": 0.06277531763195766, "name": "CooperativeMultiSwarmOptimizer", "description": "An improved cooperative multi-swarm optimizer with adaptive cognitive and social coefficients for enhanced search balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.5 + 0.5 * (self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.5 - 0.3 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 19, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.0680882772502982, 0.05695157337680823, 0.06490786934519377, 0.05821741529169189, 0.05343108545570174, 0.06058150457191336, 0.0684593630364817, 0.06228172208648608, 0.07205904827304399]}}
{"id": "b9b97c22-9f6b-4a94-82b9-049b14c49e8f", "fitness": 0.06256673475483025, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced Cooperative Multi-Swarm Optimizer with Adaptive Swarm and Strategy Adjustment for Improved Exploration and Exploitation Balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.5 + 0.5 * np.sin(self.evaluations * np.pi / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.5 - 0.3 * np.cos(self.evaluations * np.pi / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 20, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.061404645473610686, 0.058496560959512944, 0.05884668888279454, 0.05859392155875931, 0.058290660595448185, 0.05924438763813322, 0.06934102796446329, 0.06865623622113715, 0.07022648349961291]}}
{"id": "bc0e0001-ee66-4e07-94dc-a6ad7c54e637", "fitness": 0.06807949993607208, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive velocity update for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w_min, w_max = 0.4, 0.9  # New range for inertia weight\n        w = w_max + (w_min - w_max) * (self.evaluations / self.budget)  # Adaptive inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 21, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06829378713407175, 0.07804537362762287, 0.05831941158449139, 0.05865361035259509, 0.07229165601405663, 0.05464218156974254, 0.0692421981109912, 0.08917027932234034, 0.06405700170873696]}}
{"id": "410f8b49-cc68-4d61-933d-871aec076ea8", "fitness": 0.06834134494681711, "name": "CooperativeMultiSwarmOptimizer", "description": "An adaptive multi-swarm optimizer utilizing feedback-based inertia and hierarchical collaboration for enhanced convergence and exploration.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _adaptive_inertia(self, swarm, global_best_position):\n        feedback = np.mean([np.linalg.norm(p - global_best_position) for p in swarm['positions']])\n        return max(0.4, 0.9 - feedback / 10)\n\n    def _update_particles(self, swarm, global_best_position):\n        w = self._adaptive_inertia(swarm, global_best_position)\n        c1 = 1.8  # Kept constant\n        c2 = 1.2  # Kept constant\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Reduced noise\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 22, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07840625936069578, 0.06543716801553834, 0.05666027279347807, 0.07178890395022397, 0.06110021797422027, 0.05415355669400279, 0.0910955656013065, 0.07254937743372258, 0.06388078269816566]}}
{"id": "d08c6b19-7986-43e3-aa47-a5e3276d2f3a", "fitness": 0.06993423539630184, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhance the global best position update with a larger random perturbation to encourage better exploration.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.2 * np.random.uniform(-1, 1, self.dim)  # Increase perturbation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 23, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06952446296496984, 0.07489909372181969, 0.0649910823418891, 0.06469863314850077, 0.06545921487278572, 0.06047543158310131, 0.07771984890441885, 0.07885802305403455, 0.07278232797519668]}}
{"id": "b73012e5-541a-49f1-a36f-7af4653d4b21", "fitness": 0.07305638552563085, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with enhanced global best update strategy for improved exploration and convergence, now including global best momentum for refined convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n        self.global_best_momentum = np.zeros(self.dim)  # Added momentum for global best\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                # Incorporate momentum in the global best update\n                self.global_best_position += self.global_best_momentum * 0.1 \n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 24, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07185092490823708, 0.078892679106361, 0.07137135294322194, 0.05982565230249992, 0.07088004915071389, 0.06609502175976212, 0.07077463547925844, 0.08693644440619985, 0.0808807096744234]}}
{"id": "7ded4762-724b-42d0-9fd0-3a0907f77b87", "fitness": 0.06718057387165853, "name": "CooperativeMultiSwarmOptimizer", "description": "Improved multi-swarm optimizer using adaptive coefficients for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8 - 0.5 * (self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.2 + 0.5 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 25, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06913300407623946, 0.07451496700524685, 0.05626856791639456, 0.06429415659720716, 0.06694444501853791, 0.05275281230452544, 0.07749847213328254, 0.08154607519347201, 0.061672664600020854]}}
{"id": "dbf24f58-f085-4ba1-840b-cf8dcd356713", "fitness": 0.0471695335073949, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive learning rates and diversity enhancement for improved exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8 \n        c2 = 1.2 \n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        diversity = np.std(swarm['positions'], axis=0)  # Calculate diversity\n        w = w * (1 + diversity / self.dim)  # Adjust inertia weight based on diversity\n\n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 26, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.054913112898759775, 0.04306229892335789, 0.04261284293731127, 0.05160768372052871, 0.04068529094093898, 0.04025142932351222, 0.05972656150031774, 0.04610400970895723, 0.04556257161287025]}}
{"id": "43bef0ab-2817-4473-ba81-32bf563de7f8", "fitness": 0.06993423539630184, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive learning rates for enhanced balance between exploration and exploitation.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.2 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 27, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06952446296496984, 0.07489909372181969, 0.0649910823418891, 0.06469863314850077, 0.06545921487278572, 0.06047543158310131, 0.07771984890441885, 0.07885802305403455, 0.07278232797519668]}}
{"id": "3dea5082-e82f-4c15-8a79-9a8e78f22828", "fitness": 0.06611473366454812, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with a jitter mechanism to enhance local search and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n        \n            # Add jitter\n            swarm['positions'][i] += 0.01 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 28, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06534385763748518, 0.07253848536642005, 0.057513698787976075, 0.06098735757464069, 0.06736484527505904, 0.05388173484298331, 0.07250140441246933, 0.08176196703373417, 0.06313925205016524]}}
{"id": "7dfb9f31-67f7-44c1-a500-b816aa1a91ff", "fitness": 0.06130622474139957, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive mutation for enhanced exploration and faster convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n        \n        # Apply adaptive mutation\n        mutation_rate = 0.1 * (1 - self.evaluations / self.budget)\n        mutation = mutation_rate * np.random.uniform(-1, 1, swarm['positions'].shape)\n        swarm['positions'] += mutation\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 29, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07097153422485925, 0.0609543688823414, 0.05358637040409453, 0.05732555539476114, 0.056888409162467846, 0.05416238568641829, 0.06733754629536481, 0.06707075662742812, 0.06345909599486077]}}
{"id": "8f34652c-33c3-4478-afd1-11b0cceed641", "fitness": 0.0698976166380132, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive inertia and enhanced swarm cooperation for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.9 - 0.5 * (self.evaluations / self.budget)  # Swap dynamic inertia weight\n        c1 = 1.8\n        c2 = 1.2\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + 0.05 * np.random.uniform(-1, 1, self.dim))\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 30, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06261974187153363, 0.0744960142664618, 0.06882629528979212, 0.058565760493674235, 0.06901794504076231, 0.06358203329549139, 0.06918004046212645, 0.08422018726497438, 0.07857053175730244]}}
{"id": "8f178813-c14b-4f7e-94c7-ef2d5411e581", "fitness": 0.06808567205978065, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced interaction strategy with adaptive swarm influence to improve convergence and exploration balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions with adaptive influence\n                            influence = 0.5 + 0.5 * (self.evaluations / self.budget)\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] * influence)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 31, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.0627351434684017, 0.07939313545095328, 0.05650456775861423, 0.06222799197536344, 0.07184189143071185, 0.05369498947063012, 0.07417151204697325, 0.08932897107218751, 0.06287284586419051]}}
{"id": "6986605d-99b6-4dc2-90a7-a66c29b559ad", "fitness": 0.06332861201829797, "name": "CooperativeMultiSwarmOptimizer", "description": "Cooperative multi-swarm optimizer with adaptive dynamic inertia for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.7 + 0.2 * (1 - self.evaluations / self.budget)  # Adjusted dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 32, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06415471612949575, 0.07378502326764758, 0.05259690005086115, 0.05995589551637359, 0.06438402292269652, 0.0496798071347766, 0.07093682872277463, 0.07699068489897953, 0.057473629521076375]}}
{"id": "dfc688c2-50c2-420a-84f2-2a1a7fde6af2", "fitness": 0.063223584502986, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperation and exploration in a multi-swarm optimizer by adjusting velocity update strategy.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.6 + 0.3 * (1 - self.evaluations / self.budget)  # Adjusted dynamic inertia weight\n        c1 = 2.0  # Adjusted cognitive coefficient\n        c2 = 1.0  # Adjusted social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 33, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06935142007202988, 0.06826217186807926, 0.04950203081769189, 0.06462509857042564, 0.0635625805030019, 0.046622198726343766, 0.07729724433288143, 0.07622026405114679, 0.05356925158527348]}}
{"id": "ee32850a-122f-441a-b4b2-1298af50e3af", "fitness": 0.06837994667765077, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with enhanced exploration by introducing a small random perturbation to the global best position.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim) + 0.05 * np.random.normal(0, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 34, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06909331038662325, 0.0719097898218658, 0.060801469052156554, 0.06424964514418252, 0.06684524815203385, 0.05718649366763007, 0.07741757701028329, 0.08068702123847526, 0.06722896562560632]}}
{"id": "dacda752-6db6-40ef-a11f-57a27c62f52d", "fitness": 0.06073397982553107, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperation between swarms through adaptive information sharing to improve convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + 0.05 * np.random.uniform(-1, 1, self.dim))\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 35, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.05992070881155298, 0.0672029384170072, 0.05159997389819437, 0.05613644651160021, 0.06268086401990991, 0.05029546881796576, 0.06579003142643658, 0.07469540969092048, 0.05828397683619213]}}
{"id": "2c508172-cfb8-45b7-b165-d7e66bb7b84c", "fitness": 0.0650854875930008, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced Cooperative Multi-Swarm Optimizer with adaptive social coefficient scaling for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2 + 0.3 * np.random.rand()  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 36, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.05781984025803344, 0.0625040988412977, 0.062318116866839524, 0.06690119126688132, 0.05869874007218312, 0.05804283510437125, 0.08156413400089868, 0.06970027438609239, 0.06822015754040978]}}
{"id": "5ef888a3-e012-47d3-b2a8-36ecfbc0deba", "fitness": 0.0659415680933541, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with improved particle update logic based on dynamic parameters for better exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 2.0  # Adjusted cognitive coefficient\n        c2 = 1.0  # Adjusted social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 37, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07311099421711997, 0.0714641446488482, 0.05568621498640236, 0.06092160276291714, 0.06641426428883823, 0.05248448032190434, 0.07210401667567179, 0.08024649406572393, 0.061041900872760846]}}
{"id": "3765446f-2c26-48eb-b56c-fb614328a5c2", "fitness": 0.06864887742132696, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with adaptive coefficients for better convergence and exploration balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 2.0 - 0.4 * (self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.0 + 0.4 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 38, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07233228144812509, 0.0786499806020875, 0.05252627924764608, 0.06718755696890677, 0.0726832085643192, 0.047949276837607635, 0.08136704753590907, 0.08978886127610586, 0.05535540431123542]}}
{"id": "16b1c8c5-45f9-4ed2-8f3e-0f35b2f288c0", "fitness": 0.06874060809890009, "name": "CooperativeMultiSwarmOptimizer", "description": "Improved exploration and exploitation balance by dynamically adjusting coefficients and enhancing cooperation between swarms.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.5 + 0.3 * np.random.rand()  # Adjusted cognitive coefficient for exploration\n        c2 = 1.5 - 0.3 * np.random.rand()  # Adjusted social coefficient for exploitation\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, 0.5 * (other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + swarm['best_positions'][np.argmin(swarm['best_values'])]))\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 39, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07309211646291192, 0.05984988082190079, 0.06936914682025996, 0.06878236347334821, 0.05541766234923373, 0.06449170011864691, 0.08505479579478514, 0.0647931234420207, 0.0778146836069934]}}
{"id": "9ae82f55-718b-4c43-8ac0-bb5d10caa842", "fitness": 0.06539240359132076, "name": "CooperativeMultiSwarmOptimizer", "description": "Introduced a diversity-preserving mechanism by jittering best positions to avoid premature convergence in the cooperative multi-swarm optimizer.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position + 0.01 * np.random.uniform(-1, 1, self.dim)  # Jitter best position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 40, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06375571071388486, 0.0678479401916835, 0.056755430162303555, 0.05629365855388879, 0.0721467519646447, 0.0532040459324199, 0.06597245772426052, 0.09036011013582035, 0.062195526942980583]}}
{"id": "21743578-61dd-485f-b87c-4b79d76e4a8c", "fitness": 0.06486935541956619, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced Cooperative Multi-Swarm Optimizer with adaptive velocity scaling for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8\n        c2 = 1.2\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        # Adaptive velocity scaling\n        velocity_scale = 0.1 + 0.9 * (1 - self.evaluations / self.budget)\n        swarm['velocities'] = velocity_scale * (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 41, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06999683366618203, 0.07648730182355823, 0.045929424639061356, 0.06507307337688539, 0.06202589285841431, 0.05145725913035937, 0.0784884120310625, 0.0741200344402615, 0.060245966810311025]}}
{"id": "b1a93db9-620b-4c7e-8f4e-556e0ee5f64b", "fitness": 0.06073397982553107, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with stochastic attraction to global best for improved diversity.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + 0.05 * np.random.uniform(-1, 1, self.dim))\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 42, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.05992070881155298, 0.0672029384170072, 0.05159997389819437, 0.05613644651160021, 0.06268086401990991, 0.05029546881796576, 0.06579003142643658, 0.07469540969092048, 0.05828397683619213]}}
{"id": "f4e1ae46-f0b6-4f77-9f99-79ade88c17a6", "fitness": 0.06314851261324347, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with adaptive cognitive and social coefficients for better convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.5 + 0.3 * (self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.5 - 0.3 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 43, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06552647788683619, 0.05966329810830073, 0.06176819578272441, 0.061093352220869424, 0.05585346751103504, 0.05781572097511367, 0.0729364364952515, 0.06565939936809129, 0.06802026517096904]}}
{"id": "69247486-ac4e-4c68-8534-e76796ec265c", "fitness": 0.06800731784888574, "name": "CooperativeMultiSwarmOptimizer", "description": "Introduce a dynamic adaptation mechanism for the cognitive and social coefficients to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8 - 0.8 * (self.evaluations / self.budget)  # Dynamic cognitive coefficient\n        c2 = 1.2 + 0.8 * (self.evaluations / self.budget)  # Dynamic social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 44, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06451273314089456, 0.073852021433368, 0.06370489974045412, 0.06023619522882051, 0.06845304562642152, 0.05587801493522504, 0.07149174890115306, 0.08336902992008599, 0.07056817171354879]}}
{"id": "dc4fbce3-20c3-404e-b6c0-a941c8c5ffcb", "fitness": 0.06171109146397594, "name": "CooperativeMultiSwarmOptimizer", "description": "An enhanced cooperative multi-swarm optimizer using adaptive coefficients and random perturbations for improved exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.9 - 0.5 * (self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 2.0 - (1.5 * self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 2.0 + (1.5 * self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            perturbation = np.random.normal(0, 0.1, self.dim)\n                            attract_position = other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + perturbation\n                            self._update_particles(swarm, attract_position)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 45, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.061645763395573594, 0.058624884459649085, 0.06300851288195974, 0.05749870163810855, 0.054287672454923386, 0.05894652210838358, 0.06848013806267028, 0.06338230719843807, 0.06952532097607711]}}
{"id": "27241d1e-e00c-4cdc-8263-5c0118a5d517", "fitness": 0.06458014581818818, "name": "CooperativeMultiSwarmOptimizer", "description": "An improved cooperative multi-swarm optimizer using adaptive coefficients and dynamic swarm interactions for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  \n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  \n        c1 = 1.5 + 0.5 * (self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.5 - 0.3 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 46, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07361431660662521, 0.05557978456034296, 0.0622512132875539, 0.06731369740811444, 0.052147517175201386, 0.05820854483844584, 0.08256446841694964, 0.06078101633567956, 0.06876075373478063]}}
{"id": "3fda7cd2-df42-4a80-8070-b322acad81e5", "fitness": 0.06774681327895249, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with a refined enhancement in the global best update strategy for improved exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8\n        c2 = 1.2\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position  # Removed random perturbation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 47, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06645811966792126, 0.06747607961979074, 0.06623668182613429, 0.06213015785045195, 0.06292354528351407, 0.0613533877803597, 0.07411704114931394, 0.07510962200086868, 0.07391668433221776]}}
{"id": "3678633c-a0ce-4610-a79b-7b34cfcedc42", "fitness": 0.06791169253964162, "name": "CooperativeMultiSwarmOptimizer", "description": "Cooperative multi-swarm optimizer with a refined global best update strategy for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Refined update strategy\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 48, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06693903191429729, 0.07186469695826558, 0.06179579180807082, 0.06242290844065368, 0.0668417870443514, 0.057789650136984005, 0.07449053992800392, 0.08055580533531248, 0.06850502129083536]}}
{"id": "1c490073-a04a-43f5-8481-852a458ad180", "fitness": 0.0471695335073949, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced multi-swarm optimizer with adaptive velocity adjustments and swarm-centric cooperation mechanism.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))  # Reduced initial velocity range\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.4 + 0.5 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.6  # Adjusted cognitive coefficient\n        c2 = 1.4  # Adjusted social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Fine-tuned perturbation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 49, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.054913112898759775, 0.04306229892335789, 0.04261284293731127, 0.05160768372052871, 0.04068529094093898, 0.04025142932351222, 0.05972656150031774, 0.04610400970895723, 0.04556257161287025]}}
{"id": "aeb07f3b-fd26-40f3-ba38-0071d2bce2fd", "fitness": 0.05858870185308773, "name": "CooperativeMultiSwarmOptimizer", "description": "Improved the swarm cooperation strategy by dynamically adjusting the attraction factor towards other swarms' best positions for enhanced convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            attraction_factor = 0.1 + 0.9 * (1 - self.evaluations / self.budget)  # Dynamic adjustment\n                            for p_idx in range(self.num_particles):\n                                swarm['positions'][p_idx] += attraction_factor * (other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] - swarm['positions'][p_idx])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 50, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06342413334524155, 0.058387982568195884, 0.05095520992801472, 0.058357128191923735, 0.057041515868809456, 0.04795046622812016, 0.06897580179147722, 0.0670094953204955, 0.05519658343551137]}}
{"id": "7e911b99-283a-4e50-a96b-4753955f1c5a", "fitness": 0.0471695335073949, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced multi-swarm optimizer with adaptive parameters and focused swarm cooperation for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))  # Adjusted velocity range\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.6 + 0.3 * (1 - self.evaluations / self.budget)  # Modified inertia weight\n        c1 = 1.5  # Adjusted cognitive coefficient\n        c2 = 1.5  # Adjusted social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Reduced random perturbation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best_position = other_swarm['best_positions'][np.argmin(other_swarm['best_values'])]\n                        # Focused cooperation on best known positions\n                        self._update_particles(swarm, other_swarm_best_position)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 51, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.054913112898759775, 0.04306229892335789, 0.04261284293731127, 0.05160768372052871, 0.04068529094093898, 0.04025142932351222, 0.05972656150031774, 0.04610400970895723, 0.04556257161287025]}}
{"id": "b1b334a0-02ff-4350-8465-7e99ff83cd2d", "fitness": 0.06051207546768828, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced swarm cooperation by incorporating random perturbation to improve exploration.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms with random perturbation\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions with added randomness\n                            perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + perturbation)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 52, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06053032247068835, 0.06485228599167314, 0.05501382436271807, 0.05669036302186514, 0.06058318615718561, 0.050324475632820165, 0.06651757532911229, 0.07176472871082007, 0.058331917532311706]}}
{"id": "0a99e703-4605-4de2-93b5-0a5716fdec43", "fitness": 0.06367173895762106, "name": "CooperativeMultiSwarmOptimizer", "description": "Introduced a stochastic element in the swarm's velocity update to enhance exploration and potentially improve convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n            + 0.05 * np.random.uniform(-1, 1, swarm['velocities'].shape)  # Stochastic element added\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 53, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06392588593089088, 0.07065208157902125, 0.05590445328847082, 0.057153820747938955, 0.06558541537730811, 0.05247720929845512, 0.0671541671822461, 0.07913456708586886, 0.061058050128389385]}}
{"id": "ea6f0c3f-53f0-4ef4-9593-032b8c7a36ec", "fitness": 0.06319612430628319, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with dynamic swarm size adjustment for enhanced adaptability and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        np.clip(swarm['velocities'], -2, 2, out=swarm['velocities'])  # Limit velocities\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 54, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06814467383352196, 0.05676018770656355, 0.06444729286850548, 0.06352878896644021, 0.053255510201419165, 0.057261683103856265, 0.07596932493259101, 0.06207655092168618, 0.06732110622196485]}}
{"id": "868d5d2b-b7d6-48f6-a5dd-c9d804b6a420", "fitness": 0.06444779429812648, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive learning rates for enhanced convergence and diversity management.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.4 + 0.5 * (1 - self.evaluations / self.budget)  # Adjusted inertia weight\n        c1 = 1.9  # Adjusted cognitive coefficient\n        c2 = 1.3  # Adjusted social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 55, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.02.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06481762480467934, 0.07973731052502742, 0.04892307750490821, 0.06058528655332096, 0.07340022424285231, 0.041579914896053616, 0.0717612703708107, 0.09193086178316157, 0.04729457800232428]}}
{"id": "4ef0f518-474a-4a3d-beed-7ea23dc1d4bc", "fitness": 0.062661431639421, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive inter-swarm learning and enhanced exploration using random perturbations for robust convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.5  # Adjusted cognitive coefficient\n        c2 = 1.5  # Adjusted social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            perturbation = np.random.normal(0, 0.1, self.dim)\n                            best_position_with_perturbation = other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + perturbation\n                            self._update_particles(swarm, best_position_with_perturbation)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 56, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06140475729309347, 0.05855332605689434, 0.06516305878899398, 0.058368813600931824, 0.055969950444987204, 0.059323773208664, 0.06945915509840794, 0.06598487663753994, 0.06972517362527642]}}
{"id": "68e12ec7-b245-4315-a8c7-e8b105b87ffc", "fitness": 0.06494994801854419, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced exploration-exploitation balance in Cooperative Multi-Swarm Optimizer by adjusting cognitive and social coefficients.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.7  # Changed cognitive coefficient (previously 1.8)\n        c2 = 1.3  # Changed social coefficient (previously 1.2)\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 57, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06472435516808606, 0.07265995441239248, 0.055023539695584156, 0.060270933556904716, 0.06624822780929929, 0.0517810776401505, 0.07147666095072247, 0.08199812216133162, 0.06036666077242636]}}
{"id": "a1c06450-a5b5-4e17-9489-71b495e9c4c7", "fitness": 0.06184424941747345, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced multi-swarm optimizer leveraging dynamic attraction to global and cooperative best positions for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.15 * np.random.uniform(-1, 1, self.dim)  # Slightly increased randomness\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 58, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06395866009284257, 0.06534448870747489, 0.05379698284962764, 0.05961150233694312, 0.06108431560452965, 0.05050028625165859, 0.07113064192385787, 0.07246239665699561, 0.05870897033333111]}}
{"id": "2b1af8b2-d753-4148-ba7a-735df1d54c95", "fitness": 0.061777148989372414, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative swarm optimizer with adaptive parameters for improved convergence and exploration balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim) \n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.6 + 0.3 * np.cos(0.5 * np.pi * self.evaluations / self.budget)\n        c1 = 2.0 - 0.8 * (self.evaluations / self.budget)\n        c2 = 1.5  \n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 59, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06101681826291927, 0.056774013314236926, 0.06518509604814515, 0.05714628665355925, 0.05328234445465185, 0.06088990173713826, 0.06737971478838345, 0.06208268961462915, 0.07223747603068842]}}
{"id": "8e49896a-90fb-4691-9c8a-ff50018c71e2", "fitness": 0.06781129231057786, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with adaptive inter-swarm communication to improve convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms with adaptive strategy\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Increase influence from better performing swarm\n                            adapt_factor = 0.3 * (other_swarm_best / (swarm['best_values'].mean() + 1e-8))\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + adapt_factor)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 60, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06607554223046497, 0.07536978908853409, 0.054822970794832004, 0.06182149373592738, 0.08108240579847681, 0.051755253679973134, 0.07409662046691257, 0.08408087124028174, 0.06119668375979814]}}
{"id": "db5870c5-f2c4-4e4d-98d8-3c66ac931f98", "fitness": 0.06594194321579042, "name": "CooperativeMultiSwarmOptimizer", "description": "An improved multi-swarm optimizer with enhanced cooperation by selectively sharing best positions among swarms for optimized convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Reduced perturbation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm and np.min(other_swarm['best_values']) < np.min(swarm['best_values']):  # Selective sharing\n                        other_swarm_best_position = other_swarm['best_positions'][np.argmin(other_swarm['best_values'])]\n                        self._update_particles(swarm, other_swarm_best_position)\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 61, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06874852722153446, 0.06262016564996509, 0.06294958235175441, 0.06399861477044821, 0.05965818510940546, 0.05851127651306798, 0.07681814427498734, 0.0706359539706859, 0.06953703908026487]}}
{"id": "ada247b4-0f88-4a1c-9e82-ca92123cf209", "fitness": 0.07042455230704434, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with a fine-tuned inertia weight formula for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.9 - 0.7 * (self.evaluations / self.budget)  # Fine-tuned inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 62, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06612289002018779, 0.08585606436951465, 0.05652876579494348, 0.06152840525485215, 0.07875936795231442, 0.05163169711159088, 0.0734810786213318, 0.09984692881052148, 0.060065772828142405]}}
{"id": "4eb8516f-861c-43da-9ff6-52ce8152a15a", "fitness": 0.07305638552563085, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with dynamic exploration-exploitation balance using adaptive coefficients for improved performance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                c1 = 1.5 + 0.5 * np.cos(0.5 * np.pi * self.evaluations / self.budget)  # Modified line for adaptive c1\n                c2 = 1.5 + 0.5 * np.sin(0.5 * np.pi * self.evaluations / self.budget)  # Modified line for adaptive c2\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 63, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07185092490823708, 0.078892679106361, 0.07137135294322194, 0.05982565230249992, 0.07088004915071389, 0.06609502175976212, 0.07077463547925844, 0.08693644440619985, 0.0808807096744234]}}
{"id": "04c5e777-3f39-48c7-b6ad-fd7095c7e0c6", "fitness": 0.07276113384812738, "name": "CooperativeMultiSwarmOptimizer", "description": "An enhanced cooperative multi-swarm optimizer with dynamic cognitive and social coefficients for improved adaptability and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8 - 0.6 * (self.evaluations / self.budget)  # Dynamic cognitive coefficient\n        c2 = 1.2 + 0.6 * (self.evaluations / self.budget)  # Dynamic social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 64, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.0799190063370161, 0.07421267757112715, 0.06139464107218828, 0.07343653331250677, 0.0666083697266644, 0.05741070009815985, 0.09285206817991498, 0.08124174283641183, 0.067774465499157]}}
{"id": "f2b1beac-965e-464b-bf0e-7ea8d2423132", "fitness": 0.06495601011253159, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced Cooperative Multi-Swarm Optimizer leveraging adaptive learning rates for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 2.0 - 0.8 * (self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 0.8 + 0.4 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 65, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06900452586894346, 0.06846289602396227, 0.05160966057584715, 0.07160727258790966, 0.06360069506568056, 0.04348001783251276, 0.09029569446581087, 0.07695393242404369, 0.049589396168073896]}}
{"id": "056f5a6b-2a79-4f84-8bd6-3fbcb42d43ec", "fitness": 0.06620771711631218, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced multi-swarm optimizer with adaptive learning rates for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8 + 0.2 * np.random.rand()  # Modified to include adaptive cognitive coefficient\n        c2 = 1.2 + 0.3 * np.random.rand()  # Modified to include adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 66, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06303752942633889, 0.060340599164621644, 0.07240419344150828, 0.05890299753073236, 0.056521961240078245, 0.06719344813745032, 0.06973775127892823, 0.06622286527132293, 0.0815081085558288]}}
{"id": "e53c4b62-6d95-4233-8b6e-8de9ec475d66", "fitness": 0.07305638552563085, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with enhanced global best update strategy for improved exploration and convergence, now with adaptive swarm count based on remaining budget.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = max(1, int(num_swarms * (budget / 1000)))  # Adaptive swarm count\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 67, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07185092490823708, 0.078892679106361, 0.07137135294322194, 0.05982565230249992, 0.07088004915071389, 0.06609502175976212, 0.07077463547925844, 0.08693644440619985, 0.0808807096744234]}}
{"id": "827e165c-5a7f-487f-925c-127ca9bfcee4", "fitness": 0.07305638552563085, "name": "CooperativeMultiSwarmOptimizer", "description": "CooperativeMultiSwarmOptimizer with rejuvenation strategy to prevent stagnation by redistributing particles.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        stagnation_threshold = 0.01  # New line for rejuvenation threshold\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n                # Rejuvenation strategy to prevent stagnation\n                if np.std(swarm['best_values']) < stagnation_threshold:  # Change in condition for rejuvenation\n                    swarm['positions'] = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))  # Reset positions\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 68, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07185092490823708, 0.078892679106361, 0.07137135294322194, 0.05982565230249992, 0.07088004915071389, 0.06609502175976212, 0.07077463547925844, 0.08693644440619985, 0.0808807096744234]}}
{"id": "6baeddc5-2b4e-40fb-9055-62bc712cf825", "fitness": 0.06962360745919845, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive social learning to balance exploration and exploitation.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2 + 0.8 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 69, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07334428971195017, 0.07255482549888059, 0.05882641600700933, 0.06788252977280296, 0.06734287144184203, 0.05704360391958263, 0.08330636595429108, 0.08170633976949349, 0.06460522505693378]}}
{"id": "b97d8d8a-d0fc-424d-b7c0-c17a30a898d8", "fitness": 0.06753976178325963, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with enhanced cooperation using global best blending and adaptive velocity scaling for refined exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        # Line changed for adaptive velocity scaling\n        adaptive_velocity = np.random.uniform(0.8, 1.2, (self.num_particles, self.dim))\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        ) * adaptive_velocity\n        \n        # Line changed for better exploration\n        swarm['positions'] += swarm['velocities'] + np.random.normal(0, 0.1, swarm['positions'].shape)\n        \n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                # Line changed for global best blending\n                self.global_best_value = value\n                self.global_best_position = 0.9 * position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 70, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06679105580292366, 0.06315778840844521, 0.07209601323853732, 0.058979811536013504, 0.05905333589440531, 0.06689436520052205, 0.06975102455678028, 0.06976910093679245, 0.08136536047491683]}}
{"id": "9048635e-4fbe-4c68-b2c6-30f977cf0a77", "fitness": 0.06614164656924731, "name": "CooperativeMultiSwarmOptimizer", "description": "Refinement of the CooperativeMultiSwarmOptimizer using an adaptive cognitive coefficient to enhance convergence precision.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8 - 0.5 * (self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 71, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07110144380141348, 0.07636499318447554, 0.05192185378879721, 0.06054358692597683, 0.07072533998453434, 0.049346316930032885, 0.07177337551077045, 0.08638737713433153, 0.05711053186289361]}}
{"id": "a10877b2-fb93-49ab-bad3-1818044323ea", "fitness": 0.06791169253964162, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer enhanced by modified mutation for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Modified mutation\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 72, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06693903191429729, 0.07186469695826558, 0.06179579180807082, 0.06242290844065368, 0.0668417870443514, 0.057789650136984005, 0.07449053992800392, 0.08055580533531248, 0.06850502129083536]}}
{"id": "7aa31d51-9054-456b-84cf-23831a3dbced", "fitness": 0.0, "name": "CooperativeMultiSwarmOptimizer", "description": "An enhanced cooperative multi-swarm optimizer with adaptive learning rates and noise-injected global best update for improved exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        # Adaptive learning rates based on swarm's performance\n        c1 *= 1 + 0.5 * (swarm['best_values'].mean() / self.global_best_value)\n        c2 *= 1 + 0.5 * (self.global_best_value / swarm['best_values'].mean())\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                # Inject noise into global best position update\n                self.global_best_position = position + 0.15 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 73, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "236696a7-b547-48fb-a2b7-6a7250e1015f", "fitness": 0.06785451442221563, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with adaptive global best perturbation to enhance exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                perturbation = 0.1 * (1 - self.evaluations / self.budget)  # Adaptive perturbation\n                self.global_best_position = position + perturbation * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 74, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06797957233341456, 0.07768421629456213, 0.054969641402397795, 0.06338974408172893, 0.07180025199534257, 0.050935820560319756, 0.0761113696756569, 0.08855985844782788, 0.059260155008690196]}}
{"id": "78125d46-ff37-40b9-9e04-976680ca74dc", "fitness": 0.061398061940831555, "name": "CooperativeMultiSwarmOptimizer", "description": "An adaptive exploration-exploitation balance in the CooperativeMultiSwarmOptimizer improves performance by dynamically adjusting the cognitive and social coefficients.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8 * (1 - self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.2 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 75, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06909526819743061, 0.05451585742751108, 0.05752799536410347, 0.06316415222812888, 0.0519175958408824, 0.05580667713443699, 0.07536908455322322, 0.0602770696616276, 0.06490885706013971]}}
{"id": "7095e020-6498-4533-8dcd-7e720816d0c9", "fitness": 0.06791169253964162, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with a more adaptive global best update to enhance convergence accuracy.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 76, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06693903191429729, 0.07186469695826558, 0.06179579180807082, 0.06242290844065368, 0.0668417870443514, 0.057789650136984005, 0.07449053992800392, 0.08055580533531248, 0.06850502129083536]}}
{"id": "be90cbc6-54e3-4991-b910-79035997c456", "fitness": 0.0, "name": "CooperativeMultiSwarmOptimizer", "description": "Improved Cooperative Multi-Swarm Optimizer with adaptive learning rates and contextual swarm cooperation for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.5 + 0.3 * (np.mean(swarm['best_values']) / self.global_best_value)  # Adaptive cognitive coefficient\n        c2 = 1.5 - 0.3 * (np.mean(swarm['best_values']) / self.global_best_value)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 77, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "47855a98-7350-4cba-8576-e905d5b6607c", "fitness": 0.061398061940831555, "name": "CooperativeMultiSwarmOptimizer", "description": "Introduced adaptive learning factors to improve the balance between exploration and exploitation in multi-swarm particle update strategy.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8 * (1 - self.evaluations / self.budget)  # Adaptive cognitive coefficient\n        c2 = 1.2 * (self.evaluations / self.budget)  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 78, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06909526819743061, 0.05451585742751108, 0.05752799536410347, 0.06316415222812888, 0.0519175958408824, 0.05580667713443699, 0.07536908455322322, 0.0602770696616276, 0.06490885706013971]}}
{"id": "0aa5d54c-c516-4c4f-aeee-bba9bcc3bfa7", "fitness": 0.06580037486663372, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced global best update strategy by adjusting the global best's influence on particle updates for improved convergence speed.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position + 0.05 * np.random.uniform(-1, 1, self.dim) - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 79, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07148416179422068, 0.06873273429726323, 0.054424273192853256, 0.06640662614859383, 0.06378449104618167, 0.051101048154719275, 0.08035730610216074, 0.07649077096998769, 0.05942196209372308]}}
{"id": "00d6b154-4e8c-43b0-9562-24c133374942", "fitness": 0.0667067851969682, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with adaptive learning coefficients for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.5 + 0.5 * np.random.rand()  # Adaptive cognitive coefficient\n        c2 = 1.0 + 0.4 * (1 - np.random.rand())  # Adaptive social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 80, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06681873723546006, 0.06269598396812226, 0.07050241395846857, 0.06139520425383127, 0.058631286486848344, 0.06244380339446076, 0.07402041695672146, 0.06920198087588103, 0.07465123964291998]}}
{"id": "cfe1923a-1db4-4aac-8a62-00a3faea1167", "fitness": 0.06791169253964162, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with a refined learning strategy for faster convergence by enhancing local search capabilities.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Adjusted for enhanced local search\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 81, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06693903191429729, 0.07186469695826558, 0.06179579180807082, 0.06242290844065368, 0.0668417870443514, 0.057789650136984005, 0.07449053992800392, 0.08055580533531248, 0.06850502129083536]}}
{"id": "31b6deb2-6c41-45e9-9064-f9ffecfa9174", "fitness": 0.06864639404857298, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with enhanced local search capabilities through adaptive mutation and diversity maintenance to improve convergence rates.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _mutate(self, position):\n        mutation_strength = 0.1 * (1 - self.evaluations / self.budget)\n        mutation = mutation_strength * np.random.uniform(-1, 1, self.dim)\n        return position + mutation\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        c1 = 1.8\n        c2 = 1.2\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = self._mutate(swarm['positions'][i])\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 82, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06463107911666699, 0.06679515730463159, 0.06304273484300504, 0.06927039642392296, 0.06233966616592057, 0.05533711443300304, 0.09733448075987194, 0.07428487695130037, 0.06478204043883429]}}
{"id": "51e6f5ab-029f-466b-a69e-91beec443914", "fitness": 0.06494994801854419, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with a fine-tuned balance between cognitive and social factors for enhanced convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.7  # Fine-tuned cognitive coefficient\n        c2 = 1.3  # Fine-tuned social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 83, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06472435516808606, 0.07265995441239248, 0.055023539695584156, 0.060270933556904716, 0.06624822780929929, 0.0517810776401505, 0.07147666095072247, 0.08199812216133162, 0.06036666077242636]}}
{"id": "8218825c-c8f5-4aee-91ac-778d337e7d86", "fitness": 0.06791169253964162, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced cooperative multi-swarm optimizer with improved global best attraction strategy for better convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Reduced step size for better accuracy\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 84, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06693903191429729, 0.07186469695826558, 0.06179579180807082, 0.06242290844065368, 0.0668417870443514, 0.057789650136984005, 0.07449053992800392, 0.08055580533531248, 0.06850502129083536]}}
{"id": "776c652c-a635-4ac2-ba45-2ebdcbe16a98", "fitness": 0.0, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced Multi-Swarm Optimizer with Adaptive Global Attraction and Fine-Tuned Learning Rates for Efficient Exploration and Exploitation.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.3 * (1 - self.evaluations / self.budget)  # Adjusted dynamic inertia weight\n        c1 = 1.6  # Fine-tuned cognitive coefficient\n        c2 = 1.4  # Fine-tuned social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        adaptive_attraction = 0.9 + 0.1 * (self.global_best_value / (1 + np.abs(self.global_best_value)))\n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + adaptive_attraction * c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 85, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00 with standard deviation 0.00.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]}}
{"id": "7e7cb558-6929-4657-855c-28986de17462", "fitness": 0.06848784641588944, "name": "CooperativeMultiSwarmOptimizer", "description": "An enhanced cooperative multi-swarm optimizer with refined inter-swarm cooperation mechanism for improved exploration.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, 0.5 * (other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + self.global_best_position))\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 86, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06157064713826543, 0.07558256490797777, 0.06227501458171314, 0.061001994796922476, 0.0700411973621674, 0.05786450642404117, 0.07249574685737559, 0.08571900514389463, 0.06983994053064735]}}
{"id": "3f0e8a41-621e-469c-8419-b47c4c89d6ca", "fitness": 0.062032161580893336, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with stochastic velocity adjustment for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        # Modified line for stochastic velocity adjustment\n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n            + 0.1 * np.random.uniform(-1, 1, (self.num_particles, self.dim))  # Add stochastic term\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 87, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06200515048019384, 0.06735248868866128, 0.05166747106130842, 0.0578106611505087, 0.06274970498771504, 0.05245420168528181, 0.06804418409014956, 0.07511176294884825, 0.06109382913537309]}}
{"id": "7528f16f-220e-4409-b364-af2655fc401f", "fitness": 0.06073397982553107, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced swarm cooperation by adjusting velocity based on proximity to the best-known position of other swarms.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])] + 0.05 * np.random.uniform(-1, 1, self.dim))\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 88, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.05992070881155298, 0.0672029384170072, 0.05159997389819437, 0.05613644651160021, 0.06268086401990991, 0.05029546881796576, 0.06579003142643658, 0.07469540969092048, 0.05828397683619213]}}
{"id": "f4473ebf-86b6-4dfa-98e7-abca2b1fa2d3", "fitness": 0.05966788020888772, "name": "CooperativeMultiSwarmOptimizer", "description": "An enhanced cooperative multi-swarm optimizer with adaptive cooperation strength based on swarm performance differential.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8\n        c2 = 1.2\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        cooperation_strength = np.exp(-abs(other_swarm_best - swarm['best_values'].mean()))  # Change 1\n                        if other_swarm_best < (swarm['best_values'].mean() * cooperation_strength):  # Change 2\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 89, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06818912516181153, 0.06275497637903105, 0.04875320698561847, 0.061974252897314064, 0.05871032882520455, 0.044491873075871546, 0.07194536561231346, 0.06922069971537148, 0.0509710932274533]}}
{"id": "ab0cb210-a847-4381-ad70-d192a7207a74", "fitness": 0.06791169253964162, "name": "CooperativeMultiSwarmOptimizer", "description": "Refined global best position attractor logic for better swarm convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 90, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06693903191429729, 0.07186469695826558, 0.06179579180807082, 0.06242290844065368, 0.0668417870443514, 0.057789650136984005, 0.07449053992800392, 0.08055580533531248, 0.06850502129083536]}}
{"id": "24baba02-1ad2-4043-9c7e-cd771442dd1a", "fitness": 0.06805650725215162, "name": "CooperativeMultiSwarmOptimizer", "description": "A refined cooperative multi-swarm optimizer using dynamic strategy adaptation and mutation-based diversification for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.4 + 0.3 * np.exp(-5 * self.evaluations / self.budget)  # Adaptive inertia weight\n        c1 = 2.0  # Increased cognitive coefficient\n        c2 = 1.0  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 91, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06549775841774919, 0.07685640620199452, 0.0588885263432688, 0.06118467039545816, 0.07074727898319688, 0.05492485775764644, 0.07241751136509367, 0.08776167074684083, 0.06422988505811611]}}
{"id": "a0cc52f3-1abf-4e71-9e50-2e983a90932b", "fitness": -Infinity, "name": "CooperativeMultiSwarmOptimizer", "description": "A cooperative multi-swarm optimizer with enhanced global best update strategy and dynamic swarm cooperation for improved exploration and convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values']) + np.random.randint(-1, 2)])  # Add random perturbation for diversity\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 92, "feedback": "An exception occurred: IndexError('index 10 is out of bounds for axis 0 with size 10').", "error": "IndexError('index 10 is out of bounds for axis 0 with size 10')", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {}}
{"id": "eef38070-6de1-4703-a5b5-8121ef421988", "fitness": 0.06218102789992698, "name": "CooperativeMultiSwarmOptimizer", "description": "A refined cooperative multi-swarm optimizer with adaptive cognitive and social coefficients for enhanced convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)\n        # Adaptive cognitive and social coefficients\n        c1 = 1.5 + 0.3 * np.sin(self.evaluations / self.budget * np.pi)\n        c2 = 1.5 + 0.3 * np.cos(self.evaluations / self.budget * np.pi)\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 93, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06714243771036132, 0.054796130307058766, 0.06217070644056899, 0.06246440546008525, 0.05146334449626144, 0.058206329882153796, 0.0751793361291847, 0.05974502430792805, 0.06846153636574048]}}
{"id": "e41f58d9-f00e-47d3-ae69-095bd5e793a9", "fitness": 0.06791169253964162, "name": "CooperativeMultiSwarmOptimizer", "description": "Modified global best update strategy to enhance exploitation when approaching the target.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # Initialize to avoid NoneType\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.4 * (1 - self.evaluations / self.budget)  # Dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Reduced noise for finer adjustment\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                # Encourage cooperation between swarms\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            # Attract swarm towards other swarm's best known positions\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 94, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06693903191429729, 0.07186469695826558, 0.06179579180807082, 0.06242290844065368, 0.0668417870443514, 0.057789650136984005, 0.07449053992800392, 0.08055580533531248, 0.06850502129083536]}}
{"id": "8899e855-882c-4224-8f6d-f23c308a6769", "fitness": 0.07062919131435105, "name": "CooperativeMultiSwarmOptimizer", "description": "An improved cooperative multi-swarm optimizer with adaptive learning strategy for enhanced local and global search balance.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.9 - 0.5 * (self.evaluations / self.budget)  # Adjusted dynamic inertia weight\n        c1 = 2.0  # Slightly increased cognitive coefficient\n        c2 = 1.5  # Increased social coefficient\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        local_temp_best_value = float('inf')  # Add a local best tracker\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < local_temp_best_value:  # Track local best\n                local_temp_best_value = value\n            \n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n        \n        # Ensure cooperation based on local best\n        for other_swarm in self.swarms:\n            if local_temp_best_value < np.min(other_swarm['best_values']):\n                other_swarm['positions'] += 0.1 * (swarm['best_positions'] - other_swarm['positions'])\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 95, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.07023197153796668, 0.06968050455526398, 0.06808050820708433, 0.06533934171279421, 0.0651563440904056, 0.06346364152575379, 0.07895235774069331, 0.0789231208638892, 0.07583493159530841]}}
{"id": "916655d0-0cd0-42aa-9903-f1ff0546ce54", "fitness": 0.07438541343440103, "name": "CooperativeMultiSwarmOptimizer", "description": "An improved cooperative multi-swarm optimizer with dynamic adaptation for better exploration and convergence within a limited budget.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.4 + 0.5 * np.random.rand()  # Randomized dynamic inertia weight\n        c1 = 1.6  # Adjusted cognitive coefficient for better local search\n        c2 = 1.4  # Adjusted social coefficient for improved cooperation\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 96, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["3e78bf94-ca34-47d1-ad8f-e257710f1478"], "operator": null, "metadata": {"aucs": [0.06964326331110993, 0.08070136852166199, 0.0690687834596474, 0.0647022735704138, 0.07335187586613112, 0.0617357549072558, 0.07821650411428793, 0.09852016818994325, 0.07352872896915807]}}
{"id": "1b33baf9-a374-4692-946a-6714fda30106", "fitness": 0.06818081055338844, "name": "CooperativeMultiSwarmOptimizer", "description": "An enhanced cooperative multi-swarm optimizer with a minor adjustment to the global best position update for better convergence under limited budget constraints.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.4 + 0.5 * np.random.rand()  # Randomized dynamic inertia weight\n        c1 = 1.6  # Adjusted cognitive coefficient for better local search\n        c2 = 1.4  # Adjusted social coefficient for improved cooperation\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.05 * np.random.uniform(-1, 1, self.dim)  # Slight adjustment\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 97, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["916655d0-0cd0-42aa-9903-f1ff0546ce54"], "operator": null, "metadata": {"aucs": [0.0701529317530416, 0.05645239247759948, 0.07442783806176023, 0.0650753301531215, 0.05300028734040163, 0.06882285906998564, 0.07915572364002876, 0.061742711554113705, 0.0847972209304434]}}
{"id": "02c45e8b-ad54-45e1-9cc0-7bb344736961", "fitness": 0.06723737170820407, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced swarm collaboration through dynamic velocity scaling for improved convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(self.num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.4 + 0.5 * np.random.rand()  # Randomized dynamic inertia weight\n        c1 = 1.6  # Adjusted cognitive coefficient for better local search\n        c2 = 1.4  # Adjusted social coefficient for improved cooperation\n        r1, r2 = np.random.rand(2, self.num_particles, self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        ) * (1 - 0.5 * np.random.rand())  # Added dynamic velocity scaling\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(self.num_particles):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 98, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["916655d0-0cd0-42aa-9903-f1ff0546ce54"], "operator": null, "metadata": {"aucs": [0.06641207193256426, 0.0631898210984122, 0.06505006138767377, 0.06704412246359648, 0.059005119943456696, 0.06077318303864521, 0.08155572028173919, 0.07006524129604685, 0.07204100393170199]}}
{"id": "543b1e70-51b3-4c49-a265-e769ea5287d6", "fitness": 0.06934885229485196, "name": "CooperativeMultiSwarmOptimizer", "description": "Enhanced Cooperative Multi-Swarm Optimizer with dynamic swarm size and adaptive learning rates for optimal convergence.", "code": "import numpy as np\n\nclass CooperativeMultiSwarmOptimizer:\n    def __init__(self, budget, dim, num_swarms=3, num_particles=10):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = num_swarms\n        self.num_particles = num_particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        \n        self.swarms = [self._initialize_swarm() for _ in range(num_swarms)]\n        self.global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        self.global_best_value = float('inf')\n        self.evaluations = 0\n\n    def _initialize_swarm(self):\n        num_particles = self.num_particles + np.random.randint(-2, 3)  # Dynamic swarm size\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        best_positions = positions.copy()\n        best_values = np.full(num_particles, float('inf'))\n        return {'positions': positions, 'velocities': velocities, 'best_positions': best_positions, 'best_values': best_values}\n\n    def _update_particles(self, swarm, global_best_position):\n        w = 0.5 + 0.3 * np.random.rand()  # Altered dynamic inertia weight\n        c1 = 1.8  # Increased cognitive coefficient\n        c2 = 1.2  # Decreased social coefficient\n        r1, r2 = np.random.rand(2, len(swarm['positions']), self.dim)\n        \n        swarm['velocities'] = (\n            w * swarm['velocities'] \n            + c1 * r1 * (swarm['best_positions'] - swarm['positions']) \n            + c2 * r2 * (global_best_position - swarm['positions'])\n        )\n        swarm['positions'] += swarm['velocities']\n        np.clip(swarm['positions'], self.lower_bound, self.upper_bound, out=swarm['positions'])\n\n    def _evaluate_particles(self, swarm, func):\n        for i in range(len(swarm['positions'])):\n            if self.evaluations >= self.budget:\n                break\n            position = swarm['positions'][i]\n            value = func(position)\n            self.evaluations += 1\n\n            if value < swarm['best_values'][i]:\n                swarm['best_values'][i] = value\n                swarm['best_positions'][i] = position\n\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = position + 0.1 * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        while self.evaluations < self.budget:\n            for swarm in self.swarms:\n                self._update_particles(swarm, self.global_best_position)\n                self._evaluate_particles(swarm, func)\n\n                for other_swarm in self.swarms:\n                    if other_swarm is not swarm:\n                        other_swarm_best = np.min(other_swarm['best_values'])\n                        if other_swarm_best < swarm['best_values'].mean():\n                            self._update_particles(swarm, other_swarm['best_positions'][np.argmin(other_swarm['best_values'])])\n\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 99, "feedback": "The algorithm CooperativeMultiSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["916655d0-0cd0-42aa-9903-f1ff0546ce54"], "operator": null, "metadata": {"aucs": [0.07229472979152107, 0.06310361307238721, 0.07380329940650954, 0.06469559404872838, 0.058904439310882295, 0.06511406097920147, 0.07763857735516866, 0.06945796355739764, 0.07912739313187145]}}
