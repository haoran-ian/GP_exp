{"id": "3ed52689-fba2-4bd3-b7b1-1c8bb7e6515d", "fitness": 0.04889368893764826, "name": "ANGES", "description": "Adaptive Neighborhood Guided Evolutionary Strategy (ANGES) which dynamically adjusts exploration and exploitation using neighborhood-based sampling.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Generate neighborhoods\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 0, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.0497433816102808, 0.0497433816102808, 0.0497433816102808, 0.042900279803589236, 0.042900279803589236, 0.042900279803589236, 0.054037405399074756, 0.054037405399074756, 0.054037405399074756]}}
{"id": "e1706b3d-6859-4cb0-836c-e21800b59aea", "fitness": 0.04516662705306829, "name": "ANGES", "description": "ANGES+ introduces adaptive mutation strength to better balance exploration and exploitation over the optimization process.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Generate neighborhoods with adaptive mutation strength\n            adaptive_mutation_strength = self.mutation_strength * (1 - budget_used / self.budget)\n            neighborhoods = [elites[i] + np.random.normal(0, adaptive_mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 1, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["3ed52689-fba2-4bd3-b7b1-1c8bb7e6515d"], "operator": null, "metadata": {"aucs": [0.045949517729704126, 0.045949517729704126, 0.045949517729704126, 0.04107167519440513, 0.04107167519440513, 0.04107167519440513, 0.0484786882350956, 0.0484786882350956, 0.0484786882350956]}}
{"id": "075ecd32-0cc0-48b7-9abd-d111b40db441", "fitness": 0.04516662705306829, "name": "ANGES", "description": "ANGES+ with enhanced mutation strategy for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Generate neighborhoods with dynamic mutation strength\n            dynamic_mutation_strength = self.mutation_strength * (1 - budget_used / self.budget)\n            neighborhoods = [elites[i] + np.random.normal(0, dynamic_mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 2, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["3ed52689-fba2-4bd3-b7b1-1c8bb7e6515d"], "operator": null, "metadata": {"aucs": [0.045949517729704126, 0.045949517729704126, 0.045949517729704126, 0.04107167519440513, 0.04107167519440513, 0.04107167519440513, 0.0484786882350956, 0.0484786882350956, 0.0484786882350956]}}
{"id": "800e2eda-8084-4f4f-80a3-fe01dc080fdb", "fitness": 0.04516662705306829, "name": "ANGES", "description": "Adaptive Neighborhood Guided Evolutionary Strategy (ANGES) with enhanced mutation strength adaptation based on budget usage.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on budget usage\n            self.mutation_strength = 0.1 * (1 - (budget_used / self.budget))\n            \n            # Generate neighborhoods\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 3, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["3ed52689-fba2-4bd3-b7b1-1c8bb7e6515d"], "operator": null, "metadata": {"aucs": [0.045949517729704126, 0.045949517729704126, 0.045949517729704126, 0.04107167519440513, 0.04107167519440513, 0.04107167519440513, 0.0484786882350956, 0.0484786882350956, 0.0484786882350956]}}
{"id": "3bdccad5-51a4-48af-a7cb-75f5465e3df6", "fitness": 0.04606990172564759, "name": "ANGES", "description": "Refinement of ANGES to improve diversity by adjusting mutation strength based on population fitness variance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            self.mutation_strength = 0.1 + 0.9 * np.var(fitness) / np.mean(fitness)\n\n            # Generate neighborhoods\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 4, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["3ed52689-fba2-4bd3-b7b1-1c8bb7e6515d"], "operator": null, "metadata": {"aucs": [0.04627283601209653, 0.04627283601209653, 0.04627283601209653, 0.04132366472243165, 0.04132366472243165, 0.04132366472243165, 0.05061320444241457, 0.05061320444241457, 0.05061320444241457]}}
{"id": "4599ff85-a922-452b-8e70-29153c4754b2", "fitness": 0.05037517971208313, "name": "ANGES", "description": "Enhanced ANGES with dynamic mutation strength to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment\n            self.mutation_strength = max(0.01, self.mutation_strength * 0.95)\n\n            # Generate neighborhoods\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 5, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["3ed52689-fba2-4bd3-b7b1-1c8bb7e6515d"], "operator": null, "metadata": {"aucs": [0.049382408781752485, 0.049382408781752485, 0.049382408781752485, 0.04724626868910842, 0.04724626868910842, 0.04724626868910842, 0.054496861665388474, 0.054496861665388474, 0.054496861665388474]}}
{"id": "fdf6e16c-155a-4195-98a6-b4d834a5d076", "fitness": 0.05015481625076531, "name": "ANGES", "description": "Introduce adaptive elite fraction for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment\n            self.mutation_strength = max(0.01, self.mutation_strength * 0.95)\n\n            # Generate neighborhoods\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n            # Adjust elite fraction dynamically\n            self.elite_fraction = min(0.5, max(0.1, self.elite_fraction * 1.01))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 6, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["4599ff85-a922-452b-8e70-29153c4754b2"], "operator": null, "metadata": {"aucs": [0.04797369879594815, 0.04797369879594815, 0.04797369879594815, 0.04688759368959694, 0.04688759368959694, 0.04688759368959694, 0.05560315626675083, 0.05560315626675083, 0.05560315626675083]}}
{"id": "155072c6-7107-4b78-bf2f-e2717d333dd6", "fitness": 0.04734519678733976, "name": "ANGES", "description": "Improved exploration-exploitation balance with adaptive population size.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment\n            self.mutation_strength = max(0.01, self.mutation_strength * 0.95)\n\n            # Generate neighborhoods\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n            # Adaptive population size adjustment\n            self.population_size = min(100, self.population_size + 1)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 7, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["4599ff85-a922-452b-8e70-29153c4754b2"], "operator": null, "metadata": {"aucs": [0.047329844395968435, 0.047329844395968435, 0.047329844395968435, 0.0446875557769808, 0.0446875557769808, 0.0446875557769808, 0.050018190189070055, 0.050018190189070055, 0.050018190189070055]}}
{"id": "6ef1cb46-d4e8-4021-8efa-cf2687e9aefd", "fitness": -Infinity, "name": "ANGES", "description": "Introduce adaptive neighborhood size scaling to improve exploitation.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment\n            self.mutation_strength = max(0.01, self.mutation_strength * 0.95)\n\n            # Generate neighborhoods with adaptive scaling\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (int(self.neighborhood_size * (budget_used / self.budget)), self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 8, "feedback": "An exception occurred: ValueError('Cannot apply_along_axis when any iteration dimensions are 0').", "error": "ValueError('Cannot apply_along_axis when any iteration dimensions are 0')", "parent_ids": ["4599ff85-a922-452b-8e70-29153c4754b2"], "operator": null, "metadata": {}}
{"id": "cb1b2653-3508-4b08-9526-1830fb42c47a", "fitness": 0.05037517971208313, "name": "ANGES", "description": "Enhanced ANGES with adaptive neighborhood size for better exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment\n            self.mutation_strength = max(0.01, self.mutation_strength * 0.95)\n\n            # Adaptive neighborhood size based on remaining budget\n            adaptive_neighborhood_size = min(self.neighborhood_size, self.budget - budget_used)\n            \n            # Generate neighborhoods\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (adaptive_neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * adaptive_neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 9, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["4599ff85-a922-452b-8e70-29153c4754b2"], "operator": null, "metadata": {"aucs": [0.049382408781752485, 0.049382408781752485, 0.049382408781752485, 0.04724626868910842, 0.04724626868910842, 0.04724626868910842, 0.054496861665388474, 0.054496861665388474, 0.054496861665388474]}}
{"id": "e30f3489-9d8a-4432-a686-988c8bef9be0", "fitness": 0.051461990359601896, "name": "ANGES", "description": "Adjust neighbourhood size dynamically based on budget usage to enhance exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment\n            self.mutation_strength = max(0.01, self.mutation_strength * 0.95)\n\n            # Generate neighborhoods\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))  # Dynamic neighborhood size\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 10, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["4599ff85-a922-452b-8e70-29153c4754b2"], "operator": null, "metadata": {"aucs": [0.051479903777274405, 0.051479903777274405, 0.051479903777274405, 0.0457266499444402, 0.0457266499444402, 0.0457266499444402, 0.05717941735709109, 0.05717941735709109, 0.05717941735709109]}}
{"id": "e71835dd-6e20-41d4-8ec0-9e144774adad", "fitness": 0.04705890837852519, "name": "ANGES", "description": "Enhance exploration by adjusting mutation strength to be more adaptive based on remaining budget.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment\n            self.mutation_strength = max(0.01, self.mutation_strength * (0.95 + 0.05 * (1 - budget_used / self.budget)))\n\n            # Generate neighborhoods\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))  # Dynamic neighborhood size\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 11, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["e30f3489-9d8a-4432-a686-988c8bef9be0"], "operator": null, "metadata": {"aucs": [0.04425259815057481, 0.04425259815057481, 0.04425259815057481, 0.04729259776304473, 0.04729259776304473, 0.04729259776304473, 0.04963152922195602, 0.04963152922195602, 0.04963152922195602]}}
{"id": "a5402556-524c-442e-817a-9936caad7585", "fitness": 0.051461990359601896, "name": "ANGES", "description": "Improve exploitation by refining neighborhood evaluation with a weighted average.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment\n            self.mutation_strength = max(0.01, self.mutation_strength * 0.95)\n\n            # Generate neighborhoods\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))  # Dynamic neighborhood size\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods using weighted average\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 12, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["e30f3489-9d8a-4432-a686-988c8bef9be0"], "operator": null, "metadata": {"aucs": [0.051479903777274405, 0.051479903777274405, 0.051479903777274405, 0.0457266499444402, 0.0457266499444402, 0.0457266499444402, 0.05717941735709109, 0.05717941735709109, 0.05717941735709109]}}
{"id": "28398783-1cbf-40c9-96ad-5e46853bef7f", "fitness": 0.046820476565533155, "name": "ANGES", "description": "ANGES with adaptive mutation strength based on elite diversity to enhance exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment based on elite diversity\n            self.mutation_strength = max(0.01, self.mutation_strength * (1 + np.std(elites)))\n\n            # Generate neighborhoods\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))  # Dynamic neighborhood size\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 13, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["e30f3489-9d8a-4432-a686-988c8bef9be0"], "operator": null, "metadata": {"aucs": [0.046886070856069106, 0.046886070856069106, 0.046886070856069106, 0.043294529088815925, 0.043294529088815925, 0.043294529088815925, 0.05028082975171444, 0.05028082975171444, 0.05028082975171444]}}
{"id": "711d3351-a4a5-4f42-9eca-f35cabf3c13d", "fitness": 0.05156785818884346, "name": "ANGES", "description": "ANGES+ improves exploration by refining mutation strength scaling with elite quality.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment based on elite's performance\n            elite_quality = np.mean(fitness[elite_indices])\n            self.mutation_strength = max(0.01, self.mutation_strength * (0.95 + 0.05 * elite_quality))\n\n            # Generate neighborhoods\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))  # Dynamic neighborhood size\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 14, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["e30f3489-9d8a-4432-a686-988c8bef9be0"], "operator": null, "metadata": {"aucs": [0.047871652295853995, 0.047871652295853995, 0.047871652295853995, 0.051911989913596135, 0.051911989913596135, 0.051911989913596135, 0.05491993235708026, 0.05491993235708026, 0.05491993235708026]}}
{"id": "330bcffd-8a9d-4c46-bc80-3633f8d75d65", "fitness": 0.04764934143701297, "name": "ANGES", "description": "ANGES++ fine-tunes neighborhood creation by adapting to population diversity for enhanced exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment based on elite's performance\n            elite_quality = np.mean(fitness[elite_indices])\n            self.mutation_strength = max(0.01, self.mutation_strength * (0.95 + 0.05 * elite_quality))\n\n            # Generate neighborhoods with diversity-based adjustment\n            diversity_factor = np.std(population)\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + diversity_factor / 10)))  # Adjusted neighborhood size\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 15, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["711d3351-a4a5-4f42-9eca-f35cabf3c13d"], "operator": null, "metadata": {"aucs": [0.0493610640822888, 0.0493610640822888, 0.0493610640822888, 0.041281939848155424, 0.041281939848155424, 0.041281939848155424, 0.0523050203805947, 0.0523050203805947, 0.0523050203805947]}}
{"id": "e27eb8e8-0af2-4961-acde-02cd35772cf9", "fitness": 0.05641445349674475, "name": "ANGES", "description": "Refine ANGES+ by introducing adaptive mutation strength based on average elite improvement.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment based on average elite improvement\n            previous_elite_quality = np.mean(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if previous_elite_quality < np.mean(fitness[elite_indices]) else 1.1\n\n            # Generate neighborhoods\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))  # Dynamic neighborhood size\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 16, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["711d3351-a4a5-4f42-9eca-f35cabf3c13d"], "operator": null, "metadata": {"aucs": [0.05338420401099819, 0.05338420401099819, 0.05338420401099819, 0.05614306647441225, 0.05614306647441225, 0.05614306647441225, 0.05971609000482381, 0.05971609000482381, 0.05971609000482381]}}
{"id": "9c4c0c90-9f8d-423b-9d31-aedc15f5c7bc", "fitness": 0.20510343837786305, "name": "ANGES", "description": "Introduce a decay factor to mutation_strength for dynamic adjustment over time.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            # Select elite individuals\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Dynamic mutation strength adjustment based on average elite improvement\n            previous_elite_quality = np.mean(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if previous_elite_quality < np.mean(fitness[elite_indices]) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)  # Decay factor added to mutation strength\n\n            # Generate neighborhoods\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))  # Dynamic neighborhood size\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            # Evaluate neighborhoods\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Update population with neighborhood bests\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 17, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.09.", "error": "", "parent_ids": ["e27eb8e8-0af2-4961-acde-02cd35772cf9"], "operator": null, "metadata": {"aucs": [0.32745980982360223, 0.32745980982360223, 0.32745980982360223, 0.10959311586705422, 0.10959311586705422, 0.10959311586705422, 0.17825738944293268, 0.17825738944293268, 0.17825738944293268]}}
{"id": "7b22ea8d-98b5-42b0-8671-93b753b0e97e", "fitness": 0.29919280182681185, "name": "ANGES", "description": "Introduce adaptive mutation based on fitness variance to enhance solution exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 18, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.17.", "error": "", "parent_ids": ["9c4c0c90-9f8d-423b-9d31-aedc15f5c7bc"], "operator": null, "metadata": {"aucs": [0.0674665509413912, 0.0674665509413912, 0.0674665509413912, 0.3400059206162851, 0.3400059206162851, 0.3400059206162851, 0.49010593392275925, 0.49010593392275925, 0.49010593392275925]}}
{"id": "831e6548-9204-4c13-bbdb-88c56a8f7fe1", "fitness": 0.07625761594877571, "name": "ANGES", "description": "Introduce elite expansion to allow more diverse exploration from top solutions.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size + 1, self.dim))\n                             for i in range(elite_size)]  # Changed line\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 19, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.03.", "error": "", "parent_ids": ["7b22ea8d-98b5-42b0-8671-93b753b0e97e"], "operator": null, "metadata": {"aucs": [0.05310110794003564, 0.05310110794003564, 0.05310110794003564, 0.1121456486748188, 0.1121456486748188, 0.1121456486748188, 0.06352609123147268, 0.06352609123147268, 0.06352609123147268]}}
{"id": "979d27de-575a-4ba8-b06e-61d5311e4eab", "fitness": 0.20510343837786305, "name": "ANGES", "description": "Introduce dynamic adjustment of mutation strength based on elite diversity to enhance solution exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on elite diversity\n            elite_diversity = np.std(elites)\n            self.mutation_strength *= 0.9 if elite_diversity < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 20, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.09.", "error": "", "parent_ids": ["7b22ea8d-98b5-42b0-8671-93b753b0e97e"], "operator": null, "metadata": {"aucs": [0.32745980982360223, 0.32745980982360223, 0.32745980982360223, 0.10959311586705422, 0.10959311586705422, 0.10959311586705422, 0.17825738944293268, 0.17825738944293268, 0.17825738944293268]}}
{"id": "f98c1c08-aafd-46e6-8714-a401b17accd6", "fitness": 0.43239441465179856, "name": "ANGES", "description": "Introduce dynamic population size adjustment based on budget usage to improve solution diversity.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))  # Changed line\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 21, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.06.", "error": "", "parent_ids": ["7b22ea8d-98b5-42b0-8671-93b753b0e97e"], "operator": null, "metadata": {"aucs": [0.4216075758383727, 0.4216075758383727, 0.4216075758383727, 0.36785206496105693, 0.36785206496105693, 0.36785206496105693, 0.507723603155966, 0.507723603155966, 0.507723603155966]}}
{"id": "003465d2-bdcc-4650-8401-e249af44ef0c", "fitness": -Infinity, "name": "ANGES", "description": "Enhance exploration by introducing adaptive mutation strength scaling based on relative population diversity.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.mutation_strength *= np.std(population) / np.mean(population)  # Changed line\n            \n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 22, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["f98c1c08-aafd-46e6-8714-a401b17accd6"], "operator": null, "metadata": {}}
{"id": "0b33d3b2-0ee4-47a1-8098-9e71ab57f456", "fitness": 0.05966304265855885, "name": "ANGES", "description": "Enhance mutation strategy and neighborhood selection for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n            \n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(2, int(5 * (self.elite_fraction)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength * np.random.rand(), (self.neighborhood_size, self.dim))  # Changed line\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 23, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["f98c1c08-aafd-46e6-8714-a401b17accd6"], "operator": null, "metadata": {"aucs": [0.05703626120844274, 0.05703626120844274, 0.05703626120844274, 0.0546549128417525, 0.0546549128417525, 0.0546549128417525, 0.06729795392548132, 0.06729795392548132, 0.06729795392548132]}}
{"id": "9a13ad22-ce20-4179-bf4f-90a8258aa95a", "fitness": 0.43239441465179856, "name": "ANGES", "description": "Balance exploration and exploitation by dynamically adjusting mutation strength with a decaying factor based on unused budget.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 24, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.06.", "error": "", "parent_ids": ["f98c1c08-aafd-46e6-8714-a401b17accd6"], "operator": null, "metadata": {"aucs": [0.4216075758383727, 0.4216075758383727, 0.4216075758383727, 0.36785206496105693, 0.36785206496105693, 0.36785206496105693, 0.507723603155966, 0.507723603155966, 0.507723603155966]}}
{"id": "23a7d303-166c-4669-b398-a5b98811e0d3", "fitness": 0.43239441465179856, "name": "ANGES", "description": "Introduce dynamic mutation strength adjustment based on remaining budget to improve solution exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))  \n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 25, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.06.", "error": "", "parent_ids": ["f98c1c08-aafd-46e6-8714-a401b17accd6"], "operator": null, "metadata": {"aucs": [0.4216075758383727, 0.4216075758383727, 0.4216075758383727, 0.36785206496105693, 0.36785206496105693, 0.36785206496105693, 0.507723603155966, 0.507723603155966, 0.507723603155966]}}
{"id": "a9faa920-40ea-4830-a565-fe6ea977c767", "fitness": 0.17980972348841606, "name": "ANGES", "description": "Introduce a dynamic budget allocation strategy by modifying the mutation strength formula to enhance adaptability.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - (budget_used / self.budget) ** 2)  # Modified line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))  # Changed line\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 26, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.02.", "error": "", "parent_ids": ["f98c1c08-aafd-46e6-8714-a401b17accd6"], "operator": null, "metadata": {"aucs": [0.15859343824967398, 0.15859343824967398, 0.15859343824967398, 0.17514563400005445, 0.17514563400005445, 0.17514563400005445, 0.20569009821551976, 0.20569009821551976, 0.20569009821551976]}}
{"id": "f53cbd4e-d237-4359-b762-08bedfbdeb2b", "fitness": 0.5745919607700497, "name": "ANGES", "description": "ANGES with adaptive elite fraction to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 27, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["f98c1c08-aafd-46e6-8714-a401b17accd6"], "operator": null, "metadata": {"aucs": [0.5126547012797091, 0.5126547012797091, 0.5126547012797091, 0.5763216934790754, 0.5763216934790754, 0.5763216934790754, 0.6347994875513647, 0.6347994875513647, 0.6347994875513647]}}
{"id": "89b60b20-c748-4619-b1d6-c19d338cc3e6", "fitness": 0.5614639218960544, "name": "ANGES", "description": "ANGES with adaptive elite fraction and mutation strength modulation to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.05 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 28, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.56 with standard deviation 0.04.", "error": "", "parent_ids": ["f53cbd4e-d237-4359-b762-08bedfbdeb2b"], "operator": null, "metadata": {"aucs": [0.5416606489306922, 0.5416606489306922, 0.5416606489306922, 0.5268635110828997, 0.5268635110828997, 0.5268635110828997, 0.6158676056745713, 0.6158676056745713, 0.6158676056745713]}}
{"id": "fdfcd91c-40d9-436b-8c26-99fcb5735011", "fitness": 0.3926041960793798, "name": "ANGES", "description": "Enhanced ANGES with adaptive elite and mutation strategy to improve convergence rate.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n        prev_best_fitness = np.min(fitness)  # New line\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n            current_best_fitness = np.min(fitness)  # New line\n            if current_best_fitness < prev_best_fitness:  # New line\n                self.elite_fraction *= 0.95  # New line\n                self.mutation_strength *= 0.95  # New line\n            else:  # New line\n                self.elite_fraction *= 1.05  # New line\n                self.mutation_strength *= 1.05  # New line\n            prev_best_fitness = current_best_fitness  # New line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 29, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.22.", "error": "", "parent_ids": ["f53cbd4e-d237-4359-b762-08bedfbdeb2b"], "operator": null, "metadata": {"aucs": [0.09232917261392959, 0.09232917261392959, 0.09232917261392959, 0.5896120962692919, 0.5896120962692919, 0.5896120962692919, 0.495871319354918, 0.495871319354918, 0.495871319354918]}}
{"id": "b5d5c0d4-f170-415d-aca4-5e01dbca9686", "fitness": 0.3794861462962553, "name": "ANGES", "description": "ANGES with adaptive mutation strength adjustment to enhance convergence speed.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.mutation_strength *= 0.99  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 30, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.05.", "error": "", "parent_ids": ["f53cbd4e-d237-4359-b762-08bedfbdeb2b"], "operator": null, "metadata": {"aucs": [0.3192161100498928, 0.3192161100498928, 0.3192161100498928, 0.386358395077398, 0.386358395077398, 0.386358395077398, 0.43288393376147527, 0.43288393376147527, 0.43288393376147527]}}
{"id": "d0cd170c-9317-4302-a835-f0424dbea116", "fitness": 0.5745919607700497, "name": "ANGES", "description": "ANGES with adaptive elite fraction and dynamic population resizing to improve convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = max(10, int(50 * (1 - budget_used / self.budget)))  # Changed line\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 31, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["f53cbd4e-d237-4359-b762-08bedfbdeb2b"], "operator": null, "metadata": {"aucs": [0.5126547012797091, 0.5126547012797091, 0.5126547012797091, 0.5763216934790754, 0.5763216934790754, 0.5763216934790754, 0.6347994875513647, 0.6347994875513647, 0.6347994875513647]}}
{"id": "f0596b36-4e24-45aa-b772-900ea3e49f41", "fitness": -Infinity, "name": "ANGES", "description": "ANGES with dynamic elite adaptation based on diversity to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= 0.9 if fitness_variance < np.mean(fitness) else 1.1\n            self.mutation_strength *= (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * np.std(fitness)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 32, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["f53cbd4e-d237-4359-b762-08bedfbdeb2b"], "operator": null, "metadata": {}}
{"id": "28549cf9-ea8c-40ab-a7a2-d249eb878bf7", "fitness": 0.5745919607709891, "name": "ANGES", "description": "ANGES with adaptive elite fraction and scaled mutation strength to balance exploration and exploitation.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 33, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["f53cbd4e-d237-4359-b762-08bedfbdeb2b"], "operator": null, "metadata": {"aucs": [0.5126547012824159, 0.5126547012824159, 0.5126547012824159, 0.57632169347916, 0.57632169347916, 0.57632169347916, 0.6347994875513913, 0.6347994875513913, 0.6347994875513913]}}
{"id": "02d1b6bb-ffb6-4e07-b1e3-622d54c8d77c", "fitness": -Infinity, "name": "ANGES", "description": "ANGES with dynamic elite fraction adjustment linked to population diversity.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.02 * np.std(fitness) / np.mean(fitness)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 34, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {}}
{"id": "1c1c66a4-42c9-4726-9222-f238aeff3602", "fitness": -Infinity, "name": "ANGES", "description": "Enhancing ANGES by adapting elite fraction based on fitness improvement to fine-tune exploration and exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 if fitness[elite_indices[0]] > np.min(fitness) else 1.02  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 35, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 20')", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {}}
{"id": "39cf33de-c5ab-4ff3-944b-335e069aafb5", "fitness": 0.13594222882481122, "name": "ANGES", "description": "Enhanced ANGES with adaptive mutation based on runtime budget and elite diversity.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on elite diversity instead of fitness variance\n            diversity = np.mean([np.linalg.norm(elites[i] - elites[j]) for i in range(elite_size) for j in range(i+1, elite_size)])\n            self.mutation_strength *= (0.9 if diversity < (self.upper_bound - self.lower_bound) / 2 else 1.1)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 36, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.10.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.2776951437252214, 0.2776951437252214, 0.2776951437252214, 0.058136255414358295, 0.058136255414358295, 0.058136255414358295, 0.07199528733485394, 0.07199528733485394, 0.07199528733485394]}}
{"id": "c20679b7-8cf3-4fa4-a5bd-de6929565b27", "fitness": 0.5745919607709891, "name": "ANGES", "description": "ANGES with improved mutation strength scaling using harmonic mean to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength using harmonic mean instead of arithmetic mean\n            fitness_harmonic_mean = len(fitness[elite_indices]) / np.sum(1.0 / fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_harmonic_mean < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 37, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5126547012824159, 0.5126547012824159, 0.5126547012824159, 0.57632169347916, 0.57632169347916, 0.57632169347916, 0.6347994875513913, 0.6347994875513913, 0.6347994875513913]}}
{"id": "fdf36123-96d0-42ed-bdb4-97cd54b54bed", "fitness": 0.3719724412716111, "name": "ANGES", "description": "ANGES with improved mutation strength adaptation for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.85 if fitness_variance < np.mean(fitness) else 1.15) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 38, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.20.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.08690482992291382, 0.08690482992291382, 0.08690482992291382, 0.4865140791056105, 0.4865140791056105, 0.4865140791056105, 0.5424984147863091, 0.5424984147863091, 0.5424984147863091]}}
{"id": "fd8e0701-31e9-462c-bf45-43860d6f4213", "fitness": 0.06728890817192423, "name": "ANGES", "description": "ANGES with enhanced neighborhood exploration by incorporating adaptive neighborhood scaling.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength * 1.05, (self.neighborhood_size, self.dim))  # Changed line\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 39, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.00.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.0723887899671124, 0.0723887899671124, 0.0723887899671124, 0.06703067792454453, 0.06703067792454453, 0.06703067792454453, 0.062447256624115766, 0.062447256624115766, 0.062447256624115766]}}
{"id": "b353fb0c-0c37-4a5c-88f6-3002566ba161", "fitness": 0.4012664657443379, "name": "ANGES", "description": "ANGES with adaptive elite fraction and scaled mutation strength and enhanced exploitation through dynamic elite fraction adjustment.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction = max(0.1, self.elite_fraction * 0.98 + 0.04 * (budget_used / self.budget))  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 40, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.09.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.2849774976270737, 0.2849774976270737, 0.2849774976270737, 0.5088024531100868, 0.5088024531100868, 0.5088024531100868, 0.4100194464958531, 0.4100194464958531, 0.4100194464958531]}}
{"id": "60554456-a7f1-4041-a7bd-063a45c90ac1", "fitness": 0.06311204089219462, "name": "ANGES", "description": "Enhanced ANGES with adaptive exploration and dynamic population control for improved convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n            self.mutation_strength = max(0.01, self.mutation_strength)  # Changed line\n\n            self.population_size = int(50 * np.exp(-budget_used / self.budget))  # Changed line\n            self.neighborhood_size = max(1, int(5 * np.exp(-budget_used / self.budget)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction = max(0.1, self.elite_fraction * (0.98 + 0.04 * (budget_used / self.budget)))  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 41, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.055829015067771715, 0.055829015067771715, 0.055829015067771715, 0.06098475490715449, 0.06098475490715449, 0.06098475490715449, 0.07252235270165763, 0.07252235270165763, 0.07252235270165763]}}
{"id": "5612fdd8-b0a7-425e-944b-29c4f22d6602", "fitness": 0.5169230236453513, "name": "ANGES", "description": "ANGES with adaptive elite fraction, scaled mutation strength, and enhanced exploration via dynamic mutation range.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength * np.random.uniform(0.5, 1.5), (self.neighborhood_size, self.dim))  # Changed line\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 42, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.02.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5201230898660588, 0.5201230898660588, 0.5201230898660588, 0.4860590053271715, 0.4860590053271715, 0.4860590053271715, 0.5445869757428232, 0.5445869757428232, 0.5445869757428232]}}
{"id": "a246fd15-f382-43cf-a390-21160d583268", "fitness": 0.48103720199191613, "name": "ANGES", "description": "ANGES with adaptive elite fraction and scaled mutation strength to balance exploration and exploitation; enhanced strategy using dynamic population size adjustment.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (0.5 + 0.5 * np.cos(budget_used / self.budget * np.pi)))  # Changed line\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 43, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.05.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.45658010060885745, 0.45658010060885745, 0.45658010060885745, 0.4296753641496104, 0.4296753641496104, 0.4296753641496104, 0.5568561412172808, 0.5568561412172808, 0.5568561412172808]}}
{"id": "aab64545-ae9f-42d3-ba2e-49dc17ef77d2", "fitness": -Infinity, "name": "ANGES", "description": "Enhanced ANGES with adaptive mutation decay and diversification strategy to improve convergence and exploration balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adaptive mutation decay\n            self.mutation_strength *= 0.99\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            # Diversification strategy with random perturbation\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             + np.random.uniform(-0.1, 0.1, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            # Adjust elite fraction towards end\n            self.elite_fraction *= (0.98 + 0.02 * (budget_used / self.budget))\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 44, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {}}
{"id": "3c6acb05-6005-4f01-8240-c7b5bbe2cfde", "fitness": 0.5745919607709891, "name": "ANGES", "description": "ANGES with dynamic neighborhood scaling to enhance adaptability across varying optimization landscapes.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + np.std(fitness) / np.mean(fitness))))  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 45, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5126547012824159, 0.5126547012824159, 0.5126547012824159, 0.57632169347916, 0.57632169347916, 0.57632169347916, 0.6347994875513913, 0.6347994875513913, 0.6347994875513913]}}
{"id": "4969a1ef-f0de-4a5c-ab61-e7a110ce3b3b", "fitness": 0.5745919607709891, "name": "ANGES", "description": "ANGES with improved adaptive mutation strength to enhance convergence rate by utilizing normalized fitness variance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on normalized fitness variance\n            fitness_variance = np.var(fitness[elite_indices]) / (np.mean(fitness)**2)\n            self.mutation_strength *= (0.9 if fitness_variance < 1 else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 46, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5126547012824159, 0.5126547012824159, 0.5126547012824159, 0.57632169347916, 0.57632169347916, 0.57632169347916, 0.6347994875513913, 0.6347994875513913, 0.6347994875513913]}}
{"id": "14588bc8-d1ed-463a-a347-cb3fc311e6b7", "fitness": -Infinity, "name": "ANGES", "description": "ANGES with adaptive elite fraction and enhanced mutation scaling to optimize exploration-exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - (budget_used**1.5) / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 47, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {}}
{"id": "15cd3828-fd47-4914-ae6f-d47560c3787e", "fitness": 0.5745919607709891, "name": "ANGES", "description": "ANGES with dynamic population reduction strategy to enhance convergence speed.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)[:self.population_size]  # Changed line\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 48, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5126547012824159, 0.5126547012824159, 0.5126547012824159, 0.57632169347916, 0.57632169347916, 0.57632169347916, 0.6347994875513913, 0.6347994875513913, 0.6347994875513913]}}
{"id": "c99c952b-138d-49a2-aac0-d625700f53da", "fitness": 0.29253558022577236, "name": "ANGES", "description": "ANGES with dynamically adjusted mutation strength to enhance adaptability based on budget usage.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget * 0.5)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 49, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.18.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.05930499760426422, 0.05930499760426422, 0.05930499760426422, 0.3322925445172228, 0.3322925445172228, 0.3322925445172228, 0.48600919855583, 0.48600919855583, 0.48600919855583]}}
{"id": "58bc777a-6f0f-4c3b-ba50-2fabebfcf3db", "fitness": 0.2940485915869407, "name": "ANGES", "description": "ANGES with adaptive neighborhood scaling to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength * (1 - budget_used / self.budget), (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 50, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.17.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.3181308392962999, 0.3181308392962999, 0.3181308392962999, 0.06997233920287826, 0.06997233920287826, 0.06997233920287826, 0.4940425962616438, 0.4940425962616438, 0.4940425962616438]}}
{"id": "333db25f-67fa-4b3e-9e27-7c7a45e046bd", "fitness": 0.05262134785610358, "name": "ANGES", "description": "ANGES with adaptive mutation strength linked to current fitness improvement to enhance convergence.  ", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            fitness_improvement = np.mean(fitness) - np.mean(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 + fitness_improvement)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 51, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.046273855776097994, 0.046273855776097994, 0.046273855776097994, 0.057347956094327524, 0.057347956094327524, 0.057347956094327524, 0.054242231697885224, 0.054242231697885224, 0.054242231697885224]}}
{"id": "a493a36e-2e1d-489c-9fcc-ae8eb732af54", "fitness": 0.28604292407758986, "name": "ANGES", "description": "ANGES with optimized mutation strength adjustment using fitness variance and convergence rate to enhance solution quality.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.95 if fitness_variance < 0.5 * np.mean(fitness) else 1.05) * (1 - budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 52, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.15.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.07925795870317909, 0.07925795870317909, 0.07925795870317909, 0.3956977813964464, 0.3956977813964464, 0.3956977813964464, 0.383173032133144, 0.383173032133144, 0.383173032133144]}}
{"id": "2d353f9d-81f7-41b5-a4d7-09c1c4546b0a", "fitness": 0.45378143841581525, "name": "ANGES", "description": "ANGES with an adaptive mutation strength adjustment using fitness variance and progress rate to improve convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance and progress rate\n            fitness_variance = np.var(fitness[elite_indices])\n            progress_rate = np.abs(fitness[elite_indices[0]] - fitness[elite_indices[-1]]) / np.abs(fitness[elite_indices[0]] + 1e-12)\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) and progress_rate < 0.1 else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 53, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.04.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5168683477697438, 0.5168683477697438, 0.5168683477697438, 0.4188823100516734, 0.4188823100516734, 0.4188823100516734, 0.4255936574260287, 0.4255936574260287, 0.4255936574260287]}}
{"id": "0efe0b99-4655-475a-8d5e-f15b1ec45aca", "fitness": 0.5365934824925156, "name": "ANGES", "description": "Enhance adaptive mutation strength by incorporating both fitness variance and current best fitness improvement to refine exploration-exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            best_fitness_improvement = np.min(fitness) - np.min(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget) * (\n                0.9 if best_fitness_improvement < 1e-3 else 1.1)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 54, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.00.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5355805308495777, 0.5355805308495777, 0.5355805308495777, 0.5395871931691718, 0.5395871931691718, 0.5395871931691718, 0.5346127234587974, 0.5346127234587974, 0.5346127234587974]}}
{"id": "0879b0d1-7901-4dc5-a44f-a0ed42befc4a", "fitness": -Infinity, "name": "ANGES", "description": "ANGES with refined adaptive elite fraction adjustment for improved convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.96 + 0.08 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 55, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {}}
{"id": "ebd990b9-d52d-4f69-8c59-72d43b4b482c", "fitness": 0.4690242943265994, "name": "ANGES", "description": "ANGES with enhanced adaptive elite fraction that decreases slower to maintain diversity longer.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.99 + 0.02 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 56, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.06.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.3839024159172817, 0.3839024159172817, 0.3839024159172817, 0.5202409351070736, 0.5202409351070736, 0.5202409351070736, 0.5029295319554432, 0.5029295319554432, 0.5029295319554432]}}
{"id": "f0303b8b-6bc0-447c-9d0c-3b2c3910ab14", "fitness": 0.5745919607709891, "name": "ANGES", "description": "Enhanced fitness variance adjustment to improve mutation strength dynamics.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1 + 0.05 * fitness_variance) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 57, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5126547012824159, 0.5126547012824159, 0.5126547012824159, 0.57632169347916, 0.57632169347916, 0.57632169347916, 0.6347994875513913, 0.6347994875513913, 0.6347994875513913]}}
{"id": "eb9db2e4-670a-4f04-ab16-8302c72f1490", "fitness": -Infinity, "name": "ANGES", "description": "ANGES with dynamic population resizing based on budget consumption for improved convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget)**2)  # Changed line\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 58, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {}}
{"id": "fe679961-235f-4126-a6ed-33a73f911fd1", "fitness": 0.5745919607709891, "name": "ANGES", "description": "ANGES with dynamic neighborhood size adjustment for improved convergence speed and precision.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 59, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.57 with standard deviation 0.05.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5126547012824159, 0.5126547012824159, 0.5126547012824159, 0.57632169347916, 0.57632169347916, 0.57632169347916, 0.6347994875513913, 0.6347994875513913, 0.6347994875513913]}}
{"id": "b08e309f-b28d-43c1-8c71-5f80d3d017e3", "fitness": 0.06283970753974066, "name": "ANGES", "description": "ANGES with adaptive elite fraction and scaled mutation strength to balance exploration and exploitation, with enhanced mutation control.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Changed line\n            population = np.concatenate((population[:elite_size], neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 60, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.02.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.09665683306495831, 0.09665683306495831, 0.09665683306495831, 0.044572614295601554, 0.044572614295601554, 0.044572614295601554, 0.04728967525866212, 0.04728967525866212, 0.04728967525866212]}}
{"id": "90eba625-1954-467d-b0d9-2e13175a9093", "fitness": 0.5853569895728428, "name": "ANGES", "description": "Enhanced ANGES by introducing a dynamic neighborhood size based on budget utilization.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 61, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_ids": ["28549cf9-ea8c-40ab-a7a2-d249eb878bf7"], "operator": null, "metadata": {"aucs": [0.5416880566759228, 0.5416880566759228, 0.5416880566759228, 0.5658684676191312, 0.5658684676191312, 0.5658684676191312, 0.6485144444234741, 0.6485144444234741, 0.6485144444234741]}}
{"id": "09cb5d71-af41-437c-b8f0-fbf19d6862e7", "fitness": 0.18879348846593313, "name": "ANGES", "description": "Introduced adaptive mutation strength decay to improve convergence by modifying the calculation based on fitness variance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)**2  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 62, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.07088704506308396, 0.07088704506308396, 0.07088704506308396, 0.06994339106758163, 0.06994339106758163, 0.06994339106758163, 0.4255500292671338, 0.4255500292671338, 0.4255500292671338]}}
{"id": "d020d8bd-041c-496d-9f55-c6711cffdef5", "fitness": 0.5853569895728428, "name": "ANGES", "description": "Enhanced neighborhood strategy by introducing a dynamic mutation strength based on neighborhood fitness.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 63, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.5416880566759228, 0.5416880566759228, 0.5416880566759228, 0.5658684676191312, 0.5658684676191312, 0.5658684676191312, 0.6485144444234741, 0.6485144444234741, 0.6485144444234741]}}
{"id": "6a343a7d-2a6c-4b89-8f63-899dfa450d67", "fitness": 0.23653811966911262, "name": "ANGES", "description": "Improved exploration by introducing adaptive mutation strength based on budget utilization.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance and budget utilization\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 64, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.03.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.2415131709538456, 0.2415131709538456, 0.2415131709538456, 0.20219665264904285, 0.20219665264904285, 0.20219665264904285, 0.26590453540444936, 0.26590453540444936, 0.26590453540444936]}}
{"id": "c2afcf9d-7184-452b-8495-13b25492dfe4", "fitness": 0.3942887164719302, "name": "ANGES", "description": "Enhanced mutation strength adjustment using adaptive scaling for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget) * (1 + np.std(fitness) / np.mean(fitness))  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 65, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.03.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.35863369301559667, 0.35863369301559667, 0.35863369301559667, 0.3895850991816564, 0.3895850991816564, 0.3895850991816564, 0.43464735721853753, 0.43464735721853753, 0.43464735721853753]}}
{"id": "247d948b-ecfd-4da2-872c-cce85652dc45", "fitness": 0.5853569895728428, "name": "ANGES", "description": "Fine-tuned mutation strength adaptation to enhance convergence efficiency.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.15) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 66, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.5416880566759228, 0.5416880566759228, 0.5416880566759228, 0.5658684676191312, 0.5658684676191312, 0.5658684676191312, 0.6485144444234741, 0.6485144444234741, 0.6485144444234741]}}
{"id": "7ab98080-13c1-49d0-8d4b-b63708f5d86e", "fitness": 0.4175408872345607, "name": "ANGES", "description": "Optimized ANGES by tweaking the mutation strength adjustment to enhance convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.85 if fitness_variance < np.mean(fitness) else 1.15) * (1 - budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 67, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.06.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.33862896017873034, 0.33862896017873034, 0.33862896017873034, 0.44331495452707215, 0.44331495452707215, 0.44331495452707215, 0.4706787469978796, 0.4706787469978796, 0.4706787469978796]}}
{"id": "f815ddac-74b5-42ad-8ec3-10870376ed75", "fitness": -Infinity, "name": "ANGES", "description": "Improve elite fraction adjustment by incorporating a scaling factor based on elite performance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= (0.98 + 0.04 * (budget_used / self.budget) * (np.min(fitness) / np.mean(fitness[elite_indices])))  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 68, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 20').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 20')", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {}}
{"id": "44425ebe-2a63-41b6-a266-30bd5432cd2c", "fitness": 0.05661114261079906, "name": "ANGES", "description": "Refined ANGES by adapting mutation strength dynamically and leveraging fitness diversity to adjust elite fraction.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.02 * (fitness_variance / (fitness_variance + 1e-6))  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 69, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.05520938115937413, 0.05520938115937413, 0.05520938115937413, 0.05173504757034664, 0.05173504757034664, 0.05173504757034664, 0.06288899910267642, 0.06288899910267642, 0.06288899910267642]}}
{"id": "9ed9a1e1-db93-40ed-a752-999bc592deca", "fitness": 0.08486071706201499, "name": "ANGES", "description": "Adaptive mutation strength and dynamic population size adjustment based on convergence rate during optimization.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance and convergence rate\n            fitness_variance = np.var(fitness[elite_indices])\n            convergence_rate = np.abs(np.mean(fitness) - np.min(fitness[elite_indices]))\n            self.mutation_strength *= (0.9 if fitness_variance < convergence_rate else 1.1)  # Changed line\n\n            # Dynamic population size adjustment based on convergence rate\n            self.population_size = int(50 * (1 - budget_used / self.budget) * (1 + convergence_rate))  # Changed line\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 70, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.04.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.1413672486471954, 0.1413672486471954, 0.1413672486471954, 0.052111167199709985, 0.052111167199709985, 0.052111167199709985, 0.0611037353391396, 0.0611037353391396, 0.0611037353391396]}}
{"id": "beae7fdb-7091-4559-99df-a62b50308789", "fitness": -Infinity, "name": "ANGES", "description": "Enhanced ANGES by introducing adaptive elite fraction adjustment and dynamic mutation strength based on fitness improvement. ", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n        last_best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness improvement\n            current_best_fitness = np.min(fitness)\n            fitness_improvement = max(1e-9, last_best_fitness - current_best_fitness)\n            self.mutation_strength *= (1.1 if fitness_improvement < 1e-3 else 0.9)\n            last_best_fitness = current_best_fitness\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.95 + 0.05 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 71, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {}}
{"id": "fd2ca0e8-8141-4ebe-8123-03510ab2d6dd", "fitness": 0.2365381112343954, "name": "ANGES", "description": "Enhanced exploration by adapting mutation strength based on dynamic budget usage.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - (budget_used / self.budget)**2)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 72, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.03.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.24151317474265344, 0.24151317474265344, 0.24151317474265344, 0.2021966232954613, 0.2021966232954613, 0.2021966232954613, 0.26590453566507144, 0.26590453566507144, 0.26590453566507144]}}
{"id": "7e7ad0bb-01c0-4d1b-af57-103f4d8350aa", "fitness": 0.26055926990149847, "name": "ANGES", "description": "Improved ANGES by refining mutation strength adjustment for enhanced diversity and convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness change\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.95 if fitness_variance < np.mean(fitness) else 1.05) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 73, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.13.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.09144404875369716, 0.09144404875369716, 0.09144404875369716, 0.39435662532395555, 0.39435662532395555, 0.39435662532395555, 0.2958771356268426, 0.2958771356268426, 0.2958771356268426]}}
{"id": "ca56e7ad-8665-4113-aa74-15475fb4cd05", "fitness": 0.27743093549579445, "name": "ANGES", "description": "ANGES with adaptive mutation strength scaling based on budget utilization.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength * (1 + budget_used / self.budget), (self.neighborhood_size, self.dim))  # Changed line\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 74, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.13.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.09373228493369301, 0.09373228493369301, 0.09373228493369301, 0.3495436589222629, 0.3495436589222629, 0.3495436589222629, 0.38901686263142754, 0.38901686263142754, 0.38901686263142754]}}
{"id": "5b4ce08e-02d8-4c9e-9a91-76eb99226e7d", "fitness": 0.2500557593274715, "name": "ANGES", "description": "Enhanced mutation strategy by adjusting mutation strength based on the budget, aiming for more robust exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance and budget\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - 0.5 * budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 75, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.14.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.05916420758463692, 0.05916420758463692, 0.05916420758463692, 0.30622363269826214, 0.30622363269826214, 0.30622363269826214, 0.3847794376995154, 0.3847794376995154, 0.3847794376995154]}}
{"id": "1824bf70-932f-4174-9aa7-7b8524b6c2b4", "fitness": 0.5239009313583307, "name": "ANGES", "description": "Refined ANGES by dynamically adjusting elite fraction based on budget utilization for more effective exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.06 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 76, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.06.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.44024315736449493, 0.44024315736449493, 0.44024315736449493, 0.5339487640952023, 0.5339487640952023, 0.5339487640952023, 0.5975108726152949, 0.5975108726152949, 0.5975108726152949]}}
{"id": "2f1b900c-3863-4d1b-b9c3-96f66d5d2f06", "fitness": -Infinity, "name": "ANGES", "description": "Further refine ANGES by incorporating adaptive elite fraction adjustment based on budget utilization to enhance convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n            # Adjust elite fraction more aggressively as budget depletes\n            self.elite_fraction *= 0.95 + 0.05 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 77, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {}}
{"id": "cdc572c2-2be5-455e-a92e-84f81f7253f6", "fitness": 0.2931664386329739, "name": "ANGES", "description": "Enhanced ANGES by modifying the mutation strength adjustment to be more adaptive based on elite fitness convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on elite fitness convergence\n            self.mutation_strength *= (0.9 if np.std(fitness[elite_indices]) < 0.1 else 1.1) * (1 - budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 78, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.18.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.520544063833023, 0.520544063833023, 0.520544063833023, 0.07912835447584154, 0.07912835447584154, 0.07912835447584154, 0.2798268975900572, 0.2798268975900572, 0.2798268975900572]}}
{"id": "4e99368b-9c62-4394-abeb-e2656836f3d4", "fitness": 0.5853569895728428, "name": "ANGES", "description": "Introduced a dynamic elite fraction adjustment to enhance diversity based on the optimization progress.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction = max(0.1, self.elite_fraction * (0.98 + 0.04 * (budget_used / self.budget)))  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 79, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.5416880566759228, 0.5416880566759228, 0.5416880566759228, 0.5658684676191312, 0.5658684676191312, 0.5658684676191312, 0.6485144444234741, 0.6485144444234741, 0.6485144444234741]}}
{"id": "b7de46b1-91f8-456a-9bf9-3f2fe32d8596", "fitness": 0.5853569895728428, "name": "ANGES", "description": "Enhanced ANGES with adaptive mutation strength scaling to improve exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.2) * (1 - budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 80, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.5416880566759228, 0.5416880566759228, 0.5416880566759228, 0.5658684676191312, 0.5658684676191312, 0.5658684676191312, 0.6485144444234741, 0.6485144444234741, 0.6485144444234741]}}
{"id": "8d70da77-1acf-4d68-bf95-e17ac5b163ce", "fitness": 0.5537324640738155, "name": "ANGES", "description": "Refined ANGES by modifying the adjustment strategy for mutation strength based on elite fitness variance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.8 if fitness_variance < np.median(fitness[elite_indices]) else 1.2) * (1 - budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 81, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.05.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.6162142370615267, 0.6162142370615267, 0.6162142370615267, 0.5035240066317046, 0.5035240066317046, 0.5035240066317046, 0.5414591485282152, 0.5414591485282152, 0.5414591485282152]}}
{"id": "d1a5b658-0ce9-4bb3-8d4f-643af84d312d", "fitness": 0.2365381112343954, "name": "ANGES", "description": "Refined mutation strength adjustment by incorporating budget utilization for enhanced convergence rates.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance and budget utilization\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - (budget_used / self.budget) ** 2)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 82, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.03.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.24151317474265344, 0.24151317474265344, 0.24151317474265344, 0.2021966232954613, 0.2021966232954613, 0.2021966232954613, 0.26590453566507144, 0.26590453566507144, 0.26590453566507144]}}
{"id": "d1d27301-72fa-4698-8265-3b9335274bfa", "fitness": 0.3741688307772585, "name": "ANGES", "description": "Refined ANGES strategy by adjusting mutation strength decay using an exponential function to enhance exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance and budget utilization\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * np.exp(-budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 83, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.21.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.07328976063691406, 0.07328976063691406, 0.07328976063691406, 0.5047753560630657, 0.5047753560630657, 0.5047753560630657, 0.5444413756317958, 0.5444413756317958, 0.5444413756317958]}}
{"id": "66cc9033-06c3-45f1-bb4a-bb9ed789ba58", "fitness": -Infinity, "name": "ANGES", "description": "Refined ANGES by dynamically adjusting elite fraction based on the variance of fitness to improve exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n\n            # Adjust elite fraction based on fitness variance\n            self.elite_fraction *= (0.98 + 0.04 * (budget_used / self.budget)) * (0.9 if fitness_variance < np.mean(fitness) else 1.1)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 84, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {}}
{"id": "30023f1d-b639-4fb2-bb3d-a140be78b001", "fitness": 0.47463720869365633, "name": "ANGES", "description": "Enhanced ANGES by adjusting population size scaling for better diversity and exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - 0.5 * budget_used / self.budget))  # Changed line\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 85, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.07.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.37315165987512555, 0.37315165987512555, 0.37315165987512555, 0.514376373145943, 0.514376373145943, 0.514376373145943, 0.5363835930599005, 0.5363835930599005, 0.5363835930599005]}}
{"id": "dae0ff05-ef5e-419f-8aee-7fc739180a63", "fitness": 0.3741688307772585, "name": "ANGES", "description": "Improved fitness variance-based mutation strength adjustment by incorporating exponential decay.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance with exponential decay\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * np.exp(-budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 86, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.21.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.07328976063691406, 0.07328976063691406, 0.07328976063691406, 0.5047753560630657, 0.5047753560630657, 0.5047753560630657, 0.5444413756317958, 0.5444413756317958, 0.5444413756317958]}}
{"id": "cb335f21-6772-4932-bb53-7f346349385b", "fitness": 0.26055926990149847, "name": "ANGES", "description": "Optimized ANGES by fine-tuning parameter adjustment based on fitness variance to improve convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.95 if fitness_variance < np.mean(fitness) else 1.05) * (1 - budget_used / self.budget)  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 87, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.13.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.09144404875369716, 0.09144404875369716, 0.09144404875369716, 0.39435662532395555, 0.39435662532395555, 0.39435662532395555, 0.2958771356268426, 0.2958771356268426, 0.2958771356268426]}}
{"id": "70e0ef55-fe84-4e1f-9d5d-a59b18107037", "fitness": 0.36387163543506323, "name": "ANGES", "description": "Introduced adaptive mutation by scaling it with neighborhood best fitness difference to boost exploration when approaching convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            # Modified line\n            self.mutation_strength *= 1 + np.std([fitness[i] - np.min(nf) for i, nf in zip(elite_indices, neighborhood_fitness)])\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 88, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.05.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.301843600440887, 0.301843600440887, 0.301843600440887, 0.38097265151173365, 0.38097265151173365, 0.38097265151173365, 0.408798654352569, 0.408798654352569, 0.408798654352569]}}
{"id": "222c5fe0-48b0-4895-b9a1-6cb5211a278e", "fitness": 0.18879348846593313, "name": "ANGES", "description": "Refined ANGES by enhancing mutation strength adaptation for improved search capability.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)**2  # Changed line\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 89, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.07088704506308396, 0.07088704506308396, 0.07088704506308396, 0.06994339106758163, 0.06994339106758163, 0.06994339106758163, 0.4255500292671338, 0.4255500292671338, 0.4255500292671338]}}
{"id": "64a9e786-1c1f-48af-9a7a-5058a5a0e846", "fitness": 0.40493896173440874, "name": "ANGES", "description": "Introduced adaptive mutation strength scaling with an inverse relation to the elite fitness variance to enhance convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance (change made here)\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (1.1 if fitness_variance < np.mean(fitness) else 0.9) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 90, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.01.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.4089135379542923, 0.4089135379542923, 0.4089135379542923, 0.39626945902489974, 0.39626945902489974, 0.39626945902489974, 0.409633888224034, 0.409633888224034, 0.409633888224034]}}
{"id": "279e5ea9-664e-4397-ae83-088b3227de5b", "fitness": 0.38753265560016525, "name": "ANGES", "description": "Introduced adaptive elite fraction scaling to improve exploration-exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= (0.98 + 0.04 * (budget_used / self.budget)) * (1.02 if budget_used < self.budget / 2 else 0.98)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 91, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.07.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.29948921458482636, 0.29948921458482636, 0.29948921458482636, 0.4013713347399184, 0.4013713347399184, 0.4013713347399184, 0.46173741747575126, 0.46173741747575126, 0.46173741747575126]}}
{"id": "66f5b2e4-1aea-4148-a891-bbe1d7cc7470", "fitness": -Infinity, "name": "ANGES", "description": "ANGES with Adaptive Elite Fraction and Mutation Strength Decay for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n            \n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98  # Changed line\n            self.mutation_strength += 0.05 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 92, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {}}
{"id": "39852510-6626-4025-bb86-19266aac3885", "fitness": -Infinity, "name": "ANGES", "description": "Dynamic Multi-Objective ANGES enhances convergence by balancing exploration and exploitation with adaptive elitism and mutation strategies.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance and budget utilization\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.2) * (0.8 + 0.2 * (budget_used / self.budget))\n\n            self.population_size = max(5, int(50 * (1 - budget_used / self.budget)))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget)**2))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.95 + 0.05 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 93, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {}}
{"id": "686374c8-8e22-45c5-9f71-77ab4175a405", "fitness": 0.47846049939701324, "name": "ANGES", "description": "Introduced adaptive mutation strength scaling based on elite diversity to enhance search efficiency.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on elite diversity\n            diversity_measure = np.mean(np.std(elites, axis=0))\n            self.mutation_strength *= (0.9 if diversity_measure < 0.5 else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 94, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.02.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.5107503483417921, 0.5107503483417921, 0.5107503483417921, 0.46551679148669767, 0.46551679148669767, 0.46551679148669767, 0.4591143583625499, 0.4591143583625499, 0.4591143583625499]}}
{"id": "31026eb7-26ec-472d-8649-c03baa24864b", "fitness": -Infinity, "name": "ANGES", "description": "Introduced adaptive elite fraction adjustment for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.02 * (np.std(fitness) / np.mean(fitness))  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 95, "feedback": "An exception occurred: ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)').", "error": "ValueError('all the input arrays must have same number of dimensions, but the array at index 0 has 2 dimension(s) and the array at index 1 has 1 dimension(s)')", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {}}
{"id": "50e36174-59a1-44b6-b857-a9a0b9f7b8b8", "fitness": 0.5853569895728428, "name": "ANGES", "description": "Refined ANGES by implementing adaptive mutation decay and diverse neighborhood exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))  # Changed line\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 96, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.59 with standard deviation 0.05.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.5416880566759228, 0.5416880566759228, 0.5416880566759228, 0.5658684676191312, 0.5658684676191312, 0.5658684676191312, 0.6485144444234741, 0.6485144444234741, 0.6485144444234741]}}
{"id": "1571a8d9-c702-49a8-b746-f73998458d37", "fitness": 0.45156652354172366, "name": "ANGES", "description": "ANGES with adaptive elite fraction adjustment for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.1) * (1 - budget_used / self.budget)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.99 + 0.02 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 97, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.08.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.3407647329445791, 0.3407647329445791, 0.3407647329445791, 0.473917525246804, 0.473917525246804, 0.473917525246804, 0.5400173124337877, 0.5400173124337877, 0.5400173124337877]}}
{"id": "3c4786de-ad37-4c8e-acca-dc6082bd967f", "fitness": 0.45156652354172366, "name": "ANGES", "description": "Improved ANGES by introducing adaptive mutation and elite retention based on search space exploration.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adjust mutation strength based on fitness variance\n            fitness_variance = np.var(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if fitness_variance < np.mean(fitness) else 1.05) * (1 - budget_used / self.budget)  # Changed line\n\n            self.population_size = max(10, int(50 * (1 - budget_used / self.budget)))  # Changed line\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))\n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.99 + 0.02 * (budget_used / self.budget)  # Changed line\n\n        best_index = np.argmin(fitness)\n        return population[best_index]", "configspace": "", "generation": 98, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.08.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.3407647329445791, 0.3407647329445791, 0.3407647329445791, 0.473917525246804, 0.473917525246804, 0.473917525246804, 0.5400173124337877, 0.5400173124337877, 0.5400173124337877]}}
{"id": "6421a418-e93a-4bf2-a7d4-85501e4d7807", "fitness": 0.050658724756881456, "name": "ANGES", "description": "Enhanced ANGES with adaptive mutation strength and diverse initialization to improve exploration and convergence.", "code": "import numpy as np\n\nclass ANGES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 50\n        self.neighborhood_size = 5\n        self.mutation_strength = 0.1\n        self.elite_fraction = 0.2\n\n    def __call__(self, func):\n        np.random.seed(42)\n        # Diverse initialization with Sobol sequence\n        initial_population = np.random.uniform(0, 1, (self.population_size, self.dim))\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * initial_population\n        fitness = np.apply_along_axis(func, 1, population)\n        budget_used = self.population_size\n\n        while budget_used < self.budget:\n            elite_size = int(self.elite_fraction * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_size]\n            elites = population[elite_indices]\n\n            # Adaptive mutation strength based on the best fitness improvement\n            best_fitness_improvement = np.min(fitness) - np.min(fitness[elite_indices])\n            self.mutation_strength *= (0.9 if best_fitness_improvement < 0.01 else 1.1)\n\n            self.population_size = int(50 * (1 - budget_used / self.budget))\n            self.neighborhood_size = max(1, int(5 * (1 - budget_used / self.budget) * (1 + budget_used / self.budget)))  \n            neighborhoods = [elites[i] + np.random.normal(0, self.mutation_strength, (self.neighborhood_size, self.dim))\n                             for i in range(elite_size)]\n            neighborhoods = np.clip(neighborhoods, self.lower_bound, self.upper_bound)\n\n            neighborhood_fitness = [np.apply_along_axis(func, 1, neighborhood) for neighborhood in neighborhoods]\n            neighborhood_best_indices = [np.argmin(nf) for nf in neighborhood_fitness]\n            neighborhood_best = [neighborhoods[i][neighborhood_best_indices[i]] for i in range(elite_size)]\n\n            population = np.concatenate((elites, neighborhood_best), axis=0)\n            fitness = np.array([func(ind) for ind in population])\n            budget_used += elite_size * self.neighborhood_size\n            self.elite_fraction *= 0.98 + 0.04 * (budget_used / self.budget)\n\n        best_index = np.argmin(fitness)\n        return population[best_index]\n\n# Example usage:\n# optimizer = ANGES(budget=1000, dim=10)\n# best_solution = optimizer(lambda x: np.sum(x**2))", "configspace": "", "generation": 99, "feedback": "The algorithm ANGES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["90eba625-1954-467d-b0d9-2e13175a9093"], "operator": null, "metadata": {"aucs": [0.05871595794750628, 0.05871595794750628, 0.05871595794750628, 0.04254328603478885, 0.04254328603478885, 0.04254328603478885, 0.05071693028834923, 0.05071693028834923, 0.05071693028834923]}}
