{"id": "e255e012-bd73-4235-8c88-a7dd70b356b3", "fitness": 0.06312717862854082, "name": "AdaptiveClusteringOptimizer", "description": "Adaptively balanced exploration-exploitation metaheuristic leveraging dynamic population clustering for efficient search.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 2)  # Number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)\n        new_candidates = cluster_center + perturbation\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.07008700241826737, 0.06216541850834845, 0.05453284055872154, 0.06510150786309321, 0.05730950576990701, 0.05190601905092207, 0.07882323185369022, 0.06765255443850393, 0.060566527195413555]}}
{"id": "f3e5d3ef-f81a-4531-a689-cde289a2aed5", "fitness": 0.06407190774453125, "name": "AdaptiveClusteringOptimizer", "description": "Improved dynamic clustering and exploration balance with adaptive cluster count adjustment for enhanced search efficiency.  ", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Adjusted perturbation range\n        new_candidates = cluster_center + perturbation\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["e255e012-bd73-4235-8c88-a7dd70b356b3"], "operator": null, "metadata": {"aucs": [0.07173315578778383, 0.06780245004499486, 0.053732610494165334, 0.065904825058827, 0.05875875741264158, 0.05004363265409362, 0.08008838253178918, 0.0705038143163953, 0.05807954140009064]}}
{"id": "395039f0-0e95-4aae-ab83-a1a67281bf77", "fitness": 0.06392279658483173, "name": "AdaptiveClusteringOptimizer", "description": "Enhanced exploration strategy with adaptive perturbation for more effective search in solution space.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation_range = 0.3 * (0.5 + np.std(cluster, axis=0) / self.upper_bound)  # Adaptive perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)\n        new_candidates = cluster_center + perturbation\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["f3e5d3ef-f81a-4531-a689-cde289a2aed5"], "operator": null, "metadata": {"aucs": [0.07355208732635343, 0.06518013142280477, 0.05315883717322878, 0.06800699735674742, 0.05767402932622989, 0.049153514550434596, 0.08349863061805507, 0.06827345747373315, 0.05680748401589841]}}
{"id": "775870f9-4c93-4bf0-8453-f26b7d1fac65", "fitness": 0.05686756855510725, "name": "AdaptiveClusteringOptimizer", "description": "Enhanced exploration and exploitation strategy with dynamic perturbation and population size adjustment for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation_range = np.std(cluster)  # Dynamic perturbation based on cluster deviation\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)\n        new_candidates = cluster_center + perturbation\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["f3e5d3ef-f81a-4531-a689-cde289a2aed5"], "operator": null, "metadata": {"aucs": [0.05729735981693418, 0.05850532111373952, 0.057686333369670995, 0.05304586868965655, 0.05477704609727663, 0.04860961215152426, 0.06161544119061091, 0.0641477827922875, 0.05612335177426475]}}
{"id": "6c82887c-ea0d-45e6-8355-4a6c7e50abb5", "fitness": 0.06607087574625138, "name": "AdaptiveClusteringOptimizer", "description": "Enhanced AdaptiveClusteringOptimizer with refined cluster exploration using strategic scaling for improved solution refinement.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.5  # Introduced scaling factor for exploration\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["f3e5d3ef-f81a-4531-a689-cde289a2aed5"], "operator": null, "metadata": {"aucs": [0.0811202620184096, 0.06248133201947359, 0.05043539785112916, 0.07431064187180514, 0.06018778753857135, 0.04625785039244912, 0.09489747913041813, 0.07189498686513729, 0.05305214402886904]}}
{"id": "1f6200b0-bb00-44de-9a38-56c7e89c9d39", "fitness": 0.06302785481745449, "name": "AdaptiveClusteringOptimizer", "description": "Enhanced cluster exploration with adaptive perturbation scaling for improved refinement.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape) \n        scaling_factor = np.std(cluster, axis=0) * 0.5  # Adaptive scaling factor based on cluster std deviation\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["6c82887c-ea0d-45e6-8355-4a6c7e50abb5"], "operator": null, "metadata": {"aucs": [0.07395405266356447, 0.06096191309115295, 0.04855181208977133, 0.06667078956641781, 0.057870342176290834, 0.05065592437821298, 0.08128597353791611, 0.06848436840407657, 0.05881551744968727]}}
{"id": "d2f44e49-8afd-4870-98ec-193d08dcd1c7", "fitness": 0.0653839211737654, "name": "AdaptiveClusteringOptimizer", "description": "Enhanced exploration by introducing dynamic scaling factor and perturbation adjustment for improved convergence efficiency.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.5 + (0.5 * np.random.rand())  # Introduced dynamic scaling factor for exploration\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["6c82887c-ea0d-45e6-8355-4a6c7e50abb5"], "operator": null, "metadata": {"aucs": [0.07670294387295751, 0.07221798028315107, 0.04974945299525779, 0.07068098191790351, 0.058049930357674584, 0.048342923565226514, 0.08814548266471833, 0.06881046921813339, 0.05575512568886598]}}
{"id": "39ff4245-9a28-485f-b254-81c56e79eeb0", "fitness": 0.06200924749770244, "name": "AdaptiveClusteringOptimizer", "description": "Enhanced AdaptiveClusteringOptimizer with dynamic scaling factor for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = np.random.uniform(0.4, 0.6)  # Dynamic scaling factor for exploration\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["6c82887c-ea0d-45e6-8355-4a6c7e50abb5"], "operator": null, "metadata": {"aucs": [0.0710577369410047, 0.06219810790108127, 0.05001021884546408, 0.06591257307435061, 0.058465537986105875, 0.046871747468845926, 0.08005590603061585, 0.06967019373422478, 0.05384120549762883]}}
{"id": "9a10a737-6b38-43b0-b9cd-1996ec620607", "fitness": 0.07004582928245344, "name": "AdaptiveClusteringOptimizer", "description": "Enhanced exploration via dynamic scaling adjustment in cluster perturbation to boost performance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 10  # Dynamic scaling factor adjustment\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["6c82887c-ea0d-45e6-8355-4a6c7e50abb5"], "operator": null, "metadata": {"aucs": [0.08820278410693771, 0.05901062685344971, 0.051158693689899226, 0.07970103384877225, 0.0644038090282909, 0.046851471635280584, 0.10806690105243333, 0.07920264864739779, 0.05381449467961941]}}
{"id": "d6fbeca9-5c62-4ed5-89fb-9bf21dd27414", "fitness": 0.06619899142451505, "name": "AdaptiveClusteringOptimizer", "description": "Enhanced exploration via dynamic scaling adjustment in cluster perturbation with adaptive cluster centering to boost performance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.median(cluster, axis=0)  # Change mean to median for robust centering\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Adjust scaling factor computation\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 9, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["9a10a737-6b38-43b0-b9cd-1996ec620607"], "operator": null, "metadata": {"aucs": [0.07365140675329385, 0.060100236638416904, 0.053542099259426434, 0.06814688404486013, 0.06599127565157681, 0.050558936071386174, 0.0837262044578847, 0.0814026245834204, 0.05867125536036999]}}
{"id": "b19c17d8-6b8d-4ca2-95ca-8abd3ccc5f42", "fitness": -Infinity, "name": "AdaptiveClusteringOptimizer", "description": "Introduced adaptive mutation scaling based on cluster score variance for improved exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)\n        cluster_scores = np.array([func(ind) for ind in cluster])  # Change 1\n        scaling_factor = 0.5 + np.std(cluster_scores) / 10  # Change 2\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))  # Change 3\n        return population[best_index]", "configspace": "", "generation": 10, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["9a10a737-6b38-43b0-b9cd-1996ec620607"], "operator": null, "metadata": {}}
{"id": "5238122c-5bb7-4d5a-8335-5305a8011cab", "fitness": 0.06697603714044488, "name": "AdaptiveClusteringOptimizer", "description": "Optimized exploration by adjusting perturbation range based on cluster variation for better performance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation_range = np.std(cluster, axis=0) * 0.05  # Adjusted perturbation range based on cluster variation\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 10  # Dynamic scaling factor adjustment\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 11, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["9a10a737-6b38-43b0-b9cd-1996ec620607"], "operator": null, "metadata": {"aucs": [0.08024216449707378, 0.06430805014926544, 0.04912248770221872, 0.07358635218183351, 0.058778928192633084, 0.052346061542766886, 0.09348115634318921, 0.0697983044914049, 0.061120829163618384]}}
{"id": "92d96477-0b1f-49a9-9128-b88215a22a8c", "fitness": 0.06454325046001458, "name": "AdaptiveClusteringOptimizer", "description": "Improved AdaptiveClusteringOptimizer with dynamic exploration-exploitation balance using variance-based perturbation adjustment to refine optimization.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 10  # Dynamic scaling factor adjustment\n        new_candidates = cluster_center + perturbation * scaling_factor * np.std(cluster, axis=0)  # Adjusted line\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 12, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["9a10a737-6b38-43b0-b9cd-1996ec620607"], "operator": null, "metadata": {"aucs": [0.07367597390799352, 0.06416781405506944, 0.047057659827020926, 0.06733876332593125, 0.06067538463332112, 0.05209809215441974, 0.08243973798482607, 0.07265984401255265, 0.06077598423899644]}}
{"id": "39c401ed-a2d9-4ea8-939c-5622d6a7e9f5", "fitness": 0.05796976089728761, "name": "AdaptiveClusteringOptimizer", "description": "Introduced adaptive cluster count and refined perturbation scaling for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 2)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Increased perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 10  # Dynamic scaling factor adjustment\n        new_candidates = cluster_center + perturbation * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 13, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["9a10a737-6b38-43b0-b9cd-1996ec620607"], "operator": null, "metadata": {"aucs": [0.06636336402275, 0.06169202673760121, 0.04575130768816815, 0.06186146392805836, 0.05517827972789535, 0.04312428966514836, 0.07389387478166798, 0.06470679861973416, 0.04915644290456489]}}
{"id": "b446f6d8-d562-40a5-be8d-be909da07895", "fitness": 0.0710069960770749, "name": "AdaptiveClusteringOptimizer", "description": "Improve convergence speed by refining scaling factor adjustment and introducing a mutation factor.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.1, 0.1, cluster.shape)  # Slightly reduced perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.1, cluster.shape)  # Introduce mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 14, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["9a10a737-6b38-43b0-b9cd-1996ec620607"], "operator": null, "metadata": {"aucs": [0.08891412061649984, 0.0632103963657733, 0.050807931220086755, 0.08034846281070684, 0.061311121218700526, 0.05140587416616238, 0.10916171840667688, 0.07367748952638531, 0.060225850362682354]}}
{"id": "6415b15f-7ae3-43bb-a9c8-ca2aaaf59870", "fitness": 0.058955058710262104, "name": "AdaptiveClusteringOptimizer", "description": "Improve convergence speed by refining perturbation range and increasing cluster count.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(3, self.dim // 2)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)  # Slightly increased perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.1, cluster.shape)  # Introduce mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 15, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["b446f6d8-d562-40a5-be8d-be909da07895"], "operator": null, "metadata": {"aucs": [0.06801555926100533, 0.06782963896608574, 0.045817934721105735, 0.06328905495565096, 0.054778263705162145, 0.04239159329160669, 0.07609205820530573, 0.06414955337977357, 0.048231871906663004]}}
{"id": "6020247e-afe5-4dd0-bf13-ab46fba2f872", "fitness": 0.06090370773148928, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploitation through dynamic clustering and adaptive mutation rate for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.05, 0.05, cluster.shape)  # Reduced perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 10  # More refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.05, cluster.shape)  # Reduced mutation factor for precision\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 16, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["b446f6d8-d562-40a5-be8d-be909da07895"], "operator": null, "metadata": {"aucs": [0.07135346954381105, 0.059360769658856616, 0.048060123371596486, 0.06578035511114355, 0.057414247959200915, 0.04586924664077907, 0.07988813612795409, 0.06784808406043363, 0.05255893710962811]}}
{"id": "fc8cb6d7-af16-4023-99f8-446393e0b662", "fitness": 0.06567296683312898, "name": "AdaptiveClusteringOptimizer", "description": "Enhance the exploration-exploitation balance by adjusting mutation and scaling factors based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.1, 0.1, cluster.shape)  \n        diversity = np.std(cluster)\n        scaling_factor = 0.6 + diversity / 4  # Increased effect of diversity\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Increased mutation factor variance\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 17, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["b446f6d8-d562-40a5-be8d-be909da07895"], "operator": null, "metadata": {"aucs": [0.07394012264414052, 0.07473970116608986, 0.053781843773117344, 0.06838144685662773, 0.05762134366516691, 0.050887776284689545, 0.08418259135800965, 0.06838689924338515, 0.05913497650693411]}}
{"id": "c4d6b0b7-dec2-4314-8b92-43d6eab89c41", "fitness": 0.06781725575021944, "name": "AdaptiveClusteringOptimizer", "description": "Enhance clustering strategy by incorporating adaptive mutation factor based on cluster diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.1, 0.1, cluster.shape)  # Slightly reduced perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        cluster_diversity = np.std(cluster)\n        mutation_factor = np.random.normal(0, 0.1 * cluster_diversity, cluster.shape)  # Adaptive mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 18, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["b446f6d8-d562-40a5-be8d-be909da07895"], "operator": null, "metadata": {"aucs": [0.08430291228096187, 0.07195330051291626, 0.046591211825842804, 0.07679192539573942, 0.05705341277480058, 0.04895430147893487, 0.10083988326228588, 0.06731215875916086, 0.05655619546133239]}}
{"id": "3425daf3-8e5f-41b4-b4db-b7f80eb47aa4", "fitness": 0.06749628603840664, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by increasing the perturbation range and improving the mutation factor distribution.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)  # Increased perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.15, cluster.shape)  # Improved mutation factor distribution\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 19, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["b446f6d8-d562-40a5-be8d-be909da07895"], "operator": null, "metadata": {"aucs": [0.0827978003163915, 0.06171780303635932, 0.049962226660924536, 0.07561136354016629, 0.060890562465408915, 0.04890708442609648, 0.09785399203427936, 0.07323229716786528, 0.05649344469816808]}}
{"id": "93611042-7373-43ee-b017-643121a39973", "fitness": 0.06781725575021944, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by dynamically adjusting mutation based on cluster diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.1, 0.1, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        diversity_factor = np.std(cluster) / 10  # Line changed\n        mutation_factor = np.random.normal(0, diversity_factor, cluster.shape)  # Line changed\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 20, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["b446f6d8-d562-40a5-be8d-be909da07895"], "operator": null, "metadata": {"aucs": [0.08430291228096187, 0.07195330051291626, 0.046591211825842804, 0.07679192539573942, 0.05705341277480058, 0.04895430147893487, 0.10083988326228588, 0.06731215875916086, 0.05655619546133239]}}
{"id": "c6f727cc-d4db-4b81-89bd-da0aa7657fdd", "fitness": 0.08067579039997567, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by expanding the perturbation range and refine mutation factors.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 21, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.03.", "error": "", "parent_ids": ["b446f6d8-d562-40a5-be8d-be909da07895"], "operator": null, "metadata": {"aucs": [0.09925434691695656, 0.07275512376360727, 0.05002392615861406, 0.09091570410608896, 0.0667116712665361, 0.04919863852539008, 0.15769880527020308, 0.08265308025888729, 0.056870817333497636]}}
{"id": "6ea4532f-a7f5-41b2-8b90-d53c93873e71", "fitness": 0.06353637403353594, "name": "AdaptiveClusteringOptimizer", "description": "Introduce dynamic exploration-exploitation balance by adjusting perturbation and scaling factors based on iteration count.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n        self.iteration = 0\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation_range = 0.3 * (1 - self.iteration / (self.budget / self.population_size))\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)  # Dynamic perturbation range\n        scaling_factor = (0.4 + 0.2 * np.cos(np.pi * self.iteration / (self.budget / self.population_size)))  # Dynamic scaling factor\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n            self.iteration += 1  # Increase iteration count\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 22, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07521245929351938, 0.06509954135582052, 0.0527578505789803, 0.06922369866170597, 0.05633897306643765, 0.0471316015150961, 0.08557508636585398, 0.0663039424939107, 0.05418421297049891]}}
{"id": "eb681879-5f5b-4b05-81c2-0d1ae8fa9bf8", "fitness": 0.06749628603840664, "name": "AdaptiveClusteringOptimizer", "description": "Adjust mutation factor and perturbation range to enhance convergence precision. ", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)  # Adjust perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.15, cluster.shape)  # Adjust mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 23, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0827978003163915, 0.06171780303635932, 0.049962226660924536, 0.07561136354016629, 0.060890562465408915, 0.04890708442609648, 0.09785399203427936, 0.07323229716786528, 0.05649344469816808]}}
{"id": "4e873d75-2145-454c-b225-5f6ce944e680", "fitness": 0.06546820747840143, "name": "AdaptiveClusteringOptimizer", "description": "Introduce adaptive mutation scaling based on iteration progress to improve convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster, iteration_fraction):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2 * (1 - iteration_fraction), cluster.shape)  # Adaptive mutation scaling\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n        total_iterations = self.budget // self.population_size\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            iteration_fraction = evaluations / self.budget  # Calculate iteration fraction for adaptive mutation\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster, iteration_fraction)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 24, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07947509517333218, 0.060081217508718754, 0.05466305589459275, 0.07336385127055389, 0.05659706323279312, 0.04860981884233062, 0.09355375853013259, 0.06672405388918745, 0.05614595296397151]}}
{"id": "624b6ec4-7be6-4f2c-99e0-151b9e2320e6", "fitness": 0.07189603152383311, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by refined perturbation and improved mutation dynamics for optimized search efficiency.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.35, 0.35, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.15, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 25, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.03.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07087483829015762, 0.06201789087327536, 0.05096755894928717, 0.07023147303444877, 0.0591969982761269, 0.048565050783370145, 0.15871101308928093, 0.0704627832113639, 0.05603667720718719]}}
{"id": "906b015c-383d-4beb-a995-7792c1736e7e", "fitness": 0.061541723148585796, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by increasing perturbation range and incorporating dynamic scaling in mutation factors.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 6  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Modified mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 26, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06745234270873712, 0.06152908494864873, 0.052672808412913885, 0.06230862616224475, 0.05628490882001769, 0.05205080866064571, 0.07456897896896109, 0.06630644059491464, 0.06070150906018856]}}
{"id": "80efade2-cdef-4342-bc4a-1b9701fd6d55", "fitness": 0.06107920121141042, "name": "AdaptiveClusteringOptimizer", "description": "Improve the algorithm by adjusting clustering strategies and mutation dynamics.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 2)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 5  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.15, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 27, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06838401515816928, 0.06214208600781801, 0.049327572782468576, 0.06360785777319766, 0.05795446315163433, 0.04789711675376751, 0.07660798996113694, 0.0685643345482363, 0.05522737476626516]}}
{"id": "b8fc9b70-4f77-40c5-a4ab-a104ceaed6b6", "fitness": 0.06575163098318315, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by expanding perturbation range, refine mutation factors, and adaptively adjust cluster counts based on dimensionality.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 2)  # Adjusted number of clusters for better adaptability\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Refined mutation factor for better exploration\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 28, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0840918246872675, 0.05957615681289408, 0.048857597480315484, 0.0766728012660911, 0.054768890167081086, 0.048137143797079895, 0.09998528353662106, 0.0641366970339119, 0.05553828406738626]}}
{"id": "a5a58380-c35d-472d-8ea6-26e136c58b7e", "fitness": 0.06203831072958274, "name": "AdaptiveClusteringOptimizer", "description": "Introduce stochastic ranking and enhanced mutation factors for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  \n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Enhanced mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def stochastic_ranking(self, population, scores):\n        probabilities = np.random.rand(len(population))\n        return population[np.argsort(scores + probabilities)]  # Stochastic ranking of solutions\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n            population = self.stochastic_ranking(population, scores)  # Apply stochastic ranking\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 29, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07127445519986231, 0.060986605395665916, 0.051229299984292265, 0.06595566814821552, 0.057180911587964345, 0.04812568723821964, 0.08040942186018252, 0.06767537295147708, 0.05550737420036511]}}
{"id": "0c55ec47-18ab-4b2f-b1f5-02a744e31a0f", "fitness": 0.05553722807548115, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration by dynamically adjusting perturbation and mutation factors based on cluster diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        diversity = np.std(cluster, axis=0) # Calculate the diversity of the cluster\n        perturbation = np.random.uniform(-diversity, diversity, cluster.shape)  # Dynamic perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, diversity/5, cluster.shape)  # Dynamic mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 30, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.057687472704962994, 0.0586177816535437, 0.04501509331081721, 0.05412616615503607, 0.056982565440298116, 0.04529114445711535, 0.06307142946673794, 0.06722062465645451, 0.05182277483436448]}}
{"id": "3aa93a32-ca0a-46ee-9e1b-0cad22788da4", "fitness": 0.06350218433637314, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by modifying perturbation and scaling factor for improved diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.8 + np.std(cluster, axis=0) / 6  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07347946914856429, 0.05965097378109585, 0.05312344945481229, 0.06801381462677569, 0.05835781101877291, 0.04920949145278408, 0.08361453097797811, 0.06918200839591682, 0.0568881101706582]}}
{"id": "5c92e00e-29f8-48b9-99da-8d7f09639b1a", "fitness": 0.06422263687683379, "name": "AdaptiveClusteringOptimizer", "description": "Fine-tune exploration using dynamic perturbation scaling and adaptive mutation for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 10  # Adjusted scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.1, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 32, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07315036320100698, 0.06189445094551593, 0.046160674500507204, 0.06826678808536069, 0.061269703825711175, 0.05066917066360399, 0.08401545926155063, 0.07374520456512013, 0.058831916843127385]}}
{"id": "c997621b-7602-4022-ac03-9baa20d6df55", "fitness": 0.06730110833967513, "name": "AdaptiveClusteringOptimizer", "description": "Improve clustering stability and mutation diversity for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.median(cluster, axis=0)  # Change 1: Use median for clustering stability\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Change 2: Increase mutation diversity\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 33, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07457893065863785, 0.062096554851529095, 0.05557968138789948, 0.06889917267589751, 0.05924184515001951, 0.0558669522139138, 0.08517352364177344, 0.07046853316796997, 0.07380478130943557]}}
{"id": "594347c3-9925-420b-b464-a81b8209d5b6", "fitness": 0.06847168074390662, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration and exploitation balance by adjusting the mutation and scaling factors based on convergence rate.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 10  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 34, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.08451874178217977, 0.06300855744965528, 0.05526583102700999, 0.07693620192254835, 0.05715523576812631, 0.05118516284245922, 0.1011084838503099, 0.0675381921850372, 0.05952871986783359]}}
{"id": "c9f78204-8666-4070-ad20-ca4eb46228d4", "fitness": 0.06576674815394394, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration through enhanced perturbation variability and adaptive cluster scaling.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Enhanced perturbation variability\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 6  # Adaptive cluster scaling\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 35, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06961335225998111, 0.061864280506325864, 0.054544726014483125, 0.06466316625724988, 0.06887245865923897, 0.04963902489846639, 0.07829891672144873, 0.08694496311127231, 0.05745984495702905]}}
{"id": "35c90f75-03c2-47d5-aeed-9351d4d92112", "fitness": 0.06061502763519365, "name": "AdaptiveClusteringOptimizer", "description": "Improve cluster diversity by dynamically adjusting the number of clusters and enhancing exploration range.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 2)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 36, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06855167420271568, 0.060403339959219426, 0.05155359850114927, 0.06374892063501703, 0.05619560043764704, 0.047475182881247746, 0.0767465065717714, 0.06622509223495199, 0.05463533329302328]}}
{"id": "6fd1d0f6-1bfd-499c-9de1-80c6893df016", "fitness": 0.062430443501380856, "name": "AdaptiveClusteringOptimizer", "description": "Enhance solution diversity with random restart and improve convergence by refining scaling and mutation factors.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  \n        self.cluster_count = max(2, self.dim // 3)  \n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape) \n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 6  # Adjusted scaling factor\n        mutation_factor = np.random.normal(0, 0.15, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 37, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07102723691518953, 0.06043043672315185, 0.05008966494918543, 0.06603398468255628, 0.05678229218236064, 0.05093979020657535, 0.08029750136064007, 0.0670709547054873, 0.05920212978728123]}}
{"id": "9e7bac73-2313-4a21-81ab-796c30fe921d", "fitness": 0.06249003749981371, "name": "AdaptiveClusteringOptimizer", "description": "Introduce diversity by adjusting perturbation and mutation strategies for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expanded perturbation range for diversity\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 6  # Refined scaling factor adjustment for better scaling\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Increased mutation factor for more exploration\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 38, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06915032940301746, 0.06061971084428175, 0.0530968585467434, 0.06411111452012375, 0.0572747228579682, 0.05224690733496784, 0.0772881622481647, 0.06764283970050311, 0.06097969204255316]}}
{"id": "090d1655-100a-4119-9ad4-6e109c3bae59", "fitness": 0.06508698549934006, "name": "AdaptiveClusteringOptimizer", "description": "Enhance the exploration-exploitation balance by adjusting perturbation and mutation dynamics.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.25, 0.25, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 10  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 39, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07627103113399136, 0.06402407899674845, 0.05027046123366696, 0.07032095324285514, 0.05988138875327709, 0.049150443721695636, 0.0875147221675916, 0.07150219117661738, 0.05684759906761683]}}
{"id": "579a7e66-7d0b-40ca-b7fb-7072618211ec", "fitness": 0.06109748367491433, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploitation by dynamically adjusting mutation factors based on cluster compactness.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        cluster_compactness = np.std(cluster, axis=0)  # Measure of compactness\n        scaling_factor = 0.6 + cluster_compactness / 8\n        mutation_factor = np.random.normal(0, 0.1 + cluster_compactness / 5, cluster.shape)  # Adjust mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 40, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06650354987600082, 0.06194669693965371, 0.05058602539855095, 0.06317265387882687, 0.05845988603225971, 0.04794707670561249, 0.07614075735601611, 0.06930257392734662, 0.05581813295996163]}}
{"id": "fed68cfe-f532-4acf-b0ea-61a1dfa515f6", "fitness": 0.0675806878220338, "name": "AdaptiveClusteringOptimizer", "description": "Enhance adaptive behavior by dynamically adjusting the perturbation and mutation scaling factors based on convergence progress.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation_factor = 0.3 + np.std(cluster) / 10  # Dynamic perturbation factor\n        perturbation = np.random.uniform(-perturbation_factor, perturbation_factor, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Adjust mutation factor range\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 41, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07178062278094544, 0.06084531852781827, 0.057805384070237165, 0.06633098122235226, 0.06636824539308817, 0.05532866721695384, 0.08234947125169512, 0.0821100533791369, 0.06530744655607701]}}
{"id": "3397aa10-cd36-48fe-92fa-fc1c636c8510", "fitness": 0.062405861526722846, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration by introducing adaptive perturbation range and scaling factor based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        diversity = np.std(cluster, axis=0)  # Measure diversity of the cluster\n        perturbation_range = 0.3 + (0.2 * np.mean(diversity))  # Adaptive perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)\n        scaling_factor = 0.6 + diversity / 8  # Adjust scaling factor based on diversity\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 42, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06288154304325544, 0.06254763818291786, 0.05550749228239449, 0.05878251794007727, 0.057764004194659546, 0.056569173220221036, 0.06947273093148387, 0.06832377271247358, 0.0698038812330225]}}
{"id": "6b7cd888-f91a-4785-a170-f4d257b3f47e", "fitness": 0.06249003749981371, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration by increasing perturbation range and introducing adaptive mutation scaling.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 6  # Adjusted scaling factor\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Increased mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06915032940301746, 0.06061971084428175, 0.0530968585467434, 0.06411111452012375, 0.0572747228579682, 0.05224690733496784, 0.0772881622481647, 0.06764283970050311, 0.06097969204255316]}}
{"id": "c8f2a648-ec2e-4251-a8f2-5155269dd708", "fitness": 0.06350324321590178, "name": "AdaptiveClusteringOptimizer", "description": "Improve convergence by fine-tuning cluster perturbation and scaling factors.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.25, 0.25, cluster.shape)  # Fine-tuned perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 10  # Further refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.15, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 44, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07431557203990125, 0.06090862018927512, 0.05120792254159556, 0.06848734608808127, 0.05745262117374206, 0.04955096248814983, 0.08433972142893154, 0.0678922236530165, 0.05737419934042298]}}
{"id": "c05f1e4d-0585-4632-922c-f8cc6f8a0ed1", "fitness": 0.0651824423227399, "name": "AdaptiveClusteringOptimizer", "description": "Introduce adaptive perturbation and mutation tuning to enhance both exploration and exploitation efficiency.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        # Adaptive perturbation and mutation\n        adapt_factor = 1 + np.random.rand() * 0.05\n        new_candidates = cluster_center + (perturbation + mutation_factor * adapt_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 45, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07639761115765864, 0.06163390842459615, 0.05440798472768804, 0.07043162414093662, 0.05869728807214958, 0.04985429022504928, 0.08777847962374541, 0.0696977391441902, 0.057743055388645215]}}
{"id": "b3b879ec-9aed-4be1-8b98-f7c3726de8a3", "fitness": 0.06447880416438583, "name": "AdaptiveClusteringOptimizer", "description": "Improve perturbation by increasing its range for better exploration.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 46, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07097131730392181, 0.06268703470799619, 0.052249407743953924, 0.06531765912912535, 0.06273806565620577, 0.05132924891874924, 0.07921846026111101, 0.0758832895792434, 0.0599147541791657]}}
{"id": "5bae2328-140b-4f2b-9f09-203d4ce2b43e", "fitness": 0.06079911298152323, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by expanding the perturbation range and refine mutation factors with adaptive population size and dynamic clustering.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, max(10, budget // 10))  # Adjusted population size\n        self.cluster_count = max(2, min(10, self.dim // 3))  # Limited number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 47, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06931475781626395, 0.06337083841093039, 0.054988782079549714, 0.060778625284231724, 0.05966175395972961, 0.04502360078184042, 0.07198504362769065, 0.07062881270754295, 0.05143980216592969]}}
{"id": "3ccc92ab-618c-480d-bc3c-d1a52bae52d2", "fitness": 0.06286015766301477, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploitation by adjusting the mutation factor with a smaller standard deviation.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.1, cluster.shape)  # Refine mutation factor with smaller std dev\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 48, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07571637487460225, 0.060400611596046816, 0.047354920455672245, 0.06831788547704709, 0.057759142774630345, 0.04824365614390458, 0.08400686730386586, 0.06833370895349822, 0.055608251387865515]}}
{"id": "834b6437-086b-4efa-8cd5-a4626ebef3f4", "fitness": 0.06543317910636842, "name": "AdaptiveClusteringOptimizer", "description": "Adaptive clustering and diversified perturbation for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 49, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0702886679721656, 0.06123789499561838, 0.0536397048155518, 0.06527884323068367, 0.06296775265687926, 0.05507239796754704, 0.07914522681319669, 0.07633661088861154, 0.06493151261706187]}}
{"id": "53bb63f9-6bd8-4516-a9ae-c5853a28abc0", "fitness": 0.06326120444768471, "name": "AdaptiveClusteringOptimizer", "description": "Refine exploration by introducing dynamic perturbation scaling and adaptive mutation range.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape) * (1 + np.std(cluster) / 10)  # Dynamic perturbation scaling\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2 * (1 + np.std(cluster) / 10), cluster.shape)  # Adaptive mutation range\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 50, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06827832111396481, 0.06445764161678902, 0.05446851117831508, 0.06350994481874173, 0.057232177045558275, 0.05388043003210352, 0.07651799091843059, 0.06759519364675426, 0.06341062965850508]}}
{"id": "a9a9c59f-c8e2-4d5b-96a8-bde4df4a1973", "fitness": 0.061612667481959954, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by dynamically adjusting mutation factors based on cluster diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        mutation_factor = np.random.normal(0, 0.2 + np.std(cluster) / 5, cluster.shape)  # Dynamic mutation adjustment\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 51, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06592203161943688, 0.06841003358642395, 0.05092064983143196, 0.060686070114953305, 0.05879695221822445, 0.04993246791353634, 0.07219706946467963, 0.06979718177916838, 0.05785155080978466]}}
{"id": "ba06c36a-adbe-4b57-b4ff-038e2a6bb767", "fitness": 0.061449175856976054, "name": "AdaptiveClusteringOptimizer", "description": "Improve convergence by increasing population diversity and adaptive mutation scaling.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(150, budget)  # Increased initial population size\n        self.cluster_count = max(2, self.dim // 3)  \n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.4 + np.std(cluster, axis=0) / 4  # Adaptive scaling factor\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 52, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06228202307420183, 0.060485054985815245, 0.05659503973875579, 0.05737205789319344, 0.060689707915129065, 0.05283252115813708, 0.06766600830535274, 0.07309161330522629, 0.06202855633697302]}}
{"id": "242256af-1f3b-4b07-a446-c0f95858dd24", "fitness": 0.05832098588094069, "name": "AdaptiveClusteringOptimizer", "description": "Utilize adaptive clustering with dynamic mutation scaling and diverse exploration for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)\n        self.cluster_count = max(2, self.dim // 3)\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Increased range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 5  # More dynamic scaling\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Increased variance\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        diversity_candidates = np.random.uniform(self.lower_bound, self.upper_bound, cluster.shape)  # Added diversity\n        new_candidates = np.where(np.random.rand(*cluster.shape) < 0.5, new_candidates, diversity_candidates)  # Blend new and diverse\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 53, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.05859590560078243, 0.05954805924211248, 0.053883899332934804, 0.054971922404288165, 0.0587541801555842, 0.04876550767214538, 0.06417314207531921, 0.06988299481539018, 0.05631326162990935]}}
{"id": "7f06fe84-55c5-4acc-9506-d26d239a945b", "fitness": -Infinity, "name": "AdaptiveClusteringOptimizer", "description": "Introduce adaptive scaling based on convergence to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        # Introduce adaptive scaling based on cluster score variance\n        score_variance = np.var([func(ind) for ind in cluster])\n        adaptive_factor = 0.3 * np.tanh(score_variance)\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape) * adaptive_factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 54, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {}}
{"id": "24c06d7c-d8ed-482b-b70a-a7a2fec646cd", "fitness": 0.061543067982985776, "name": "AdaptiveClusteringOptimizer", "description": "Use adaptive cluster size based on population diversity for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        # Introduced adaptive cluster size adjustment based on population diversity\n        diversity = np.mean(np.std(sorted_population, axis=0))\n        adjusted_cluster_count = max(2, int(self.cluster_count * (1 + diversity / 5)))\n        clusters = np.array_split(sorted_population, adjusted_cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 55, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07369715272502786, 0.06001460639366829, 0.04724468887159883, 0.06812774338723449, 0.055088446631970545, 0.04702780441700127, 0.0840099384227122, 0.06457349269051638, 0.0541037383071421]}}
{"id": "f5308d2a-1cc6-47e2-9849-83ee74993b3d", "fitness": 0.0643812909190684, "name": "AdaptiveClusteringOptimizer", "description": "Introduce dynamic adjustment of cluster count and perturbation range based on function evaluation feedback.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        # Adjust perturbation range dynamically based on standard deviation\n        perturbation_range = 0.3 + np.std(cluster) / 10\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)  \n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            # Adjust cluster count based on evaluations\n            self.cluster_count = max(2, int(self.dim // 3 + evaluations / self.budget * 2))\n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 56, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0687830925573043, 0.059143078143205186, 0.053348830638599964, 0.06397732620044083, 0.06446880988160719, 0.05250961182520453, 0.07707940340906394, 0.07877096517233773, 0.06135050044385193]}}
{"id": "99b9a418-51f1-435a-9bdf-06b5e35a94bb", "fitness": 0.08067579039997567, "name": "AdaptiveClusteringOptimizer", "description": "Introduce a dynamic population size adjustment strategy to improve convergence speed.  ", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n\n            self.population_size = int(self.population_size * 0.9)  # Dynamically adjust population size\n\n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 57, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.03.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.09925434691695656, 0.07275512376360727, 0.05002392615861406, 0.09091570410608896, 0.0667116712665361, 0.04919863852539008, 0.15769880527020308, 0.08265308025888729, 0.056870817333497636]}}
{"id": "c22a2b6e-5748-40da-b662-3f3d62777cf2", "fitness": 0.06203992735117789, "name": "AdaptiveClusteringOptimizer", "description": "Enhance perturbation strategy with dynamic scaling and hybrid mutation operators for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 4  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Enhanced mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 58, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06717335128991175, 0.06246404146051199, 0.052569627667091945, 0.062494947948313784, 0.0579445808938569, 0.05148369956072285, 0.07520818021584974, 0.06896983022513059, 0.06005108689921146]}}
{"id": "dc06b71d-94cf-47b1-858a-d912d8b1f792", "fitness": 0.06046014955432433, "name": "AdaptiveClusteringOptimizer", "description": "Improved adaptive clustering using dynamic population and mutation scaling.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(150, budget)  # Increased initial population size\n        self.cluster_count = max(2, self.dim // 3)  \n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + (np.std(cluster, axis=0) / 8) * np.random.rand()  # Dynamic scaling factor\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 59, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07055905768350057, 0.061313409805710095, 0.05442158799552688, 0.05597204238417819, 0.056872625615044914, 0.05177018047127446, 0.06565107809802428, 0.06710624198904047, 0.06047512194661908]}}
{"id": "513f292b-a0c9-4bd9-9256-b23b84f492bf", "fitness": 0.06115052724985511, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by expanding perturbation range dynamically based on cluster variance, and refine mutation factors.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-np.std(cluster) / 2, np.std(cluster) / 2, cluster.shape)  # Dynamic perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06396969507120354, 0.05949773713995132, 0.056115280704057025, 0.05924672577495027, 0.059496939951205086, 0.05110514111011877, 0.07017469773185758, 0.07088578694649572, 0.059862740818856675]}}
{"id": "7a996a90-ffcc-46ab-a43b-419ceaab8231", "fitness": 0.06096984611162911, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploitation by dynamically adjusting cluster sizes and focusing on promising areas.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(1, int(self.dim / 2))  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 61, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07164560014244603, 0.059702151051487795, 0.04813897757145491, 0.06634770352273722, 0.05519774093445917, 0.04748506493910942, 0.0807820965715802, 0.0646787702128494, 0.054750510058537816]}}
{"id": "0b2b1396-aa51-48ec-95ed-e5d8e75005db", "fitness": 0.06632927658671448, "name": "AdaptiveClusteringOptimizer", "description": "Improve convergence by introducing dynamic cluster resizing and an adaptive scaling mechanism.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        dynamic_cluster_count = max(2, self.cluster_count + np.random.randint(-1, 2))  # Dynamic resizing\n        clusters = np.array_split(sorted_population, dynamic_cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        variance_term = np.std(cluster, axis=0) / 6  # Adaptive scaling mechanism\n        scaling_factor = 0.6 + variance_term\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 62, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07490376460052073, 0.07398187360626518, 0.049942506941972, 0.06905278907783385, 0.05927173901598404, 0.052057518216489074, 0.08637779558863523, 0.07052061265428677, 0.06085488957844343]}}
{"id": "c02bee31-c256-411d-85fc-ba49efe72269", "fitness": 0.06288979503783129, "name": "AdaptiveClusteringOptimizer", "description": "Increase diversity by dynamically adjusting the mutation factor range based on inter-cluster distance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        inter_cluster_distance = np.max(np.linalg.norm(np.diff(cluster, axis=0), axis=1))  # Calculate inter-cluster distance\n        mutation_factor = np.random.normal(0, 0.2 + inter_cluster_distance / 50, cluster.shape)  # Dynamically adjust mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 63, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07307663257236197, 0.06487088693255738, 0.05173712937519925, 0.06780215989683247, 0.05723578569359533, 0.04672273576304942, 0.08335130629831378, 0.06756196761166555, 0.05364955119690651]}}
{"id": "d6f75890-ace5-432e-8b8b-52ad3e2982fe", "fitness": 0.06550404610013673, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration by dynamically adjusting the perturbation and scaling factor.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation_range = 0.3 * (1 - np.std(cluster) / 5)  # Dynamically adjust perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 5  # Adjust scaling factor refinement\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 64, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07452071940576932, 0.06385149807226354, 0.05607775263017334, 0.06884539668097323, 0.060300573400905555, 0.050411637360703754, 0.08494657501654213, 0.0720946929883135, 0.05848756934558619]}}
{"id": "c017066a-602a-45a1-85d9-044052af9d83", "fitness": 0.0671499967757571, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by dynamically adjusting perturbation and mutation factors based on iteration count.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster, iteration, max_iter):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation_range = max(0.1, 0.3 - (iteration / max_iter) * 0.2)  # Dynamic perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2 - (iteration / max_iter) * 0.1, cluster.shape)  # Dynamic mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n        max_iterations = self.budget // self.population_size\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                iteration = evaluations // self.population_size\n                new_candidates = self.explore_exploit(cluster, iteration, max_iterations)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 65, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0827978003163915, 0.06127133819569208, 0.04932301752275747, 0.07561136354016629, 0.060127378857617986, 0.048947284211149134, 0.09785399203427936, 0.07187119994034097, 0.05654659636341908]}}
{"id": "5711dcb0-f7ff-4d81-a983-b68dce28bc0f", "fitness": 0.061824463750200204, "name": "AdaptiveClusteringOptimizer", "description": "Introducing dynamic population clustering and adaptive scaling factors to enhance convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        # Adjusted scaling factor with dynamic population\n        scaling_factor = 0.6 + np.var(cluster, axis=0) / 6  \n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            # Dynamically calculate cluster count based on budget\n            self.cluster_count = max(2, len(population) // 10) \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 66, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07299554985869205, 0.06272168366848097, 0.04460648135249412, 0.06756654633632919, 0.05899494806890482, 0.04509768073306053, 0.08279520198518375, 0.07001655316485655, 0.05162552858379987]}}
{"id": "656f69b8-bb00-4cb3-9387-024feb0fb30a", "fitness": 0.078867917566439, "name": "AdaptiveClusteringOptimizer", "description": "Utilize dynamic cluster counts based on performance variance to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        performance_variance = np.var(scores)\n        self.cluster_count = max(2, int(self.cluster_count * (1 + performance_variance)))  # Dynamic cluster count\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 67, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.03.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.09925434691695656, 0.07650888707720138, 0.05002392615861406, 0.08770203242301655, 0.06683148229590719, 0.04919863852539008, 0.14054676147699752, 0.08287436589037, 0.056870817333497636]}}
{"id": "5c27e89e-b9e8-4fa8-a5a2-95e772dd6a91", "fitness": 0.0787017880014075, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration by dynamically adjusting the perturbation range based on generation progress.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster, generation, max_generations):\n        cluster_center = np.mean(cluster, axis=0)\n        dynamic_range = 0.3 * (1 - generation / max_generations)  # Dynamically adjust perturbation\n        perturbation = np.random.uniform(-dynamic_range, dynamic_range, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n        max_generations = self.budget // self.population_size\n        generation = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster, generation, max_generations)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n            generation += 1\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 68, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.03.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.09925434691695656, 0.07225168047939456, 0.050689062017786335, 0.08770203242301655, 0.0667116712665361, 0.05022344786317967, 0.14054676147699752, 0.08265308025888729, 0.05828400930991284]}}
{"id": "cb5ef49f-340c-4f51-80d6-2e66436e554c", "fitness": 0.06824581176657302, "name": "AdaptiveClusteringOptimizer", "description": "Fine-tune exploration by balancing perturbation range and mutation diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.25, 0.25, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.65 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 69, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.08428525615595006, 0.06459028484168916, 0.054777080013629464, 0.07680770924921843, 0.05682929561787298, 0.050518090155339035, 0.10052704671533197, 0.06722783537570476, 0.058649707774421356]}}
{"id": "64151a92-beda-4f70-b816-2b589d3c802c", "fitness": 0.06394644330289466, "name": "AdaptiveClusteringOptimizer", "description": "Enhance convergence by adjusting the mutation strategy and optimizing cluster division.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 4)  # Adjusted number of clusters for better division\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.7 + np.std(cluster, axis=0) / 8  # Slightly adjusted scaling factor\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Enhanced mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 70, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0715549954324971, 0.06264812859020352, 0.05068803631637808, 0.06806142126679138, 0.05688830937345579, 0.052846033416200644, 0.08376349730956634, 0.06725648968489539, 0.061811078336063696]}}
{"id": "7a5e80cb-4db0-4889-9fb2-f00506c46073", "fitness": 0.06704786213175143, "name": "AdaptiveClusteringOptimizer", "description": "Adjust cluster mutation and selection strategy to enhance convergence speed.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.2, 0.2, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.7 + np.std(cluster, axis=0) / 10  # Adjusted scaling factor\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 71, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.08091223620019106, 0.06621854554345519, 0.05116004670450347, 0.07410238312533679, 0.060670904011912885, 0.04784615839463047, 0.094794474605706, 0.07261929260476285, 0.05510671799526412]}}
{"id": "e8f43737-6629-4128-a223-1c79a11d0c43", "fitness": 0.06217530019426119, "name": "AdaptiveClusteringOptimizer", "description": "Refine exploration by implementing dynamic mutation and perturbation range adjustments based on cluster diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        diversity = np.std(cluster, axis=0)  # Measure cluster diversity\n        perturbation_range = 0.2 + diversity / 10  # Dynamically adjust perturbation range\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)\n        scaling_factor = 0.6 + diversity / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2 + diversity / 20, cluster.shape)  # Dynamic mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 72, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06897048711413722, 0.06254066185014873, 0.05354336669018511, 0.06408235566687126, 0.055884490457503544, 0.051405672101725086, 0.07748017875095936, 0.06572820924681266, 0.059942279870007775]}}
{"id": "7aeb0c3f-08af-4e90-8a87-aff9d3a46711", "fitness": 0.0643336208128001, "name": "AdaptiveClusteringOptimizer", "description": "Refine the exploration-exploitation balance with adaptive scaling and dynamic mutation for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 6  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 73, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07520574540758873, 0.06035244160225883, 0.05228131726505536, 0.06946635153320901, 0.05650746685386587, 0.05195209836849368, 0.08608283162794117, 0.06654483215246776, 0.06060950250432051]}}
{"id": "9593b0d7-0db0-45c4-a9ee-5049fceb721d", "fitness": 0.06564313939135186, "name": "AdaptiveClusteringOptimizer", "description": "Enhance convergence by combining adaptive exploration with dynamic clustering based on diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 5  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.15, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 74, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07849215016552302, 0.05901247822991229, 0.049548910213385366, 0.0720997543651537, 0.06104789773391872, 0.04917977017209152, 0.09133748551464627, 0.07322150022913942, 0.056848307898396455]}}
{"id": "c6e30f82-64e1-4137-be9b-6e93558d8f09", "fitness": 0.06507747799293497, "name": "AdaptiveClusteringOptimizer", "description": "Adjust perturbation range and scaling factor for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 6  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 75, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07277274688197433, 0.060669744252722535, 0.05560852812638051, 0.06700733325987818, 0.05868162413666367, 0.054846295271856804, 0.08184841361794493, 0.06965486603169446, 0.06460775035729927]}}
{"id": "b15225cc-b67b-4d88-8a90-6336abad191c", "fitness": 0.06928182897621576, "name": "AdaptiveClusteringOptimizer", "description": "Refine clustering and mutation by dynamically adjusting the number of clusters and scaling factor based on diversity metrics.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 4)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        diversity_metric = np.std(cluster, axis=0)  # Compute diversity\n        scaling_factor = 0.5 + diversity_metric / 6  # Modified scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06815023844968338, 0.07526818180870465, 0.05264145708537593, 0.07729151210339857, 0.058311625472878825, 0.055090945708338945, 0.10272746516255793, 0.06912274189824275, 0.06493229309676096]}}
{"id": "9446926b-b216-428f-b864-9d24975f57ae", "fitness": 0.06356695482570304, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by allowing larger mutation factors and improve clustering adaptiveness.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 4)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Larger mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 77, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07187249152319564, 0.0643358651307564, 0.05267423551463479, 0.06554462300345187, 0.05593753096366083, 0.053575024213075695, 0.0795532553659738, 0.06579821575515898, 0.0628113519614194]}}
{"id": "e217face-e2ef-49a1-8a8e-d80b589e3179", "fitness": 0.06533031418781952, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration and exploitation balance by refining perturbation and mutation factors to enhance optimization performance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.25, 0.25, cluster.shape)  # Slightly refined perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 8  # Slightly refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 78, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07891368784817765, 0.06174581488655617, 0.05104720845766186, 0.07251774580521331, 0.057143440241668286, 0.049831714839511654, 0.09159271593831064, 0.06745162722257259, 0.05772887245070357]}}
{"id": "81195cdb-7669-452a-90f7-2c6a07f79230", "fitness": 0.06489377629978722, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration by dynamically adjusting mutation and perturbation factors based on convergence rate.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        mutation_factor = np.random.normal(0, 0.2 + 0.1/np.log1p(self.dim), cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n        prev_best_score = float('inf')\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n            current_best_score = min(scores)\n            if current_best_score < prev_best_score:\n                self.cluster_count = max(2, self.cluster_count - 1)  # Adjust cluster count dynamically\n            prev_best_score = current_best_score\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 79, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07481378802360694, 0.06280877129943707, 0.0533335205222204, 0.07029455060575573, 0.05745434408107131, 0.05044301494462944, 0.08848878908398783, 0.0678820084356132, 0.058525199701763064]}}
{"id": "4ebcf680-936e-4706-a7ec-9185c7a787db", "fitness": 0.06107775375062482, "name": "AdaptiveClusteringOptimizer", "description": "Introduce a dynamic mutation factor based on cluster diversity to enhance convergence.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        cluster_std = np.std(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2 + 0.1 * cluster_std.mean(), cluster.shape)  # Dynamic mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 80, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06863426980539977, 0.059404363755094725, 0.05119754509204877, 0.06384639239878864, 0.05594985093375138, 0.05000513244438198, 0.0768791863235817, 0.06580775035626552, 0.05797529264631085]}}
{"id": "7aa2f580-3311-4b6a-a59c-a1b093b16233", "fitness": 0.06749471378214583, "name": "AdaptiveClusteringOptimizer", "description": "Improve cluster structure by integrating adaptive weighting and dynamic resizing.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)\n        self.cluster_count = max(2, self.dim // 3)\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        importance_weight = np.linspace(1.5, 0.5, num=len(cluster))[:, None]  # New line\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor * importance_weight  # Modified line\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 81, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.08038123011947995, 0.061167437469895836, 0.057652241572261675, 0.07557714778870028, 0.054917507545616084, 0.05276831624925982, 0.09884930069289644, 0.06434120187254544, 0.06179804072865691]}}
{"id": "89e33699-4dc1-4526-bf17-0d96806db4fc", "fitness": 0.06460308162025719, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration and convergence by adjusting cluster centers and perturbation ranges.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.median(cluster, axis=0)  # Change mean to median for robustness\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expand perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 82, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07022046439904617, 0.06450175981090878, 0.05514856919987454, 0.06519924575636371, 0.06061902987458401, 0.05212270956934095, 0.07903159325210718, 0.07369691454343719, 0.06088744817665215]}}
{"id": "fa727efb-76ee-4be3-b203-a31518fa42ad", "fitness": 0.06501975354663096, "name": "AdaptiveClusteringOptimizer", "description": "Improve adaptive clustering by refining cluster splitting and mutation dynamics.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.median(cluster, axis=0)  # Use median instead of mean\n        perturbation = np.random.uniform(-0.25, 0.25, cluster.shape)  # Refined perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 83, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07390436643465181, 0.06231586996126803, 0.05839621642809789, 0.0682940281989266, 0.05817879772906476, 0.05136936807034198, 0.08401653256445196, 0.06891517219924592, 0.059787430333629654]}}
{"id": "b4f4c6bb-edf0-4d6d-a2ff-d20c2c276492", "fitness": 0.06346485936993856, "name": "AdaptiveClusteringOptimizer", "description": "Optimize exploration and exploitation by adjusting perturbation and mutation factors dynamically.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.7 + np.std(cluster, axis=0) / 10  # Adjusted scaling factor\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 84, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06901271748350701, 0.06291415967690162, 0.0557399155171554, 0.06382787959698188, 0.05758294192018054, 0.053918928590942494, 0.0768301163129913, 0.06805763688223398, 0.0632994383485529]}}
{"id": "8efe0591-23a6-477d-ad6c-16df0db2d985", "fitness": 0.06447386332657581, "name": "AdaptiveClusteringOptimizer", "description": "Slightly refine perturbation and mutation factors to increase exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Modified perturbation range\n        scaling_factor = 0.7 + np.std(cluster, axis=0) / 8  # Slightly increased scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 85, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07572709329597282, 0.06078116527433708, 0.05391775413574429, 0.07098037511507738, 0.05613668406049621, 0.049765070568805414, 0.08930295852785197, 0.06603405363600068, 0.057619615324896456]}}
{"id": "faacf00e-d226-448e-9f30-3b6cea4bb93f", "fitness": 0.0707816831045279, "name": "AdaptiveClusteringOptimizer", "description": "Introduce oscillatory scaling factors to enhance diversification and intensify convergence.  ", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8 * np.sin(np.pi / 4)  # Oscillatory scaling factor\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 86, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07463450909269176, 0.075753941847724, 0.0553927510663057, 0.06904442441305902, 0.07195968114316242, 0.050372897458693666, 0.08566280123625902, 0.0957880122265583, 0.058426129456297216]}}
{"id": "097d740d-8b22-49a7-9020-28bdf8098c26", "fitness": 0.06488813578818026, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by updating perturbation range and scaling mutation factors dynamically based on evaluations.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster, evaluations):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation_range = max(0.1, 0.3 - 0.2 * (evaluations / self.budget))  # Updated perturbation range dynamically\n        perturbation = np.random.uniform(-perturbation_range, perturbation_range, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.1 + 0.2 * (1 - evaluations / self.budget), cluster.shape)  # Dynamically scaling mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster, evaluations)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 87, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07460543724737634, 0.0647427242555374, 0.050775851368505376, 0.06895028972826212, 0.059331933751783694, 0.050707534536139076, 0.08513945994231309, 0.07060666956973505, 0.05913332169397012]}}
{"id": "83293677-ab1b-4f72-9594-753c43096999", "fitness": 0.06454295855098728, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by modifying the cluster size adaptively and refining mutation factors.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 4)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 10  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 88, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07509167517786564, 0.06504664031010376, 0.05303951893846759, 0.068017050630237, 0.05581755243105402, 0.05283084137493499, 0.08363188237769092, 0.06562973572852615, 0.06178172999000542]}}
{"id": "f32fc20a-46d5-4766-afb2-1a600b0631c0", "fitness": 0.06500813522862538, "name": "AdaptiveClusteringOptimizer", "description": "Improve clustering by using a dynamic cluster count and increase mutation factor randomness for more diverse solutions.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 4)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Increased mutation factor randomness\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 89, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07268569501321154, 0.06644533481969728, 0.056004296546575905, 0.06334839985180885, 0.05507428894581157, 0.05937665271051018, 0.0761799388933202, 0.06456146101147076, 0.07139714926522212]}}
{"id": "6bc5304c-885a-406d-b018-63e2971c00a4", "fitness": 0.06416237578307485, "name": "AdaptiveClusteringOptimizer", "description": "Adaptive perturbation and hybrid selection to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.1, 0.1, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 90, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0737644929206841, 0.06441030996221953, 0.04815081451438219, 0.06823797693275924, 0.05687034382719558, 0.05296894759735227, 0.08391794804845754, 0.06716882358693754, 0.061971724657685634]}}
{"id": "5d6ee75b-7bda-4a24-8e14-2f3476ba5179", "fitness": 0.06394644330289466, "name": "AdaptiveClusteringOptimizer", "description": "Enhance the adaptive clustering strategy by refining mutation and cluster size dynamics.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(3, self.dim // 4)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.7 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 91, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0715549954324971, 0.06264812859020352, 0.05068803631637808, 0.06806142126679138, 0.05688830937345579, 0.052846033416200644, 0.08376349730956634, 0.06725648968489539, 0.061811078336063696]}}
{"id": "09e0239b-82ba-4dd5-ba8a-bf3eaa8e8ff7", "fitness": 0.06697848536505052, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by modifying mutation and perturbation parameters to improve solution diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expand perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Increase mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 92, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0754047672459287, 0.06327958914964382, 0.05384864271212264, 0.0696176943796043, 0.055899800644195974, 0.06014880153311464, 0.08640734861589161, 0.06570820122367271, 0.07249152278128035]}}
{"id": "e608094b-4e30-4e98-9a6e-8e0a0a952222", "fitness": 0.06766902776957971, "name": "AdaptiveClusteringOptimizer", "description": "Enhance adaptive clustering by introducing dynamic cluster count and improved mutation factor distribution.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, int(np.sqrt(self.dim)))  # Dynamic number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.15, cluster.shape)  # Improved mutation factor distribution\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 93, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07050319726838383, 0.07802361024952575, 0.05453393331556311, 0.07334637566005708, 0.059156186452972936, 0.05083335303508818, 0.0931010422641706, 0.07033363281249239, 0.05918991886796354]}}
{"id": "113f7125-08b1-4fd5-b203-adae003ee6d1", "fitness": 0.06697848536505052, "name": "AdaptiveClusteringOptimizer", "description": "Enhance neighborhood generation by diversifying mutation and perturbation strategy.  ", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Line changed: Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Line changed: Altered mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 94, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.0754047672459287, 0.06327958914964382, 0.05384864271212264, 0.0696176943796043, 0.055899800644195974, 0.06014880153311464, 0.08640734861589161, 0.06570820122367271, 0.07249152278128035]}}
{"id": "eb3fe59c-b829-4de9-b8ff-a5bd2e666afb", "fitness": 0.06670344404465918, "name": "AdaptiveClusteringOptimizer", "description": "Improve clustering effectiveness by dynamically adjusting cluster count based on evaluation scores.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)\n        self.cluster_count = max(2, self.dim // 3)\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        self.cluster_count = max(2, int(self.dim // 3 * (1 - np.std(scores) / np.mean(scores))))  # Dynamic cluster adjustment\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        mutation_factor = np.random.normal(0, 0.2, cluster.shape)\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 95, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.07787355310375477, 0.08760314032332062, 0.051529734655727744, 0.06722022833374808, 0.05764608459810505, 0.04945600538058936, 0.0825498852346137, 0.06922973627665319, 0.05722262849542015]}}
{"id": "83b9dec7-ed78-478d-ab2a-2f39da3eaf21", "fitness": 0.06069637775884673, "name": "AdaptiveClusteringOptimizer", "description": "Improve exploration and exploitation balance by refining clustering and perturbation handling.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 2)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.5 + np.std(cluster, axis=0) / 10  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.1, cluster.shape)  # Refine mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 96, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06853388283543105, 0.06239554976676387, 0.05139482936009376, 0.06375214970774479, 0.05572715420717789, 0.04735247078317706, 0.07675578885265644, 0.06548826320645951, 0.054867311110116224]}}
{"id": "05669da4-8688-4989-8eaa-cbf10d1d7bef", "fitness": 0.06402999857322941, "name": "AdaptiveClusteringOptimizer", "description": "Improve adaptive exploration by dynamic cluster adjustment and enhanced perturbation variance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 4)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.5, 0.5, cluster.shape)  # Expanded perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Enhanced mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 97, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06708210385473146, 0.06564550329567553, 0.05212300195745556, 0.06738064141942157, 0.060809740207833696, 0.049875833347539755, 0.0825728137263082, 0.07301412565975662, 0.057766223690342344]}}
{"id": "ce7dee0f-e852-4a23-ba3e-a405a8b43751", "fitness": 0.0648458126040113, "name": "AdaptiveClusteringOptimizer", "description": "Enhance exploration by adjusting the perturbation range and improving mutation factors with increased diversity.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)  # Initial population size\n        self.cluster_count = max(2, self.dim // 3)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.4, 0.4, cluster.shape)  # Adjusted perturbation range\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8  # Refined scaling factor adjustment\n        mutation_factor = np.random.normal(0, 0.25, cluster.shape)  # Adjusted mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        # Final evaluation of the remaining budget\n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 98, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06938239286643044, 0.06638739754007006, 0.05629968988176559, 0.06294335032433729, 0.06011053668400046, 0.054625411567382764, 0.07784482018188488, 0.07173142012897615, 0.06428729426125412]}}
{"id": "8d015291-d848-409b-9d22-dbf31304320e", "fitness": 0.06072052230102779, "name": "AdaptiveClusteringOptimizer", "description": "Introduce adaptive mutation scaling and refined clustering to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveClusteringOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = min(100, budget)\n        self.cluster_count = max(2, self.dim // 2)  # Adjusted number of clusters\n\n    def initialize_population(self):\n        return np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n    \n    def evaluate_population(self, population, func):\n        return np.array([func(ind) for ind in population])\n\n    def cluster_population(self, population, scores):\n        sorted_indices = np.argsort(scores)\n        sorted_population = population[sorted_indices]\n        clusters = np.array_split(sorted_population, self.cluster_count)\n        return clusters\n\n    def explore_exploit(self, cluster):\n        cluster_center = np.mean(cluster, axis=0)\n        perturbation = np.random.uniform(-0.3, 0.3, cluster.shape)\n        scaling_factor = 0.6 + np.std(cluster, axis=0) / 8\n        mutation_factor = np.random.normal(0, 0.3, cluster.shape)  # Increased mutation factor\n        new_candidates = cluster_center + (perturbation + mutation_factor) * scaling_factor\n        new_candidates = np.clip(new_candidates, self.lower_bound, self.upper_bound)\n        return new_candidates\n\n    def __call__(self, func):\n        population = self.initialize_population()\n        evaluations = 0\n\n        while evaluations + self.population_size <= self.budget:\n            scores = self.evaluate_population(population, func)\n            evaluations += self.population_size\n            \n            clusters = self.cluster_population(population, scores)\n            new_population = []\n\n            for cluster in clusters:\n                new_candidates = self.explore_exploit(cluster)\n                new_population.extend(new_candidates)\n\n            population = np.array(new_population[:self.population_size])\n        \n        if evaluations < self.budget:\n            remaining_budget = self.budget - evaluations\n            scores = self.evaluate_population(population[:remaining_budget], func)\n        \n        best_index = np.argmin(self.evaluate_population(population, func))\n        return population[best_index]", "configspace": "", "generation": 99, "feedback": "The algorithm AdaptiveClusteringOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c6f727cc-d4db-4b81-89bd-da0aa7657fdd"], "operator": null, "metadata": {"aucs": [0.06602145235292245, 0.06215431594302123, 0.05304765820397017, 0.06112494837413973, 0.05561413997226783, 0.051017433231865805, 0.07278080129837972, 0.06532015065625163, 0.059403800676431584]}}
