{"id": "7ba9d16a-9546-4969-9533-3ba00f418b87", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "A hybrid metaheuristic combining Differential Evolution and Simulated Annealing for robust exploration and exploitation.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99  # Cooling rate for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 0, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "215a0e3a-0a45-43dc-a3dc-d72fd83243f6", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "Enhanced the Simulated Annealing cooling rate and mutation factor in Differential Evolution for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.98  # Cooling rate for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), self.lower_bound, self.upper_bound)  # Adjusted mutation factor\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 1, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["7ba9d16a-9546-4969-9533-3ba00f418b87"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "af595a66-62ce-46ba-9a6d-75229e1ba0cd", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "A refined hybrid metaheuristic optimizing mutation scaling and acceptance strategy for improved search efficiency.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99  # Cooling rate for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                F = 0.9 + 0.1 * np.random.rand()  # Slightly adjust mutation factor F\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(10 * (fitness[i] - candidate_fitness) / self.temp)):  # Adjusted acceptance probability\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 2, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["7ba9d16a-9546-4969-9533-3ba00f418b87"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "df6cdabe-41ba-4a5f-b0b6-6cfbf5ebe259", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "A refined hybrid optimizer that adjusts the mutation factor dynamically for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99  # Cooling rate for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            mutation_factor = 0.5 * (self.budget / (10 * self.dim))  # Dynamic mutation factor\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 3, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["7ba9d16a-9546-4969-9533-3ba00f418b87"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "b208aa7e-fc29-422e-b8e7-977e5ad8c4b8", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "Enhanced hybrid optimizer with an improved mutation factor for better exploration.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.99  # Cooling rate for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), self.lower_bound, self.upper_bound)  # Changed mutation factor\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 4, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["7ba9d16a-9546-4969-9533-3ba00f418b87"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "77682b17-234c-49ec-ada1-09db143390af", "fitness": 0.05511102957203392, "name": "HybridOptimizer", "description": "Improved HybridOptimizer by adjusting population size and cooling rate for faster convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.95  # Accelerated cooling rate for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 5, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["7ba9d16a-9546-4969-9533-3ba00f418b87"], "operator": null, "metadata": {"aucs": [0.054593224246197614, 0.05845450679247577, 0.05080873180718115, 0.05131438105037389, 0.054768890167081086, 0.04767113597922579, 0.059363552107523976, 0.0641366970339119, 0.054888146964334084]}}
{"id": "0845c0ea-06b4-4c54-a8e8-7481ed454439", "fitness": 0.05511102957203392, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by incorporating adaptive control of mutation factor and crossover probability for increased exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.95  # Accelerated cooling rate for Simulated Annealing\n        self.mutation_factor = 0.8  # Initial mutation factor\n        self.crossover_prob = 0.9  # Initial crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.crossover_prob, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Adapt mutation factor and crossover probability\n            self.mutation_factor = 0.5 + 0.3 * np.random.rand()\n            self.crossover_prob = 0.7 + 0.2 * np.random.rand()\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 6, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.054593224246197614, 0.05845450679247577, 0.05080873180718115, 0.05131438105037389, 0.054768890167081086, 0.04767113597922579, 0.059363552107523976, 0.0641366970339119, 0.054888146964334084]}}
{"id": "c5052c94-14da-4552-aa2f-77cd73af130d", "fitness": 0.055013563132024844, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer with adaptive mutation factor and dynamic temperature adjustment for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n        self.mutation_factor = 0.8  # Added adaptive mutation factor\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                # Adaptive mutation factor\n                self.mutation_factor = 0.5 + 0.5 * (1 - self.budget / (self.budget + self.population_size))\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Dynamic temperature adjustment\n            self.temp *= (self.cooling_rate + 0.05 * np.random.rand())\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 7, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.051055374062522696, 0.054768890167081086, 0.04767113597922579, 0.05902775100467306, 0.0641366970339119, 0.054888146964334084]}}
{"id": "21648814-539b-4c30-a1a6-6b30470dc04a", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "HybridOptimizer with adaptive crossover rate and dynamic population size adjustment for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size for diversity\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.93  # Adjusted cooling rate for Simulated Annealing\n        self.initial_budget = budget\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            adaptive_crossover_rate = 0.8 + 0.2 * (1 - (self.budget / self.initial_budget))  # Adaptive crossover\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < adaptive_crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 8, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "a12141ea-6405-487c-bec3-fdfda05f8b35", "fitness": 0.05504045659952413, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by increasing the mutation factor and crossover probability for improved exploration.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.95  # Accelerated cooling rate for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), self.lower_bound, self.upper_bound)  # Changed mutation factor\n                trial = np.where(np.random.rand(self.dim) < 0.95, mutant, population[i])  # Changed crossover probability\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 9, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05438811846016889, 0.05845450679247577, 0.05080873180718115, 0.0511273384197104, 0.054768890167081086, 0.04767113597922579, 0.05912054377162812, 0.0641366970339119, 0.054888146964334084]}}
{"id": "c8a5b9c0-2d68-4854-ab84-8014193c56ea", "fitness": 0.05511102957203392, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by incorporating adaptive mutation and crossover rates and optimizing perturbation strategy in Simulated Annealing.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n        self.mutation_factor = 0.8  # Initialize mutation factor\n        self.crossover_rate = 0.9  # Initialize crossover rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp / 2, self.dim)  # Adjust perturbation\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n            self.mutation_factor = max(0.5, self.mutation_factor * 0.99)  # Adjust mutation factor\n            self.crossover_rate = min(0.95, self.crossover_rate * 1.01)  # Adjust crossover rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 10, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.054593224246197614, 0.05845450679247577, 0.05080873180718115, 0.05131438105037389, 0.054768890167081086, 0.04767113597922579, 0.059363552107523976, 0.0641366970339119, 0.054888146964334084]}}
{"id": "0033ad9c-02e4-4a3d-8182-1c53a140f9ef", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by introducing adaptive mutation factor and dynamic population size adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.95  # Accelerated cooling rate for Simulated Annealing\n        self.mutation_factor = 0.8  # Adaptive mutation factor\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            self.population_size = max(4, int(0.5 * self.population_size))  # Dynamic population adjustment\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                self.mutation_factor = 0.5 + 0.5 * np.random.rand()  # Adjust mutation factor\n                mutant = np.clip(a + self.mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 11, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "9fad51e7-0da0-4570-ac56-1da41f6d6fdb", "fitness": 0.05315203939985532, "name": "HybridOptimizer", "description": "Introduced adaptive mutation and crossover rates and a Gaussian cooling schedule to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n        self.mutation_rate = 0.5 + (0.3 * np.random.rand())  # Adaptive mutation rate\n        self.crossover_rate = 0.9 + (0.05 * np.random.rand())  # Adaptive crossover rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_rate * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= np.exp(-0.02)  # Gaussian cooling schedule\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 12, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05567816850204732, 0.05222346365552988, 0.05010797581476667, 0.05218135602562879, 0.04913352294627038, 0.04713394085221867, 0.0609211443484613, 0.05666301422368514, 0.05432576823008972]}}
{"id": "5b2a8688-36f4-424b-acae-a2801e9d5cc5", "fitness": 0.05315203939985532, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer using adaptive differential evolution parameters and dynamic cooling.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.scaling_factor = 0.5 + 0.3 * np.random.rand()  # Adaptive scaling factor\n        self.temp = 1.0\n        self.cooling_rate = 0.9 + 0.05 * np.random.rand()  # Dynamic cooling rate\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.scaling_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < 0.9, mutant, population[i])\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 13, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05567816850204732, 0.05222346365552988, 0.05010797581476667, 0.05218135602562879, 0.04913352294627038, 0.04713394085221867, 0.0609211443484613, 0.05666301422368514, 0.05432576823008972]}}
{"id": "b74ec565-3508-4532-81f5-00fb9c32fb36", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by introducing adaptive population scaling and dynamic crossover probability to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size\n        self.temp = 1.0  \n        self.cooling_rate = 0.95 \n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = np.random.uniform(0.5, 1.0)  # Added adaptive mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_prob = np.random.uniform(0.7, 0.9)  # Added dynamic crossover probability\n                trial = np.where(np.random.rand(self.dim) < crossover_prob, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 14, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "ef0dd52f-c2a0-46ca-8359-3123a75e8cf5", "fitness": 0.05507359421252109, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by increasing trial solution variability and refining selection pressure for improved exploration.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced Population size for Differential Evolution\n        self.temp = 1.0  # Initial temperature for Simulated Annealing\n        self.cooling_rate = 0.95  # Accelerated cooling rate for Simulated Annealing\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        # Main optimization loop\n        while self.budget > 0:\n            for i in range(self.population_size):\n                # Differential Evolution-like mutation and crossover\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.85 * (b - c), self.lower_bound, self.upper_bound)  # Slightly increased differential weight\n                trial = np.where(np.random.rand(self.dim) < 0.85, mutant, population[i])  # Adjusted crossover probability\n\n                # Evaluate new candidate solution\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            # Simulated Annealing-like perturbation\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                # Metropolis acceptance criterion\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            # Cool down temperature\n            self.temp *= self.cooling_rate\n\n        # Return the best solution found\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 15, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05448536286970718, 0.05845450679247577, 0.05080873180718115, 0.051215072926353966, 0.054768890167081086, 0.04767113597922579, 0.0592338033724189, 0.0641366970339119, 0.054888146964334084]}}
{"id": "587650bf-b516-49d2-9962-cac9fa058cf6", "fitness": 0.0552461400868633, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by fine-tuning crossover strategy and restarting mechanism to boost exploration and convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # Restart mechanism\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 16, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["77682b17-234c-49ec-ada1-09db143390af"], "operator": null, "metadata": {"aucs": [0.05498366372087715, 0.05845450679247577, 0.05080873180718115, 0.05166598115247223, 0.054768890167081086, 0.04767113597922579, 0.059837507164210546, 0.0641366970339119, 0.054888146964334084]}}
{"id": "27abb7a4-cd84-4c1e-9fa8-db4ec7ea9703", "fitness": 0.0552461400868633, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by refining the cooling rate strategy for better convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.92  # Refined cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # Restart mechanism\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 17, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05498366372087715, 0.05845450679247577, 0.05080873180718115, 0.05166598115247223, 0.054768890167081086, 0.04767113597922579, 0.059837507164210546, 0.0641366970339119, 0.054888146964334084]}}
{"id": "d4a1a695-06f7-46bb-9209-59f6a3e4bbb6", "fitness": 0.055085105048364134, "name": "HybridOptimizer", "description": "Improved HybridOptimizer by modifying the mutation strategy for enhanced diversity and exploration.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - population[i]), self.lower_bound, self.upper_bound)  # Modified mutation strategy\n                crossover_rate = np.random.uniform(0.7, 1.0)  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # Restart mechanism\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 18, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05451881102042677, 0.05845450679247577, 0.05080873180718115, 0.05124448824948058, 0.054768890167081086, 0.04767113597922579, 0.05927453742116007, 0.0641366970339119, 0.054888146964334084]}}
{"id": "b11f802e-66b0-4f1c-acb0-7cd6ed694b76", "fitness": 0.0552461400868633, "name": "HybridOptimizer", "description": "Improved HybridOptimizer by adjusting the cooling rate to enhance the algorithm's convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.90  # Adjusted cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # Restart mechanism\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 19, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05498366372087715, 0.05845450679247577, 0.05080873180718115, 0.05166598115247223, 0.054768890167081086, 0.04767113597922579, 0.059837507164210546, 0.0641366970339119, 0.054888146964334084]}}
{"id": "9dd9eda4-8529-41e7-bd16-52f7f0c3da89", "fitness": 0.0552461400868633, "name": "HybridOptimizer", "description": "Modified the perturbation method to enhance diversity and exploration capabilities.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp * np.random.choice([-1, 1]), self.dim)  # Modified perturbation\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # Restart mechanism\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 20, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05498366372087715, 0.05845450679247577, 0.05080873180718115, 0.05166598115247223, 0.054768890167081086, 0.04767113597922579, 0.059837507164210546, 0.0641366970339119, 0.054888146964334084]}}
{"id": "94130922-ff03-4a04-b97e-f9454690db93", "fitness": 0.0552461400868633, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by optimizing the cooling rate for faster convergence and better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.98  # Updated cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 21, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05498366372087715, 0.05845450679247577, 0.05080873180718115, 0.05166598115247223, 0.054768890167081086, 0.04767113597922579, 0.059837507164210546, 0.0641366970339119, 0.054888146964334084]}}
{"id": "82e1921f-aef1-49fa-a4de-b7cafdccc1e6", "fitness": 0.0552461400868633, "name": "HybridOptimizer", "description": "Improved HybridOptimizer by dynamically adjusting population size based on the remaining budget to enhance adaptability and efficiency.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # Restart mechanism\n                self.population_size = max(4 * self.dim, int(self.budget / 2))  # Dynamically adjust population size\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 22, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05498366372087715, 0.05845450679247577, 0.05080873180718115, 0.05166598115247223, 0.054768890167081086, 0.04767113597922579, 0.059837507164210546, 0.0641366970339119, 0.054888146964334084]}}
{"id": "40460f72-0f92-4fde-a436-c1977a4c3f7c", "fitness": 0.0552461400868633, "name": "HybridOptimizer", "description": "Improved HybridOptimizer by adjusting the perturbation distribution to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.uniform(-self.temp, self.temp, self.dim)  # Changed from normal to uniform distribution\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # Restart mechanism\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 23, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05498366372087715, 0.05845450679247577, 0.05080873180718115, 0.05166598115247223, 0.054768890167081086, 0.04767113597922579, 0.059837507164210546, 0.0641366970339119, 0.054888146964334084]}}
{"id": "f41e0dbe-ec21-4d5e-95d0-0dc9ff16626c", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer by adjusting the mutation strategy for better exploration and convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.9 * (b - c), self.lower_bound, self.upper_bound)  # Adjusted mutation strategy\n                crossover_rate = np.random.uniform(0.7, 1.0)  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # Restart mechanism\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 24, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "53e051da-de07-48c9-86b3-938f9ef935b3", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Improved exploration with adaptive mutation scaling to enhance population diversity and convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_scale = np.random.uniform(0.5, 1.0)  # Adaptive mutation scaling\n                mutant = np.clip(a + mutation_scale * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 25, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "f9a845cb-48a8-4d31-a6e0-c74e15507c94", "fitness": 0.0552461400868633, "name": "HybridOptimizer", "description": "Improved HybridOptimizer by integrating adaptive population size and enhanced candidate replacement to boost performance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= population_size\n\n        while self.budget > 0:\n            for i in range(population_size):\n                indices = [idx for idx in range(population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + 0.8 * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n            population_size = max(4, population_size - 1)  # Adaptive population size\n            if self.budget < 0.1 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 26, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.05498366372087715, 0.05845450679247577, 0.05080873180718115, 0.05166598115247223, 0.054768890167081086, 0.04767113597922579, 0.059837507164210546, 0.0641366970339119, 0.054888146964334084]}}
{"id": "44c6545d-94f8-4e5f-880d-bc6ed28eb1da", "fitness": 0.05525075555942839, "name": "HybridOptimizer", "description": "Optimized exploration and convergence by adjusting mutation factor adaptively based on iteration progress.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.8 * (1 - (self.budget / (self.population_size * self.dim)))  # Adaptive mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 27, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["587650bf-b516-49d2-9962-cac9fa058cf6"], "operator": null, "metadata": {"aucs": [0.0549969621793136, 0.05845450679247577, 0.05080873180718115, 0.051677888965041996, 0.054768890167081086, 0.04767113597922579, 0.05985384014629014, 0.0641366970339119, 0.054888146964334084]}}
{"id": "09b9352c-160f-4402-a082-e5af4a576c83", "fitness": 0.05506112368234696, "name": "HybridOptimizer", "description": "Enhanced convergence by adjusting crossover rate adaptively based on iteration progress.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.8 * (1 - (self.budget / (self.population_size * self.dim)))  # Adaptive mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.7 + 0.3 * (1 - (self.budget / (self.population_size * self.dim)))  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 28, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44c6545d-94f8-4e5f-880d-bc6ed28eb1da"], "operator": null, "metadata": {"aucs": [0.054448873112840857, 0.05845450679247577, 0.05080873180718115, 0.05118196922895624, 0.054768890167081086, 0.04767113597922579, 0.059191162055115765, 0.0641366970339119, 0.054888146964334084]}}
{"id": "82d83ad8-dbbb-440b-9de3-a847acc9be19", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced exploration and convergence by integrating dynamic population resizing and adaptive parameter control.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            mutation_factor = 0.8 * (1 - (self.budget / (self.population_size * self.dim)))  # Adaptive mutation factor\n            crossover_rate = 0.7 + 0.3 * (self.budget / (self.population_size * self.dim))  # Adaptive crossover rate\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:\n                new_population_size = max(4 * self.dim, int(0.5 * self.population_size))  # Dynamic population resizing\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (new_population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= new_population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 29, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44c6545d-94f8-4e5f-880d-bc6ed28eb1da"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "99b9c2f7-1b7e-4bc1-b6f2-fc0b18929bec", "fitness": 0.05525557491963905, "name": "HybridOptimizer", "description": "Enhanced exploration and convergence by introducing a dynamic mutation factor and adaptive population restart mechanism.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.8 * np.exp(-self.budget / (self.population_size * self.dim / 2))  # Dynamic mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 30, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44c6545d-94f8-4e5f-880d-bc6ed28eb1da"], "operator": null, "metadata": {"aucs": [0.055010844706304574, 0.05845450679247577, 0.05080873180718115, 0.05169031254614831, 0.054768890167081086, 0.04767113597922579, 0.059870908280088786, 0.0641366970339119, 0.054888146964334084]}}
{"id": "8ce19ff1-7fe6-4829-804e-e80283175a28", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Refined exploration through enhanced mutation strategy and improved dynamic restart criteria.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.9 * np.exp(-self.budget / (self.population_size * self.dim / 3))  # Dynamic mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.25 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 31, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["99b9c2f7-1b7e-4bc1-b6f2-fc0b18929bec"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "a1523d9f-0c1d-4321-8967-1874574e53bf", "fitness": 0.05525557491963905, "name": "HybridOptimizer", "description": "Integrate a temperature-dependent crossover rate to enhance adaptive exploration and convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.8 * np.exp(-self.budget / (self.population_size * self.dim / 2))  # Dynamic mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7 * self.temp, 1.0 * self.temp)  # Temperature-dependent crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 32, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["99b9c2f7-1b7e-4bc1-b6f2-fc0b18929bec"], "operator": null, "metadata": {"aucs": [0.055010844706304574, 0.05845450679247577, 0.05080873180718115, 0.05169031254614831, 0.054768890167081086, 0.04767113597922579, 0.059870908280088786, 0.0641366970339119, 0.054888146964334084]}}
{"id": "ec50d1e7-f91c-4ce4-bfc6-7db687ae1dfd", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced exploration and convergence by dynamically adjusting mutation factor and introducing perturbation diversity with Gaussian noise.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.9 * np.exp(-self.budget / (self.population_size * self.dim / 2))  # Dynamic mutation factor adjustment\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp * 0.5, self.dim)  # Introduce diversity with adjusted Gaussian noise\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 33, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["99b9c2f7-1b7e-4bc1-b6f2-fc0b18929bec"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "010311d9-ad17-4022-95d8-cebb157e463f", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Refined exploration by introducing a conditional adaptive mutation factor enhancement.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.8 * np.exp(-self.budget / (self.population_size * self.dim / 2))\n                if np.random.rand() < 0.5:  # Conditional mutation factor enhancement\n                    mutation_factor *= 1.1\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = np.random.uniform(0.7, 1.0)\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 34, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["99b9c2f7-1b7e-4bc1-b6f2-fc0b18929bec"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "c957f928-b67a-4191-894f-5abc4f967aa7", "fitness": 0.05526253261691302, "name": "HybridOptimizer", "description": "Enhanced population diversity by integrating adaptive differential evolution strategies with an updated mutation factor and selection pressure.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Updated mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9  # Increased selection pressure\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 35, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["99b9c2f7-1b7e-4bc1-b6f2-fc0b18929bec"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05152861224561134, 0.05105474244806241, 0.054768890167081086, 0.04832573403373841, 0.059027019191387975, 0.0641366970339119, 0.0557557572631302]}}
{"id": "2baf8b03-b943-4b8e-832b-d4187b23004f", "fitness": 0.05526253261691302, "name": "HybridOptimizer", "description": "Incorporate a dynamic population size reduction strategy to enhance convergence speed.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Updated mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9  # Increased selection pressure\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                self.population_size = max(4 * self.dim, self.population_size // 2)  # Dynamic population reduction\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 36, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05152861224561134, 0.05105474244806241, 0.054768890167081086, 0.04832573403373841, 0.059027019191387975, 0.0641366970339119, 0.0557557572631302]}}
{"id": "c45d0a26-16db-418a-a8f6-f2de6dc29558", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced mutation and adaptive crossover rate, leveraging self-adaptive selection pressure for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.random.rand()  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 37, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "ef67f13a-4c2c-453a-bec3-c85d5037cfc6", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Improved convergence and exploration balance by introducing a dynamic crossover rate and enhanced cooling strategy.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.9  # Enhanced cooling strategy\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.7 + 0.3 * (self.budget / (self.budget + self.population_size))  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 38, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "b7e42173-b0d0-4702-84d8-c82753603a4e", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhance solution exploration with a dynamic mutation factor for improved convergence.  ", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.3 + 0.7 * np.random.rand()  # Updated mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9  # Increased selection pressure\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 39, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "434bec3f-13ec-4457-ba5d-f51bd20aeac9", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Refinement of adaptive differential evolution by introducing adaptive crossover rate and enhanced mutation strategy for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.3 * np.random.rand()  # Updated mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.random.rand()  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 40, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "b680cdad-2a28-4ff6-bbce-3219869d40b4", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "Improved hybrid optimizer with adaptive parameters and strategic diversity injection for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Adjusted population size\n        self.temp = 1.0\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * np.random.rand()  # Updated mutation factor range\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 41, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "71effa1f-cc50-4fef-ac7f-9e143e144f85", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Improved convergence by enhancing mutation strategy and dynamic crossover rate.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Changed mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.random.rand()  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 42, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "26eb6a61-6f0b-483f-8dad-9ed2bcaede1b", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced adaptive mutation and crossover strategies with localized search and dynamic population resizing.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.7 + 0.3 * np.random.rand()  # Updated mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c) + 0.1 * (np.mean(population, axis=0) - a), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                self.population_size //= 2  # Dynamic population resizing\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 43, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "69218fec-c18b-4a52-99d6-6dce84db36c8", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Improved exploration and exploitation by adjusting the mutation factor and crossover rate dynamically based on population diversity.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.3 + 0.7 * np.random.rand()  # Updated mutation factor for increased diversity\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.std(population, axis=0).mean()  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 44, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "115432e6-c951-4a9a-a13c-6ff4a67068b5", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Improved convergence by integrating a dynamic mutation factor and adaptive crossover strategy with adaptive annealing.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.9  # More aggressive cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.3 * np.random.rand()  # Reduced mutation factor range\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 45, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "a19d0b38-091d-4af9-ad2a-b5662838e78f", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhancing convergence by introducing adaptive crossover rates and dynamically adjusting cooling rates while maintaining diversity.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.97  # Adjusted cooling rate for more gradual temperature decrease\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.7 + 0.2 * np.random.rand()  # Adaptive crossover rate for increased variation\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 46, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "873cda6e-4e8f-455a-9f09-ac1f03b081d7", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Introduce a dynamic crossover strategy and perturbation mechanism to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.6 + np.random.rand() * 0.3  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp * 0.5, self.dim)  # Adjusted perturbation\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 47, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "51e09ec4-7c82-4801-825f-41c8622f11e9", "fitness": 0.05505429430000294, "name": "HybridOptimizer", "description": "Enhanced diversity through adaptive mutation and perturbation strategies combined with gradual increase of crossover rate.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Updated mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * (1 - self.budget / (8 * self.dim))  # Gradually increase crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp * 0.5, self.dim)  # Adjusted perturbation strength\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n            if self.budget < 0.2 * (self.population_size + 2):  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 48, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05436303655307417, 0.05845450679247577, 0.05087472089723788, 0.05110252084451972, 0.054768890167081086, 0.04773195036573685, 0.059088862803721276, 0.0641366970339119, 0.05496746324226787]}}
{"id": "0c6f4d27-d622-4bc0-8042-fb7fb08cf2c5", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced hybrid optimization by introducing dynamic mutation and crossover rates for adaptive exploration.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.3 + 0.7 * np.random.rand()  # Changed mutation factor range\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.random.rand()  # Changed crossover rate range\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  # Greedy selection\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Adjusted restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 49, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "44f8c636-e311-4926-82ce-ebdd816e585f", "fitness": 0.055331766150983244, "name": "HybridOptimizer", "description": "Introduced adaptive restart and refined mutation strategy for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 50, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["c957f928-b67a-4191-894f-5abc4f967aa7"], "operator": null, "metadata": {"aucs": [0.05437730459626322, 0.05845450679247577, 0.05166251897062668, 0.051115485208459766, 0.054768890167081086, 0.048445285791818504, 0.0591057693589786, 0.0641366970339119, 0.055919437439233666]}}
{"id": "47b2b6d1-8279-4a07-afcc-436fb9d3daad", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced local search with diverse mutation strategies to improve solution diversity and convergence speed.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.8 + 0.2 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp / 2, self.dim)  # Adjusted perturbation\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 51, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "3d1590bc-7dc4-49fb-bf41-61abcb79159d", "fitness": 0.055331766150983244, "name": "HybridOptimizer", "description": "Enhanced exploration by introducing dynamic population size adjustment based on budget utilization.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                self.population_size = max(4 * self.dim, self.population_size // 2)  # Dynamic population size\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 52, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05437730459626322, 0.05845450679247577, 0.05166251897062668, 0.051115485208459766, 0.054768890167081086, 0.048445285791818504, 0.0591057693589786, 0.0641366970339119, 0.055919437439233666]}}
{"id": "b4809113-56cc-405d-9d4a-8e3eb8dcf8e4", "fitness": 0.05526253261691302, "name": "HybridOptimizer", "description": "Enhanced mutation factor range and random restart mechanism for increased search efficiency.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Enhanced mutation factor range\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.20 * self.budget:  # Random restart mechanism\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 53, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05152861224561134, 0.05105474244806241, 0.054768890167081086, 0.04832573403373841, 0.059027019191387975, 0.0641366970339119, 0.0557557572631302]}}
{"id": "7e0f5bd9-fbec-4663-8991-da831a207eb0", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced convergence by increasing mutation diversity and adaptive crossover rates.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.7 + 0.5 * np.random.rand()  # Changed mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * (1 - self.budget / (self.population_size * self.dim))  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 54, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "5db70229-554a-4ceb-9dfa-20692a7b8050", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Introduced population diversity enhancement by integrating an elitism strategy and dynamic crossover rate for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.random.rand()  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:\n                population[1:] = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size - 1, self.dim))  # Elitism strategy\n                fitness[1:] = np.array([func(ind) for ind in population[1:]])\n                self.budget -= (self.population_size - 1)\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 55, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "5b881f1a-0878-4abc-b352-5698d9897982", "fitness": 0.05504558389365092, "name": "HybridOptimizer", "description": "Enhanced convergence through adaptive learning rates and dynamic crossover strategy.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            learning_rate = max(0.1, self.temp)  # Adaptive learning rate\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = learning_rate * (0.6 + 0.4 * np.random.rand())  # Refined mutation factor with learning rate\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.7 + 0.3 * np.random.rand()  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 56, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.054404166303310575, 0.05845450679247577, 0.05080873180718115, 0.05113988617935805, 0.054768890167081086, 0.04767113597922579, 0.0591380938159799, 0.0641366970339119, 0.054888146964334084]}}
{"id": "2292522b-5aef-4a09-b501-7f65cb9c1b0f", "fitness": 0.055032064106501646, "name": "HybridOptimizer", "description": "Enhanced exploitation with an elite preservation strategy and reduced mutation range for more precise convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)  # Track best index for elite preservation\n        elite_solution = population[best_index].copy()  # Copy the best individual\n        elite_fitness = fitness[best_index]\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.3 + 0.3 * np.random.rand()  # Reduced mutation range\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            # Preserve the elite solution\n            if elite_fitness < np.min(fitness):\n                population[np.argmax(fitness)] = elite_solution\n                fitness[np.argmax(fitness)] = elite_fitness\n            else:\n                best_index = np.argmin(fitness)\n                elite_solution = population[best_index].copy()\n                elite_fitness = fitness[best_index]\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 57, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.054351497359974243, 0.05845450679247577, 0.050849829280895986, 0.05105474244806241, 0.054768890167081086, 0.047707932445745005, 0.059027019191387975, 0.0641366970339119, 0.05493746223898044]}}
{"id": "502f61dc-cbe2-41c8-920d-9612bfcaa059", "fitness": 0.05502906926259938, "name": "HybridOptimizer", "description": "Fine-tuned the crossover rate for enhanced exploration efficacy.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85  # Fine-tuned crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 58, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05435636112480091, 0.05845450679247577, 0.05080873180718115, 0.051096362756189895, 0.054768890167081086, 0.04767113597922579, 0.059080790738193834, 0.0641366970339119, 0.054888146964334084]}}
{"id": "2d8aa0d3-61cf-4828-ad03-766c74b46598", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Improved exploration by increasing population diversity via enhanced perturbation and mutation strategies.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.8 + 0.2 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp * 1.5, self.dim)  # Enhanced perturbation\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 59, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "f3586bf2-a46f-4828-8918-d31add302cd7", "fitness": 0.05505429430000294, "name": "HybridOptimizer", "description": "Enhanced selection pressure and mutation diversity to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Enhanced mutation diversity\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.95  # Increased selection pressure\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 60, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05436303655307417, 0.05845450679247577, 0.05087472089723788, 0.05110252084451972, 0.054768890167081086, 0.04773195036573685, 0.059088862803721276, 0.0641366970339119, 0.05496746324226787]}}
{"id": "a1f7abc1-26be-4c25-8101-bdd5204cf82d", "fitness": 0.055331766150983244, "name": "HybridOptimizer", "description": "Enhanced adversarial diversity and improved cooling rate for intensified search.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.93  # Modified cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 61, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05437730459626322, 0.05845450679247577, 0.05166251897062668, 0.051115485208459766, 0.054768890167081086, 0.048445285791818504, 0.0591057693589786, 0.0641366970339119, 0.055919437439233666]}}
{"id": "5cf0f383-b697-47ca-8c26-95a57c0c4a18", "fitness": 0.05526253261691302, "name": "HybridOptimizer", "description": "Enhanced adaptive restart condition and mutation factor for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Enhanced adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 62, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05152861224561134, 0.05105474244806241, 0.054768890167081086, 0.04832573403373841, 0.059027019191387975, 0.0641366970339119, 0.0557557572631302]}}
{"id": "c3bec24b-1b30-4808-86d7-e7cda71f1dc3", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced mutation strategy with dynamic crossover and mutation rates for improved adaptability.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.random.rand()  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 63, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "456980fd-0ba4-4555-8b24-c012352dc65c", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced crossover strategy with a dynamic rate for improved adaptability.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9 - 0.5 * (self.budget / (self.budget + self.population_size))  # Changed line\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 64, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "9e1868a4-a5ce-41df-8d4a-bb5b66b4a5b3", "fitness": 0.05502906926259938, "name": "HybridOptimizer", "description": "Enhanced hybrid optimizer by introducing dynamic crossover rate adjustment and refined adaptive restart criteria.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * (self.budget / (self.budget + self.population_size))  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Refined adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 65, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05435636112480091, 0.05845450679247577, 0.05080873180718115, 0.051096362756189895, 0.054768890167081086, 0.04767113597922579, 0.059080790738193834, 0.0641366970339119, 0.054888146964334084]}}
{"id": "8f537d3c-da78-4a0a-9acd-440a1ff2897e", "fitness": 0.05520586012737908, "name": "HybridOptimizer", "description": "Enhanced crossover strategy with dynamic crossover rate adjustment based on fitness improvement.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9 * (1 - (fitness[i] / (np.max(fitness) + 1e-9)))  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 66, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05129703016250298, 0.05105474244806241, 0.054768890167081086, 0.048117148664624465, 0.059027019191387975, 0.0641366970339119, 0.055685872309547135]}}
{"id": "55a4d386-fafe-40ae-9c89-a3e371e2e8da", "fitness": 0.055331766150983244, "name": "HybridOptimizer", "description": "Enhanced adaptive strategy by modifying cooling and restart conditions for better performance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.925  # Changed from 0.95 to 0.925\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.20 * self.budget:  # Changed from 0.15 to 0.20\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 67, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05437730459626322, 0.05845450679247577, 0.05166251897062668, 0.051115485208459766, 0.054768890167081086, 0.048445285791818504, 0.0591057693589786, 0.0641366970339119, 0.055919437439233666]}}
{"id": "d4c150ff-3220-43ec-9e33-f3f26aefd0ef", "fitness": 0.05503928353536206, "name": "HybridOptimizer", "description": "Enhanced mutation strategy using current-to-best approach to improve convergence rate.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]  # Best individual in the current population\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c) + 0.5 * (best_individual - population[i]), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 68, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.051156041446649536, 0.054768890167081086, 0.04767113597922579, 0.05915856725058122, 0.0641366970339119, 0.054888146964334084]}}
{"id": "4c14994d-f987-4939-a0f4-1aabb56f1b45", "fitness": 0.05502906926259938, "name": "HybridOptimizer", "description": "Introduced dynamic crossover rate and temperature perturbation strategy to enhance exploration capabilities.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * (self.budget / 100)  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate * (0.9 + 0.1 * np.random.rand())  # Temperature perturbation strategy\n\n            if self.budget < 0.15 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 69, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05435636112480091, 0.05845450679247577, 0.05080873180718115, 0.051096362756189895, 0.054768890167081086, 0.04767113597922579, 0.059080790738193834, 0.0641366970339119, 0.054888146964334084]}}
{"id": "be480a0b-ef32-4b67-9ec9-45a9a4ea661a", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced exploration-exploitation balance by adjusting mutation factor variability and introducing dynamic crossover rates.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Increased variability in mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.random.rand()  # Introduced dynamic crossover rates\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 70, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "35099c98-6418-4086-9e44-3cb139a7adec", "fitness": 0.05502409335704931, "name": "HybridOptimizer", "description": "Introduced a dynamic mutation factor to adaptively improve exploration over iterations.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        initial_budget = self.budget  # Store initial budget for dynamic mutation factor\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                # Dynamic mutation factor based on remaining budget\n                mutation_factor = 0.6 + (0.4 * (self.budget / initial_budget)) * np.random.rand()  \n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 71, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.0508395726293035, 0.05105474244806241, 0.054768890167081086, 0.04769937905485766, 0.059027019191387975, 0.0641366970339119, 0.05492519851954547]}}
{"id": "0db4f3cf-752b-4897-85c6-4c52c7c6a22d", "fitness": 0.055331766150983244, "name": "HybridOptimizer", "description": "Enhanced the adaptive restart strategy and adjusted the cooling rate for better convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.budget:  # Enhanced adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 72, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05437730459626322, 0.05845450679247577, 0.05166251897062668, 0.051115485208459766, 0.054768890167081086, 0.048445285791818504, 0.0591057693589786, 0.0641366970339119, 0.055919437439233666]}}
{"id": "488e1fe7-538b-4f65-b351-bc80ecd12e3d", "fitness": 0.05508476588032981, "name": "HybridOptimizer", "description": "Enhanced mutation strategy and dynamic crossover rate for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Enhanced mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.1 * (1 - self.budget / (8 * dim))  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 73, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.0510138202238668, 0.05105474244806241, 0.054768890167081086, 0.04786029811438974, 0.059027019191387975, 0.0641366970339119, 0.05513608457497454]}}
{"id": "b8aac216-7119-4a54-89f6-fd2d2609b319", "fitness": 0.055312273062489044, "name": "HybridOptimizer", "description": "Enhanced population diversity and adaptive mutation based on fitness variance to improve convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            fitness_variance = np.var(fitness)  # Calculate fitness variance\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (fitness_variance / (1 + fitness_variance))  # Adaptive mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 74, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05517475777713576, 0.05845450679247577, 0.05080873180718115, 0.051846763927634654, 0.054768890167081086, 0.04767113597922579, 0.0600608271134212, 0.0641366970339119, 0.054888146964334084]}}
{"id": "c9e6bbec-c77f-4459-b10a-41177b02ce57", "fitness": 0.05503629643421237, "name": "HybridOptimizer", "description": "Enhanced convergence by introducing a dynamic crossover rate and improved adaptive restart based on convergence rate monitoring.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        initial_budget = self.budget\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            improvement = 0\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9 - 0.4 * (self.budget / initial_budget)  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                    improvement += 1\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if improvement / self.population_size < 0.1:  # Improved adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 75, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05437730459626322, 0.05845450679247577, 0.05080873180718115, 0.051115485208459766, 0.054768890167081086, 0.04767113597922579, 0.0591057693589786, 0.0641366970339119, 0.054888146964334084]}}
{"id": "dd2b495d-a566-4776-952c-8311c0849d01", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced mutation strategy by incorporating dynamic crossover rates for better adaptability.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * np.random.rand()  # Refined mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.8 + 0.2 * np.random.rand()  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 76, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "79e6527a-0f83-4297-992a-a22d2822b954", "fitness": 0.05564636053114195, "name": "HybridOptimizer", "description": "Enhanced the exploitation phase by introducing elitism and dynamic mutation factor adjustment to improve convergence speed and precision.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            # Elitism: Keep track of the best individual found so far\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 77, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["44f8c636-e311-4926-82ce-ebdd816e585f"], "operator": null, "metadata": {"aucs": [0.05612729973391262, 0.05845450679247577, 0.05080873180718115, 0.05269602028396647, 0.054768890167081086, 0.047687015747149064, 0.0612291086682738, 0.0641366970339119, 0.054908974546325706]}}
{"id": "78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf", "fitness": 0.055650204707921036, "name": "HybridOptimizer", "description": "Improved convergence through adaptive mutation and tournament selection for robust search space exploration.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 78, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["79e6527a-0f83-4297-992a-a22d2822b954"], "operator": null, "metadata": {"aucs": [0.05615002982496897, 0.05845450679247577, 0.05080873180718115, 0.05271620087956419, 0.054768890167081086, 0.04767113597922579, 0.06125750292254639, 0.0641366970339119, 0.054888146964334084]}}
{"id": "ae8b9226-6f0e-4a7a-a88a-d8be41b869d2", "fitness": 0.05563568164747844, "name": "HybridOptimizer", "description": "Enhanced HybridOptimizer with dynamic population scaling and refined mutation strategy for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n        self.initial_population_size = self.population_size  # New line\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.6 + 0.4 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                self.population_size = max(4, int(self.initial_population_size / 2))  # Dynamic population scaling\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 79, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05610837526248791, 0.05845450679247577, 0.05080873180718115, 0.052679191688992266, 0.054768890167081086, 0.04767113597922579, 0.061205459131616013, 0.0641366970339119, 0.054888146964334084]}}
{"id": "9324ef0c-1d79-48ae-b743-c20bc0c6975b", "fitness": 0.055650204707921036, "name": "HybridOptimizer", "description": "Enhanced population diversity and adaptive mechanisms for improved exploration and convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.random.randint(self.population_size)] = best_individual  # Random replacement for diversity\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 80, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05615002982496897, 0.05845450679247577, 0.05080873180718115, 0.05271620087956419, 0.054768890167081086, 0.04767113597922579, 0.06125750292254639, 0.0641366970339119, 0.054888146964334084]}}
{"id": "eaa82538-4cf3-4d87-94c2-3358650c4978", "fitness": 0.055650204707921036, "name": "HybridOptimizer", "description": "Enhanced convergence by incorporating a dynamic population size and adaptive cooling rate for efficient exploration and exploitation.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.temp = 1.0\n        self.cooling_rate = 0.9  # Adjusted cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * (self.budget / float(self.budget + 1))\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  \n                self.population_size = max(4, self.population_size // 2)  # Dynamic population size\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 81, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05615002982496897, 0.05845450679247577, 0.05080873180718115, 0.05271620087956419, 0.054768890167081086, 0.04767113597922579, 0.06125750292254639, 0.0641366970339119, 0.054888146964334084]}}
{"id": "a88e80b6-a6b3-46d5-8a22-0753d0a92650", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced exploration with adaptive crossover and strategy diversification for robust optimization.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (np.exp(-(self.budget / float(self.budget + 1))))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.5 + 0.5 * np.random.rand()  # Adaptive crossover\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 82, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "da33e9cf-85a7-45d8-b926-23865d3e5da5", "fitness": 0.05564503170772349, "name": "HybridOptimizer", "description": "Enhanced exploration by tweaking mutation factor scaling for better adaptation to the search landscape.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 83, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05615204767306137, 0.05845450679247577, 0.05080873180718115, 0.05269602028396647, 0.054768890167081086, 0.04767113597922579, 0.0612291086682738, 0.0641366970339119, 0.054888146964334084]}}
{"id": "507c8c8e-763f-4f23-a142-bc6e6b160ec2", "fitness": 0.0553487179171044, "name": "HybridOptimizer", "description": "Enhanced convergence by integrating adaptive crossover and dynamic population size adjustments.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n        self.initial_budget = budget  # Store initial budget\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * (self.budget / float(self.initial_budget))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.65 + 0.2 * (fitness[i] / np.max(fitness))  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.initial_budget:  # Adaptive restart condition\n                self.population_size = int(5 * self.dim)  # Dynamic population size\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 84, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.055127305242333224, 0.05845450679247577, 0.05096287252324905, 0.051800466300218395, 0.054768890167081086, 0.04781231286129195, 0.060002714256692236, 0.0641366970339119, 0.05507269607668597]}}
{"id": "14f899f5-5417-496c-a79e-23167df56870", "fitness": 0.05512597607307344, "name": "HybridOptimizer", "description": "Enhanced adaptive mutation with crowding distance for improved diversity and convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (np.mean(fitness) - fitness[i]) / (np.max(fitness) - np.min(fitness) + 1e-9)  # Enhanced mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 85, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05463055798935923, 0.05845450679247577, 0.05080873180718115, 0.05135680512815277, 0.054768890167081086, 0.04767113597922579, 0.05941831279593923, 0.0641366970339119, 0.054888146964334084]}}
{"id": "e4ddd4e5-c1cc-4985-8d17-1dcf18217189", "fitness": 0.055642281936706964, "name": "HybridOptimizer", "description": "Enhanced diversity through adaptive mutation and dynamic crossover rates for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9 - 0.5 * np.sin(np.pi * self.budget / float(self.budget + 1))  # Dynamic crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 86, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05612729973391262, 0.05845450679247577, 0.05080873180718115, 0.05269602028396647, 0.054768890167081086, 0.04767113597922579, 0.0612291086682738, 0.0641366970339119, 0.054888146964334084]}}
{"id": "b2a7a927-635d-49b4-a2ed-33f8397f18c0", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced exploration-exploitation balance using dynamic mutation and selective crossover adaptation.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (self.budget / float(self.budget + 10))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9 if np.random.rand() < 0.5 else 0.8  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 87, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "29c47043-3ef7-48c3-a67f-63530044654d", "fitness": 0.05564503170772349, "name": "HybridOptimizer", "description": "Enhancing global search capability through refined mutation and adaptive cooling for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.9  # Slightly faster cooling\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (self.budget / float(self.budget + 1))  # Increase mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 88, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05615204767306137, 0.05845450679247577, 0.05080873180718115, 0.05269602028396647, 0.054768890167081086, 0.04767113597922579, 0.0612291086682738, 0.0641366970339119, 0.054888146964334084]}}
{"id": "171e359a-e75a-479b-906b-a2ff9a412d37", "fitness": 0.05564448303132249, "name": "HybridOptimizer", "description": "Enhanced convergence with dynamic cooling and adaptive crossover for improved search efficiency.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.9  # Adjusted cooling rate for faster convergence\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * (self.budget / float(self.budget + 1))\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.7 + 0.3 * (fitness[best_index] / (np.min(fitness) + 1e-10))  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 89, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05613361178737908, 0.05845450679247577, 0.05080873180718115, 0.05270163141897555, 0.054768890167081086, 0.04767113597922579, 0.06123699533133797, 0.0641366970339119, 0.054888146964334084]}}
{"id": "6bf0c180-386d-4715-8797-fad77fb88a1b", "fitness": 0.05564503170772349, "name": "HybridOptimizer", "description": "Enhanced exploration through dynamic mutation factor adjustment and refined cooling strategy.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.93\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 90, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05615204767306137, 0.05845450679247577, 0.05080873180718115, 0.05269602028396647, 0.054768890167081086, 0.04767113597922579, 0.0612291086682738, 0.0641366970339119, 0.054888146964334084]}}
{"id": "a0c008cd-3921-41f7-8443-32e35b089eb6", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced exploration and exploitation using dynamic population size and adaptive crossover strategy for improved optimization.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim  # Initial population size\n        self.population_size = self.initial_population_size\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * (self.budget / float(self.budget + 1))\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9 - 0.4 * (self.budget / float(self.budget + 1))  # Adaptive crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):\n                    population[i], fitness[i] = trial, trial_fitness\n\n            self.population_size = max(int(self.initial_population_size * (self.budget / (self.budget + 1))), self.dim)\n            population = population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 91, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "e4b29e4f-7a21-44fa-8c9f-216995b43a8e", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "Enhanced mutation and selection strategies with fine-tuned parameters to improve convergence performance.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size for better exploration\n        self.temp = 1.0\n        self.cooling_rate = 0.97  # Modified cooling rate for slower temperature decrease\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * (self.budget / float(self.budget + 1))\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):\n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 92, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "4b9d9bf5-cf30-4dde-9069-7d245a9b08d0", "fitness": 0.055013411640053134, "name": "HybridOptimizer", "description": "Enhanced mutation strategy and adaptive temperature scaling for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * np.random.rand()  # Change 1: Enhanced mutation strategy\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= (self.cooling_rate + 0.01)  # Change 2: Adaptive temperature scaling\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 93, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
{"id": "fa7837ce-afe5-4feb-a72e-c05836263731", "fitness": 0.05562370038343773, "name": "HybridOptimizer", "description": "Enhanced convergence through dynamic mutation and precision-adjusted cooling.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.92  # Adjusted cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.4 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 94, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05080873180718115, 0.05337180538100261, 0.054768890167081086, 0.04767113597922579, 0.06220255494890914, 0.0641366970339119, 0.054888146964334084]}}
{"id": "01a65e6f-f8a0-4a98-b431-a2e3a31fb027", "fitness": 0.05508634264824473, "name": "HybridOptimizer", "description": "Enhanced exploration with adaptive mutation and strategic restarts for improved convergence efficiency.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size\n        self.temp = 1.0\n        self.cooling_rate = 0.93  # Slightly increased cooling rate\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (self.budget / float(self.budget + 1))  # More dynamic mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9  # Increased crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.1 * self.budget:  # More aggressive adaptive restart\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 95, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.05101820439016225, 0.05105474244806241, 0.054768890167081086, 0.04786477133633449, 0.059027019191387975, 0.0641366970339119, 0.055141418097968686]}}
{"id": "0de908b8-3b1f-4d7e-8308-326f75c475e6", "fitness": 0.055650204707921036, "name": "HybridOptimizer", "description": "Enhanced mutation strategy by introducing dynamic population size adjustment for improved exploration.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.4 + 0.6 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                self.population_size = int(self.population_size * 0.9)  # Dynamically adjust population size\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 96, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05615002982496897, 0.05845450679247577, 0.05080873180718115, 0.05271620087956419, 0.054768890167081086, 0.04767113597922579, 0.06125750292254639, 0.0641366970339119, 0.054888146964334084]}}
{"id": "3dc2085f-5ceb-437f-8b4b-41fa4665d2e5", "fitness": 0.05564636053114195, "name": "HybridOptimizer", "description": "Enhanced convergence speed and accuracy with adaptive population size and mutation rate dynamics.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.95\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n            \n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.5 + 0.5 * (self.budget / float(self.budget + 1))  # Adjusted mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n            \n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                self.population_size = max(4 * self.dim, self.population_size // 2)  # Dynamic population size adjustment\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 97, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05612729973391262, 0.05845450679247577, 0.05080873180718115, 0.05269602028396647, 0.054768890167081086, 0.047687015747149064, 0.0612291086682738, 0.0641366970339119, 0.054908974546325706]}}
{"id": "5085430f-76c3-43fa-8522-e3bc85286192", "fitness": 0.05563528956413049, "name": "HybridOptimizer", "description": "Enhanced exploration and exploitation through adaptive mutation and dynamic cooling for improved convergence.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.93  # Changed cooling rate for more gradual cooling \n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n\n            mutation_factor_base = 0.5  # Increase base mutation factor\n            mutation_factor_decay = 0.5 * (self.budget / float(self.budget + 1))  # Adjusted decay calculation\n            mutation_factor = mutation_factor_base + mutation_factor_decay\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.85\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.15 * self.budget:  # Adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 98, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05610724093045272, 0.05845450679247577, 0.05080873180718115, 0.05267819544608765, 0.054768890167081086, 0.04767113597922579, 0.06120406095642428, 0.0641366970339119, 0.054888146964334084]}}
{"id": "9eb381db-7312-471b-aaac-b10ceaecd369", "fitness": 0.05501681216547963, "name": "HybridOptimizer", "description": "Enhanced convergence through dynamic parameter control and stochastic local search for efficient exploitation.", "code": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.temp = 1.0\n        self.cooling_rate = 0.9  # Adjusted cooling rate\n        self.initial_budget = budget\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        self.budget -= self.population_size\n\n        while self.budget > 0:\n            best_index = np.argmin(fitness)\n            best_individual = population[best_index]\n\n            for i in range(self.population_size):\n                indices = [idx for idx in range(self.population_size) if idx != i]\n                a, b, c = population[np.random.choice(indices, 3, replace=False)]\n                mutation_factor = 0.2 + 0.8 * (self.budget / float(self.initial_budget))  # Dynamic mutation factor\n                mutant = np.clip(a + mutation_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = 0.9  # Adjusted crossover rate\n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, population[i])\n\n                trial_fitness = func(trial)\n                self.budget -= 1\n\n                if trial_fitness < fitness[i]:\n                    population[i], fitness[i] = trial, trial_fitness\n                elif np.random.rand() < np.exp(-(trial_fitness - fitness[i]) / self.temp):  \n                    population[i], fitness[i] = trial, trial_fitness\n\n            for i in range(self.population_size):\n                perturbation = np.random.normal(0, self.temp, self.dim)\n                candidate = np.clip(population[i] + perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                self.budget -= 1\n\n                if (candidate_fitness < fitness[i]) or (np.random.rand() < np.exp(-(candidate_fitness - fitness[i]) / self.temp)):\n                    population[i], fitness[i] = candidate, candidate_fitness\n\n            self.temp *= self.cooling_rate\n\n            if self.budget < 0.2 * self.initial_budget:  # Adjusted adaptive restart condition\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                self.budget -= self.population_size\n\n            if fitness[best_index] < np.min(fitness):\n                population[np.argmax(fitness)] = best_individual\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "configspace": "", "generation": 99, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.00.", "error": "", "parent_ids": ["78d98418-3fa9-4c8d-a0f5-1fc393cd6dbf"], "operator": null, "metadata": {"aucs": [0.05431083437681805, 0.05845450679247577, 0.050839336536019575, 0.05105474244806241, 0.054768890167081086, 0.04767113597922579, 0.059027019191387975, 0.0641366970339119, 0.054888146964334084]}}
