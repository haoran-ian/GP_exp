{"id": "de3da08c-0622-418b-be7a-33c96ff2fc64", "fitness": 0.7421723962913204, "name": "AdaptiveHarmonySearch", "description": "An adaptive harmony search algorithm that self-tunes parameters based on feedback from function evaluations to efficiently explore and exploit the search space.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.3  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.04.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.689023142992337, 0.7890025256141785, 0.7319161292916443, 0.6790500911924415, 0.7175203802449248, 0.7280929920037138, 0.7455060712291924, 0.8138192265387273, 0.7856210075147239]}}
{"id": "853df978-4248-40fd-8c81-b162a0200574", "fitness": 0.7228906078495586, "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with a dynamic pitch adjustment mechanism and memory enrichment for improved exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.dynamic_bw_init = 0.1  # Dynamic bandwidth initialization\n        self.bw_decay = 0.99  # Bandwidth decay factor\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n        self.dynamic_memory = []\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        dynamic_bw = self.dynamic_bw_init * (self.bw_decay ** (len(self.dynamic_memory) // 10))\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        self.dynamic_memory.append((new_harmony, new_fitness))\n        if len(self.dynamic_memory) > self.memory_size:\n            self.dynamic_memory.pop(0)\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.72 with standard deviation 0.08.", "error": "", "parent_ids": ["de3da08c-0622-418b-be7a-33c96ff2fc64"], "operator": null, "metadata": {"aucs": [0.575902028802389, 0.7302574469575117, 0.7834293035043548, 0.6453892577966414, 0.7298488573197781, 0.7620007009085703, 0.6612423745364553, 0.8148569208875744, 0.8030885799327521]}}
{"id": "c04fda13-39ef-4eaa-b6ed-e272526b8043", "fitness": 0.5161711809563369, "name": "HybridAdaptiveHarmonySearch", "description": "A hybrid adaptive harmony search algorithm incorporating a local refinement phase to balance exploration and exploitation for enhanced convergence.", "code": "import numpy as np\n\nclass HybridAdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  \n        self.par = 0.3  \n        self.bw = 0.01  \n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.normal(0, self.bw)  # Changed from uniform to normal distribution\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        return np.clip(new_harmony, self.lower_bound, self.upper_bound)\n\n    def local_refinement(self, harmony, func):  # Added new local refinement phase\n        refined_harmony = harmony + np.random.normal(0, 0.05, self.dim)\n        refined_harmony = np.clip(refined_harmony, self.lower_bound, self.upper_bound)\n        refined_fitness = func(refined_harmony)\n        return refined_harmony, refined_fitness\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_harmony, new_fitness = self.local_refinement(new_harmony, func)  # Incorporate local refinement\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 2, "feedback": "The algorithm HybridAdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.17.", "error": "", "parent_ids": ["de3da08c-0622-418b-be7a-33c96ff2fc64"], "operator": null, "metadata": {"aucs": [0.5017421914798275, 0.478992295164937, 0.7477306866646432, 0.1609994467942878, 0.48327556623544454, 0.3549767970823612, 0.5740792575140377, 0.6452072208293191, 0.6985371668421743]}}
{"id": "a034a748-3596-4781-97f4-e06b0c5cea89", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "An adaptive harmony search algorithm with enhanced exploration capability by adjusting harmony memory size dynamically based on function evaluation feedback.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.3  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n            if evaluations % 10 == 0:  # Dynamically adjust memory size for better exploration\n                self.memory_size = min(self.memory_size + 1, 100)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 3, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_ids": ["de3da08c-0622-418b-be7a-33c96ff2fc64"], "operator": null, "metadata": {}}
{"id": "6cd493c2-e526-436c-a99d-cbaf46d79b7a", "fitness": 0.7407980159384188, "name": "AdaptiveHarmonySearch", "description": "A refined version of Adaptive Harmony Search that tweaks the pitch adjustment bandwidth dynamically based on convergence speed.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.3  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw * np.random.rand())  # Dynamic bandwidth\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.10.", "error": "", "parent_ids": ["de3da08c-0622-418b-be7a-33c96ff2fc64"], "operator": null, "metadata": {"aucs": [0.7438795378928894, 0.8200979523137857, 0.8484097608673481, 0.5946019399605625, 0.7761773857708933, 0.7277911239478636, 0.7111627738197998, 0.8778956516522466, 0.5671660172203792]}}
{"id": "a095f611-868c-492b-814e-22c3d5f1b593", "fitness": 0.6342618264359472, "name": "AdaptiveHarmonySearch", "description": "Enhanced adaptive harmony search using dynamic pitch adjustment for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.3  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    # Dynamic bandwidth adjustment\n                    self.bw = 0.01 + 0.49 * (self.budget - self.memory_size) / self.budget\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.63 with standard deviation 0.12.", "error": "", "parent_ids": ["de3da08c-0622-418b-be7a-33c96ff2fc64"], "operator": null, "metadata": {"aucs": [0.4816723249961359, 0.7192673397624344, 0.4161945668857012, 0.5874445795448101, 0.7269270894200948, 0.6199377378970817, 0.6406127079191346, 0.8036757639605652, 0.7126243275375657]}}
{"id": "69eb6400-c660-4de2-b2ba-209d6e6c5b9c", "fitness": 0.45891557910505054, "name": "AdaptiveHarmonySearch", "description": "An enhanced adaptive harmony search algorithm introducing dynamic parameter tuning and memory reshuffling to boost exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9\n        self.par = 0.3\n        self.bw = 0.01\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def dynamic_parameter_tuning(self, evaluations):\n        \"\"\"Adjust parameters dynamically based on the number of evaluations.\"\"\"\n        self.hmcr = 0.7 + 0.3 * (evaluations / self.budget)\n        self.par = 0.1 + 0.3 * (1 - evaluations / self.budget)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def reshuffle_memory(self):\n        \"\"\"Introduce diversity by reshuffling memory occasionally.\"\"\"\n        if np.random.rand() < 0.1:\n            np.random.shuffle(self.memory)\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            self.dynamic_parameter_tuning(evaluations)\n            new_harmony = self.generate_new_harmony()\n            self.reshuffle_memory()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 6, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.14.", "error": "", "parent_ids": ["de3da08c-0622-418b-be7a-33c96ff2fc64"], "operator": null, "metadata": {"aucs": [0.5766559986766719, 0.32383451739186686, 0.39842075358736584, 0.36707249574419987, 0.2347569221801824, 0.4638830703406246, 0.6446227633226305, 0.42065026798660554, 0.7003434227153071]}}
{"id": "1890d58e-5086-4489-9d35-507c55795146", "fitness": 0.762323846929067, "name": "AdaptiveHarmonySearch", "description": "A slight adjustment in the pitch adjustment rate (par) to potentially enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 7, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.76 with standard deviation 0.08.", "error": "", "parent_ids": ["de3da08c-0622-418b-be7a-33c96ff2fc64"], "operator": null, "metadata": {"aucs": [0.7030017055694707, 0.7314218660012795, 0.8674618463437441, 0.7558827731269926, 0.6060651485958646, 0.7421471098678392, 0.7447999940661072, 0.8720194357419992, 0.8381147430483056]}}
{"id": "3e7c723b-345a-4178-a715-b75612b3bda2", "fitness": 0.795419425394272, "name": "AdaptiveHarmonySearch", "description": "Enhanced exploration and exploitation by dynamically adjusting the bandwidth (bw) during pitch adjustment for better performance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.bw = 0.01 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Adjust bw dynamically\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.04.", "error": "", "parent_ids": ["1890d58e-5086-4489-9d35-507c55795146"], "operator": null, "metadata": {"aucs": [0.7856373758046442, 0.7722835612337479, 0.8141119505826786, 0.712098251099412, 0.83313427619989, 0.7871753475257883, 0.8255655694569785, 0.8647393075992276, 0.7640291890460806]}}
{"id": "eddc1b95-074c-406a-8715-3763f49ec192", "fitness": 0.7984657431413449, "name": "AdaptiveHarmonySearch", "description": "Enhanced exploration and exploitation by dynamically adjusting the pitch adjustment rate (par) for better performance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Adjust par dynamically\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 9, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.04.", "error": "", "parent_ids": ["3e7c723b-345a-4178-a715-b75612b3bda2"], "operator": null, "metadata": {"aucs": [0.7762504062739541, 0.7986583068609178, 0.8765790790570371, 0.7819268896918663, 0.7567298832820301, 0.7535653880276614, 0.8593947832994246, 0.7934297089459853, 0.7896572428332286]}}
{"id": "7676540c-98c3-4bb1-8100-b62cc4daeef0", "fitness": 0.7886340561152378, "name": "AdaptiveHarmonySearch", "description": "Improved Harmony Search with adaptive bandwidth adjustment for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Adjust par dynamically\n                    self.bw = 0.01 * (1 + (np.std(self.memory_fitness) / np.mean(self.memory_fitness)))  # Adjust bw dynamically\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 10, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.03.", "error": "", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {"aucs": [0.7926175230220829, 0.8074886510677206, 0.8203902226352757, 0.7397197743204734, 0.8329676627463911, 0.7426434933274493, 0.7928074793330661, 0.7496757793475172, 0.8193959192371635]}}
{"id": "c16e763a-6e9e-4de3-84f1-0090327f1de4", "fitness": 0.7751164316097081, "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with dynamic bandwidth adjustment for improved exploitation and exploration balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Adjust par dynamically\n                    self.bw = 0.01 * (1 + (np.max(self.memory_fitness) - np.min(self.memory_fitness)) / np.mean(self.memory_fitness))  # Adjust bw dynamically\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 11, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.08.", "error": "", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {"aucs": [0.7770977555515818, 0.7323293380354926, 0.8056183721572517, 0.5805055096942284, 0.7916215496957657, 0.8021634267533762, 0.795627670339895, 0.8409680670107915, 0.8501161952489902]}}
{"id": "b5eb61df-a7b3-4dbd-b400-12a6dc4c87d9", "fitness": 0.4750566338577622, "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search with stochastic memory consideration rate and variance-based pitch adjustment for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        dynamic_hmcr = self.hmcr * (1 - np.std(self.memory_fitness) / np.mean(self.memory_fitness))  # Adjust hmcr dynamically\n        for i in range(self.dim):\n            if np.random.rand() < dynamic_hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Reused line, counts as unchanged\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw * np.std(self.memory[:, i]))  # Adjust bw with feature variance\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 12, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.15.", "error": "", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {"aucs": [0.4184358731524841, 0.4864530921329798, 0.19852884690387618, 0.33961005005451583, 0.5634379878575755, 0.5723958208879493, 0.3820098402416877, 0.6265757635779863, 0.6880624299108048]}}
{"id": "498aee4c-762c-42b3-be38-11deb5408153", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Introduced dynamic bandwidth adjustment and memory diversification for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Adjust par dynamically\n                    self.bw = np.std(self.memory, axis=0)[i] * 0.1  # Dynamic bandwidth adjustment\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        # Memory diversification\n        if np.random.rand() < 0.1:\n            random_idx = np.random.randint(0, self.memory_size)\n            self.memory[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.memory_fitness[random_idx] = func(self.memory[random_idx])\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 13, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {}}
{"id": "1e07b1bb-79a2-43b6-b78a-2d8f437e912d", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Improved exploration and exploitation by using adaptive bandwidth and memory diversification.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Adjust par dynamically\n                    adaptive_bw = self.bw * (1 - np.min(self.memory_fitness) / (np.mean(self.memory_fitness) + 1e-9))  # Adaptive bandwidth\n                    new_harmony[i] += np.random.uniform(-adaptive_bw, adaptive_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        elif np.random.rand() < 0.05:  # Memory diversification by random replacement\n            random_idx = np.random.randint(self.memory_size)\n            self.memory[random_idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n            self.memory_fitness[random_idx] = func(self.memory[random_idx])\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 14, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {}}
{"id": "12544a9b-11ff-4ea0-a6af-0569b17bf8e4", "fitness": 0.7832570417234967, "name": "AdaptiveHarmonySearch", "description": "Improved exploration by adjusting `bw` based on the diversity of harmony memory.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Adjust par dynamically\n                    self.bw = np.std(self.memory[:, i])  # Adjust bw based on diversity\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 15, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.04.", "error": "", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {"aucs": [0.7699621831306628, 0.7010978072034479, 0.8337015762355486, 0.7732582636988372, 0.8191760005928657, 0.7321622192848308, 0.8210090247426323, 0.7746376907147702, 0.8243086099078752]}}
{"id": "4d529202-e009-49ee-a007-190ecf3d5b94", "fitness": 0.768540377004295, "name": "AdaptiveHarmonySearch", "description": "Improved adaptive pitch adjustment rate by including standard deviation for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness) + np.std(self.memory_fitness)))  # Adjust par dynamically\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 16, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.11.", "error": "", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {"aucs": [0.70804796419048, 0.8476158650094349, 0.8471354366397451, 0.5081002331743395, 0.8156814240120331, 0.7754344214739493, 0.7052451692779458, 0.8293272910379811, 0.8802755882227458]}}
{"id": "29063457-33af-4b28-96eb-2e38d85cfd5c", "fitness": 0.7984657431413449, "name": "AdaptiveHarmonySearch", "description": "Enhanced dynamic adjustment of the pitch adjustment rate (par) to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Adjust par dynamically with stability\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 17, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.04.", "error": "", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {"aucs": [0.7762504062739541, 0.7986583068609178, 0.8765790790570371, 0.7819268896918663, 0.7567298832820301, 0.7535653880276614, 0.8593947832994246, 0.7934297089459853, 0.7896572428332286]}}
{"id": "a6c4694d-5e17-40af-9890-1477c013fe86", "fitness": 0.7819485633121145, "name": "AdaptiveHarmonySearch", "description": "Enhanced memory diversity by incorporating a mutation step to escape local optima.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = 50\n        self.hmcr = 0.9  # Harmony memory consideration rate\n        self.par = 0.35  # Pitch adjustment rate\n        self.bw = 0.01  # Bandwidth for pitch adjustment\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / np.max(self.memory_fitness)))  # Adjust par dynamically\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.1:  # Mutation step\n            mutation_idx = np.random.randint(0, self.dim)\n            new_harmony[mutation_idx] += np.random.uniform(-0.1, 0.1)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 18, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.07.", "error": "", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {"aucs": [0.8470699694433438, 0.7970542205948656, 0.7266768807458492, 0.8031257303928261, 0.6482097266167821, 0.6853725282905967, 0.835329739794304, 0.845519425095555, 0.849178848834907]}}
{"id": "d09fac54-c9d8-445f-b495-26ce272b7346", "fitness": 0.8038001602251451, "name": "AdaptiveHarmonySearch", "description": "Introduce adaptive bandwidth and memory size to enhance solution exploration in Adaptive Harmony Search.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.35\n        self.bw = 0.01\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 19, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.07.", "error": "", "parent_ids": ["eddc1b95-074c-406a-8715-3763f49ec192"], "operator": null, "metadata": {"aucs": [0.7859496290307992, 0.819880361991255, 0.7305048193766781, 0.6602543440831417, 0.8520167194956858, 0.763481558189667, 0.8703386114274034, 0.8801997352507291, 0.871575663180947]}}
{"id": "1c21c61d-2237-4826-899b-60d75fdd0c6e", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Enhance exploration by introducing non-uniform selection for HMCR component.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.35\n        self.bw = 0.01\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.choice(range(self.memory_size), p=self.memory_fitness / np.sum(self.memory_fitness))\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 20, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["d09fac54-c9d8-445f-b495-26ce272b7346"], "operator": null, "metadata": {}}
{"id": "6b1585c2-9b33-40ee-8c51-d6472ce86edc", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by introducing dynamic control of the harmony memory considering fitness variance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.35\n        self.bw = 0.01\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        if np.var(self.memory_fitness) > 0.05:  # Dynamic control based on fitness variance\n            self.memory_size = min(50, self.memory_size + 1)  # Adjust memory size\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 21, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 46').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 46')", "parent_ids": ["d09fac54-c9d8-445f-b495-26ce272b7346"], "operator": null, "metadata": {}}
{"id": "bce97589-3201-4b44-969e-3be22e5a1a25", "fitness": 0.7527091830557435, "name": "AdaptiveHarmonySearch", "description": "Refine the pitch adjustment rate (par) formula to avoid premature convergence in Adaptive Harmony Search.  ", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.35\n        self.bw = 0.01\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * 0.5  # Adjust par more conservatively\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 22, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.11.", "error": "", "parent_ids": ["d09fac54-c9d8-445f-b495-26ce272b7346"], "operator": null, "metadata": {"aucs": [0.5352272155802531, 0.7099446332031729, 0.8262377733110141, 0.6403731768631988, 0.8522165209070557, 0.7152989237096092, 0.8442917548186867, 0.8559032069545665, 0.7948894421541339]}}
{"id": "37bd9970-782c-4927-864a-6d8a641b2941", "fitness": 0.7797457562353156, "name": "AdaptiveHarmonySearch", "description": "Enhance dynamic parameters and introduce elite learning in Adaptive Harmony Search to improve convergence and solution quality.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.35\n        self.bw = 0.01\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        best_idx = np.argmin(self.memory_fitness)  # Elite learning\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.mean(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.mean(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = (self.memory[best_idx, i] + np.random.uniform(self.lower_bound, self.upper_bound)) / 2\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 23, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.08.", "error": "", "parent_ids": ["d09fac54-c9d8-445f-b495-26ce272b7346"], "operator": null, "metadata": {"aucs": [0.6646910182735621, 0.8343863124493249, 0.8416253014949934, 0.6336859624180591, 0.7150668133232874, 0.8210888537945109, 0.7953026522063884, 0.8544227165040706, 0.8574421756536436]}}
{"id": "6725a218-99c0-481e-ba4f-8c2e09006f63", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Implement dynamic adjustment of memory size and bandwidth based on convergence rate in Adaptive Harmony Search.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.35\n        self.bw = 0.01\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.35 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n            improvement_rate = (np.max(self.memory_fitness) - new_fitness) / (np.max(self.memory_fitness) + 1e-6)\n            self.memory_size = int(max(30, self.memory_size * (1 + improvement_rate)))  # Dynamic memory size\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 24, "feedback": "An exception occurred: IndexError('index 49 is out of bounds for axis 0 with size 46').", "error": "IndexError('index 49 is out of bounds for axis 0 with size 46')", "parent_ids": ["d09fac54-c9d8-445f-b495-26ce272b7346"], "operator": null, "metadata": {}}
{"id": "517209ff-4c71-4138-8a16-c5ba69b477e9", "fitness": 0.828238047575507, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by tuning pitch adjustment rate and dynamic bandwidth for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 25, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.03.", "error": "", "parent_ids": ["d09fac54-c9d8-445f-b495-26ce272b7346"], "operator": null, "metadata": {"aucs": [0.790877209732082, 0.8154462093031137, 0.8313381018677903, 0.8041579173970607, 0.7923389165796413, 0.8547970208972331, 0.8484339661133771, 0.8585399758044696, 0.8582131104847954]}}
{"id": "47fa3f63-159c-4de3-ba17-a700480e6ce0", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by implementing a more dynamic pitch adjustment rate scaling with iteration count for improved diversity.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * (1 - evaluations/self.budget) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 26, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "09b06612-2843-4519-a783-438483037ed9", "fitness": 0.8092759384878896, "name": "AdaptiveHarmonySearch", "description": "Fine-tune the bandwidth adjustment factor to further stabilize convergence dynamics.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * 0.5 # Fine-tuned dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 27, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8044162212407704, 0.8585301166923704, 0.782850257043159, 0.7971937963836534, 0.7579415415466791, 0.7820416117346658, 0.8295345385949151, 0.8249672388191313, 0.8460081243356621]}}
{"id": "1755dede-e4d1-433e-8e46-70404c7eba2b", "fitness": 0.8092759384878896, "name": "AdaptiveHarmonySearch", "description": "Further optimize Adaptive Harmony Search by refining memory utilization and pitch adjustment for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw / 2, dynamic_bw / 2)  # Refined bandwidth adjustment\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 28, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8044162212407704, 0.8585301166923704, 0.782850257043159, 0.7971937963836534, 0.7579415415466791, 0.7820416117346658, 0.8295345385949151, 0.8249672388191313, 0.8460081243356621]}}
{"id": "823c1250-b40b-403a-b75b-5aad5e887007", "fitness": 0.7924418963139249, "name": "AdaptiveHarmonySearch", "description": "Improve Adaptive Harmony Search by incorporating adaptive memory consideration in new harmony generation and updating.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.mean(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjusted use of mean instead of min\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 29, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.06.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8044079266919696, 0.7370667219132332, 0.8333309104844704, 0.7632950838044237, 0.7299376513390572, 0.7126137218127235, 0.9071638746432679, 0.7918720742772158, 0.8522891018589632]}}
{"id": "9bd314df-3174-4544-8334-e34433caf45c", "fitness": 0.7742319755229939, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by implementing an adaptive memory consideration rate and dynamically adjusting pitch adjustment using the diversity of harmony memory.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        diversity = np.std(self.memory, axis=0)  # Calculate diversity\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    dynamic_par = self.par * (1 - diversity[i] / (np.mean(diversity) + 1e-6)) # Adjust par based on diversity\n                    new_harmony[i] += np.random.uniform(-self.bw, self.bw) * dynamic_par\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 30, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.06.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.675921678854488, 0.8440909874599309, 0.8633489739362384, 0.6774862288112711, 0.757538048464963, 0.7345819326352065, 0.8310881571081424, 0.7890207068516452, 0.7950110655850608]}}
{"id": "222e3ab2-8b84-4190-b8ec-bcf848188743", "fitness": 0.8175213630027393, "name": "AdaptiveHarmonySearch", "description": "Fine-tune the dynamic bandwidth calculation for improved exploration-exploitation balance in Adaptive Harmony Search.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * np.sqrt(1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Fine-tuned dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 31, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8367527393532932, 0.8462321010575231, 0.7177580367674625, 0.7590840972622525, 0.7986698053811201, 0.7966666808630257, 0.836330719423025, 0.8934603763945026, 0.8727377105224488]}}
{"id": "1f335d36-d557-4f70-8ec1-603ae10248b9", "fitness": 0.7798054273310915, "name": "AdaptiveHarmonySearch", "description": "Enhance pitch adjustment by introducing stochastic variation to improve exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw) + np.random.normal(0, 0.01) # Stochastic variation\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 32, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8149687939830121, 0.7382423908287225, 0.7941131077670303, 0.734105714632394, 0.6951768757510224, 0.7630147262636048, 0.7942647881707743, 0.8492011435054578, 0.8351613050778047]}}
{"id": "1bfd06eb-d980-405d-b8e4-c3719a375ae5", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by adjusting the memory size dynamically based on current diversity for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        self.memory_size = max(30, int(len(self.memory_fitness) * np.ptp(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Dynamic memory size\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 33, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 46').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 46')", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "1a4a13d6-03b5-47cf-bdd5-9c10250f3b48", "fitness": 0.6038831333854418, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by dynamically adjusting both pitch adjustment rate and memory consideration rate based on the fitness diversity for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9  # Adaptive memory consideration rate\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr * (1 - (np.std(self.memory_fitness) / (np.mean(self.memory_fitness) + 1e-6))):\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 34, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.14.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7055609561279366, 0.5347573917616577, 0.5421698657152811, 0.48559704503074796, 0.4912468972184848, 0.39785889761105275, 0.842105998148231, 0.7011965318013222, 0.7344546170542621]}}
{"id": "606e0636-7400-4eaf-9052-46ed8c3c6a0d", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Introduce an adaptive memory update mechanism and refined pitch adjustment based on fitness variance to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        fitness_variance = np.var(self.memory_fitness)  # Calculate fitness variance\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - fitness_variance / (np.max(self.memory_fitness) + 1e-6))  # Adjust par\n                    dynamic_bw = self.bw * (1 - fitness_variance / (np.max(self.memory_fitness) + 1e-6))  # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        prob_replace = fitness_variance / (np.min(self.memory_fitness) + 1e-6)  # Probability of replacement\n        if new_fitness < self.memory_fitness[worst_idx] or np.random.rand() < prob_replace:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 35, "feedback": "An exception occurred: NameError(\"name 'fitness_variance' is not defined\").", "error": "NameError(\"name 'fitness_variance' is not defined\")", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "e9f83fbe-d852-475d-be5e-95e5397e467e", "fitness": 0.08052033806493725, "name": "AdaptiveCMSAHarmonySearch", "description": "Adaptive Harmony Search with Covariance Matrix Adaptation for dynamic exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveCMSAHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n        self.C = np.eye(dim)  # Covariance matrix\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        noise = np.random.multivariate_normal(np.zeros(self.dim), self.C)\n        new_harmony = np.clip(new_harmony + noise, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n            self.C = self._update_covariance_matrix(new_harmony)\n\n    def _update_covariance_matrix(self, new_harmony):\n        mean_harmony = np.mean(self.memory, axis=0)\n        diffs = self.memory - mean_harmony\n        return np.cov(diffs.T) + np.outer(new_harmony - mean_harmony, new_harmony - mean_harmony)\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 36, "feedback": "The algorithm AdaptiveCMSAHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.00.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.0780457546234058, 0.08576982606311345, 0.0821883750182093, 0.08236970848992453, 0.06851981597077317, 0.08096616743857621, 0.08337787657994278, 0.08218982436525712, 0.08125569403523292]}}
{"id": "f3241126-9d35-469a-9bb2-327a77c0ef94", "fitness": 0.7780092833053873, "name": "AdaptiveHarmonySearch", "description": "Further enhance Adaptive Harmony Search by implementing a dynamic memory size reduction mechanism to intensify search as the algorithm progresses.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n        self.memory_size = max(10, int(self.memory_size * (1 - (evaluations / self.budget))))  # Dynamic memory size reduction\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 37, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.08.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.6467732547653045, 0.878509819882203, 0.7316130510176746, 0.6599984221529566, 0.7924571702115322, 0.7423720952108549, 0.8709722833507783, 0.8318136553385811, 0.8475737978186011]}}
{"id": "c732396a-dfa5-4918-b079-5d21c8b839fa", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Fine-tune pitch adjustment rate by dynamically scaling based on fitness improvements for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * (evaluations / self.budget) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 38, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "5d895a62-574d-431d-b47b-08de9ab2d8e3", "fitness": 0.12797640798984147, "name": "AdaptiveHarmonySearch", "description": "Utilize a dynamically adjusted memory consideration rate (hmcr) for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Updated line: Dynamic adjustment of hmcr for better adaptation\n            self.hmcr = 0.9 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 39, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.11.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.06655800352550634, 0.08022559104286997, 0.3698001096279573, 0.0654022793681932, 0.06084329825613999, 0.062484389289673814, 0.08415042609602863, 0.08876563337625731, 0.2735579413259469]}}
{"id": "c18d6c4e-dd6c-43f0-a69f-1b23aacceaea", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Further optimize Adaptive Harmony Search by introducing a temperature-controlled dynamic bandwidth for improved solution diversity.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * np.exp(-0.01 * (self.budget - evaluations))  # Temperature-controlled dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 40, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "3b975fce-d5a7-4aaf-ba50-09c39736411b", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Further refine Adaptive Harmony Search by dynamically adjusting both pitch adjustment rate and memory size based on fitness distribution.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n            self.memory_size = min(self.memory_size + 1, 100)  # Dynamic memory size increase\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 41, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 46').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 46')", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "0ce67577-6bd5-4cfe-a39a-3de815781fc9", "fitness": 0.828238047575507, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by dynamically adjusting the harmony memory considering diversity to improve exploration.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        diversity = np.std(self.memory, axis=0).mean()  # Calculate diversity of memory\n        if new_fitness < self.memory_fitness[worst_idx] or diversity < 0.1:  # Change condition to consider diversity\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 42, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.790877209732082, 0.8154462093031137, 0.8313381018677903, 0.8041579173970607, 0.7923389165796413, 0.8547970208972331, 0.8484339661133771, 0.8585399758044696, 0.8582131104847954]}}
{"id": "14096cfa-fae7-4d59-bec9-0719ed50f076", "fitness": 0.7654705449604353, "name": "AdaptiveHarmonySearch", "description": "Enhance convergence by adjusting pitch adjustment rate more precisely using exponential decay.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * np.exp(-0.1 * (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Adjust par using exponential decay\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 43, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8178970852947809, 0.7336435801460914, 0.8134335396700385, 0.8092763595645986, 0.6908486250843044, 0.6935814962069007, 0.7954764327158617, 0.7961768395727643, 0.7389009463885771]}}
{"id": "202d39e5-4bb2-4560-b1b9-ee38e7b55edd", "fitness": 0.7929576842357768, "name": "AdaptiveHarmonySearch", "description": "Further enhance exploration by implementing a dynamic adjustment for bandwidth and pitch adjustment rate based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    fitness_range = np.max(self.memory_fitness) - np.min(self.memory_fitness)\n                    self.par = 0.45 * (1 - (np.var(self.memory_fitness) / (fitness_range + 1e-6)))  # Adjust par using variance\n                    dynamic_bw = self.bw * (1 - (np.var(self.memory_fitness) / (fitness_range + 1e-6)))  # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 44, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7860018163894862, 0.7530632591190682, 0.8572793163370718, 0.7943786100660863, 0.6779274719168886, 0.8192440040136456, 0.8298762441646598, 0.7593451386402805, 0.8595032974748038]}}
{"id": "365c4751-e9ec-4c05-bb15-48bed5c393f9", "fitness": 0.8094590810601434, "name": "AdaptiveHarmonySearch", "description": "Slightly adjust bandwidth calculation to improve adaptive exploration.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * 0.9 # Dynamic bandwidth with slight reduction\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 45, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8310033501935075, 0.7845950988762749, 0.8028524314211604, 0.8230709069046717, 0.83696131410175, 0.7396639108896892, 0.8416670590617555, 0.8384929357879212, 0.7868247223045608]}}
{"id": "1a040072-3032-4a4b-9e5c-658cb5baa56b", "fitness": 0.7883138728378246, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by incorporating a memory initialization strategy that leverages opposition-based learning for diversity.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        opposition = self.lower_bound + self.upper_bound - self.memory  # Opposition-based learning\n        combined = np.vstack((self.memory, opposition))\n        fitness_values = np.apply_along_axis(func, 1, combined)\n        best_indices = np.argsort(fitness_values)[:self.memory_size]\n        self.memory = combined[best_indices]\n        self.memory_fitness = fitness_values[best_indices]\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 46, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8227334274259315, 0.7512638619167806, 0.826553522524059, 0.664085499940323, 0.7861466728711041, 0.7712522564222596, 0.8185502220245099, 0.7934619917985738, 0.8607774006168808]}}
{"id": "70e432c2-4dad-4c61-adab-9aa24b21b1a9", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Improve the exploration capability by dynamically adjusting the harmony memory considering convergence speed.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n            self.memory_size = max(30, int(self.memory_size * (1 - (new_fitness / (np.max(self.memory_fitness) + 1e-6)))))  # Dynamic adjustment\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 47, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 46').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 46')", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "6ce5894e-9e8c-4f39-a50f-ae001f162b20", "fitness": 0.28355104981360185, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by dynamically varying harmony memory consideration rate (HMCR) to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            self.hmcr = 0.9 * (1 - evaluations / self.budget)  # Dynamic HMCR based on evaluations\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 48, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.29.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.1451621985929762, 0.12601083578927608, 0.15400906689253524, 0.08948214918804609, 0.1251843077430813, 0.14293083974276666, 0.8879655921801539, 0.12043592284407378, 0.7607785353495072]}}
{"id": "3c09bf6b-74b7-4f11-975c-ac876e6354e6", "fitness": 0.828238047575507, "name": "AdaptiveHarmonySearch", "description": "Improve Adaptive Harmony Search by fine-tuning the initial pitch adjustment rate for robust initial exploration.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.5  # Fine-tuned initial pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 49, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.790877209732082, 0.8154462093031137, 0.8313381018677903, 0.8041579173970607, 0.7923389165796413, 0.8547970208972331, 0.8484339661133771, 0.8585399758044696, 0.8582131104847954]}}
{"id": "c609cbf5-b150-406f-b4a7-e4ac69cbdad8", "fitness": 0.6038831333854418, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by dynamically adjusting harmony memory consideration rate (HMCR) based on fitness to enhance adaptability.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            # Dynamically adjust hmcr based on fitness variance\n            self.hmcr = 0.9 * (1 - (np.std(self.memory_fitness) / (np.mean(self.memory_fitness) + 1e-6))) \n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 50, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.14.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7055609561279366, 0.5347573917616577, 0.5421698657152811, 0.48559704503074796, 0.4912468972184848, 0.39785889761105275, 0.842105998148231, 0.7011965318013222, 0.7344546170542621]}}
{"id": "362a659e-8008-453c-987c-f4a916f039cf", "fitness": 0.7843040827214134, "name": "AdaptiveHarmonySearch", "description": "Introducing a dynamic adjustment for pitch adjustment rate (par) and bandwidth (bw) based on population diversity.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.std(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Changed from min to std\n                    dynamic_bw = self.bw * (1 - (np.std(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Changed from min to std\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 51, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.07.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8358712167720453, 0.7506155822572218, 0.7384413847064578, 0.6666287988572932, 0.7960935816061833, 0.7432065038490296, 0.8447424172288931, 0.7824276927130811, 0.9007095665025148]}}
{"id": "f84d482b-0a4f-4d30-b90e-a527b8b01663", "fitness": 0.828238047575507, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by introducing adaptive memory size based on evaluation progress.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            if evaluations > self.budget * 0.5:  # Adapt memory size based on progress\n                self.memory_size = max(20, self.memory_size // 2)\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 52, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.790877209732082, 0.8154462093031137, 0.8313381018677903, 0.8041579173970607, 0.7923389165796413, 0.8547970208972331, 0.8484339661133771, 0.8585399758044696, 0.8582131104847954]}}
{"id": "1b7c20fa-4b69-45b5-9bcd-ce8c5d243576", "fitness": 0.8107086621691466, "name": "AdaptiveHarmonySearch", "description": "Slightly adjust the dynamic bandwidth calculation to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - np.std(self.memory_fitness)) # Adjust dynamic bandwidth using standard deviation\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 53, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7995361426211175, 0.7506376465000855, 0.8271917785224362, 0.7769766858031686, 0.8395258475254773, 0.8155396296582675, 0.8366563943905965, 0.8161691342996298, 0.8341447002015403]}}
{"id": "d2382a4f-c0bb-4450-88ed-8ae9b2d6497c", "fitness": 0.6516690381984551, "name": "AdaptiveHarmonySearch", "description": "Enhance diversity by introducing adaptive mutation based on fitness variance for improved exploration.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        fitness_range = np.ptp(self.memory_fitness) + 1e-6  # Calculate fitness range for diversity\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            # Incorporate adaptive mutation based on fitness variance\n            new_harmony[i] += np.random.uniform(-fitness_range, fitness_range) * 0.1  \n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 54, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.65 with standard deviation 0.13.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.66017598668297, 0.6413306759072752, 0.6638262072821797, 0.7068008100480625, 0.3162947405091078, 0.6846980521682221, 0.7574047228757435, 0.6683004403373203, 0.7661897079752149]}}
{"id": "20e0aacc-707c-4734-9913-c3c28afc78f7", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by incorporating adaptive memory consideration and enhanced exploration through dynamic adjustment.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            new_harmony[i] += np.random.normal(0, dynamic_bw / 2)  # Added exploration via Gaussian noise\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 55, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'dynamic_bw' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'dynamic_bw' referenced before assignment\")", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "7d8241d3-8611-4168-b77a-b88eebfe9512", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by introducing a dynamic memory size based on convergence rate to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n            if new_fitness < np.mean(self.memory_fitness):  # Dynamic memory size adjustment\n                self.memory_size = min(self.memory_size + 1, 60)\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 56, "feedback": "An exception occurred: IndexError('index 46 is out of bounds for axis 0 with size 46').", "error": "IndexError('index 46 is out of bounds for axis 0 with size 46')", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "970d075d-0736-4e06-86bd-695f78fc7993", "fitness": 0.6867391627431387, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by dynamically adapting the harmony memory considering the diversity of harmonies.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n            # Adapt memory size dynamically based on diversity\n            self.memory_size = max(30, int(np.std(self.memory_fitness) * 10))\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 57, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.69 with standard deviation 0.13.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.5846314640376702, 0.7478691546307423, 0.7827235494182945, 0.3655903408730825, 0.6963141750488784, 0.6696712334488908, 0.7625598400275435, 0.7089948348145116, 0.8622978723886344]}}
{"id": "7fb9712b-c319-4cd6-a1d8-f9fdf5fbbf29", "fitness": 0.663111066052054, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by adjusting memory size and dynamically updating pitch adjustment rate for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(40, dim * 3)  # Adjusted memory size to improve exploration\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.5 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Increased adaptive par for better balance\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 58, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.66 with standard deviation 0.07.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.754487826966556, 0.6429347303477914, 0.6882587408844983, 0.5712224120421912, 0.5369096772846563, 0.6229857778652028, 0.7446321034449084, 0.6808630647187961, 0.7257052609138868]}}
{"id": "347dc268-b9b5-4884-b611-c8a48ebac755", "fitness": 0.8168223284530026, "name": "AdaptiveHarmonySearch", "description": "Fine-tune dynamic bandwidth adjustment by introducing exponential decay for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * np.exp(-(np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Exponential decay for dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 59, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82 with standard deviation 0.04.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8168365565908153, 0.8074863256842244, 0.8083850941246934, 0.7977996063808325, 0.7440928235216588, 0.8210682558228944, 0.8204555381295275, 0.8796655426829737, 0.8556112131394036]}}
{"id": "17e0b712-2058-45d7-82a6-e3d59b543d8f", "fitness": 0.7414378648970575, "name": "AdaptiveHarmonySearch", "description": "Introduce a dynamic memory strategy with adaptive parameters for improved convergence in Adaptive Harmony Search.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.4  # Slightly reduced pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.4 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        elif np.random.rand() < 0.1:  # Introduce new harmony with a small probability\n            idx_to_replace = np.random.randint(0, self.memory_size)\n            self.memory[idx_to_replace] = new_harmony\n            self.memory_fitness[idx_to_replace] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.74 with standard deviation 0.09.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7188323898135743, 0.8170170776058703, 0.7627245019232756, 0.6763396098561327, 0.7432061601859632, 0.5522277235496379, 0.8188773657091557, 0.8557528378796704, 0.7279631175502375]}}
{"id": "28849979-5611-49bc-9944-8d68b74a1541", "fitness": 0.6134089262419373, "name": "AdaptiveHarmonySearch", "description": "Improve Adaptive Harmony Search by integrating a dynamic learning rate for enhanced adaptation and convergence efficiency.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  \n        self.hmcr = 0.9\n        self.par = 0.45 \n        self.bw = 0.02  \n        self.lr = 0.1  # Learning rate for adaptation\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) \n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n                new_harmony[i] += self.lr * (np.random.uniform(self.lower_bound, self.upper_bound) - new_harmony[i])  # Learning adaptation\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n            self.lr = max(0.01, self.lr * 0.99)  # Adjust learning rate \n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 61, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.61 with standard deviation 0.11.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.6833196640959184, 0.4629442115657263, 0.5967443124631856, 0.45569052178378555, 0.589520209576757, 0.5343255686184603, 0.7385237587951441, 0.6703617075544688, 0.789250381723989]}}
{"id": "1ad0af0a-8980-4034-ac6b-bc70e0b312ed", "fitness": 0.7056347092043677, "name": "AdaptiveHarmonySearch", "description": "Further refine Adaptive Harmony Search by dynamically adjusting harmony memory consideration rate and utilizing fitness diversity.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            self.hmcr = 0.9 + 0.1 * (1 - np.std(self.memory_fitness) / (np.mean(self.memory_fitness) + 1e-6))  # Dynamic HMCR\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 62, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.71 with standard deviation 0.22.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7874734136661106, 0.7211856847771615, 0.8346399726949844, 0.7078567769410119, 0.09086786659321466, 0.7171801376629582, 0.7829103967578248, 0.8758530466225309, 0.8327450871235123]}}
{"id": "9cec36da-96c4-4e94-ab70-5b47af6a02eb", "fitness": 0.7758829992509669, "name": "AdaptiveHarmonySearch", "description": "Refine the tuning of the pitch adjustment rate and dynamic bandwidth for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.50 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 63, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.07.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8258801708426992, 0.7033445747586706, 0.7000195850676467, 0.775028693433876, 0.73358022683059, 0.709796712171158, 0.8532440151579652, 0.8994986582780282, 0.7825543567180678]}}
{"id": "8b37ddb6-df14-429e-a5c6-c00aa7ee1ed4", "fitness": 0.828238047575507, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by integrating elitism and adaptive memory consideration for enhanced convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        best_idx = np.argmin(self.memory_fitness)  # Elitism: Keep track of the best\n        return self.memory[best_idx], self.memory_fitness[best_idx]\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n        \n        best_harmony, best_fitness = None, float('inf')  # Initialize best solution tracking\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            _, current_best_fitness = self.update_memory(new_harmony, new_fitness)\n            \n            if current_best_fitness < best_fitness:  # Update if a better solution is found\n                best_harmony = self.memory[np.argmin(self.memory_fitness)]\n                best_fitness = current_best_fitness\n\n        return best_harmony, best_fitness", "configspace": "", "generation": 64, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.790877209732082, 0.8154462093031137, 0.8313381018677903, 0.8041579173970607, 0.7923389165796413, 0.8547970208972331, 0.8484339661133771, 0.8585399758044696, 0.8582131104847954]}}
{"id": "5a5182eb-64d1-43c5-90d4-05f1b62c2bce", "fitness": 0.7716612137651431, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by introducing a stochastic memory consideration rate to enhance diversity.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        # Introduced stochastic adjustment to memory consideration rate\n        current_hmcr = self.hmcr * np.random.uniform(0.95, 1.05)\n        for i in range(self.dim):\n            if np.random.rand() < current_hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 65, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.04.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8044485044823005, 0.7307148953253966, 0.7395978696958366, 0.7417396019918328, 0.7240002876499263, 0.7546001542075564, 0.7803737833766515, 0.8424482803863325, 0.8270275467704546]}}
{"id": "ffc678b8-c8cb-41d5-8824-6f99b4a6b9c2", "fitness": 0.828238047575507, "name": "AdaptiveHarmonySearch", "description": "Fine-tune the pitch adjustment rate to dynamically enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 66, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.790877209732082, 0.8154462093031137, 0.8313381018677903, 0.8041579173970607, 0.7923389165796413, 0.8547970208972331, 0.8484339661133771, 0.8585399758044696, 0.8582131104847954]}}
{"id": "7409a74a-f996-4704-a340-b8cb1bfbac21", "fitness": 0.8157026840133089, "name": "AdaptiveHarmonySearch", "description": "Enhance pitch adjustment rate to decrease linearly over evaluations for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    # Adjust par to decrease linearly over evaluations\n                    self.par = 0.45 * (1 - ((np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)) + ((self.budget - 1) / self.budget)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 67, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82 with standard deviation 0.08.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7015230101196752, 0.8822308552624317, 0.878145734663803, 0.6654690971196711, 0.8469738193484833, 0.8448722438308494, 0.7967099877309132, 0.8486390756064945, 0.8767603324374591]}}
{"id": "95f59c9c-922e-4b70-81f3-25a5877923bf", "fitness": 0.7861996480696312, "name": "AdaptiveHarmonySearch", "description": "Improve Adaptive Harmony Search by incorporating memory-based diversity and enhanced dynamic parameter adaptation for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45  \n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.2:  # Encourage diversity\n            random_idx = np.random.randint(0, self.memory_size)\n            new_harmony += 0.1 * (self.memory[random_idx] - new_harmony)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 68, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7728938672630365, 0.7905472130780491, 0.7861550739692988, 0.68949255325495, 0.7815690844669182, 0.7332874660904898, 0.8744188192075634, 0.8317427342359714, 0.8156900210604024]}}
{"id": "a31e8751-fa0b-4359-bd6c-e90c1c29e2ad", "fitness": 0.07335130285207998, "name": "AdaptiveHarmonySearch", "description": "Further refine Adaptive Harmony Search by dynamically adjusting memory consideration rate and introducing global-best harmony influence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        best_harmony = self.memory[np.argmin(self.memory_fitness)]\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n                self.hmcr *= (1 + 0.1 * np.random.uniform(-1, 1))  # Dynamic hmcr adjustment\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            new_harmony[i] += 0.1 * (best_harmony[i] - new_harmony[i])  # Influence of global best\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 69, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.06672305068602924, 0.06807462873766568, 0.10824084868177819, 0.05824576326333675, 0.06411395745522319, 0.06146968843441891, 0.07068738881786862, 0.0915406678299292, 0.07106573176247011]}}
{"id": "a5b521ce-6e74-4492-933b-8efb37abf1be", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Enhanced Adaptive Harmony Search by introducing a temperature-based pitch adjustment rate for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    temperature = 1.0 - (evaluations / self.budget)  # Temperature decay\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * temperature\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 70, "feedback": "An exception occurred: NameError(\"name 'evaluations' is not defined\").", "error": "NameError(\"name 'evaluations' is not defined\")", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "950e128e-5048-4be9-9555-23c3ec093b8a", "fitness": 0.787464779658402, "name": "AdaptiveHarmonySearch", "description": "Further refine Adaptive Harmony Search by implementing dynamic adjustment of HMCR based on fitness variance to balance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        fitness_variance = np.var(self.memory_fitness)  # New line for dynamic HMCR adjustment\n        self.hmcr = 0.9 * (1 - fitness_variance / (np.mean(self.memory_fitness) + 1e-6))  # Adjust HMCR based on variance\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 71, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8200486006384151, 0.8208152859795042, 0.7192159669347156, 0.756190160917443, 0.7781731094618345, 0.6887342556577367, 0.8224482072082592, 0.8483730271936926, 0.8331844029340165]}}
{"id": "9a45b388-a06f-493d-a4ca-efaceb251737", "fitness": 0.700074298910155, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by adding local search to the best harmony for enhanced exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n            # Local search on the best harmony\n            best_idx = np.argmin(self.memory_fitness)\n            best_harmony = self.memory[best_idx]\n            local_harmony = best_harmony + np.random.normal(0, 0.01, self.dim)  # Local exploration\n            local_harmony = np.clip(local_harmony, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_harmony)\n            evaluations += 1\n            if local_fitness < self.memory_fitness[best_idx]:\n                self.memory[best_idx] = local_harmony\n                self.memory_fitness[best_idx] = local_fitness\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 72, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.70 with standard deviation 0.08.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.6773229602084087, 0.5832586288125401, 0.7173064897881337, 0.6260671835015781, 0.5994334677278151, 0.679733844186225, 0.8153749817626144, 0.788102332338114, 0.8140688018659663]}}
{"id": "3f47bf7e-fb91-4c0d-a890-8eb1d5da9556", "fitness": 0.06393648321390585, "name": "AdaptiveHarmonySearch", "description": "Adaptive Harmony Search with improved memory updating by introducing elitism to enhance convergence rate.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        best_idx = np.argmin(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx] and new_fitness < self.memory_fitness[best_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 73, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.05173742924328628, 0.06825975840303289, 0.05936742928158767, 0.053205071422846584, 0.0715626985091603, 0.04677777250141968, 0.062140908127726546, 0.09328490901384812, 0.06909237242224464]}}
{"id": "84d5dfee-16f0-4649-881a-4aeebdefe7f3", "fitness": 0.06202594600984336, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by adjusting the harmony memory consideration rate (HMCR) dynamically based on fitness variance for more balanced exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr * (1 - np.var(self.memory_fitness) / (np.var(self.memory_fitness) + 1e-6)):\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 74, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.062023254959299834, 0.06413092034968348, 0.05727110476109831, 0.05768199728121737, 0.05956238404176417, 0.053416309628864456, 0.06906511516134917, 0.07179804944915735, 0.06328437845615609]}}
{"id": "a025e20a-5f1e-4d45-9a68-31ad00de44ae", "fitness": 0.7930282144745567, "name": "AdaptiveHarmonySearch", "description": "Improve Adaptive Harmony Search by incorporating a non-linear pitch adjustment strategy and adaptive memory consideration.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.55 * (1 - np.tanh(np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - np.tanh(np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 75, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.04.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8109712627799897, 0.747691984508021, 0.8039651057679672, 0.7453054637163079, 0.8237818064980708, 0.7609396205538645, 0.7759660561797701, 0.778983814616469, 0.8896488156505502]}}
{"id": "1ad0b9b2-ac0a-4760-99b1-59f7b9081216", "fitness": 0.6675087957229082, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search with a self-adaptive pitch adjustment rate and dynamic memory size for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 3)  # Increased memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Self-adaptive par\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.09.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7366617909303007, 0.456647366347273, 0.6807908402988372, 0.6779890640600288, 0.5609292233688767, 0.6727310616118304, 0.7310613872146442, 0.715334296073708, 0.7754341316006754]}}
{"id": "7df023c6-0e4f-4298-b881-ab92e3ad8001", "fitness": 0.7539776830490305, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by introducing an adaptive memory consideration rate and adjusting exploration based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                fitness_variance = np.var(self.memory_fitness)\n                if np.random.rand() < self.par * fitness_variance:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 77, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.22.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7994351943317339, 0.803242741516019, 0.8098303520525313, 0.1348865115924358, 0.8460258443247972, 0.832173305190222, 0.8344101967823283, 0.8933451496122026, 0.832449852039003]}}
{"id": "fc368b8e-5263-40e4-be70-5116184bb65b", "fitness": 0.06558791615932119, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by introducing an adaptive memory consideration rate and dynamically adjusting pitch adjustment rate and bandwidth for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n        self.hmcr_decay = 0.95  # Introduce decay for harmony memory consideration rate\n        self.dynamic_par = True  # Enable dynamic pitch adjustment\n        self.dynamic_bw = True  # Enable dynamic bandwidth\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    if self.dynamic_par:\n                        self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    if self.dynamic_bw:\n                        bw_dynamic = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                        new_harmony[i] += np.random.uniform(-bw_dynamic, bw_dynamic)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n        self.hmcr *= self.hmcr_decay  # Decay harmony memory consideration rate\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 78, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.06312942645222863, 0.06170567575861774, 0.08316310628824297, 0.05556240521608402, 0.06109415687022701, 0.055764793028065696, 0.07222521832785989, 0.06513081788979824, 0.07251564560276658]}}
{"id": "eaf99705-ae1d-4831-bae0-7b0bff4b2cd0", "fitness": 0.821571325228358, "name": "AdaptiveHarmonySearch", "description": "Refine pitch adjustment and dynamic bandwidth to be more adaptive based on fitness variance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                fitness_variance = np.var(self.memory_fitness)\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - fitness_variance) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 79, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.82 with standard deviation 0.04.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7807241825737136, 0.7975937946815362, 0.8035199782604838, 0.810972038967186, 0.7471075351431177, 0.8462995386779755, 0.8648321335637341, 0.8592511042170862, 0.8838416209703888]}}
{"id": "c39c87a8-ea49-4721-8a4e-11119e771b72", "fitness": 0.7951336382590641, "name": "AdaptiveHarmonySearch", "description": "Introduce an adaptive memory size scaling factor to balance exploration and exploitation in Adaptive Harmony Search.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, int(dim * 2 * 0.98))  # Changed line: Adaptive scaling factor for memory size\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 80, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.06.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7396626361899723, 0.8526698613624287, 0.795334057087679, 0.7530107688146044, 0.6868775929594613, 0.8138183730451187, 0.7753632726813441, 0.8918475126437813, 0.8476186695471871]}}
{"id": "c9d81a1d-a4bd-4593-a236-8df70b752b98", "fitness": 0.6038831333854418, "name": "AdaptiveHarmonySearch", "description": "Further enhance exploration by introducing a dynamic adjustment to `hmcr` based on fitness diversity.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            self.hmcr = 0.9 * (1 - np.std(self.memory_fitness) / (np.mean(self.memory_fitness) + 1e-6))  # Dynamic hmcr\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 81, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.60 with standard deviation 0.14.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7055609561279366, 0.5347573917616577, 0.5421698657152811, 0.48559704503074796, 0.4912468972184848, 0.39785889761105275, 0.842105998148231, 0.7011965318013222, 0.7344546170542621]}}
{"id": "bd066af9-12ce-4b26-b9a5-b956498d7d77", "fitness": 0.8047004462008039, "name": "AdaptiveHarmonySearch", "description": "Improve exploration by introducing memory diversity based on fitness variance and adaptive bandwidth.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        fitness_variance = np.var(self.memory_fitness) # New line: Calculate fitness variance\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) + fitness_variance * 0.01 # Modified line: Adjust dynamic bandwidth with fitness variance\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 82, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.782718093643856, 0.8382406994134937, 0.7969409278199522, 0.7731766012787279, 0.7846964833371834, 0.6998089365619773, 0.8564523036517104, 0.8146661829769131, 0.895603787123422]}}
{"id": "650ac7ce-07e8-4c40-aa58-3ff54f925ea9", "fitness": 0.7967237065799665, "name": "AdaptiveHarmonySearch", "description": "Introduce a momentum factor to the pitch adjustment rate to enhance convergence speed.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    # Introduce momentum to the pitch adjustment rate\n                    momentum = 0.5 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    self.par = 0.45 * momentum # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 83, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.07.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8386828095858863, 0.8204861901682023, 0.7807857164599905, 0.815135990145944, 0.821081240219975, 0.8149538964860851, 0.6223560820392597, 0.8662031571263749, 0.7908282769879807]}}
{"id": "0c9bbbb4-4351-4c32-bf2a-52b81b750585", "fitness": 0.7846291588811224, "name": "AdaptiveHarmonySearch", "description": "Fine-tune pitch adjustment rate initialization and introduce decay to enhance solution refinement.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.5  # Slight increment in initial pitch adjustment rate\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    # Introducing decay in pitch adjustment rate\n                    self.par = 0.5 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * (self.budget - self.memory_size) / self.budget\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 84, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.78 with standard deviation 0.05.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8176040881022317, 0.7327572186574245, 0.7377684901896515, 0.7477525796263458, 0.7124294109933034, 0.801415877960591, 0.8277503481953506, 0.8565856978992724, 0.8275987183059307]}}
{"id": "94ab7da6-a9ca-4b23-9d95-e9dd18a38663", "fitness": 0.7693983500134977, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by introducing a dynamic memory size scaling with budget and an adaptive pitch adjustment rate based on harmony diversity.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, int(dim * (budget / 1000)))  # Dynamic memory size scaling with budget\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.var(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adapt par based on harmony diversity\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 85, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.04.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7970992962376, 0.758600939245742, 0.7864543724811166, 0.687950662794152, 0.7749342575751188, 0.7365952998512051, 0.772997080822295, 0.805787865416714, 0.8041653756975354]}}
{"id": "498ab4c3-67bb-4a4c-a728-c35800894e4e", "fitness": -Infinity, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search with stochastic pitch adjustment and adaptive memory consideration for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n                if np.random.rand() < 0.2:  # Introduce stochastic element\n                    new_harmony[i] = np.random.uniform(-dynamic_bw, dynamic_bw)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness * (0.95 + 0.1 * np.random.rand())  # Adaptive memory consideration\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 86, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'dynamic_bw' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'dynamic_bw' referenced before assignment\")", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {}}
{"id": "cfaeceac-8ad9-46c2-92c5-62da2ea2b6fe", "fitness": 0.07124044579340415, "name": "AdaptiveHarmonySearch", "description": "Modify the initialization strategy and refine memory update to enhance exploration and convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        bound_range = self.upper_bound - self.lower_bound\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim)) + \\\n                      np.random.uniform(-0.1 * bound_range, 0.1 * bound_range, (self.memory_size, self.dim))  # Modified initialization\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            replacement_idx = np.random.randint(0, self.memory_size)  # Refined memory update with random replacement\n            self.memory[replacement_idx] = new_harmony\n            self.memory_fitness[replacement_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 87, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.07321850090661275, 0.05665459257628025, 0.08151469622208585, 0.05587665766940697, 0.0684882243815288, 0.06980985892047531, 0.08116127889938918, 0.07551884603376813, 0.07892135653109011]}}
{"id": "fb35ee25-d0b6-47ab-a710-d8d802cfb00d", "fitness": 0.7482111516521965, "name": "AdaptiveHarmonySearch", "description": "Improve exploration by enhancing dynamic bandwidth calculation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * np.random.rand() # Dynamic bandwidth with extra randomness\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 88, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.75 with standard deviation 0.09.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7589416635401756, 0.7415154229421714, 0.8512628577071191, 0.6164571808201205, 0.7072517413330031, 0.7685173920277952, 0.6081689313194918, 0.8425756402751825, 0.8392095349047104]}}
{"id": "07632c4f-ea41-4b72-838d-c4955f55fb43", "fitness": 0.7686105205134407, "name": "AdaptiveHarmonySearch", "description": "Adjusted harmony memory consideration rate for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.85  # Adjusted harmony memory consideration rate\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 89, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.77 with standard deviation 0.08.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8327975815926114, 0.7197351676240764, 0.8359249094210599, 0.7882675569860791, 0.6125295884297206, 0.710161776928431, 0.770621457268374, 0.7638625937684504, 0.8835940526021641]}}
{"id": "933de88b-ec54-4fd9-8198-1c1846ffad3c", "fitness": 0.8051344194026208, "name": "AdaptiveHarmonySearch", "description": "Fine-tune the Harmony Search algorithm by adjusting the dynamic bandwidth for enhanced global search capabilities.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) * 1.05 # Slightly increase dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 90, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.07.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8503016560694561, 0.6656723307071379, 0.8103894512628622, 0.8223909046299502, 0.8283887045474843, 0.7104830843347286, 0.8226041803978881, 0.8746806129622363, 0.8612988497118435]}}
{"id": "f9d4bfea-0ea9-44ae-b0f1-7dd26a0be888", "fitness": 0.8117084523746847, "name": "AdaptiveHarmonySearch", "description": "Further enhance pitch adjustment rate adaptively by basing it on both memory fitness diversity and a constant factor.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - 0.5 * (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Adjust par\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 91, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.04.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8236185989132682, 0.8186676835231762, 0.7820448580562661, 0.8328080852356732, 0.7331283474770546, 0.775043890515264, 0.8030368700203778, 0.8501170608697164, 0.8869106767613657]}}
{"id": "ac987798-abd5-44bc-95f6-681ac87cbefe", "fitness": 0.12797640798984147, "name": "AdaptiveHarmonySearch", "description": "Enhance Adaptive Harmony Search by introducing a dynamic harmony memory consideration rate (HMCR) for better adaptability.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))):  # Dynamic HMCR\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 92, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.11.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.06655800352550634, 0.08022559104286997, 0.3698001096279573, 0.0654022793681932, 0.06084329825613999, 0.062484389289673814, 0.08415042609602863, 0.08876563337625731, 0.2735579413259469]}}
{"id": "d65c2e7f-af67-45b7-852b-40e0ab3eda50", "fitness": 0.7892610975741661, "name": "AdaptiveHarmonySearch", "description": "Fine-tune exploration by adapting the pitch adjustment rate based on memory fitness variance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.var(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Adjust par based on variance\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 93, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.79 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.7719968444346936, 0.7771785095544661, 0.781039753088693, 0.7738818174439861, 0.7661129539464486, 0.7951539545255574, 0.8264465931534587, 0.7439540038254931, 0.8675854481946981]}}
{"id": "2479a3de-f7f9-4957-bd8f-270652225fc2", "fitness": 0.8058878275944413, "name": "AdaptiveHarmonySearch", "description": "Further refine Adaptive Harmony Search by introducing dynamic memory size and improved initialization for enhanced diversification.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2) + np.random.randint(-5, 5)  # Dynamic memory size\n        self.hmcr = 0.9\n        self.par = 0.45\n        self.bw = 0.02\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))  # Improved initialization\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 94, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.81 with standard deviation 0.04.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.868550175404341, 0.7721196539341015, 0.7678631367567824, 0.7838499137864287, 0.7396198167608697, 0.7834879362149088, 0.8625791648687777, 0.8171399115339502, 0.8577807390898124]}}
{"id": "092682b8-744a-4898-b596-f979a4c6080d", "fitness": 0.12797640798984147, "name": "AdaptiveHarmonySearch", "description": "Further enhance exploration by modifying harmony memory consideration rate dynamically based on convergence.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            self.hmcr = 0.9 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Dynamic HMCR\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 95, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.11.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.06655800352550634, 0.08022559104286997, 0.3698001096279573, 0.0654022793681932, 0.06084329825613999, 0.062484389289673814, 0.08415042609602863, 0.08876563337625731, 0.2735579413259469]}}
{"id": "99364f71-68c6-4269-895c-4db3c66cbe54", "fitness": 0.1509643525547044, "name": "AdaptiveHarmonySearch", "description": "Further enhance Adaptive Harmony Search by dynamically adjusting both hmcr and par for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                self.hmcr = 0.9 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6)))  # Dynamic hmcr\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 96, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.21.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.06871803821688915, 0.06997708500053368, 0.06815705789011306, 0.06471359459279835, 0.06566770686074841, 0.06593382188034469, 0.07475470693909025, 0.132938739282063, 0.7478184223297589]}}
{"id": "3a2fef83-a78a-4bb0-818e-ddebcf65af88", "fitness": 0.6732764164746187, "name": "AdaptiveHarmonySearch", "description": "Further optimize exploration by dynamically adjusting harmony memory consideration rate and bandwidth.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n            self.hmcr = 0.7 + 0.3 * (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))  # Dynamic HMCR\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 97, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.67 with standard deviation 0.06.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.6329178938849971, 0.6198139445258724, 0.6432560671054, 0.5887779768830848, 0.7377406091341359, 0.7197016314876858, 0.6501524946073491, 0.7947576191216659, 0.6723695115213779]}}
{"id": "13360852-0dbd-4a34-9ed9-4cd4411b0974", "fitness": 0.798970824783116, "name": "AdaptiveHarmonySearch", "description": "Further optimize Adaptive Harmony Search by modifying memory initialization to enhance early-stage exploration.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        random_indices = np.random.choice(np.arange(self.memory_size), size=int(self.memory_size * 0.1), replace=False)\n        self.memory[random_indices] = np.random.uniform(self.lower_bound * 2, self.upper_bound * 2, (len(random_indices), self.dim))\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 98, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.80 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.8003107822636103, 0.7979115593333294, 0.8020893091444076, 0.7625609711313197, 0.8643572625861025, 0.7388692339151527, 0.828405577490755, 0.789079008828355, 0.8071537183550113]}}
{"id": "95779650-9cfa-4a43-8e2b-78d15e6ba933", "fitness": 0.828238047575507, "name": "AdaptiveHarmonySearch", "description": "Refine Adaptive Harmony Search by dynamically adjusting harmony memory size based on convergence rate for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.memory_size = max(30, dim * 2)  # Adaptive memory size based on dimension\n        self.hmcr = 0.9\n        self.par = 0.45  # Increased pitch adjustment rate\n        self.bw = 0.02  # Increased bandwidth\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.memory_size, self.dim))\n        self.memory_fitness = None\n\n    def initialize_memory(self, func):\n        self.memory_fitness = np.apply_along_axis(func, 1, self.memory)\n\n    def generate_new_harmony(self):\n        new_harmony = np.zeros(self.dim)\n        for i in range(self.dim):\n            if np.random.rand() < self.hmcr:\n                idx = np.random.randint(0, self.memory_size)\n                new_harmony[i] = self.memory[idx, i]\n                if np.random.rand() < self.par:\n                    self.par = 0.45 * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Adjust par to avoid divide by zero\n                    dynamic_bw = self.bw * (1 - (np.min(self.memory_fitness) / (np.max(self.memory_fitness) + 1e-6))) # Dynamic bandwidth\n                    new_harmony[i] += np.random.uniform(-dynamic_bw, dynamic_bw)\n            else:\n                new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n        new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n        return new_harmony\n\n    def update_memory(self, new_harmony, new_fitness):\n        worst_idx = np.argmax(self.memory_fitness)\n        if new_fitness < self.memory_fitness[worst_idx]:\n            self.memory[worst_idx] = new_harmony\n            self.memory_fitness[worst_idx] = new_fitness\n            self.memory_size = min(max(30, self.dim * 2), self.memory_size + 1)  # Dynamically increase memory size\n\n    def __call__(self, func):\n        self.initialize_memory(func)\n        evaluations = self.memory_size\n\n        while evaluations < self.budget:\n            new_harmony = self.generate_new_harmony()\n            new_fitness = func(new_harmony)\n            evaluations += 1\n            self.update_memory(new_harmony, new_fitness)\n\n        best_idx = np.argmin(self.memory_fitness)\n        return self.memory[best_idx], self.memory_fitness[best_idx]", "configspace": "", "generation": 99, "feedback": "The algorithm AdaptiveHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.83 with standard deviation 0.03.", "error": "", "parent_ids": ["517209ff-4c71-4138-8a16-c5ba69b477e9"], "operator": null, "metadata": {"aucs": [0.790877209732082, 0.8154462093031137, 0.8313381018677903, 0.8041579173970607, 0.7923389165796413, 0.8547970208972331, 0.8484339661133771, 0.8585399758044696, 0.8582131104847954]}}
