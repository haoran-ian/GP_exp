{"role": "client", "time": "2025-12-05 18:00:09.232305", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:00:31.523281", "content": "# Description: A diversity-enhanced Particle Swarm Optimization (PSO) algorithm with dynamic topology that adapts to the problem landscape for improved exploration and exploitation.\n\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 3\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.5 + np.random.rand() / 2\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:00:40.703749", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: A diversity-enhanced Particle Swarm Optimization (PSO) algorithm with dynamic topology that adapts to the problem landscape for improved exploration and exploitation. (Score: 0.07289932477960523)\n\nThe selected solution to update is:\nA diversity-enhanced Particle Swarm Optimization (PSO) algorithm with dynamic topology that adapts to the problem landscape for improved exploration and exploitation.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 3\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.5 + np.random.rand() / 2\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.6129032258064515 lines, and the rest of the lines should remain unchanged. This input code has 62 lines, so you can only change 1 lines, the rest 61 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:00:59.366785", "content": "# Description: Slightly modified DynamicTopologyPSO with increased neighborhood size for enhanced exploration. \n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.5 + np.random.rand() / 2\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:01:08.560073", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Slightly modified DynamicTopologyPSO with increased neighborhood size for enhanced exploration.  (Score: 0.07643267855159347)\n\nThe selected solution to update is:\nSlightly modified DynamicTopologyPSO with increased neighborhood size for enhanced exploration. \n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.5 + np.random.rand() / 2\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.6129032258064515 lines, and the rest of the lines should remain unchanged. This input code has 62 lines, so you can only change 1 lines, the rest 61 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:01:17.741161", "content": "# Description: Enhanced particle velocity update with an adaptive inertia weight based on global convergence.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            # Adaptive inertia weight based on global convergence\n            inertia_weight = 0.5 + (self.global_best_value / (self.global_best_value + np.random.rand()))\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:01:26.949437", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Slightly modified DynamicTopologyPSO with increased neighborhood size for enhanced exploration.  (Score: 0.07643267855159347)\n\nThe selected solution to update is:\nSlightly modified DynamicTopologyPSO with increased neighborhood size for enhanced exploration. \n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.5 + np.random.rand() / 2\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.6129032258064515 lines, and the rest of the lines should remain unchanged. This input code has 62 lines, so you can only change 1 lines, the rest 61 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:01:38.734309", "content": "# Description: Enhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:01:47.825172", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Enhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO. (Score: 0.07896001611804768)\n\nThe selected solution to update is:\nEnhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.6129032258064515 lines, and the rest of the lines should remain unchanged. This input code has 62 lines, so you can only change 1 lines, the rest 61 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:01:54.921011", "content": "# Description: Introduced linearly decreasing inertia weight for DynamicTopologyPSO to enhance exploration-exploitation balance.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.9 - (0.5 * self.function_evaluations / self.budget)  # Changed line: Linearly decreasing inertia weight\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:02:04.195180", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Enhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO. (Score: 0.07896001611804768)\n\nThe selected solution to update is:\nEnhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 3.2% of the code, which means if the code has 100 lines, you can only change 3.225806451612903 lines, and the rest of the lines should remain unchanged. This input code has 62 lines, so you can only change 2 lines, the rest 60 lines should remain unchanged. This changing rate 3.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:02:12.055803", "content": "# Description: Introduced dynamic cognitive and social weights to enhance convergence in DynamicTopologyPSO.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5\n            cognitive_component = (1.5 + np.random.rand() / 2) * (self.personal_best_positions[i] - self.positions[i])  # Changed line\n            social_component = (1.5 + np.random.rand() / 2) * (neighborhood_best_position - self.positions[i])  # Changed line\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:02:21.170798", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Enhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO. (Score: 0.07896001611804768)\n\nThe selected solution to update is:\nEnhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.6129032258064515 lines, and the rest of the lines should remain unchanged. This input code has 62 lines, so you can only change 1 lines, the rest 61 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:02:27.044320", "content": "# Description: Introduced randomness in the social component's influence for enhanced exploration in DynamicTopologyPSO.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.uniform(0.5, 1.5) * (neighborhood_best_position - self.positions[i])  # Changed line: Introduced randomness in social influence\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:02:36.386687", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Enhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO. (Score: 0.07896001611804768)\n\nThe selected solution to update is:\nEnhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.6129032258064515 lines, and the rest of the lines should remain unchanged. This input code has 62 lines, so you can only change 1 lines, the rest 61 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:02:44.711354", "content": "# Description: Introduced dynamic neighborhood size adaptation for improved exploration and exploitation balance in DynamicTopologyPSO.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Changed line: Dynamic neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    min(self.neighborhood_size, self.function_evaluations // 10 + 1), \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5 \n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:02:53.895736", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Enhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO. (Score: 0.07896001611804768)\n\nThe selected solution to update is:\nEnhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.6129032258064515 lines, and the rest of the lines should remain unchanged. This input code has 62 lines, so you can only change 1 lines, the rest 61 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:03:02.873478", "content": "# Description: Introduce a dynamic neighborhood size strategy to adaptively adjust based on progress.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:03:12.223352", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a dynamic neighborhood size strategy to adaptively adjust based on progress. (Score: 0.07926473027637472)\n\nThe selected solution to update is:\nIntroduce a dynamic neighborhood size strategy to adaptively adjust based on progress.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5873015873015872 lines, and the rest of the lines should remain unchanged. This input code has 63 lines, so you can only change 1 lines, the rest 62 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:03:20.863791", "content": "# Description: Enhance velocity update by introducing a dynamic social component adjustment based on function evaluations.\n\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i]) * (self.function_evaluations / self.budget)  # Modified social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:03:30.143177", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a dynamic neighborhood size strategy to adaptively adjust based on progress. (Score: 0.07926473027637472)\n\nThe selected solution to update is:\nIntroduce a dynamic neighborhood size strategy to adaptively adjust based on progress.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5873015873015872 lines, and the rest of the lines should remain unchanged. This input code has 63 lines, so you can only change 1 lines, the rest 62 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:03:41.115211", "content": "# Description: Introduce a linear decay for cognitive and social components to enhance convergence speed.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = (2 * (1 - self.function_evaluations / self.budget)) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Linear decay in cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:03:50.450014", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a dynamic neighborhood size strategy to adaptively adjust based on progress. (Score: 0.07926473027637472)\n\nThe selected solution to update is:\nIntroduce a dynamic neighborhood size strategy to adaptively adjust based on progress.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5873015873015872 lines, and the rest of the lines should remain unchanged. This input code has 63 lines, so you can only change 1 lines, the rest 62 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:03:58.538017", "content": "# Description: Refine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:04:08.496590", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Refine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed. (Score: 0.1891661093884285)\n\nThe selected solution to update is:\nRefine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:04:15.770276", "content": "# Description: Introduce a momentum component to the velocity update to enhance exploration.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            momentum = 0.9 * self.velocities[i]  # Added line: Momentum component\n            self.velocities[i] = momentum + inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:04:25.107353", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Refine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed. (Score: 0.1891661093884285)\n\nThe selected solution to update is:\nRefine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:04:35.025059", "content": "# Description: Adjust personal best update condition to consider slight increases in diversity for better global exploration.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index] * 1.02:  # Changed line: Adjust personal best with slight tolerance\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:04:44.377863", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Refine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed. (Score: 0.1891661093884285)\n\nThe selected solution to update is:\nRefine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:04:51.662125", "content": "# Description: Adjust the neighborhood size dynamically to balance exploration and exploitation more effectively.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:05:00.813005", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Refine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed. (Score: 0.1891661093884285)\n\nThe selected solution to update is:\nRefine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:05:08.490754", "content": "# Description: Introduce a small random factor to the inertia weight calculation to enhance search efficiency.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5 + 0.05 * np.random.rand()) * inertia_decay  # Changed line: Add random factor to inertia weight\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:05:17.824356", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Refine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed. (Score: 0.1891661093884285)\n\nThe selected solution to update is:\nRefine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:05:28.167107", "content": "# Description: Introduce a learning factor in the inertia weight to enhance convergence by adapting to the function landscape.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n        self.learning_factor = 0.5  # Added line: Learning factor for inertia weight adaptation\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = ((0.7 + np.random.rand() / 5) * inertia_decay) * (1.0 + self.learning_factor)  # Changed line: Enhanced inertia weight with learning factor\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:05:37.551359", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Refine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed. (Score: 0.1891661093884285)\n\nThe selected solution to update is:\nRefine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:05:44.150302", "content": "# Description: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:05:53.344392", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:06:02.133648", "content": "# Description: Introduce a non-linear scaling factor for the inertia weight to enhance balance between exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * np.sqrt(inertia_decay)  # Changed line: Non-linear scaling for inertia weight\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```\n"}
{"role": "client", "time": "2025-12-05 18:06:11.435829", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:06:22.381030", "content": "# Description: Implement a fine-tuned stochastic component to the social component for improved exploration.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.1 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Updated line: Fine-tuned social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:06:31.702710", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:06:40.010035", "content": "# Description: Transition to a more aggressive social component scaling towards the end of the budget to enhance convergence.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i]) * (1 + 0.5 * (1 - inertia_decay))  # Changed line: Increasing social influence over time\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:06:49.506601", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:06:57.119081", "content": "# Description: Introduce a parameter to dynamically adjust the social component to enhance exploration.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i]) * inertia_decay  # Changed line: Adjusted social component with decay\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:07:06.531972", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:07:16.980354", "content": "# Description: Fine-tune the social component weight to optimize exploration and exploitation balance.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.05 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Fine-tuned social component weight\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:07:26.272294", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:07:35.413102", "content": "# Description: Introduce adaptive cognitive and social coefficients for dynamic balancing between exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = (0.5 + 1.5 * (self.function_evaluations / self.budget)) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Modified line\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:07:44.805282", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:07:52.731691", "content": "# Description: Introduce a slight modification to the cognitive component to enhance local exploration.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Enhanced local exploration\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:08:01.942779", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:08:10.517706", "content": "# Description: Introduce a dynamic cognitive component scaling for enhanced individual exploration.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component_scale = 1 + 0.5 * np.sin(2 * np.pi * self.function_evaluations / self.budget)  # Changed line: Dynamic cognitive component scaling\n            cognitive_component = 2 * np.random.rand() * cognitive_component_scale * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:08:20.021846", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:08:30.048088", "content": "# Description: Adjusted the cognitive component multiplier to refine the balance between personal and neighborhood influence.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component multiplier\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:08:39.235027", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:08:48.562293", "content": "# Description: Enhance the PSO by introducing a mild modification to the mutation strategy for improved exploration.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            mutation_component = 0.1 * np.random.normal(size=self.dim)  # Added line: Mutation for exploration\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component + mutation_component \n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:08:57.868751", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 4.7% of the code, which means if the code has 100 lines, you can only change 4.6875 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 3 lines, the rest 61 lines should remain unchanged. This changing rate 4.7% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:09:05.154014", "content": "# Description: Incorporate a learning rate decay to adjust velocity updates dynamically for improved convergence.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        learning_rate_decay = 0.5 + 0.5 * (1 - (self.function_evaluations / self.budget))  # Added line\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = learning_rate_decay * (inertia_weight * self.velocities[i] + cognitive_component + social_component)  # Modified line\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:09:14.462085", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:09:34.816681", "content": "# Description: Adjust the cognitive component's influence by scaling it with the inertia_decay factor for improved exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i]) * inertia_decay  # Changed line: Scaled cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:09:44.077793", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:09:51.726585", "content": "# Description: Refine the Dynamic Topology PSO by incorporating a dynamic social component factor to enhance adaptability in diverse search landscapes.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * (0.5 + np.random.rand() / 2) * (neighborhood_best_position - self.positions[i])  # Changed line: Dynamic social component factor\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:10:00.881439", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:10:08.148034", "content": "# Description: Enhance global exploration by slightly increasing the cognitive component's influence in the velocity update formula.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Slightly increased factor\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:10:17.182528", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:10:24.798643", "content": "# Description: Fine-tune the cognitive and social component coefficients to enhance convergence stability.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Fine-tuned cognitive component coefficient\n            social_component = 1.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Fine-tuned social component coefficient\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:10:34.049556", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:10:42.348097", "content": "# Description: Use a more dynamic inertia weight adjustment by incorporating an exponential decay function for better convergence reflexes.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = np.exp(-self.function_evaluations / (0.1 * self.budget))  # Changed line: Exponential decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:10:51.611042", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:11:00.750235", "content": "# Description: Enhance velocity update by increasing cognitive component influence to refine search space exploration.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component coefficient\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:11:10.053301", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:11:18.020592", "content": "# Description: Adjust the cognitive component scaling factor to enhance the exploration phase in the early stage.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted cognitive component scaling\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:11:27.288498", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:11:35.566395", "content": "# Description: Fine-tune the cognitive component range to enhance exploration and convergence properties.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.05 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component range\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:11:44.743255", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:11:54.202681", "content": "# Description: Introduce adaptive learning factors to enhance convergence and exploration balance.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_factor = 2 * (1 - self.function_evaluations / self.budget)  # Changed line: Adaptive learning factor\n            cognitive_component = cognitive_factor * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```\n"}
{"role": "client", "time": "2025-12-05 18:12:03.511784", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:12:09.709516", "content": "# Description: Adjusted learning factor for social component to improve swarm convergence.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 1.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Adjusted learning factor for social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:12:18.987319", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:12:25.049957", "content": "# Description: Adjust the inertia weight calculation for enhanced balance between exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = 0.7 * inertia_decay + np.random.rand() * 0.1  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:12:34.355319", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:12:45.806844", "content": "# Description: Slightly increase the cognitive component influence to enhance exploration dynamics.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Increased cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:12:55.066690", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:13:00.479011", "content": "# Description: Slightly tweak the inertia weight calculation to further improve convergence dynamics.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.72 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:13:09.778035", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:13:15.534675", "content": "# Description: Fine-tune the cognitive component to enhance local exploration and convergence.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Enhanced cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:13:24.640461", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:13:30.235584", "content": "# Description: Slightly adjust the cognitive component to improve convergence rate.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component multiplier\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:13:39.492335", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:13:46.005642", "content": "# Description: Adjust the cognitive component multiplier for a more balanced exploration-exploitation tradeoff.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted line: Updated cognitive component multiplier\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:13:55.180039", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:14:02.803923", "content": "# Description: Introduce a dynamic adjustment to the cognitive component to enhance exploration capabilities.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = (1.5 + np.random.rand() / 5) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Dynamic cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:14:12.299215", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:14:22.675064", "content": "# Description: Introduce adaptive learning rates for cognitive and social components to enhance exploration and exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_learning_rate = 2.5 - (2 * (self.function_evaluations / self.budget))  # Changed line\n            social_learning_rate = 0.5 + (2 * (self.function_evaluations / self.budget))  # Changed line\n            cognitive_component = cognitive_learning_rate * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line\n            social_component = social_learning_rate * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:14:31.950140", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:14:41.420523", "content": "# Description: Introduce slight random perturbations to inertia weight to escape local optima and enhance convergence.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay * (1 + 0.01 * np.random.randn())  # Changed line: Introduced small random perturbations\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:14:50.826809", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:15:02.711314", "content": "# Description: Introduce stochastic oscillations in velocity adjustment to enhance exploration capabilities.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            random_oscillation = np.random.uniform(-0.1, 0.1, self.dim)  # Added line: Stochastic oscillation to velocities\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component + random_oscillation  # Modified line: Apply oscillation\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:15:12.220466", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:15:21.217626", "content": "# Description: Introduced an adaptive cognitive component scalar for improved convergence dynamics.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_scalar = 1.5 + np.random.rand() / 2  # Changed line: Adaptive cognitive component scalar\n            cognitive_component = cognitive_scalar * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:15:30.533446", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:15:50.189949", "content": "# Description: Incorporate an adaptive cognitive component to dynamically adjust exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            adaptive_cognitive = 1.5 + 0.5 * (self.function_evaluations / self.budget)  # Modified line: Adaptive cognitive factor\n            cognitive_component = adaptive_cognitive * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:15:59.515531", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:16:08.529812", "content": "# Description: Strengthen the social component's influence by subtly increasing its scaling factor for improved convergence behavior.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.1 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Increased social component factor\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:16:17.829752", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:16:35.909856", "content": "# Description: Enhanced convergence by refining inertia weight's calculation and adjusting neighborhood dynamics.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.725 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:16:45.095373", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:16:54.588556", "content": "Certainly! Below is a refined version of the `DynamicTopologyPSO` algorithm with a minor adjustment as per your requirements.\n\n# Description: Introduce a dynamic component multiplier to enhance convergence rates by slightly adjusting the acceleration coefficients.\n\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            dynamic_component_multiplier = 1 + 0.1 * np.sin(self.function_evaluations / self.budget * np.pi)  # Changed line: Added dynamic component multiplier\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + dynamic_component_multiplier * (cognitive_component + social_component)\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```\n"}
{"role": "client", "time": "2025-12-05 18:17:03.948193", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:17:14.034042", "content": "# Description: Adjust the inertia weight calculation using a more refined dynamic adjustment for improved convergence.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.72 + np.random.rand() / 10) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:17:23.299717", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:17:29.325464", "content": "# Description: Fine-tune the cognitive component by adjusting its scaling factor for better convergence.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted line: Fine-tuned cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:17:38.709650", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:17:45.901169", "content": "# Description: Enhance convergence by introducing a dynamic adjustment to cognitive and social component multipliers based on the budget.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            dynamic_multiplier = 2 * (1 - self.function_evaluations / self.budget)  # Changed line\n            cognitive_component = dynamic_multiplier * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = dynamic_multiplier * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:17:55.380737", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:18:02.771054", "content": "# Description: Increase exploration by reducing neighborhood size at start and increasing it over time.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(2 + 3 * (self.function_evaluations / self.budget)))  # Changed line: Gradually increasing neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:18:12.064055", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:18:18.766215", "content": "# Description: Introduce a time-varying acceleration coefficient to balance exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            time_varying_accel = 2.5 - (2.5 - 0.5) * (self.function_evaluations / self.budget)  # Changed line: Added time-varying acceleration coefficient\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component * time_varying_accel\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:18:28.055295", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:18:34.109782", "content": "# Description: Adjust the social component coefficient to balance exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 1.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Adjusted social component coefficient\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:18:43.419568", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:18:51.537360", "content": "# Description: Introduce a dynamic cognitive component that adapts based on progress to enhance convergence adaptability.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * (1 - inertia_decay) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Dynamic cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:19:00.870714", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:19:06.452767", "content": "# Description: Improve convergence by slightly increasing the impact of the social component.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.1 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Updated line: Slight increase in social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:19:15.699563", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:19:21.332205", "content": "# Description: Adjust the cognitive component to increase exploration diversity in early iterations.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = (1.5 + np.random.rand()) * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:19:30.797775", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:19:36.070500", "content": "# Description: Fine-tune the cognitive component scaling factor to enhance particle guidance.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.05 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Fine-tuned cognitive component scaling\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:19:45.327875", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:19:53.563607", "content": "# Description: Increase cognitive component factor to enhance exploration capability and avoid premature convergence.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Increased cognitive component factor\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:20:02.993410", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:20:08.806479", "content": "# Description: Introduce a dynamic cognitive factor adjustment to enhance exploration and exploitation balance.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * (1 - inertia_decay) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Modified line: Dynamic cognitive factor adjustment\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:20:18.037233", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:20:21.790386", "content": "# Description: Implement a more adaptive neighborhood size to enhance exploration and exploitation trade-offs.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(3 + 3 * (self.budget - self.function_evaluations) / self.budget))  # Changed line: More adaptive neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:20:31.046057", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:20:39.270239", "content": "# Description: Adjust the social component to increase exploration during the early stages of the search.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = (1.5 + 0.5 * np.random.rand()) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Increased randomness in social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:20:48.696249", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:20:55.900998", "content": "# Description: Enhanced PSO by adjusting cognitive and social components dynamically to better explore the search space.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = (1.5 + 0.5 * inertia_decay) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line\n            social_component = (1.5 + 0.5 * inertia_decay) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:21:05.212614", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:21:13.260400", "content": "# Description: Fine-tune acceleration coefficients for improved balance between exploration and exploitation.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.8 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjust cognitive coefficient\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:21:22.601093", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:21:31.455788", "content": "# Description: Fine-tune the cognitive component's influence to enhance exploration-exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component influence\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:21:40.697716", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:21:47.802672", "content": "# Description: Introduce a slight increase to the cognitive component to enhance particles' local exploration.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Increased cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:21:57.146504", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:22:03.393635", "content": "# Description: Introduce a random mutation factor to particle positions to enhance exploration capabilities.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim), self.bounds[0], self.bounds[1])  # Changed line: Random mutation factor\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:22:12.838186", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:22:19.530783", "content": "# Description: Introduce a slight adjustment to the cognitive component influence to enhance exploration and convergence.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:22:28.630784", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:22:33.264173", "content": "# Description: Fine-tune the inertia weight's initial value to enhance convergence in challenging search spaces.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.715 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:22:42.538179", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:22:51.101907", "content": "# Description: Enhance exploration by dynamically adjusting the cognitive component based on proximity to personal best.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i]) * (0.5 + 0.5 * np.linalg.norm(self.personal_best_positions[i] - self.positions[i]) / 5.0)  # Changed line: Dynamic cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:23:00.556161", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:23:09.055236", "content": "# Description: Introduce a slight adjustment to the cognitive component coefficient to fine-tune exploration and exploitation balance.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Slight adjustment to cognitive component coefficient\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:23:18.418187", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:23:25.999944", "content": "# Description: Increase exploration by introducing a slight randomness to inertia weight scaling.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay * (1 + 0.01 * np.random.randn())  # Changed line: Introduced randomness to inertia scaling\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:23:35.405937", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:23:45.572324", "content": "# Description: Enhance social learning by introducing a mutation mechanism for diversity maintenance.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            \n            # Introduce a mutation mechanism to maintain diversity\n            if np.random.rand() < 0.1:  # Mutation probability\n                self.velocities[i] += np.random.normal(0, 0.1, self.dim)\n            \n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:23:55.025284", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 4.7% of the code, which means if the code has 100 lines, you can only change 4.6875 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 3 lines, the rest 61 lines should remain unchanged. This changing rate 4.7% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:24:03.934857", "content": "# Description: Fine-tune exploration-exploitation balance by adjusting cognitive and social components adaptively.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = (1.5 + np.random.rand() / 5) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adaptive cognitive component\n            social_component = (1.5 + np.random.rand() / 5) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Adaptive social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:24:13.401692", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:24:17.504589", "content": "# Description: Fine-tune the cognitive component to enhance individual learning within each particle.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Enhanced cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:24:26.739527", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:24:34.593495", "content": "# Description: Adjusted social component weight to improve convergence in diverse problem landscapes.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Adjusted social component weight\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:24:43.904875", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:24:51.438535", "content": "# Description: Implement inertia weight exponential decay to enhance the convergence rate.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * np.exp(-self.function_evaluations / self.budget)  # Changed line: Exponential decay for inertia weight\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:25:00.773434", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:25:08.591185", "content": "# Description: Introduce adaptive cognitive weighting to enhance individual particle exploration balance.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_weight = 2 + 0.5 * np.random.rand()  # Changed line: Adaptive cognitive weighting\n            cognitive_component = cognitive_weight * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:25:17.865188", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:25:24.742598", "content": "# Description: Introduced a dynamic adjustment of cognitive and social components to enhance adaptability during optimization.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i]) * (self.function_evaluations / self.budget)  # Changed line\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i]) * ((self.budget - self.function_evaluations) / self.budget)  # Changed line\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:25:33.960528", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:25:40.015012", "content": "# Description: Fine-tune the cognitive component's impact by introducing a decay factor to enhance convergence efficiency.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_decay = (self.budget - self.function_evaluations) / (2 * self.budget)  # New line: Added decay to cognitive component\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i]) * cognitive_decay\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:25:49.271116", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:25:54.556929", "content": "# Description: Introduce a slight increase to the cognitive component scaling to enhance individual exploration.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Slight change to increase exploration\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```\n"}
{"role": "client", "time": "2025-12-05 18:26:03.827201", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:26:12.524491", "content": "# Description: Introduce an adaptive cognitive component multiplier to enhance exploration capabilities.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_multiplier = 1.5 + np.random.rand() * 0.5  # Changed line: Adaptive cognitive multiplier\n            cognitive_component = cognitive_multiplier * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:26:21.965437", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:26:29.939762", "content": "# Description: Refine inertia weight and enhance convergence by adjusting parameters and particle exploration.\n\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Adaptive decay factor\n            inertia_weight = 0.9 - 0.5 * inertia_decay  # Fine-tuned inertia weight\n            cognitive_component = 2.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted cognitive component\n            social_component = 1.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Adjusted social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:26:39.227377", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 3.1% of the code, which means if the code has 100 lines, you can only change 3.125 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 2 lines, the rest 62 lines should remain unchanged. This changing rate 3.1% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:26:47.051619", "content": "# Description: Introduce a neighborhood best velocity adjustment for improved convergence control.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            neighbor_velocity_adjust = 0.5 * (self.velocities[self.neighbors[i]].mean(axis=0) - self.velocities[i])  # Added line: Neighborhood velocity adjustment\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component + neighbor_velocity_adjust\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:26:56.798179", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:27:04.232187", "content": "# Description: Incorporate a subtle change in the inertia weight computation to further enhance convergence properties.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.72 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:27:13.603395", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:27:18.911624", "content": "# Description: Introduce a dynamic cognitive component scaling to enhance convergence precision.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + 0.5 * cognitive_component + social_component  # Changed line: Dynamic cognitive component scaling\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:27:28.133930", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:27:35.949435", "content": "# Description: Slightly adjust the cognitive component scaling to enhance exploration and exploitation balance.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted line: Cognitive component scaling\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:27:45.318095", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:27:53.232534", "content": "# Description: Fine-tune the social component influence dynamically for improved convergence.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * (1 - inertia_decay) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Adjusted line: Dynamic social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:28:02.488952", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:28:08.851362", "content": "# Description: Slightly adjust the cognitive and social components' coefficients to enhance exploration and convergence balance.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component\n            social_component = 1.8 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Adjusted social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:28:18.092672", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:28:25.358491", "content": "# Description: Enhance exploration by slightly increasing the cognitive component's influence.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Slightly increased cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:28:34.472427", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:28:42.035693", "content": "# Description: Fine-tune the balance between exploration and exploitation by adjusting cognitive and social coefficients.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive coefficient\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:28:51.454346", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:28:58.403762", "content": "# Description: Introduce a dynamic parameter for social component to improve convergence precision.\n# Code:\n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = (0.5 + np.random.rand()) * 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Dynamic social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:29:07.578935", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 6.2% of the code, which means if the code has 100 lines, you can only change 6.25 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 4 lines, the rest 60 lines should remain unchanged. This changing rate 6.2% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:29:15.519239", "content": "# Description: Enhance neighborhood influence and adaptively balance exploration and exploitation by adjusting the cognitive and social coefficients.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = (1.5 + np.random.rand() / 2) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted cognitive factor\n            social_component = (1.5 + np.random.rand() / 2) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Adjusted social factor\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
{"role": "client", "time": "2025-12-05 18:29:24.879659", "content": "You are a highly skilled computer scientist in the field of natural computing. Your task is to design novel metaheuristic algorithms to solve black box optimization problems.\nThe optimization algorithm should handle a wide range of tasks, which is evaluated on the similar problems of a real-world problem. Your task is to write the optimization algorithm in Python code. The code should contain an `__init__(self, budget, dim)` function and the function `def __call__(self, func)`, which should optimize the black box function `func` using `self.budget` function evaluations.\nThe func() can only be called as many times as the budget allows, not more. Each of the optimization functions has a search space between -5.0 (lower bound) and 5.0 (upper bound). The dimensionality can be varied.\nGive an excellent and novel heuristic algorithm to solve this task and also give it a one-line description with the main idea.\n\nThe current population of algorithms already evaluated (name, description, score) is:\nDynamicTopologyPSO: Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics. (Score: 0.2873240579031482)\n\nThe selected solution to update is:\nIntroduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.\n\nWith code:\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n\nThe algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.\n\n\n    Refine the strategy of the selected solution to improve it. Make sure you only change 1.6% of the code, which means if the code has 100 lines, you can only change 1.5625 lines, and the rest of the lines should remain unchanged. This input code has 64 lines, so you can only change 1 lines, the rest 63 lines should remain unchanged. This changing rate 1.6% is the mandatory requirement, you cannot change more or less than this rate.\n    \n\nProvide the Python code and a one-line description with the main idea (without enters). Give the response in the format:\n# Description: <short-description>\n# Code: \n```python\n<code>\n```\n\n"}
{"role": "gpt-4o", "time": "2025-12-05 18:29:34.415566", "content": "# Description: Introduce a small perturbation to the cognitive component's coefficient to enhance local exploration capability.\n# Code: \n```python\nimport numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = (2.1 + np.random.rand() * 0.1) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Perturb cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value\n```"}
