{"id": "2cc67844-f5d2-4f07-888a-bc6891cfeedb", "fitness": 0.07289932477960523, "name": "DynamicTopologyPSO", "description": "A diversity-enhanced Particle Swarm Optimization (PSO) algorithm with dynamic topology that adapts to the problem landscape for improved exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 3\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.5 + np.random.rand() / 2\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 0, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.0790435385401912, 0.05502518448164373, 0.06477396428571569, 0.07233056737182675, 0.06654283440105069, 0.06446355451124619, 0.09339933500019426, 0.08214790311513709, 0.0783670413094415]}}
{"id": "c3105afb-dd18-4f17-a644-a8652653c1e3", "fitness": 0.07643267855159347, "name": "DynamicTopologyPSO", "description": "Slightly modified DynamicTopologyPSO with increased neighborhood size for enhanced exploration. ", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.5 + np.random.rand() / 2\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 1, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2cc67844-f5d2-4f07-888a-bc6891cfeedb"], "operator": null, "metadata": {"aucs": [0.07511603663717636, 0.059914260835493116, 0.06842230715752051, 0.07934681668421373, 0.06444278746902155, 0.0663385068483896, 0.11316441276643441, 0.0795235633301109, 0.0816254152359811]}}
{"id": "cfd2b9cb-3532-4979-8dd5-ab5a3c550d4a", "fitness": 0.06040513348159663, "name": "DynamicTopologyPSO", "description": "Enhanced particle velocity update with an adaptive inertia weight based on global convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            # Adaptive inertia weight based on global convergence\n            inertia_weight = 0.5 + (self.global_best_value / (self.global_best_value + np.random.rand()))\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 2, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["c3105afb-dd18-4f17-a644-a8652653c1e3"], "operator": null, "metadata": {"aucs": [0.059302219132927214, 0.0527607461013434, 0.05849236467063368, 0.048588771895830996, 0.047999614284686354, 0.06446024229383851, 0.04677204888276465, 0.0902466896695705, 0.07502350440277439]}}
{"id": "27fdff02-d221-4397-956f-1d1016296483", "fitness": 0.07896001611804768, "name": "DynamicTopologyPSO", "description": "Enhanced inertia weight adaptation for improved convergence in DynamicTopologyPSO.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 3, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["c3105afb-dd18-4f17-a644-a8652653c1e3"], "operator": null, "metadata": {"aucs": [0.07370548749773342, 0.06511293831000287, 0.08177329422803481, 0.06956551364193175, 0.06854132720351058, 0.0713422954881413, 0.08738662865523272, 0.1107417028767137, 0.08247095716112796]}}
{"id": "8e916601-d8e1-40c5-99f4-1bd56802998d", "fitness": 0.07630937904630981, "name": "DynamicTopologyPSO", "description": "Introduced linearly decreasing inertia weight for DynamicTopologyPSO to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.9 - (0.5 * self.function_evaluations / self.budget)  # Changed line: Linearly decreasing inertia weight\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 4, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["27fdff02-d221-4397-956f-1d1016296483"], "operator": null, "metadata": {"aucs": [0.05414538086803333, 0.07692407373265187, 0.06995614530379257, 0.07001369492685205, 0.06262645216656848, 0.07908826264345747, 0.09000506882665515, 0.07753317476798183, 0.1064921581807956]}}
{"id": "554cfa10-b32f-48fe-b0a1-43bce6c52c43", "fitness": 0.04980237057806496, "name": "DynamicTopologyPSO", "description": "Introduced dynamic cognitive and social weights to enhance convergence in DynamicTopologyPSO.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5\n            cognitive_component = (1.5 + np.random.rand() / 2) * (self.personal_best_positions[i] - self.positions[i])  # Changed line\n            social_component = (1.5 + np.random.rand() / 2) * (neighborhood_best_position - self.positions[i])  # Changed line\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 5, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["27fdff02-d221-4397-956f-1d1016296483"], "operator": null, "metadata": {"aucs": [0.045091406699528935, 0.05875877931158391, 0.04452094405055307, 0.04317745270752049, 0.04996249153923005, 0.04522049829788677, 0.05008525539766695, 0.05872820973392823, 0.05267629746468627]}}
{"id": "166e6432-caea-49a2-82fc-ae9d52b259e9", "fitness": 0.05585797882756376, "name": "DynamicTopologyPSO", "description": "Introduced randomness in the social component's influence for enhanced exploration in DynamicTopologyPSO.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.uniform(0.5, 1.5) * (neighborhood_best_position - self.positions[i])  # Changed line: Introduced randomness in social influence\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 6, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["27fdff02-d221-4397-956f-1d1016296483"], "operator": null, "metadata": {"aucs": [0.04640213518958003, 0.06683201603998934, 0.05401373017551914, 0.04663221731009504, 0.05888144749429636, 0.046792585482708704, 0.05056528983837505, 0.071063557791333, 0.061538830126177224]}}
{"id": "017e9881-bfe3-43a9-ae82-4904497a55cf", "fitness": 0.07086468100512006, "name": "DynamicTopologyPSO", "description": "Introduced dynamic neighborhood size adaptation for improved exploration and exploitation balance in DynamicTopologyPSO.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Changed line: Dynamic neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    min(self.neighborhood_size, self.function_evaluations // 10 + 1), \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5 \n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 7, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["27fdff02-d221-4397-956f-1d1016296483"], "operator": null, "metadata": {"aucs": [0.07519785953808977, 0.061941810234540484, 0.06475028186280385, 0.07400550763137603, 0.05274168447855765, 0.07452597891625867, 0.09158217046354522, 0.0624877453484165, 0.08054909057249238]}}
{"id": "54e494d1-454c-4277-9f27-45ed501aa6e5", "fitness": 0.07926473027637472, "name": "DynamicTopologyPSO", "description": "Introduce a dynamic neighborhood size strategy to adaptively adjust based on progress.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 8, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["27fdff02-d221-4397-956f-1d1016296483"], "operator": null, "metadata": {"aucs": [0.06763970434247413, 0.07639963638651903, 0.0808326499489741, 0.06545932032842994, 0.07384486943083513, 0.07315595164401656, 0.08931536809223273, 0.09425425539458188, 0.09248081691930898]}}
{"id": "ca0dfb21-3593-4283-9a2f-0173acb0350f", "fitness": 0.07099424075031185, "name": "DynamicTopologyPSO", "description": "Enhance velocity update by introducing a dynamic social component adjustment based on function evaluations.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i]) * (self.function_evaluations / self.budget)  # Modified social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 9, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["54e494d1-454c-4277-9f27-45ed501aa6e5"], "operator": null, "metadata": {"aucs": [0.0695684343476588, 0.06570141659621442, 0.0621592225306955, 0.06146141684487527, 0.07416509392907078, 0.05925419710693702, 0.0751122973681202, 0.09956524876372519, 0.07196083926550945]}}
{"id": "f8597878-e7c8-4c02-a000-de706afd7004", "fitness": 0.0703999271168446, "name": "DynamicTopologyPSO", "description": "Introduce a linear decay for cognitive and social components to enhance convergence speed.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_weight = 0.7 + np.random.rand() / 5  # Changed line: Enhanced inertia weight range\n            cognitive_component = (2 * (1 - self.function_evaluations / self.budget)) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Linear decay in cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 10, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["54e494d1-454c-4277-9f27-45ed501aa6e5"], "operator": null, "metadata": {"aucs": [0.08525619168383225, 0.06458011296330846, 0.07355889065584165, 0.05746539286817631, 0.05990249757274613, 0.06784393945851053, 0.06879742588082871, 0.07216456846090136, 0.08403032450745607]}}
{"id": "61ecbb2a-605a-4773-96e3-b5a7872886e5", "fitness": 0.1891661093884285, "name": "DynamicTopologyPSO", "description": "Refine the inertia weight calculation by incorporating an adaptive decay factor based on the function evaluations, enhancing convergence speed.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 11, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_ids": ["54e494d1-454c-4277-9f27-45ed501aa6e5"], "operator": null, "metadata": {"aucs": [0.27740749429414147, 0.07065597454670536, 0.08601387401274185, 0.46239651040491614, 0.08004113479248842, 0.06798918596850478, 0.46900649035880304, 0.10452581561051, 0.0844585045070455]}}
{"id": "9058ebf6-ef31-4563-848a-c17f97a35cd0", "fitness": 0.042275670445381414, "name": "DynamicTopologyPSO", "description": "Introduce a momentum component to the velocity update to enhance exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            momentum = 0.9 * self.velocities[i]  # Added line: Momentum component\n            self.velocities[i] = momentum + inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 12, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.01.", "error": "", "parent_ids": ["61ecbb2a-605a-4773-96e3-b5a7872886e5"], "operator": null, "metadata": {"aucs": [0.036243938846042156, 0.0419655418621151, 0.04828807667028445, 0.034053697967266316, 0.03868665660616577, 0.04521537454417446, 0.03888009890458344, 0.04450798169610948, 0.05263966691169153]}}
{"id": "739f897a-d57b-456b-ab7b-aa0db09d0316", "fitness": 0.12528741812195895, "name": "DynamicTopologyPSO", "description": "Adjust personal best update condition to consider slight increases in diversity for better global exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index] * 1.02:  # Changed line: Adjust personal best with slight tolerance\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 13, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.14.", "error": "", "parent_ids": ["61ecbb2a-605a-4773-96e3-b5a7872886e5"], "operator": null, "metadata": {"aucs": [0.06462524533542902, 0.5322893567106521, 0.06594670787703705, 0.09660591544505459, 0.0677827730318552, 0.06371205283046733, 0.08207546724654768, 0.08218164293703167, 0.07236760168355594]}}
{"id": "b2da4bef-be3b-4232-8def-be1b31019992", "fitness": 0.1891661093884285, "name": "DynamicTopologyPSO", "description": "Adjust the neighborhood size dynamically to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5) * inertia_decay  # Changed line: Enhanced inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 14, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_ids": ["61ecbb2a-605a-4773-96e3-b5a7872886e5"], "operator": null, "metadata": {"aucs": [0.27740749429414147, 0.07065597454670536, 0.08601387401274185, 0.46239651040491614, 0.08004113479248842, 0.06798918596850478, 0.46900649035880304, 0.10452581561051, 0.0844585045070455]}}
{"id": "8685666e-7047-4bb2-ae25-94d49120c749", "fitness": 0.08519477192276408, "name": "DynamicTopologyPSO", "description": "Introduce a small random factor to the inertia weight calculation to enhance search efficiency.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.7 + np.random.rand() / 5 + 0.05 * np.random.rand()) * inertia_decay  # Changed line: Add random factor to inertia weight\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 15, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.01.", "error": "", "parent_ids": ["61ecbb2a-605a-4773-96e3-b5a7872886e5"], "operator": null, "metadata": {"aucs": [0.07568271079988298, 0.07551179706857614, 0.07673159602713064, 0.07864408879127183, 0.07808376170646147, 0.07345129530022698, 0.10381792584679794, 0.11197706108925198, 0.09285271067527667]}}
{"id": "e0a8dd8c-cce3-4bf7-8eee-c498b76b2d73", "fitness": 0.09178020557389432, "name": "DynamicTopologyPSO", "description": "Introduce a learning factor in the inertia weight to enhance convergence by adapting to the function landscape.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n        self.learning_factor = 0.5  # Added line: Learning factor for inertia weight adaptation\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = ((0.7 + np.random.rand() / 5) * inertia_decay) * (1.0 + self.learning_factor)  # Changed line: Enhanced inertia weight with learning factor\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 16, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.05.", "error": "", "parent_ids": ["61ecbb2a-605a-4773-96e3-b5a7872886e5"], "operator": null, "metadata": {"aucs": [0.0759500604370521, 0.08190458539591383, 0.0609427189739169, 0.06529529631907038, 0.05708074040224698, 0.09817667599792301, 0.08116935571577732, 0.0688115452837118, 0.23669087163943658]}}
{"id": "2fb4de37-4ae4-4f2b-b2a9-0508c24571c3", "fitness": 0.2873240579031482, "name": "DynamicTopologyPSO", "description": "Introduce a very slight adjustment to the inertia weight calculation to fine-tune convergence dynamics.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 17, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.19.", "error": "", "parent_ids": ["61ecbb2a-605a-4773-96e3-b5a7872886e5"], "operator": null, "metadata": {"aucs": [0.0827557114213624, 0.5257460356539647, 0.07576253650355025, 0.46211738191368434, 0.4074770357468809, 0.06430031216213161, 0.4686878443241177, 0.42038109559023695, 0.07868856781240474]}}
{"id": "b6a45057-0ce7-49b8-b8cf-e3fb33a9aa13", "fitness": 0.0741099583053932, "name": "DynamicTopologyPSO", "description": "Introduce a non-linear scaling factor for the inertia weight to enhance balance between exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * np.sqrt(inertia_decay)  # Changed line: Non-linear scaling for inertia weight\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 18, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07473446717480903, 0.07598032269553934, 0.05051902962371457, 0.0693569239773969, 0.06554242602149873, 0.07074905077615468, 0.08751262444852015, 0.0811187306470138, 0.09147604938389164]}}
{"id": "a2b30983-398d-4a29-86e2-78bc14e092ad", "fitness": 0.07806877599642789, "name": "DynamicTopologyPSO", "description": "Implement a fine-tuned stochastic component to the social component for improved exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.1 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Updated line: Fine-tuned social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 19, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06764171583877387, 0.0618091413380335, 0.07268059566741536, 0.06140043746608226, 0.07469733957900981, 0.06696054548195962, 0.0660176335627577, 0.1295483411002747, 0.10186323393354424]}}
{"id": "b1ce6bfd-84a7-4dfc-b6c6-5edcc132c510", "fitness": 0.08607952687547257, "name": "DynamicTopologyPSO", "description": "Transition to a more aggressive social component scaling towards the end of the budget to enhance convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i]) * (1 + 0.5 * (1 - inertia_decay))  # Changed line: Increasing social influence over time\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 20, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.03.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.16378282004288824, 0.06415056997960067, 0.07563824792519402, 0.059073416612517526, 0.07402674117465546, 0.06411950525772558, 0.09740503351032326, 0.09499303617209731, 0.0815263712042511]}}
{"id": "9c87bcab-3321-4e49-883a-9176d3c641d7", "fitness": 0.08693370323525045, "name": "DynamicTopologyPSO", "description": "Introduce a parameter to dynamically adjust the social component to enhance exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i]) * inertia_decay  # Changed line: Adjusted social component with decay\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 21, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07953525347312007, 0.07658412353500155, 0.07511600568504329, 0.058817612626420934, 0.08273054552306092, 0.10854662403733273, 0.07084628048264341, 0.09981874705758398, 0.1304081366970471]}}
{"id": "90c829d7-d717-4d4c-a2e1-2f9a153b77ab", "fitness": 0.09973837403006236, "name": "DynamicTopologyPSO", "description": "Fine-tune the social component weight to optimize exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.05 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Fine-tuned social component weight\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 22, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.05.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.08598840783211492, 0.06695688348654405, 0.08349616392678261, 0.08118336273789284, 0.0774085096876953, 0.07155740887025686, 0.23798772551626557, 0.10211617577139709, 0.090950728441612]}}
{"id": "995d3de6-eda3-4ace-acb8-1ca80731f370", "fitness": 0.050236180160400004, "name": "DynamicTopologyPSO", "description": "Introduce adaptive cognitive and social coefficients for dynamic balancing between exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = (0.5 + 1.5 * (self.function_evaluations / self.budget)) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Modified line\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 23, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.00.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.050766571976416874, 0.05322908416614336, 0.04822892002665535, 0.04750708529929615, 0.04522343149540886, 0.04567604961248628, 0.05564920344158608, 0.05253657886965635, 0.05330869655595072]}}
{"id": "7ac94425-ba4c-41ea-a2df-dff26e29fae4", "fitness": 0.08484052931270979, "name": "DynamicTopologyPSO", "description": "Introduce a slight modification to the cognitive component to enhance local exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Enhanced local exploration\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 24, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.10234169335104581, 0.07677882281127713, 0.08992956303968025, 0.07512965940022198, 0.07029345361086381, 0.07171112801199953, 0.0972245804208367, 0.08963048417993658, 0.0905253789885263]}}
{"id": "800338c3-1f4d-46b5-b93b-5c67fe7091f0", "fitness": 0.08885670408115752, "name": "DynamicTopologyPSO", "description": "Introduce a dynamic cognitive component scaling for enhanced individual exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component_scale = 1 + 0.5 * np.sin(2 * np.pi * self.function_evaluations / self.budget)  # Changed line: Dynamic cognitive component scaling\n            cognitive_component = 2 * np.random.rand() * cognitive_component_scale * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 25, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.08887186934223457, 0.14669421669221672, 0.07797526509527652, 0.06980137487357929, 0.07520653859905613, 0.06891186474407673, 0.08767329868943285, 0.0968031750731283, 0.08777273362141658]}}
{"id": "b9fdc7ea-86b0-4fc5-b93c-95c2eec74193", "fitness": 0.07696950038701586, "name": "DynamicTopologyPSO", "description": "Adjusted the cognitive component multiplier to refine the balance between personal and neighborhood influence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component multiplier\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 26, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07617905044203666, 0.08323263944788084, 0.08097135305474534, 0.06607735182467267, 0.0653451368535487, 0.07064749851908647, 0.08140533389622995, 0.08012938415284576, 0.08873775529209638]}}
{"id": "c0bc892d-8929-4935-97eb-f54a4a940bea", "fitness": 0.07835543441008813, "name": "DynamicTopologyPSO", "description": "Enhance the PSO by introducing a mild modification to the mutation strategy for improved exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            mutation_component = 0.1 * np.random.normal(size=self.dim)  # Added line: Mutation for exploration\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component + mutation_component \n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 27, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.08215892648696255, 0.06630159224997245, 0.09389064086590704, 0.07697854646218294, 0.06493400682013506, 0.06471066964142846, 0.09809216769040907, 0.07280008310124708, 0.08533227637254859]}}
{"id": "ff98fe5d-85f4-4d01-a7f7-5045c13a4999", "fitness": 0.10498338963132328, "name": "DynamicTopologyPSO", "description": "Incorporate a learning rate decay to adjust velocity updates dynamically for improved convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        learning_rate_decay = 0.5 + 0.5 * (1 - (self.function_evaluations / self.budget))  # Added line\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = learning_rate_decay * (inertia_weight * self.velocities[i] + cognitive_component + social_component)  # Modified line\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 28, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.06.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.05687089385222899, 0.06465155505737485, 0.08181716098926028, 0.21446060305193604, 0.06202208980831392, 0.07483298257788074, 0.22422083147139793, 0.07524942856320882, 0.09072496131030794]}}
{"id": "48d179e8-d93c-4bd1-97b3-49566e9737f7", "fitness": 0.07136289716121427, "name": "DynamicTopologyPSO", "description": "Adjust the cognitive component's influence by scaling it with the inertia_decay factor for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i]) * inertia_decay  # Changed line: Scaled cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 29, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.056020634297784366, 0.057783745718929413, 0.07626396248590817, 0.07522079136250381, 0.05434616690685112, 0.07133736719592354, 0.10063404153475763, 0.061308330670928335, 0.08935103427734203]}}
{"id": "a1a02709-1479-432b-a7d3-972f6614ca34", "fitness": 0.12636600786252586, "name": "DynamicTopologyPSO", "description": "Refine the Dynamic Topology PSO by incorporating a dynamic social component factor to enhance adaptability in diverse search landscapes.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * (0.5 + np.random.rand() / 2) * (neighborhood_best_position - self.positions[i])  # Changed line: Dynamic social component factor\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 30, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.12.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06814738530056397, 0.06400203808317262, 0.07067789679746495, 0.3351119793220685, 0.05741725837488543, 0.055225098554145036, 0.35203502541255705, 0.0684716143708528, 0.0662057745470227]}}
{"id": "691a7eac-c260-4863-a696-438062321548", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Enhance global exploration by slightly increasing the cognitive component's influence in the velocity update formula.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Slightly increased factor\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 31, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "66e78a07-04cc-44f1-8216-fc3cf0621910", "fitness": 0.14170763089203364, "name": "DynamicTopologyPSO", "description": "Fine-tune the cognitive and social component coefficients to enhance convergence stability.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Fine-tuned cognitive component coefficient\n            social_component = 1.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Fine-tuned social component coefficient\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 32, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.22.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07733339567536124, 0.05185702813666304, 0.7697897681889765, 0.05766285353742817, 0.05193233248998452, 0.06249285257509041, 0.06681189817850997, 0.06135091973190532, 0.0761376295143833]}}
{"id": "86647484-4651-40ac-a7ec-60937e85656c", "fitness": 0.2128905241738116, "name": "DynamicTopologyPSO", "description": "Use a more dynamic inertia weight adjustment by incorporating an exponential decay function for better convergence reflexes.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = np.exp(-self.function_evaluations / (0.1 * self.budget))  # Changed line: Exponential decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 33, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.24.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.08342488443081175, 0.8542761170513049, 0.08542252175583742, 0.25999331681200943, 0.07737955119835893, 0.07892286378058344, 0.2750875415195604, 0.09854940057823158, 0.10295852043760667]}}
{"id": "ced1d482-67d3-4b30-91fd-2f6079e0c9bc", "fitness": 0.08484052931270979, "name": "DynamicTopologyPSO", "description": "Enhance velocity update by increasing cognitive component influence to refine search space exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component coefficient\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 34, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.10234169335104581, 0.07677882281127713, 0.08992956303968025, 0.07512965940022198, 0.07029345361086381, 0.07171112801199953, 0.0972245804208367, 0.08963048417993658, 0.0905253789885263]}}
{"id": "a053cd9e-8012-450e-bad8-c52bddeffa5f", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Adjust the cognitive component scaling factor to enhance the exploration phase in the early stage.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted cognitive component scaling\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 35, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "8c1a7e1c-792f-4b5e-8a8e-b4e41a83e8a9", "fitness": 0.07582162950648567, "name": "DynamicTopologyPSO", "description": "Fine-tune the cognitive component range to enhance exploration and convergence properties.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.05 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component range\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 36, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07594974214768146, 0.06857645057810102, 0.07581853803758132, 0.06607783932954792, 0.06925737470672177, 0.06930379734657599, 0.08162350559252607, 0.08748932000494813, 0.08829809781468734]}}
{"id": "290e4922-6064-4bf9-98ed-8cc096cdb693", "fitness": 0.07136289716157723, "name": "DynamicTopologyPSO", "description": "Introduce adaptive learning factors to enhance convergence and exploration balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_factor = 2 * (1 - self.function_evaluations / self.budget)  # Changed line: Adaptive learning factor\n            cognitive_component = cognitive_factor * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 37, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.056020634297784366, 0.057783745718929413, 0.07626396248590839, 0.07522079136250381, 0.05434616690968752, 0.07133736719592354, 0.10063404153475763, 0.061308330671358435, 0.08935103427734203]}}
{"id": "4c6c3f22-0ec6-4cb6-a544-d1f7b6a21fdc", "fitness": 0.08371390206604298, "name": "DynamicTopologyPSO", "description": "Adjusted learning factor for social component to improve swarm convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 1.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Adjusted learning factor for social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 38, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07695935580596414, 0.06744593945218758, 0.08113393169366745, 0.09170004290467404, 0.06571750857872916, 0.07670570024504897, 0.11398839166531971, 0.08092861849355104, 0.0988456297552448]}}
{"id": "396cfe94-2922-45ee-857c-8643c769204e", "fitness": 0.0825977059516567, "name": "DynamicTopologyPSO", "description": "Adjust the inertia weight calculation for enhanced balance between exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = 0.7 * inertia_decay + np.random.rand() * 0.1  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 39, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07229670791091547, 0.08547426310039807, 0.09156095192306246, 0.06690132177971142, 0.07204449138962266, 0.0785488031365954, 0.08439783759652886, 0.09038963662693944, 0.10176534010113658]}}
{"id": "540f86ff-35ad-4e73-9a50-86e65cd8239a", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Slightly increase the cognitive component influence to enhance exploration dynamics.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Increased cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 40, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "51a60f84-6770-47fe-9ff9-324ad1fcb2de", "fitness": 0.11921212544110249, "name": "DynamicTopologyPSO", "description": "Slightly tweak the inertia weight calculation to further improve convergence dynamics.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.72 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 41, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.11.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.42874762955971624, 0.06170099501648785, 0.08448073415070867, 0.07822287180517895, 0.06837102947556417, 0.0724752521384594, 0.09941445827820905, 0.0881032566913238, 0.0913929018542744]}}
{"id": "4ba3c17d-a967-4273-a9f0-d84cb014dbaf", "fitness": 0.09669029843420812, "name": "DynamicTopologyPSO", "description": "Fine-tune the cognitive component to enhance local exploration and convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Enhanced cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 42, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.04.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07745773887563012, 0.07646388992007025, 0.08944072178902407, 0.06505517797467375, 0.15338929010724867, 0.0697111835458839, 0.07675741160589555, 0.17349193306895272, 0.08844533902049412]}}
{"id": "0a1c7f17-bc69-4727-a5ca-8af6252312e9", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Slightly adjust the cognitive component to improve convergence rate.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component multiplier\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 43, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "5edce26a-4f62-48aa-a66e-743cdd573f6b", "fitness": 0.07696950038701586, "name": "DynamicTopologyPSO", "description": "Adjust the cognitive component multiplier for a more balanced exploration-exploitation tradeoff.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted line: Updated cognitive component multiplier\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 44, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07617905044203666, 0.08323263944788084, 0.08097135305474534, 0.06607735182467267, 0.0653451368535487, 0.07064749851908647, 0.08140533389622995, 0.08012938415284576, 0.08873775529209638]}}
{"id": "6f5b2178-9067-4083-ba8f-43a056edb567", "fitness": 0.06925863532055339, "name": "DynamicTopologyPSO", "description": "Introduce a dynamic adjustment to the cognitive component to enhance exploration capabilities.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = (1.5 + np.random.rand() / 5) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Dynamic cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 45, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06942897671860637, 0.06246690570582236, 0.08429900347232988, 0.05198474990278834, 0.06590289865530152, 0.06474045564057951, 0.061487608802733074, 0.08170429291561088, 0.0813128260712086]}}
{"id": "811466ce-f218-4cad-a257-6fea48324463", "fitness": 0.06494897617523873, "name": "DynamicTopologyPSO", "description": "Introduce adaptive learning rates for cognitive and social components to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_learning_rate = 2.5 - (2 * (self.function_evaluations / self.budget))  # Changed line\n            social_learning_rate = 0.5 + (2 * (self.function_evaluations / self.budget))  # Changed line\n            cognitive_component = cognitive_learning_rate * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line\n            social_component = social_learning_rate * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 46, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07207465066333263, 0.05370403440761651, 0.061891863633359634, 0.07771504385726535, 0.050703597487746555, 0.04890347842484144, 0.10145682449100857, 0.06068783218343843, 0.0574034604285395]}}
{"id": "e517ec05-44e3-4726-9ef7-48638fedc7b9", "fitness": 0.07122327671648479, "name": "DynamicTopologyPSO", "description": "Introduce slight random perturbations to inertia weight to escape local optima and enhance convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay * (1 + 0.01 * np.random.randn())  # Changed line: Introduced small random perturbations\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 47, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.05612283349915981, 0.07370998429167308, 0.07197154793244076, 0.06362503626599747, 0.05636945311270569, 0.07586384684807479, 0.07826251152518582, 0.06970951410715076, 0.0953747628659749]}}
{"id": "89e29aef-b9a8-438c-b991-abe0b12a7fd9", "fitness": 0.07679866015692499, "name": "DynamicTopologyPSO", "description": "Introduce stochastic oscillations in velocity adjustment to enhance exploration capabilities.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            random_oscillation = np.random.uniform(-0.1, 0.1, self.dim)  # Added line: Stochastic oscillation to velocities\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component + random_oscillation  # Modified line: Apply oscillation\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 48, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.052323843931527, 0.07324945225518076, 0.08392421476011847, 0.057706372104661674, 0.07722093891455284, 0.07806942947609707, 0.06927121721918905, 0.0971448537383729, 0.10227761901262511]}}
{"id": "81c44740-3b14-48c7-8acf-1c93ba410798", "fitness": 0.13938081973579086, "name": "DynamicTopologyPSO", "description": "Introduced an adaptive cognitive component scalar for improved convergence dynamics.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_scalar = 1.5 + np.random.rand() / 2  # Changed line: Adaptive cognitive component scalar\n            cognitive_component = cognitive_scalar * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 49, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.13.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07281476517217689, 0.07398307293241624, 0.06462333094234651, 0.05840388444950784, 0.3741086985776939, 0.06698322926953615, 0.07110987834215665, 0.3859695028173685, 0.08643101511891516]}}
{"id": "5ec2d30b-06c2-4fba-bfe4-3f462d12d422", "fitness": 0.06819055681472577, "name": "DynamicTopologyPSO", "description": "Incorporate an adaptive cognitive component to dynamically adjust exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            adaptive_cognitive = 1.5 + 0.5 * (self.function_evaluations / self.budget)  # Modified line: Adaptive cognitive factor\n            cognitive_component = adaptive_cognitive * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 50, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06757054557225295, 0.06236733283741458, 0.07213742081794206, 0.05766088490973431, 0.058921146427477145, 0.06937815929764246, 0.06760878952481242, 0.07114719762878174, 0.08692353431647426]}}
{"id": "d0963351-8251-4aae-86d9-d144c4350340", "fitness": 0.07806877599642789, "name": "DynamicTopologyPSO", "description": "Strengthen the social component's influence by subtly increasing its scaling factor for improved convergence behavior.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.1 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Increased social component factor\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 51, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06764171583877387, 0.0618091413380335, 0.07268059566741536, 0.06140043746608226, 0.07469733957900981, 0.06696054548195962, 0.0660176335627577, 0.1295483411002747, 0.10186323393354424]}}
{"id": "dfa830c1-d0fc-48cb-9ca8-efb99a0ac324", "fitness": 0.09284392811517855, "name": "DynamicTopologyPSO", "description": "Enhanced convergence by refining inertia weight's calculation and adjusting neighborhood dynamics.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.725 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 52, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.03.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.1444039352898111, 0.06326811122608811, 0.07196851277752936, 0.12702698288333658, 0.07052744713111758, 0.07057199165343564, 0.11167454076748473, 0.08844727459255841, 0.08770655671524552]}}
{"id": "6f81f488-37da-42c7-8ee6-0260e2acb659", "fitness": 0.07656007921910367, "name": "DynamicTopologyPSO", "description": "Introduce a dynamic component multiplier to enhance convergence rates by slightly adjusting the acceleration coefficients.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            dynamic_component_multiplier = 1 + 0.1 * np.sin(self.function_evaluations / self.budget * np.pi)  # Changed line: Added dynamic component multiplier\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + dynamic_component_multiplier * (cognitive_component + social_component)\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 53, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07358661949027367, 0.06848807419872116, 0.06925740275522874, 0.07282750656936687, 0.0677525299325279, 0.07272682681417575, 0.0856436848555604, 0.08428815978083748, 0.09446990857524107]}}
{"id": "d0fae076-2bd0-42d9-a4f4-1ed11cc2d2ad", "fitness": 0.10771490095738125, "name": "DynamicTopologyPSO", "description": "Adjust the inertia weight calculation using a more refined dynamic adjustment for improved convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.72 + np.random.rand() / 10) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 54, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.07.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.31021026451611255, 0.06855993716134845, 0.05637343347480428, 0.07789020224732313, 0.07947970873719601, 0.07198227885725195, 0.103803661545526, 0.10476911862938221, 0.09636550344748662]}}
{"id": "82e9a334-5b7b-4d3d-ab5f-51b1ad46535e", "fitness": 0.07696950038701586, "name": "DynamicTopologyPSO", "description": "Fine-tune the cognitive component by adjusting its scaling factor for better convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted line: Fine-tuned cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 55, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07617905044203666, 0.08323263944788084, 0.08097135305474534, 0.06607735182467267, 0.0653451368535487, 0.07064749851908647, 0.08140533389622995, 0.08012938415284576, 0.08873775529209638]}}
{"id": "70c21516-5ea3-49dc-9f29-1a9e1917c849", "fitness": 0.07101979224853362, "name": "DynamicTopologyPSO", "description": "Enhance convergence by introducing a dynamic adjustment to cognitive and social component multipliers based on the budget.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            dynamic_multiplier = 2 * (1 - self.function_evaluations / self.budget)  # Changed line\n            cognitive_component = dynamic_multiplier * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = dynamic_multiplier * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 56, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06726167659363846, 0.056608230362308776, 0.08141287056569024, 0.059065484607101704, 0.06096668545365125, 0.07454792423687728, 0.07099144326527518, 0.07376423349574257, 0.09455958165651712]}}
{"id": "e967df1d-a2a9-40f7-8f2f-0ca283a2b60b", "fitness": 0.1075649912824389, "name": "DynamicTopologyPSO", "description": "Increase exploration by reducing neighborhood size at start and increasing it over time.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(2 + 3 * (self.function_evaluations / self.budget)))  # Changed line: Gradually increasing neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 57, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.12.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.457216196770044, 0.06539143535553016, 0.06171179931558146, 0.04614167341016562, 0.06677732841904738, 0.06374537905032451, 0.05401191339444944, 0.078378880260353, 0.07471031556645458]}}
{"id": "0458a8dd-ea9e-496a-8e0d-1d1c90b10efe", "fitness": 0.06221756347833201, "name": "DynamicTopologyPSO", "description": "Introduce a time-varying acceleration coefficient to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            time_varying_accel = 2.5 - (2.5 - 0.5) * (self.function_evaluations / self.budget)  # Changed line: Added time-varying acceleration coefficient\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component * time_varying_accel\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 58, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06256039644495637, 0.053958682778080136, 0.05628566589828987, 0.0613971011711556, 0.06244642283118673, 0.042060643376682694, 0.07525362535149394, 0.0784279793102115, 0.06756755414293125]}}
{"id": "2df69d88-fb3f-4d83-8879-07ea6b06afdd", "fitness": 0.08371390206604298, "name": "DynamicTopologyPSO", "description": "Adjust the social component coefficient to balance exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 1.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Adjusted social component coefficient\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 59, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07695935580596414, 0.06744593945218758, 0.08113393169366745, 0.09170004290467404, 0.06571750857872916, 0.07670570024504897, 0.11398839166531971, 0.08092861849355104, 0.0988456297552448]}}
{"id": "3959ef2c-f626-4680-9f1b-351ced6361c8", "fitness": 0.050699263667652775, "name": "DynamicTopologyPSO", "description": "Introduce a dynamic cognitive component that adapts based on progress to enhance convergence adaptability.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * (1 - inertia_decay) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Dynamic cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 60, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.05179350363792801, 0.045197141933650764, 0.0407344145280204, 0.051631123107311994, 0.04865264491845722, 0.04521486369917982, 0.06110026536786162, 0.059157610720563025, 0.05281180509590211]}}
{"id": "31d16c4f-dc96-47a1-97b2-6a8a1bcb29fc", "fitness": 0.07806877599642789, "name": "DynamicTopologyPSO", "description": "Improve convergence by slightly increasing the impact of the social component.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.1 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Updated line: Slight increase in social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 61, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06764171583877387, 0.0618091413380335, 0.07268059566741536, 0.06140043746608226, 0.07469733957900981, 0.06696054548195962, 0.0660176335627577, 0.1295483411002747, 0.10186323393354424]}}
{"id": "4f77f084-c42e-4c15-ab21-e39dcfbe4a07", "fitness": 0.07323687976988234, "name": "DynamicTopologyPSO", "description": "Adjust the cognitive component to increase exploration diversity in early iterations.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = (1.5 + np.random.rand()) * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 62, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07800725238693496, 0.070517824622369, 0.07219043077503162, 0.06704538810635707, 0.05371682888208096, 0.07546719670952629, 0.07971624201871197, 0.06369764545310674, 0.0987731089748225]}}
{"id": "6b9837ac-d297-41ae-aefb-14e892f86ead", "fitness": 0.07582162950648567, "name": "DynamicTopologyPSO", "description": "Fine-tune the cognitive component scaling factor to enhance particle guidance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.05 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Fine-tuned cognitive component scaling\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 63, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07594974214768146, 0.06857645057810102, 0.07581853803758132, 0.06607783932954792, 0.06925737470672177, 0.06930379734657599, 0.08162350559252607, 0.08748932000494813, 0.08829809781468734]}}
{"id": "7a3069fe-8a52-4209-a686-595f2838f79a", "fitness": 0.08484052931270979, "name": "DynamicTopologyPSO", "description": "Increase cognitive component factor to enhance exploration capability and avoid premature convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Increased cognitive component factor\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 64, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.10234169335104581, 0.07677882281127713, 0.08992956303968025, 0.07512965940022198, 0.07029345361086381, 0.07171112801199953, 0.0972245804208367, 0.08963048417993658, 0.0905253789885263]}}
{"id": "8a123046-b1e7-4c4f-bd07-569f3a9f768f", "fitness": 0.050699263667652775, "name": "DynamicTopologyPSO", "description": "Introduce a dynamic cognitive factor adjustment to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * (1 - inertia_decay) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Modified line: Dynamic cognitive factor adjustment\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 65, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.05179350363792801, 0.045197141933650764, 0.0407344145280204, 0.051631123107311994, 0.04865264491845722, 0.04521486369917982, 0.06110026536786162, 0.059157610720563025, 0.05281180509590211]}}
{"id": "289c1f40-4e1b-4bd4-8c56-ec17749e23eb", "fitness": 0.2234575351116601, "name": "DynamicTopologyPSO", "description": "Implement a more adaptive neighborhood size to enhance exploration and exploitation trade-offs.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(3 + 3 * (self.budget - self.function_evaluations) / self.budget))  # Changed line: More adaptive neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 66, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.16.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.3939517066729391, 0.47758594328861326, 0.06931257959168224, 0.36524906508294097, 0.06549192131568227, 0.07737986217921444, 0.38087334552504415, 0.0809845385389012, 0.10028885380992347]}}
{"id": "209a6e62-26a0-41d2-857c-e795182bb3f9", "fitness": 0.09033871403804097, "name": "DynamicTopologyPSO", "description": "Adjust the social component to increase exploration during the early stages of the search.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = (1.5 + 0.5 * np.random.rand()) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Increased randomness in social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 67, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.05.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.0712875786825623, 0.0756396746442537, 0.05971271116224908, 0.07792371475698379, 0.06799936188282119, 0.059892722085303274, 0.24197731380382148, 0.08427946444551149, 0.07433588487886245]}}
{"id": "0c4551a8-1380-4f4f-ba97-3990773ac229", "fitness": 0.08195374527998138, "name": "DynamicTopologyPSO", "description": "Enhanced PSO by adjusting cognitive and social components dynamically to better explore the search space.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = (1.5 + 0.5 * inertia_decay) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line\n            social_component = (1.5 + 0.5 * inertia_decay) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 68, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.09214423255110948, 0.06328222281445839, 0.06945266257894156, 0.07778370028126025, 0.0764718994026935, 0.06414747712254454, 0.11771470269695528, 0.0982240295899629, 0.07836278048190648]}}
{"id": "9d2d13cd-afd8-4ae5-8af7-7ee85418561b", "fitness": 0.10297691714352783, "name": "DynamicTopologyPSO", "description": "Fine-tune acceleration coefficients for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.8 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjust cognitive coefficient\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 69, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.07.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.2993598932977901, 0.07665117136090982, 0.08372042816333103, 0.0661910223905795, 0.06786715727516213, 0.07539094508628508, 0.08159988101807614, 0.08433120494628144, 0.09168055075333525]}}
{"id": "12c7986c-29f7-4fc6-a761-ae816c2bca36", "fitness": 0.07696950038701586, "name": "DynamicTopologyPSO", "description": "Fine-tune the cognitive component's influence to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component influence\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 70, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07617905044203666, 0.08323263944788084, 0.08097135305474534, 0.06607735182467267, 0.0653451368535487, 0.07064749851908647, 0.08140533389622995, 0.08012938415284576, 0.08873775529209638]}}
{"id": "d5b6ab6d-b85a-4198-a58d-d521cb05c819", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Introduce a slight increase to the cognitive component to enhance particles' local exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Increased cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 71, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "6d4d69a4-ce65-436f-8bdb-51e0fe58e34d", "fitness": 0.0738407044405167, "name": "DynamicTopologyPSO", "description": "Introduce a random mutation factor to particle positions to enhance exploration capabilities.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i] + np.random.uniform(-0.1, 0.1, self.dim), self.bounds[0], self.bounds[1])  # Changed line: Random mutation factor\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 72, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.056429663694635424, 0.08015570833258445, 0.08211951258155392, 0.0677378205637642, 0.06135519102343667, 0.07087296661611875, 0.08500755676616356, 0.07212529177712634, 0.08876262860926698]}}
{"id": "659afdd0-ba3e-4d54-8d25-136425215051", "fitness": 0.09669029843420812, "name": "DynamicTopologyPSO", "description": "Introduce a slight adjustment to the cognitive component influence to enhance exploration and convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 73, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.04.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07745773887563012, 0.07646388992007025, 0.08944072178902407, 0.06505517797467375, 0.15338929010724867, 0.0697111835458839, 0.07675741160589555, 0.17349193306895272, 0.08844533902049412]}}
{"id": "c7ae7740-6122-43c3-9b69-9ef438ecc470", "fitness": 0.07725276882712663, "name": "DynamicTopologyPSO", "description": "Fine-tune the inertia weight's initial value to enhance convergence in challenging search spaces.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.715 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 74, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.08026090346730719, 0.08188855603192358, 0.07165987820694264, 0.05944885420903079, 0.08513416109711436, 0.06582587428673214, 0.07175649176651044, 0.098443781644171, 0.08085641873440752]}}
{"id": "3760ca3a-7dd0-4d8a-a7dd-95f2e648fb6d", "fitness": 0.10050033537122541, "name": "DynamicTopologyPSO", "description": "Enhance exploration by dynamically adjusting the cognitive component based on proximity to personal best.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i]) * (0.5 + 0.5 * np.linalg.norm(self.personal_best_positions[i] - self.positions[i]) / 5.0)  # Changed line: Dynamic cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 75, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.03.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.16476762559664482, 0.08712088179950772, 0.10300938403007642, 0.07947611008423794, 0.08276095857800969, 0.07630987744281825, 0.10209908472727969, 0.11144677376165524, 0.09751232232079887]}}
{"id": "92fdf1ef-8858-400a-b466-d7d57e1814f2", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Introduce a slight adjustment to the cognitive component coefficient to fine-tune exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Slight adjustment to cognitive component coefficient\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 76, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "8a66bd47-7b3c-4e5f-8449-888a79697aac", "fitness": 0.07122327671648479, "name": "DynamicTopologyPSO", "description": "Increase exploration by introducing a slight randomness to inertia weight scaling.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay * (1 + 0.01 * np.random.randn())  # Changed line: Introduced randomness to inertia scaling\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 77, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.05612283349915981, 0.07370998429167308, 0.07197154793244076, 0.06362503626599747, 0.05636945311270569, 0.07586384684807479, 0.07826251152518582, 0.06970951410715076, 0.0953747628659749]}}
{"id": "5839349c-6f10-418f-a069-13b033a6d255", "fitness": 0.0802075463640494, "name": "DynamicTopologyPSO", "description": "Enhance social learning by introducing a mutation mechanism for diversity maintenance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            \n            # Introduce a mutation mechanism to maintain diversity\n            if np.random.rand() < 0.1:  # Mutation probability\n                self.velocities[i] += np.random.normal(0, 0.1, self.dim)\n            \n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 78, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.0807551547214942, 0.0904997891022905, 0.0923930581098672, 0.07193292559235032, 0.06457847692073404, 0.07041635708045879, 0.08291780889325406, 0.08037187299955662, 0.08800247385643889]}}
{"id": "c0e057e4-7768-478d-8712-ff0b2a304b16", "fitness": 0.16252129581602226, "name": "DynamicTopologyPSO", "description": "Fine-tune exploration-exploitation balance by adjusting cognitive and social components adaptively.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = (1.5 + np.random.rand() / 5) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adaptive cognitive component\n            social_component = (1.5 + np.random.rand() / 5) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Adaptive social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 79, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.08620585403939574, 0.0531517926512205, 0.07850168038150374, 0.6775612296352407, 0.05360511677897406, 0.07019917720408364, 0.10319188803719104, 0.25205987578802636, 0.08821504782856449]}}
{"id": "b9c1ea63-0e95-4799-bf53-e23f12381b0a", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Fine-tune the cognitive component to enhance individual learning within each particle.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Enhanced cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 80, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "99c5664e-21f5-43fe-a80d-a3f29eb09b1f", "fitness": 0.09144537316664009, "name": "DynamicTopologyPSO", "description": "Adjusted social component weight to improve convergence in diverse problem landscapes.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Adjusted social component weight\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 81, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.08254876976380487, 0.13888470731777958, 0.08537413041243602, 0.07376993203486304, 0.07084889969157404, 0.08037514515189381, 0.0954022352445687, 0.09075043030290186, 0.10505410857993891]}}
{"id": "e7ace68a-23cc-452c-9490-e9458afdf4c0", "fitness": 0.07736019683450551, "name": "DynamicTopologyPSO", "description": "Implement inertia weight exponential decay to enhance the convergence rate.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * np.exp(-self.function_evaluations / self.budget)  # Changed line: Exponential decay for inertia weight\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 82, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07736853930585841, 0.07310315423487856, 0.06408413481813446, 0.06822232763487368, 0.07514309762419502, 0.06890291307022078, 0.08640417968175151, 0.09733843660035069, 0.08567498854028655]}}
{"id": "ae596be2-9b29-49c8-be98-d6d28e180315", "fitness": 0.07143564542577746, "name": "DynamicTopologyPSO", "description": "Introduce adaptive cognitive weighting to enhance individual particle exploration balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_weight = 2 + 0.5 * np.random.rand()  # Changed line: Adaptive cognitive weighting\n            cognitive_component = cognitive_weight * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 83, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06948325362830277, 0.0768451693184049, 0.07765073455087257, 0.04514866736239864, 0.07775823095247192, 0.06850238066657988, 0.05331353557014962, 0.08830977177527188, 0.08590906500754503]}}
{"id": "17335b41-300e-44d2-bd5e-4284ad3491a7", "fitness": 0.04721279140533609, "name": "DynamicTopologyPSO", "description": "Introduced a dynamic adjustment of cognitive and social components to enhance adaptability during optimization.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i]) * (self.function_evaluations / self.budget)  # Changed line\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i]) * ((self.budget - self.function_evaluations) / self.budget)  # Changed line\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 84, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.05352273109347094, 0.05541853270799435, 0.039683623368908516, 0.04936328863437889, 0.04125629446714396, 0.03776998653376884, 0.05671812968041667, 0.04781764378654807, 0.04336489237539454]}}
{"id": "a5c0a6ea-158f-4021-a00c-85dd41322c14", "fitness": 0.052840480585708845, "name": "DynamicTopologyPSO", "description": "Fine-tune the cognitive component's impact by introducing a decay factor to enhance convergence efficiency.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_decay = (self.budget - self.function_evaluations) / (2 * self.budget)  # New line: Added decay to cognitive component\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i]) * cognitive_decay\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 85, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.054025586415208604, 0.07093595623782678, 0.046101990723765196, 0.04824773778229807, 0.04923644156338691, 0.04465235501074716, 0.05663618953630467, 0.05804488658017937, 0.047683181421662835]}}
{"id": "f835492d-989b-4354-89d1-5595a0a1c2f4", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Introduce a slight increase to the cognitive component scaling to enhance individual exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Slight change to increase exploration\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 86, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "f73026b7-7852-4ada-825a-aeec86e60dae", "fitness": 0.13938081973579086, "name": "DynamicTopologyPSO", "description": "Introduce an adaptive cognitive component multiplier to enhance exploration capabilities.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_multiplier = 1.5 + np.random.rand() * 0.5  # Changed line: Adaptive cognitive multiplier\n            cognitive_component = cognitive_multiplier * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 87, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.13.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07281476517217689, 0.07398307293241624, 0.06462333094234651, 0.05840388444950784, 0.3741086985776939, 0.06698322926953615, 0.07110987834215665, 0.3859695028173685, 0.08643101511891516]}}
{"id": "f91a6c69-51c0-404d-917f-2caa8a822503", "fitness": 0.0878892161929224, "name": "DynamicTopologyPSO", "description": "Refine inertia weight and enhance convergence by adjusting parameters and particle exploration.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Adaptive decay factor\n            inertia_weight = 0.9 - 0.5 * inertia_decay  # Fine-tuned inertia weight\n            cognitive_component = 2.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted cognitive component\n            social_component = 1.5 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Adjusted social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 88, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.08632303748259762, 0.09731160285590268, 0.09506872695786528, 0.07362424670976941, 0.07940320779411691, 0.07178544122658082, 0.09319996056160962, 0.11377250564561325, 0.0805142165022461]}}
{"id": "29283616-28dc-4ccd-a314-2106e3bb9dc5", "fitness": 0.08107524502456602, "name": "DynamicTopologyPSO", "description": "Introduce a neighborhood best velocity adjustment for improved convergence control.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            neighbor_velocity_adjust = 0.5 * (self.velocities[self.neighbors[i]].mean(axis=0) - self.velocities[i])  # Added line: Neighborhood velocity adjustment\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component + neighbor_velocity_adjust\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 89, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.06674105995741819, 0.08077920626738289, 0.08095016288487245, 0.05887253183160124, 0.07718010187458058, 0.082334973234795, 0.07112192367172032, 0.1022251988879832, 0.10947204661074028]}}
{"id": "101d362c-c502-446d-8a4f-ec40d687a682", "fitness": 0.11921212544110249, "name": "DynamicTopologyPSO", "description": "Incorporate a subtle change in the inertia weight computation to further enhance convergence properties.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.72 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 90, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.11.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.42874762955971624, 0.06170099501648785, 0.08448073415070867, 0.07822287180517895, 0.06837102947556417, 0.0724752521384594, 0.09941445827820905, 0.0881032566913238, 0.0913929018542744]}}
{"id": "c23c5b19-3a28-4316-97c2-9b679ecc3918", "fitness": 0.06478763897601947, "name": "DynamicTopologyPSO", "description": "Introduce a dynamic cognitive component scaling to enhance convergence precision.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + 0.5 * cognitive_component + social_component  # Changed line: Dynamic cognitive component scaling\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 91, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.04.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.16813245876649086, 0.05332436925910655, 0.0413121178825262, 0.052492833913850734, 0.04908113530948943, 0.04586425929137372, 0.06119753692834251, 0.05664906611521392, 0.05503497331778129]}}
{"id": "d37bc99e-7c41-413c-9a2a-af8658166b09", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Slightly adjust the cognitive component scaling to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted line: Cognitive component scaling\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 92, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "74ed460f-a0ba-4b58-9a41-b1a7d45c2c5e", "fitness": 0.05912930824913417, "name": "DynamicTopologyPSO", "description": "Fine-tune the social component influence dynamically for improved convergence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = 2 * (1 - inertia_decay) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Adjusted line: Dynamic social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 93, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.058187447858762176, 0.05443448466734857, 0.05829172538473815, 0.05474515732095009, 0.053158812860853666, 0.05595491575647904, 0.06814094017481165, 0.06307442441801292, 0.06617586580025125]}}
{"id": "bb03ec87-7049-46ce-8913-ff7a8e4d6e40", "fitness": 0.18279113657692692, "name": "DynamicTopologyPSO", "description": "Slightly adjust the cognitive and social components' coefficients to enhance exploration and convergence balance.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive component\n            social_component = 1.8 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Adjusted social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 94, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.14.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.082958964029619, 0.08661496088707854, 0.0881654902152561, 0.05814552597726941, 0.420734241311972, 0.3567080453028355, 0.07083634345445455, 0.10801700492430899, 0.37293965308954813]}}
{"id": "2440ede5-bd98-4d7c-9562-c4f953f7d121", "fitness": 0.11549849201843461, "name": "DynamicTopologyPSO", "description": "Enhance exploration by slightly increasing the cognitive component's influence.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2.1 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Slightly increased cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 95, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.10.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07719493490770024, 0.3983714518718009, 0.09362817515039412, 0.06623607042406288, 0.06898928179739294, 0.07614576113410454, 0.08150587158007194, 0.08617139569695131, 0.09124348560343265]}}
{"id": "5b7ff260-a6c0-455a-be8f-6aee28325ae8", "fitness": 0.07696950038701586, "name": "DynamicTopologyPSO", "description": "Fine-tune the balance between exploration and exploitation by adjusting cognitive and social coefficients.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 1.5 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Adjusted cognitive coefficient\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 96, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.01.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.07617905044203666, 0.08323263944788084, 0.08097135305474534, 0.06607735182467267, 0.0653451368535487, 0.07064749851908647, 0.08140533389622995, 0.08012938415284576, 0.08873775529209638]}}
{"id": "8daa14ef-e7e7-4c2f-b028-ff1c0df83d73", "fitness": 0.10235392047785835, "name": "DynamicTopologyPSO", "description": "Introduce a dynamic parameter for social component to improve convergence precision.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget  # Added line: Adaptive decay factor\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay  # Changed line: Fine-tuned inertia weight range\n            cognitive_component = 2 * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])\n            social_component = (0.5 + np.random.rand()) * 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Changed line: Dynamic social component\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 97, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.06.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.0657099264281934, 0.062463940461725986, 0.07943889226405687, 0.20665620738298507, 0.054023820295631686, 0.06743736328122885, 0.230919325632706, 0.06442464729087138, 0.09011116126332597]}}
{"id": "6e110a59-7445-4afd-b7cf-6e578a10c8ef", "fitness": 0.11906369107534573, "name": "DynamicTopologyPSO", "description": "Enhance neighborhood influence and adaptively balance exploration and exploitation by adjusting the cognitive and social coefficients.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4  # Increased neighborhood size\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        \n        # Update personal best\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        \n        # Update global best\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        # Randomly assign neighbors based on the interval\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))  # Changed line: Dynamic neighborhood size\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = (1.5 + np.random.rand() / 2) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Adjusted cognitive factor\n            social_component = (1.5 + np.random.rand() / 2) * np.random.rand() * (neighborhood_best_position - self.positions[i])  # Adjusted social factor\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 98, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.09.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.0721345400769583, 0.06490946675031584, 0.05228339648778413, 0.2813708532967848, 0.0661715627390348, 0.07386925254429655, 0.3046581598965059, 0.0617927349299745, 0.09438325295645689]}}
{"id": "3a135280-c1cc-4417-abf9-f1c3929c8ea3", "fitness": 0.08448167398667085, "name": "DynamicTopologyPSO", "description": "Introduce a small perturbation to the cognitive component's coefficient to enhance local exploration capability.", "code": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.num_particles = 20\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, dim))\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.num_particles, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_values = np.full(self.num_particles, np.inf)\n        self.global_best_position = np.zeros(dim)\n        self.global_best_value = np.inf\n        self.function_evaluations = 0\n        self.topology_change_interval = 50\n        self.neighborhood_size = 4\n\n    def evaluate(self, func, particle_index):\n        current_value = func(self.positions[particle_index])\n        self.function_evaluations += 1\n        if current_value < self.personal_best_values[particle_index]:\n            self.personal_best_values[particle_index] = current_value\n            self.personal_best_positions[particle_index] = self.positions[particle_index]\n        if current_value < self.global_best_value:\n            self.global_best_value = current_value\n            self.global_best_position = self.positions[particle_index]\n\n    def update_topology(self):\n        if self.function_evaluations % self.topology_change_interval == 0:\n            self.neighborhood_size = max(2, int(5 * (1 - self.function_evaluations / self.budget)))\n            self.neighbors = [\n                np.random.choice(\n                    np.delete(np.arange(self.num_particles), i), \n                    self.neighborhood_size, \n                    replace=False\n                )\n                for i in range(self.num_particles)\n            ]\n\n    def update_velocities_and_positions(self):\n        for i in range(self.num_particles):\n            neighborhood_best_position = self.personal_best_positions[self.neighbors[i]].min(axis=0)\n            inertia_decay = (self.budget - self.function_evaluations) / self.budget\n            inertia_weight = (0.705 + np.random.rand() / 5) * inertia_decay\n            cognitive_component = (2.1 + np.random.rand() * 0.1) * np.random.rand() * (self.personal_best_positions[i] - self.positions[i])  # Changed line: Perturb cognitive component\n            social_component = 2 * np.random.rand() * (neighborhood_best_position - self.positions[i])\n            self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n            self.positions[i] += self.velocities[i]\n            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])\n\n    def __call__(self, func):\n        while self.function_evaluations < self.budget:\n            self.update_topology()\n            for i in range(self.num_particles):\n                if self.function_evaluations < self.budget:\n                    self.evaluate(func, i)\n            self.update_velocities_and_positions()\n        return self.global_best_position, self.global_best_value", "configspace": "", "generation": 99, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.02.", "error": "", "parent_ids": ["2fb4de37-4ae4-4f2b-b2a9-0508c24571c3"], "operator": null, "metadata": {"aucs": [0.05927696413533079, 0.07469174237962384, 0.09473434093384814, 0.06314323842936143, 0.08240712959842789, 0.08548828988139734, 0.07696343411983964, 0.10838363005945828, 0.1152462963427503]}}
