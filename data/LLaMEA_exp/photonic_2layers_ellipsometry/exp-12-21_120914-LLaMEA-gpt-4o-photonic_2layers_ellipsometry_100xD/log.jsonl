{"id": "be4356f1-d783-4e2c-9509-563ba5e4fa40", "fitness": 0.031542679489822145, "name": "AdaptiveSwarmPerturbation", "description": "Adaptive Swarm Perturbation (ASP) leverages dynamic swarm intelligence with adaptive perturbations to efficiently explore and exploit black box landscapes.", "code": "import numpy as np\n\nclass AdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initial swarm setup\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n        \n        iter_count = 0\n\n        while iter_count < self.budget - self.population_size:\n            # Update velocities and positions\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            velocities += cognitive_component + social_component\n            swarm += velocities\n            \n            # Clip positions to bounds\n            swarm = np.clip(swarm, lb, ub)\n            \n            # Evaluate new solutions\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n            \n            # Update personal bests\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n            \n            # Update global best\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n                \n            # Adaptively perturb the swarm based on history\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.uniform(-0.1, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03154 with standard deviation 0.01517.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.04833137220755812, 0.01158332057823852, 0.034713345683669794]}}
{"id": "40c82831-6354-4350-9941-3a29dcf1e3a7", "fitness": 0.050069494452272635, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation (EASP) introduces a dynamic inertia weight and nonlinear perturbation mechanism to improve convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initial swarm setup\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n        \n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Update inertia weight dynamically\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Update velocities and positions\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            velocities = inertia_weight * velocities + cognitive_component + social_component\n            swarm += velocities\n            \n            # Clip positions to bounds\n            swarm = np.clip(swarm, lb, ub)\n            \n            # Evaluate new solutions\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n            \n            # Update personal bests\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n            \n            # Update global best\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n                \n            # Nonlinear adaptive perturbation based on success history\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05007 with standard deviation 0.03132.", "error": "", "parent_ids": ["be4356f1-d783-4e2c-9509-563ba5e4fa40"], "operator": null, "metadata": {"aucs": [0.05057076632754165, 0.011466657550127435, 0.08817105947914883]}}
{"id": "da0b27c3-1909-4c7d-9bbc-af0d5124bbe4", "fitness": -Infinity, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation (EASP) with dynamic population adjustment to balance exploration and exploitation for improved convergence and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initial swarm setup\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n        \n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Update inertia weight dynamically\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Update velocities and positions\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            velocities = inertia_weight * velocities + cognitive_component + social_component\n            swarm += velocities\n            \n            # Clip positions to bounds\n            swarm = np.clip(swarm, lb, ub)\n            \n            # Evaluate new solutions\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n            \n            # Update personal bests\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n            \n            # Update global best\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n                \n            # Nonlinear adaptive perturbation based on success history\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n            # Dynamic population adjustment\n            if global_best_score < np.mean(personal_best_scores):\n                self.population_size = min(self.population_size + 1, 50)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 2, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (21,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (21,2) (20,2) ')", "parent_ids": ["40c82831-6354-4350-9941-3a29dcf1e3a7"], "operator": null, "metadata": {}}
{"id": "fd74cb39-cee2-4700-ba94-f14c1fef1a93", "fitness": 0.014153363591478377, "name": "QuantumInspiredSwarmOptimization", "description": "Quantum-Inspired Swarm Optimization (QISO) leverages quantum principles to enhance solution diversity and convergence speed through probabilistic position updates and adaptive amplitude control.", "code": "import numpy as np\n\nclass QuantumInspiredSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        # Initial swarm setup\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n        \n        iter_count = 0\n        amplitude = 1.0\n        min_amplitude = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Quantum-inspired probabilistic position update\n            angle = np.random.uniform(-np.pi, np.pi, (self.population_size, self.dim))\n            delta = amplitude * np.tan(angle)\n            swarm += delta\n            \n            # Clip positions to bounds\n            swarm = np.clip(swarm, lb, ub)\n            \n            # Evaluate new solutions\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n            \n            # Update personal bests\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n            \n            # Update global best\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n                \n            # Adaptive amplitude control based on success history\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    amplitude = max(min_amplitude, amplitude - 0.05)\n                else:\n                    amplitude = min(1.0, amplitude + 0.05)\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 3, "feedback": "The algorithm QuantumInspiredSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01415 with standard deviation 0.01294.", "error": "", "parent_ids": ["40c82831-6354-4350-9941-3a29dcf1e3a7"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.0050000000000000044, 0.032460090774435124]}}
{"id": "b7918432-5210-4638-a8d9-93149f2cdace", "fitness": 0.015565026070107605, "name": "AdaptiveDifferentialSwarmOptimizer", "description": "The Adaptive Differential Swarm Optimizer (ADSO) integrates differential evolution with swarm intelligence, applying adaptive mutation and crossover for improved exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveDifferentialSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initial swarm setup\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n        \n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        crossover_rate = 0.9\n        differential_weight = 0.8\n\n        while iter_count < self.budget - self.population_size:\n            # Dynamic inertia weight adaptation\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Update velocities and positions using swarm and differential evolution principles\n            for i in range(self.population_size):\n                indices = np.arange(self.population_size)\n                np.random.shuffle(indices)\n                a, b, c = swarm[indices[:3]]\n                \n                # Differential mutation\n                mutant_vector = a + differential_weight * (b - c)\n                mutant_vector = np.clip(mutant_vector, lb, ub)\n                \n                # Crossover\n                trial_vector = np.where(np.random.rand(self.dim) < crossover_rate, mutant_vector, swarm[i])\n                trial_vector = np.clip(trial_vector, lb, ub)\n                \n                trial_score = func(trial_vector)\n                iter_count += 1\n                \n                # Selection\n                if trial_score < personal_best_scores[i]:\n                    personal_best[i] = trial_vector\n                    personal_best_scores[i] = trial_score\n                    if trial_score < global_best_score:\n                        global_best = trial_vector\n                        global_best_score = trial_score\n\n                # Update velocities and positions based on personal and global bests\n                cognitive_component = np.random.uniform(size=self.dim) * (personal_best[i] - swarm[i])\n                social_component = np.random.uniform(size=self.dim) * (global_best - swarm[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                swarm[i] += velocities[i]\n                swarm[i] = np.clip(swarm[i], lb, ub)\n            \n            # Adaptive perturbation\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveDifferentialSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01557 with standard deviation 0.01207.", "error": "", "parent_ids": ["40c82831-6354-4350-9941-3a29dcf1e3a7"], "operator": null, "metadata": {"aucs": [0.009234987435887687, 0.0050000000000000044, 0.032460090774435124]}}
{"id": "76decbf8-269e-4a17-8d58-99e18da07cad", "fitness": 0.07858296858400908, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation introduces self-adapting velocity components and dynamic population size adjustment to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)  # Updated line\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 5, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["40c82831-6354-4350-9941-3a29dcf1e3a7"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "7a7f2f99-0dc4-42d9-9635-434f4391e245", "fitness": 0.05782889410621087, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Dynamic Swarm Strategy Refinement with Adaptive Inertia and Population Diversification enhances exploration-exploitation balance by dynamically adjusting inertia and incorporating a perturbation-based diversification strategy.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        perturbation_factor = 0.05  # New\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)  # Refined for smoother decrease\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = (inertia_weight * velocities \n                          + cognitive_component * np.random.rand() \n                          + social_component * np.random.rand())\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Enhanced population size adjustment and perturbation strategy\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 2, self.budget // 10)  # Increased adjustment rate\n\n            if iter_count % (self.population_size * 10) == 0:  # Adjusted frequency of perturbations\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, perturbation_factor, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                    swarm = np.clip(swarm, lb, ub)  # Ensure perturbed swarm stays within bounds\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05783 with standard deviation 0.02230.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.05790450746954756, 0.030481025144114104, 0.08510114970497096]}}
{"id": "32a140ca-bee3-445d-a031-707b1d2d2f33", "fitness": 0.05416113063584049, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Learning Rate incorporates a learning rate parameter to control velocity updates, aiming to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        learning_rate = 0.5  # New parameter for controlling velocity updates\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = (inertia_weight * velocities +\n                          learning_rate * (cognitive_component * np.random.rand() +\n                                           social_component * np.random.rand()))\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 7, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05416 with standard deviation 0.02184.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0786771566693254, 0.025630799582068153, 0.05817543565612793]}}
{"id": "b6f4c6bb-415b-489c-8aa9-1a4d5b4c69c2", "fitness": 0.03879969830250337, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Balanced Swarm Perturbation introduces adaptive learning rates and exploration-exploitation adjustments while maintaining population diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 0.95  # New line\n        learning_rate = 0.5  # New line\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            inertia_weight = min(max_inertia, inertia_weight + 0.005)  # Updated line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + learning_rate * cognitive_component * np.random.rand() + learning_rate * social_component * np.random.rand()  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n            if iter_count % (self.population_size * 10) == 0:  # New line\n                learning_rate = max(0.1, learning_rate - 0.05)  # New line\n        \n        return global_best_score, global_best", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03880 with standard deviation 0.01085.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.05334301481535231, 0.027306609194156173, 0.03574947089800162]}}
{"id": "af572b7a-3a47-40b3-81f1-9d5e99a66d9e", "fitness": 0.02625064933117538, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Modified Adaptive Swarm Perturbation with Diversity Reinforcement integrates diversity measures to prevent premature convergence and maintain balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            diversity = np.std(swarm, axis=0)\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            velocities += 0.1 * diversity * np.random.randn(self.population_size, self.dim)  # Added line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02625 with standard deviation 0.01241.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03465863727286145, 0.008699078495011503, 0.03539423222565319]}}
{"id": "e5dddfe1-410b-49a2-acbd-bddbeb18616f", "fitness": 0.07858296858400908, "name": "MultiPhaseSwarmExploration", "description": "Multi-Phase Swarm Exploration (MPSE) incorporates adaptive inertia and dynamic perturbation phases to enhance exploration-exploitation balance and adapt to problem landscape.", "code": "import numpy as np\n\nclass MultiPhaseSwarmExploration:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        phase_counter = 0\n\n        while iter_count < self.budget - self.population_size:\n            # Adaptive inertia weight phase\n            if phase_counter < 5:\n                inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            else:\n                # Dynamic perturbation phase\n                perturbation_scale = 0.2 * (1 - phase_counter / 10)\n                perturbation = np.random.normal(0, perturbation_scale, size=(self.population_size, self.dim))\n                swarm += perturbation\n                phase_counter = 0\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    phase_counter += 1\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 10, "feedback": "The algorithm MultiPhaseSwarmExploration got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "89dd54d5-bff8-4ff8-974b-d57bb8a66e11", "fitness": 0.05465875146037654, "name": "QuantumInspiredAdaptiveSwarmPerturbation", "description": "Quantum-Inspired Adaptive Swarm Perturbation introduces quantum-inspired mechanisms and adaptive mutation to enhance search diversity and convergence speed in dynamic environments.", "code": "import numpy as np\n\nclass QuantumInspiredAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 1.2  # Adjusted\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, min(max_inertia, 0.9 - 0.5 * (global_best_score / max(personal_best_scores))))  # Quantum-inspired inertia\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Adaptive mutation mechanism\n            if iter_count % (self.population_size * 5) == 0:\n                mutation_rate = 0.05 * (1.0 - global_best_score / np.max(personal_best_scores))\n                mutation = np.random.uniform(-mutation_rate, mutation_rate, size=(self.population_size, self.dim))\n                swarm += mutation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 11, "feedback": "The algorithm QuantumInspiredAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05466 with standard deviation 0.03547.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.07338227826659816, 0.0050000000000000044, 0.08559397611453146]}}
{"id": "19315e33-454f-411f-8cf5-7ec826d34e0a", "fitness": 0.033154161870923494, "name": "DynamicMultiSwarmCooperation", "description": "Dynamic Multi-Swarm Cooperation integrates distributed sub-swarms with periodic knowledge sharing and adaptive velocity adjustment to enhance convergence speed and accuracy.", "code": "import numpy as np\n\nclass DynamicMultiSwarmCooperation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.main_swarm_size = 10\n        self.sub_swarm_size = 5\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        main_swarm = np.random.uniform(lb, ub, (self.main_swarm_size, self.dim))\n        velocities = np.zeros((self.main_swarm_size, self.dim))\n        personal_best = main_swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in main_swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.main_swarm_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Update main swarm\n            cognitive_component = np.random.uniform(size=(self.main_swarm_size, self.dim)) * (personal_best - main_swarm)\n            social_component = np.random.uniform(size=(self.main_swarm_size, self.dim)) * (global_best - main_swarm)\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            main_swarm += velocities\n\n            main_swarm = np.clip(main_swarm, lb, ub)\n            scores = np.array([func(ind) for ind in main_swarm])\n            iter_count += self.main_swarm_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = main_swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Periodic knowledge sharing and sub-swarm evaluation\n            if iter_count % (self.main_swarm_size * 5) == 0:\n                sub_swarm = np.random.uniform(lb, ub, (self.sub_swarm_size, self.dim))\n                sub_swarm_scores = np.array([func(ind) for ind in sub_swarm])\n                iter_count += self.sub_swarm_size\n                if np.min(sub_swarm_scores) < global_best_score:\n                    global_best = sub_swarm[np.argmin(sub_swarm_scores)]\n                    global_best_score = np.min(sub_swarm_scores)\n\n                # Introduce small perturbations if no improvement\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.main_swarm_size, self.dim))\n                    main_swarm += perturbation\n\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 12, "feedback": "The algorithm DynamicMultiSwarmCooperation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03315 with standard deviation 0.00686.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03192247894166356, 0.025440717543829594, 0.04209928912727734]}}
{"id": "5d12a70b-b957-4b6e-ab73-44328042d402", "fitness": 0.04602327583694754, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Particle Swarm Optimization with Adaptive Inertia and Perturbation introduces diversity control via adaptive inertia and random restart to improve convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight * 0.99)  # Updated line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component + social_component\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    if iter_count % (self.population_size * 10) == 0:  # Updated line\n                        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))  # Updated line\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04602 with standard deviation 0.02818.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.051628962067131856, 0.009047390391653254, 0.07739347505205751]}}
{"id": "f31feeb3-81cb-483d-bb99-e6b5da98f7f1", "fitness": 0.0664124042930817, "name": "CoevolutionaryAdaptiveSwarm", "description": "Adaptive Swarm Perturbation with Coevolutionary Component introduces a coevolutionary strategy within the swarm to enhance convergence through cooperative adaptation and perturbation mechanisms.", "code": "import numpy as np\n\nclass CoevolutionaryAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population adjustment with coevolutionary strategy\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                \n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                \n                # Coevolutionary component\n                elite_fraction = 0.2\n                elites = int(self.population_size * elite_fraction)\n                elite_individuals = swarm[np.argsort(scores)[:elites]]\n                perturbation = np.mean(elite_individuals, axis=0)\n                swarm += perturbation * 0.1\n                \n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 14, "feedback": "The algorithm CoevolutionaryAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06641 with standard deviation 0.03264.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.06984669259052267]}}
{"id": "8d24941f-c581-4e86-8492-b511b46d7c95", "fitness": 0.07450529281735137, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Dynamic Swarm Exploration and Exploitation (DSEE) leverages adaptive inertia weight, enhanced perturbation, and conditional velocity reset to improve convergence and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight * 0.99)  # Adaptive inertia weight decay\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1 * inertia_weight, size=(self.population_size, self.dim))  # Scaled perturbation\n                    swarm += perturbation\n                    velocities = np.where(np.random.rand(self.population_size, self.dim) < 0.1, 0, velocities)  # Conditional reset\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07451 with standard deviation 0.03470.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.09016412641534133, 0.026399052476310247, 0.10695269956040254]}}
{"id": "d802e295-056b-4fea-87c9-c6d5d9fe073a", "fitness": 0.05193683838090172, "name": "AdaptiveHybridSwarmOptimization", "description": "Adaptive Hybrid Swarm Optimization with Progressive Learning dynamically adjusts population behavior and integrates differential mutation to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass AdaptiveHybridSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            # Differential mutation component\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:  # Mutation probability\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    donor_vector = swarm[indices[0]] + 0.8 * (swarm[indices[1]] - swarm[indices[2]])\n                    donor_vector = np.clip(donor_vector, lb, ub)\n                    if func(donor_vector) < personal_best_scores[i]:\n                        swarm[i] = donor_vector\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 16, "feedback": "The algorithm AdaptiveHybridSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05194 with standard deviation 0.04180.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.034171104668115904, 0.011991584664349686, 0.10964782581023957]}}
{"id": "1d055222-ca12-4480-9c05-dd9a15c03296", "fitness": 0.02489133141731618, "name": "AdaptiveSwarmPerturbationWithHistory", "description": "Adaptive Swarm Perturbation with History-Informed Dynamic Learning introduces history-based acceleration coefficients and matrix perturbations to optimize convergence behavior.", "code": "import numpy as np\n\nclass AdaptiveSwarmPerturbationWithHistory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            adaptive_c1 = 1.5 + 0.5 * np.random.uniform()  # New adaptive cognitive coefficient\n            adaptive_c2 = 1.5 + 0.5 * np.random.uniform()  # New adaptive social coefficient\n            \n            velocities = (inertia_weight * velocities +\n                          adaptive_c1 * cognitive_component * np.random.rand() +\n                          adaptive_c2 * social_component * np.random.rand())  # Updated lines\n            \n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # History-informed perturbation adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation * (np.abs(global_best - personal_best.mean(axis=0)))  # Updated line\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 17, "feedback": "The algorithm AdaptiveSwarmPerturbationWithHistory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02489 with standard deviation 0.02570.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.008498350516416453, 0.0050000000000000044, 0.06117564373553208]}}
{"id": "a2778cce-f601-446f-ab0d-37af487ab51d", "fitness": 0.04763246397929518, "name": "ImprovedAdaptiveSwarmPerturbation", "description": "Improved Adaptive Swarm Perturbation introduces an adaptive inertia weight strategy and adaptive mutation mechanism based on convergence rate, enhancing exploration-exploitation dynamics and preventing premature convergence.", "code": "import numpy as np\n\nclass ImprovedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 0.9\n        adaptive_inertia_delta = (max_inertia - min_inertia) / (self.budget // self.population_size)\n\n        while iter_count < self.budget - self.population_size:\n            convergence_rate = (self.history[-1] - global_best_score) / self.history[-1] if self.history[-1] != 0 else 0\n            inertia_weight = max(min_inertia, inertia_weight - adaptive_inertia_delta * convergence_rate)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if len(self.history) > 1 and self.history[-1] == self.history[-2]:\n                mutation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                swarm += mutation\n                swarm = np.clip(swarm, lb, ub)\n            \n            self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 18, "feedback": "The algorithm ImprovedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04763 with standard deviation 0.02650.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0423327269451349, 0.018156190472434997, 0.08240847452031563]}}
{"id": "a234acd0-9a31-4801-ba9a-c69636b3adec", "fitness": 0.04976222488604206, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with improved convergence by tweaking inertia weight dynamics to strengthen exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.015)  # Updated line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04976 with standard deviation 0.03166.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.07105929081590145, 0.0050000000000000044, 0.07322738384222471]}}
{"id": "540edab6-509b-4c28-8ce3-c1b18b2ee1ce", "fitness": 0.05776828494364261, "name": "AdvancedAdaptiveSwarm", "description": "Advanced Adaptive Swarm with Self-Adapting Mutation enhances exploration with adaptive mutation rates and variable inertia weight adjustments.", "code": "import numpy as np\n\nclass AdvancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 0.9  # New line\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)  # Changed line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size and mutation rate adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim)) * np.random.uniform(0.9, 1.1)  # Changed line\n                    swarm += perturbation\n                self.history.append(global_best_score)\n                inertia_weight = min(max_inertia, inertia_weight + 0.01)  # New line\n        \n        return global_best_score, global_best", "configspace": "", "generation": 20, "feedback": "The algorithm AdvancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05777 with standard deviation 0.02222.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.05790450746954756, 0.030481025144114104, 0.08491932221726617]}}
{"id": "3643679b-f861-4dc1-aa5a-73acc0f6abe9", "fitness": 0.04062248872183061, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Stochastic Memory and Adaptive Learning dynamically adjusts learning rates and memory components for diverse exploration and robust convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        learning_rate = 0.5  # New line\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Stochastic memory addition\n            memory_component = np.random.uniform(size=(self.population_size, self.dim)) * (np.random.uniform(lb, ub, (self.population_size, self.dim)) - swarm)  # New line\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * learning_rate + social_component * (1 - learning_rate) + memory_component  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n            # Adaptive learning rate adjustment\n            learning_rate = 0.5 + 0.5 * np.sin(iter_count / self.budget * np.pi)  # New line\n        \n        return global_best_score, global_best", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04062 with standard deviation 0.03293.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0844073753910567, 0.0050000000000000044, 0.032460090774435124]}}
{"id": "7f3b7b16-fe69-4f2d-ab38-213766b46ac4", "fitness": 0.07858296858400908, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation introduces self-adapting velocity components, dynamic population size adjustment, and diversity-based position reset to improve exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                else:  # New line: reset positions based on diversity\n                    diversity_threshold = 0.1\n                    diversity = np.std(swarm, axis=0).mean()\n                    if diversity < diversity_threshold:\n                        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 22, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "e1dd4059-fa12-4c56-a06f-2ecdf65819cf", "fitness": 0.030209825990475687, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Introducing Adaptive Velocity Damping and Enhanced Diversity Mechanism to further balance exploration and exploitation in dynamic environments.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities *= 0.95  # Adaptive velocity damping\n            velocities += inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                \n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.2, size=(self.population_size, self.dim))  # Increased diversity mechanism\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 23, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03021 with standard deviation 0.01973.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.053169387196991935, 0.0050000000000000044, 0.032460090774435124]}}
{"id": "9ab3ba71-c7f7-461e-a90c-bc87af953214", "fitness": 0.029096082752192925, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Adaptive Learning introduces adaptive learning factors with random forest-based refinement to balance exploration and exploitation.", "code": "import numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        self.rf = RandomForestRegressor(n_estimators=10)  # New line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand() * np.random.uniform(0.5, 1.5, size=(self.population_size, self.dim))  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                \n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                    self.rf.fit(swarm, scores)  # New line\n                    \n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02910 with standard deviation 0.01739.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03688048711296743, 0.0050000000000000044, 0.045407761143611336]}}
{"id": "b2c85e54-572e-4c7f-a4c5-49426ab55934", "fitness": 0.07858296858400908, "name": "AdvancedSwarmAdaptation", "description": "Advanced Swarm Adaptation introduces adaptive inertia, dynamic leader selection, and crowding distance to enhance exploration and exploitation while maintaining diversity.", "code": "import numpy as np\n\nclass AdvancedSwarmAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Dynamic leader selection using crowding distance\n            crowding_distances = np.abs(np.argsort(np.argsort(personal_best_scores)) - self.population_size // 2)\n            leader_index = np.argmax(crowding_distances)\n            leader_best = personal_best[leader_index]\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (leader_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 25, "feedback": "The algorithm AdvancedSwarmAdaptation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "962a9276-daa3-4516-8c64-212696a95af5", "fitness": 0.023286526776561473, "name": "IterativeHierarchicalSwarmOptimization", "description": "The Iterative Hierarchical Swarm Optimization (IHSO) introduces a multi-layered swarm with adaptive learning layers and fitness-sharing to enhance diversity and convergence speed.", "code": "import numpy as np\n\nclass IterativeHierarchicalSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.base_population_size = 20\n        self.layers = 3\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Initialize swarms for hierarchical layers\n        swarms = [np.random.uniform(lb, ub, (self.base_population_size, self.dim)) for _ in range(self.layers)]\n        velocities = [np.zeros((self.base_population_size, self.dim)) for _ in range(self.layers)]\n        personal_best = [swarm.copy() for swarm in swarms]\n        personal_best_scores = [np.array([func(ind) for ind in swarm]) for swarm in swarms]\n        \n        # Identify global best across all layers\n        all_bests = np.array([p[np.argmin(s)] for p, s in zip(personal_best, personal_best_scores)])\n        global_best_index = np.argmin([func(ind) for ind in all_bests])\n        global_best = all_bests[global_best_index]\n        global_best_score = func(global_best)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.base_population_size * self.layers:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            for i in range(self.layers):\n                cognitive_component = np.random.uniform(size=(self.base_population_size, self.dim)) * (personal_best[i] - swarms[i])\n                social_component = np.random.uniform(size=(self.base_population_size, self.dim)) * (global_best - swarms[i])\n                \n                velocities[i] = inertia_weight * velocities[i] + cognitive_component * np.random.rand() + social_component * np.random.rand()\n                swarms[i] += velocities[i]\n\n                swarms[i] = np.clip(swarms[i], lb, ub)\n\n                scores = np.array([func(ind) for ind in swarms[i]])\n                iter_count += self.base_population_size\n\n                better_indices = scores < personal_best_scores[i]\n                personal_best[i][better_indices] = swarms[i][better_indices]\n                personal_best_scores[i][better_indices] = scores[better_indices]\n\n            # Update global best\n            all_bests = np.array([p[np.argmin(s)] for p, s in zip(personal_best, personal_best_scores)])\n            global_best_index = np.argmin([func(ind) for ind in all_bests])\n            if func(all_bests[global_best_index]) < global_best_score:\n                global_best = all_bests[global_best_index]\n                global_best_score = func(global_best)\n\n            # Introduce fitness-sharing for diversity enhancement every few iterations\n            if iter_count % (self.base_population_size * self.layers * 5) == 0:\n                for i in range(self.layers):\n                    if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                        perturbation = np.random.normal(0, 0.1 / (i + 1), size=(self.base_population_size, self.dim))\n                        swarms[i] += perturbation\n                    self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 26, "feedback": "The algorithm IterativeHierarchicalSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02329 with standard deviation 0.01710.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.01871623912871001, 0.04614334120097441]}}
{"id": "94ac592b-541b-4289-ace9-413db6d01d45", "fitness": 0.0515250340944032, "name": "EnhancedAdaptiveSwarmPerturbationWithLocalSearch", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation and Local Search incorporates a local search strategy for refined convergence through improved exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbationWithLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def local_search(self, best_individual, func):\n        \"\"\"Apply a simple local search around the best individual found so far.\"\"\"\n        neighborhood_size = 0.1  # controls the magnitude of perturbations\n        local_best = best_individual.copy()\n        local_best_score = func(best_individual)\n        \n        for _ in range(5):\n            perturbation = np.random.uniform(-neighborhood_size, neighborhood_size, size=self.dim)\n            candidate = best_individual + perturbation\n            candidate_score = func(candidate)\n            if candidate_score < local_best_score:\n                local_best = candidate\n                local_best_score = candidate_score\n\n        return local_best_score, local_best\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n            # Local search around the global best\n            global_best_score, global_best = self.local_search(global_best, func)\n\n        return global_best_score, global_best", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbationWithLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05153 with standard deviation 0.03423.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.06321550018762057, 0.0050000000000000044, 0.08635960209558902]}}
{"id": "24684d5e-da8e-4041-a1b8-bd6a072795b7", "fitness": 0.02182647891928165, "name": "QuantumInspiredPSO", "description": "Quantum-inspired Particle Swarm Optimization incorporates a quantum behavior mechanism to enhance global search and avoid local optima, improving convergence speed and solution quality.", "code": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        quantum_factor = 0.1\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            \n            # Quantum behavior mechanism\n            quantum_shift = np.random.uniform(-quantum_factor, quantum_factor, (self.population_size, self.dim))\n            swarm = swarm + quantum_shift * np.sign(global_best - swarm)\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 28, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02183 with standard deviation 0.01272.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.024715270890484087, 0.0050000000000000044, 0.035764165867360864]}}
{"id": "017a4354-0a84-4ff1-8638-a157befdecbb", "fitness": 0.026919230967487162, "name": "IntegratedMultiSwarmPerturbation", "description": "Integrated Multi-Swarm Perturbation combines multiple interacting swarms with adaptive perturbation and learning from elite solutions to enhance exploration and convergence.", "code": "import numpy as np\n\nclass IntegratedMultiSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm_count = 3\n        swarms = [np.random.uniform(lb, ub, (self.population_size, self.dim)) for _ in range(swarm_count)]\n        velocities = [np.zeros((self.population_size, self.dim)) for _ in range(swarm_count)]\n        personal_bests = [swarm.copy() for swarm in swarms]\n        personal_best_scores = [np.array([func(ind) for ind in swarm]) for swarm in swarms]\n        global_best_indexes = [np.argmin(scores) for scores in personal_best_scores]\n        global_bests = [personal_bests[i][global_best_indexes[i]] for i in range(swarm_count)]\n        global_best_scores = [scores[global_best_indexes[i]] for i, scores in enumerate(personal_best_scores)]\n        best_global_best_index = np.argmin(global_best_scores)\n        overall_best = global_bests[best_global_best_index]\n        overall_best_score = global_best_scores[best_global_best_index]\n        self.history.append(overall_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size * swarm_count:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            for i in range(swarm_count):\n                cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_bests[i] - swarms[i])\n                social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_bests[i] - swarms[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                swarms[i] += velocities[i]\n                swarms[i] = np.clip(swarms[i], lb, ub)\n\n                scores = np.array([func(ind) for ind in swarms[i]])\n                iter_count += self.population_size\n\n                better_indices = scores < personal_best_scores[i]\n                personal_bests[i][better_indices] = swarms[i][better_indices]\n                personal_best_scores[i][better_indices] = scores[better_indices]\n\n                min_index = np.argmin(personal_best_scores[i])\n                if personal_best_scores[i][min_index] < global_best_scores[i]:\n                    global_bests[i] = personal_bests[i][min_index]\n                    global_best_scores[i] = personal_best_scores[i][min_index]\n\n                if personal_best_scores[i][min_index] < overall_best_score:\n                    overall_best = personal_bests[i][min_index]\n                    overall_best_score = personal_best_scores[i][min_index]\n\n            if iter_count % (self.population_size * swarm_count * 5) == 0:\n                best_global_best_index = np.argmin(global_best_scores)\n                overall_best = global_bests[best_global_best_index]\n                overall_best_score = global_best_scores[best_global_best_index]\n                perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                swarms = [swarm + perturbation for swarm in swarms]\n\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation_scale = 0.1 * (ub - lb)\n                    perturbation = np.random.normal(0, perturbation_scale, size=(self.population_size, self.dim))\n                    swarms = [swarm + perturbation for swarm in swarms]\n\n                self.history.append(overall_best_score)\n\n        return overall_best_score, overall_best", "configspace": "", "generation": 29, "feedback": "The algorithm IntegratedMultiSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02692 with standard deviation 0.01375.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.007875777498708825, 0.03986816381143177, 0.033013751592320895]}}
{"id": "00f10c71-a08f-4f0c-91e5-58c1ff939dfd", "fitness": 0.04170902907556381, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Refined velocity update strategy by scaling cognitive and social components with a decaying factor for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            decaying_factor = 0.99 ** iter_count\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() * decaying_factor + social_component * np.random.rand() * decaying_factor  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)  # Updated line\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04171 with standard deviation 0.01643.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.04657757114534522, 0.019599744868937674, 0.05894977121240852]}}
{"id": "5bda6fb6-f4d0-41be-b058-17d86a8eb271", "fitness": 0.07858296858400908, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation and Quantum Perturbation introduces quantum-inspired perturbations for improved exploration in high-dimensional spaces.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n            \n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    quantum_perturbation = np.random.laplace(0, 0.1, size=(self.population_size, self.dim))  # Updated line\n                    swarm += quantum_perturbation  # Updated line\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "ed9a5f01-d7d6-4b29-90c3-d2a4e4072d2b", "fitness": 0.06239937543781937, "name": "EnhancedAdaptiveSwarmPerturbationWithMomentumDiversity", "description": "Enhanced Adaptive Swarm Perturbation with Momentum Diversity employs momentum-based velocity updates and introduces diversity maintenance mechanisms to improve convergence speed and robustness.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbationWithMomentumDiversity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n\n            velocities = inertia_weight * velocities + cognitive_component + social_component\n\n            # Introduce momentum to preserve previous velocity trends\n            velocities += 0.1 * np.random.randn(self.population_size, self.dim)\n\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n            # Diversity maintenance by periodically re-initializing part of the swarm\n            if iter_count % (self.population_size * 10) == 0:\n                reinit_indices = np.random.choice(self.population_size, size=self.population_size // 5, replace=False)\n                swarm[reinit_indices] = np.random.uniform(lb, ub, (len(reinit_indices), self.dim))\n\n        return global_best_score, global_best", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbationWithMomentumDiversity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06240 with standard deviation 0.06401.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.030477870686210662, 0.0050000000000000044, 0.15172025562724745]}}
{"id": "5bee45da-fb40-4fe9-9670-c84e2f607305", "fitness": 0.048928368234105735, "name": "HybridizedSwarmDE", "description": "Hybridized Swarm with Differential Evolution incorporates differential evolution strategies into swarm dynamics for enhanced diversity and convergence.", "code": "import numpy as np\n\nclass HybridizedSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        F = 0.5\n        CR = 0.9\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            # Apply Differential Evolution strategy\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = swarm[indices]\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, lb, ub)\n                trial = np.where(np.random.rand(self.dim) < CR, mutant, swarm[i])\n                trial_score = func(trial)\n                if trial_score < personal_best_scores[i]:\n                    swarm[i] = trial\n                    personal_best[i] = trial\n                    personal_best_scores[i] = trial_score\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 33, "feedback": "The algorithm HybridizedSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04893 with standard deviation 0.01608.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.07108880139295837, 0.033443183036368285, 0.04225312027299055]}}
{"id": "91a32cdf-a0d4-48c2-b44a-385fdc0dac01", "fitness": 0.04730820303504024, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Dynamic Inertia Weight introduces a dynamic inertia weight adjustment based on performance feedback to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Dynamic inertia weight adjustment based on performance feedback\n            if len(self.history) > 1 and self.history[-1] > self.history[-2]:\n                inertia_weight = max(min_inertia, inertia_weight - 0.05)  # Changed line\n            else:\n                inertia_weight = min(0.9, inertia_weight + 0.02)  # Changed line\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 34, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04731 with standard deviation 0.02204.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03899182054653072, 0.02544986164152807, 0.07748292691706193]}}
{"id": "b1fbef0a-e89d-4745-ba81-38209d18bcee", "fitness": 0.06727557125472032, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Adaptive Swarm Perturbation with Local Search introduces a local search phase and improved population dynamics to enhance convergence speed and solution diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                \n                # Local search phase\n                local_search_swarm = swarm + np.random.uniform(-0.05, 0.05, (self.population_size, self.dim))\n                local_search_swarm = np.clip(local_search_swarm, lb, ub)\n                local_score = np.array([func(ind) for ind in local_search_swarm])\n                iter_count += self.population_size\n                improving_indices = local_score < scores\n                swarm[improving_indices] = local_search_swarm[improving_indices]\n                scores[improving_indices] = local_score[improving_indices]\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06728 with standard deviation 0.03155.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.027417188641885137, 0.06984669259052267]}}
{"id": "d3460622-fa3b-4220-aad0-904d394b1684", "fitness": 0.07008198486179444, "name": "QuantumInspiredSwarmPerturbation", "description": "Quantum-Inspired Swarm Perturbation integrates quantum principles with swarm dynamics, incorporating probabilistic position updates and adaptive quorum sensing for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass QuantumInspiredSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        quantum_factor = 0.5  # New parameter for quantum-inspired update\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            \n            # Quantum-inspired position update\n            if np.random.rand() < quantum_factor:\n                swarm = np.random.uniform(swarm - velocities, swarm + velocities)\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Adaptive quorum sensing for perturbation\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1 * np.std(swarm, axis=0), size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 36, "feedback": "The algorithm QuantumInspiredSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07008 with standard deviation 0.05593.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.1488618811297744, 0.02451019563106005, 0.03687387782454887]}}
{"id": "16712af4-62da-4b3b-9ffe-a31b5449ac72", "fitness": 0.041342031208585005, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Minor refinement of Enhanced Adaptive Swarm Perturbation by adjusting velocity update and perturbation frequency to improve convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + 0.5 * cognitive_component * np.random.rand() + 1.5 * social_component * np.random.rand()  # Adjusted weights\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 7) == 0:  # Changed perturbation frequency\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04134 with standard deviation 0.00764.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03365947903690403, 0.05176537535787029, 0.03860123923098069]}}
{"id": "52df1249-48c0-436b-8465-9388cc30b105", "fitness": 0.03980539175446581, "name": "EnhancedAdaptiveSwarmPerturbationHybridMemory", "description": "Enhanced Adaptive Swarm Perturbation with Hybrid Memory utilizes a hybrid memory mechanism combining personal and historical bests to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbationHybridMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        historical_best = global_best.copy()\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        \n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            historical_component = np.random.uniform(size=(self.population_size, self.dim)) * (historical_best - swarm)\n\n            velocities = (\n                inertia_weight * velocities + \n                cognitive_component * np.random.rand() + \n                social_component * np.random.rand() + \n                0.5 * historical_component * np.random.rand()\n            )\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Update historical best for diversity\n            if global_best_score < func(historical_best):\n                historical_best = global_best.copy()\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbationHybridMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03981 with standard deviation 0.02231.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.046936351819434785, 0.00962007241365681, 0.06285975103030583]}}
{"id": "bc3a8ee0-f930-40f9-bc29-94a180aef145", "fitness": 0.03626055807969938, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Dynamic Inertia and Crossover Integration combines adaptive inertia weight and crossover operations to enhance the exploration-exploitation balance, aiming to achieve faster convergence and more robust performance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 0.9\n\n        while iter_count < self.budget - self.population_size:\n            # Dynamic inertia weight adjustment\n            inertia_weight = max(min_inertia, max_inertia - (max_inertia - min_inertia) * iter_count / self.budget)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n\n            # Crossover operation\n            crossover_prob = 0.1\n            for i in range(self.population_size):\n                if np.random.rand() < crossover_prob:\n                    partner_idx = np.random.randint(0, self.population_size)\n                    mask = np.random.rand(self.dim) < 0.5\n                    swarm[i][mask] = swarm[partner_idx][mask]\n\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03626 with standard deviation 0.02136.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.04887627747616907, 0.0061816593948345044, 0.05372373736809455]}}
{"id": "bda634f6-e82b-4f6d-b36c-65557caf8751", "fitness": 0.05782889410621087, "name": "AdvancedDynamicSwarm", "description": "Advanced Dynamic Swarm with Adaptive Mutation combines adaptive velocity scaling and local search mutations to enhance exploration and exploitation in dynamic environments.", "code": "import numpy as np\n\nclass AdvancedDynamicSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 2) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05 * (ub - lb), size=(self.population_size, self.dim))\n                    local_mutation = np.random.normal(0, 0.02, size=(self.population_size, self.dim))\n                    swarm += perturbation + local_mutation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 40, "feedback": "The algorithm AdvancedDynamicSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05783 with standard deviation 0.02230.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.05790450746954756, 0.030481025144114104, 0.08510114970497096]}}
{"id": "a1e5b892-c7c9-4e17-afe0-9f9cb264a4d1", "fitness": 0.052106669392327186, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Dynamic Learning Rate introduces adaptive learning rates and multi-level perturbation to efficiently balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        learning_rate = 0.5\n\n        while iter_count < self.budget - self.population_size:\n            # Adaptive learning rate\n            learning_rate = max(0.1, learning_rate * (1 - 0.01 * iter_count / self.budget))\n\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + learning_rate * (cognitive_component * np.random.rand() + social_component * np.random.rand())\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                # Multi-level perturbation strategy\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05 + 0.05 * (iter_count / self.budget), size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05211 with standard deviation 0.02093.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0752498015535834, 0.02455129417071855, 0.05651891245267959]}}
{"id": "4d96d6da-15ee-43b3-83d9-06643b06d3c4", "fitness": 0.07858296858400908, "name": "AdaptiveQuantumInspiredSwarm", "description": "Adaptive Quantum-inspired Swarm Optimization enhances swarm intelligence with quantum principles for improved global search capabilities.", "code": "import numpy as np\n\nclass AdaptiveQuantumInspiredSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        delta = 0.01  # New quantum parameter\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - delta)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation * (1 + np.sin(delta * iter_count))  # Quantum-inspired perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 42, "feedback": "The algorithm AdaptiveQuantumInspiredSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "68368afe-5f27-4713-83d6-c87dce0722a3", "fitness": 0.06594876589790151, "name": "ImprovedAdaptiveSwarmPerturbation", "description": "ImprovedAdaptiveSwarmPerturbation with Dynamic Inertia and Adaptive Neighborhood utilizes a dynamic inertia weight tailored to the convergence rate and integrates an adaptive neighborhood search to enhance global optimization and convergence speed.", "code": "import numpy as np\n\nclass ImprovedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        neighborhood_size = 5\n\n        while iter_count < self.budget - self.population_size:\n            improvement_rate = abs(self.history[-1] - global_best_score) / max(1, self.history[-1])\n            inertia_weight = max(min_inertia, inertia_weight - 0.1 * improvement_rate)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            # Adaptive neighborhood search\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(np.delete(np.arange(self.population_size), i), neighborhood_size, replace=False)\n                    neighborhood_best = personal_best[indices].mean(axis=0)\n                    swarm[i] += np.random.normal(0, 0.1, self.dim) * (neighborhood_best - swarm[i])\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 43, "feedback": "The algorithm ImprovedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06595 with standard deviation 0.01910.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.09296454402475196, 0.052289921632046044, 0.05259183203690654]}}
{"id": "63c0235e-17f7-4072-86e7-8f4b3c596036", "fitness": 0.025847666512449814, "name": "AdaptiveHybridSwarmOptimization", "description": "Adaptive Hybrid Swarm Optimization combines self-adaptive velocity and perturbation strategies with differential evolution-like crossover to enhance exploration and exploitation trade-off.", "code": "import numpy as np\n\nclass AdaptiveHybridSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        crossover_probability = 0.7\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n\n            # Crossover operation inspired by Differential Evolution\n            for i in range(self.population_size):\n                if np.random.rand() < crossover_probability:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    trial_vector = (swarm[indices[0]] + 0.5 * (swarm[indices[1]] - swarm[indices[2]]))\n                    trial_vector = np.clip(trial_vector, lb, ub)\n                    if func(trial_vector) < personal_best_scores[i]:\n                        swarm[i] = trial_vector\n\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Perturbation strategy\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 44, "feedback": "The algorithm AdaptiveHybridSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02585 with standard deviation 0.00905.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03202439713729377, 0.01305851162562055, 0.032460090774435124]}}
{"id": "576eb1c1-136b-464c-a96c-c42d148abcae", "fitness": 0.07858296858400908, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptive Mutation introduces a novel self-adaptive mutation strategy to maintain diversity and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Self-adaptive mutation strategy\n            if iter_count % (self.population_size * 10) == 0:\n                mutation_strength = np.exp(-np.mean(personal_best_scores) / (np.std(personal_best_scores) + 1e-10))\n                perturbation = np.random.normal(0, mutation_strength, size=(self.population_size, self.dim))\n                swarm += perturbation\n                swarm = np.clip(swarm, lb, ub)\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "f4792125-55b2-4f75-a3aa-c06a713aea36", "fitness": 0.059803175040758605, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Diversity Control incorporates diversity preservation techniques using crowding distance to improve robustness and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n            # Diversity control through crowding distance\n            if iter_count % (self.population_size * 3) == 0:  # Updated line\n                distances = np.linalg.norm(swarm - global_best, axis=1)  # Updated line\n                diversity_threshold = np.mean(distances) * 0.5  # Updated line\n                for i in range(self.population_size):  # Updated line\n                    if distances[i] < diversity_threshold:  # Updated line\n                        swarm[i] = np.random.uniform(lb, ub, self.dim)  # Updated line\n\n        return global_best_score, global_best", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05980 with standard deviation 0.04126.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.0050000000000000044, 0.06984669259052267]}}
{"id": "c83d9687-29a0-4951-8bc1-c67ba505a88d", "fitness": 0.028046393975563928, "name": "QuantumInspiredDynamicSwarm", "description": "Quantum-inspired Dynamic Swarm Optimization integrates quantum behaviors into particle dynamics with adaptive dynamic grouping to enhance exploration and exploitation in optimization tasks.", "code": "import numpy as np\n\nclass QuantumInspiredDynamicSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.group_size = 5  # Initial group size for dynamic grouping\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n\n            quantum_position = global_best + np.random.normal(0, 0.1, (self.population_size, self.dim))\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (quantum_position - swarm)\n\n            velocities = inertia_weight * velocities + cognitive_component + social_component\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Adaptive dynamic grouping\n            if iter_count % (self.population_size * 5) == 0:\n                self.group_size = min(self.group_size + 1, self.dim // 2)\n                self.population_size = min(self.population_size + self.group_size, self.budget // 10) \n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 47, "feedback": "The algorithm QuantumInspiredDynamicSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02805 with standard deviation 0.01326.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.009790470769654558, 0.040888485852027645, 0.03346022530500958]}}
{"id": "4a68d661-a142-4a04-b7c6-7b44ad32df4b", "fitness": 0.03472832562270215, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Stabilized Velocity introduces a stabilization factor to the velocity update to improve convergence stability.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        stabilization_factor = 0.5  # New line added\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            velocities *= stabilization_factor  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03473 with standard deviation 0.01522.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.014438839700709694, 0.03863786919848233, 0.051108267968914434]}}
{"id": "69497c56-577e-4530-b4a7-9c5e72466b2e", "fitness": 0.05782889410621087, "name": "MultiPhaseAdaptiveSwarmOptimization", "description": "The Multi-Phase Adaptive Swarm Optimization enhances exploration and exploitation through dynamically adjusting inertia, velocity components, and population size with environment-based phase transitions.", "code": "import numpy as np\n\nclass MultiPhaseAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.init_population_size = 20\n        self.population_size = self.init_population_size\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        exploration_factor = 1.0\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + exploration_factor * (cognitive_component * np.random.rand() + social_component * np.random.rand())\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Phase transition based on convergence\n            if iter_count % (self.population_size * 10) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    exploration_factor = np.random.choice([0.9, 1.1])\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                else:\n                    exploration_factor = 1.0\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 49, "feedback": "The algorithm MultiPhaseAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05783 with standard deviation 0.02230.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.05790450746954756, 0.030481025144114104, 0.08510114970497096]}}
{"id": "0497cfa7-315e-4b83-9684-8a0b1d526cb1", "fitness": 0.07450529281735137, "name": "EnhancedSwarmPerturbationWithDynamicInertia", "description": "Enhanced Swarm Perturbation with Dynamic Inertia and Adaptive Mutation leverages dynamic inertia weight adjustment and adaptive mutation strategies to improve convergence and solution diversity.", "code": "import numpy as np\n\nclass EnhancedSwarmPerturbationWithDynamicInertia:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight * 0.99)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Adaptive mutation strategy\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    mutation_rate = 1.0 - (global_best_score - np.min(personal_best_scores)) / (np.std(personal_best_scores) + 1e-9)\n                    perturbation = np.random.normal(0, mutation_rate, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedSwarmPerturbationWithDynamicInertia got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07451 with standard deviation 0.03470.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.09016412641534133, 0.026399052476310247, 0.10695269956040254]}}
{"id": "647ae4dc-0d80-4982-b7ad-ca7902deb218", "fitness": 0.03971637546105052, "name": "AdaptiveQuantumSwarmPerturbation", "description": "Adaptive Quantum Swarm Perturbation incorporates quantum-inspired position updates and adaptive inertia scaling to improve convergence on diverse optimization landscapes.", "code": "import numpy as np\n\nclass AdaptiveQuantumSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 0.9\n        adaptive_threshold = 5\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            # Quantum-inspired position updates\n            quantum_jump = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand() + quantum_jump\n            \n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Adaptive inertia scaling based on performance\n            if iter_count % (self.population_size * adaptive_threshold) == 0:\n                if len(self.history) > 1 and self.history[-1] >= self.history[-2]:\n                    inertia_weight = min(max_inertia, inertia_weight + 0.05)\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 51, "feedback": "The algorithm AdaptiveQuantumSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03972 with standard deviation 0.01208.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.04348351907646586, 0.0234031752748316, 0.0522624320318541]}}
{"id": "c20bccdb-efed-4c0e-8933-a42e2c166909", "fitness": 0.014679063565478398, "name": "QuantumInspiredAdaptiveSwarmPerturbation", "description": "Quantum-Inspired Adaptive Swarm Perturbation leverages quantum superposition principles to dynamically explore the search space, enhancing convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass QuantumInspiredAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n\n            # Quantum-inspired superposition for exploration\n            quantum_component = np.random.uniform(-1, 1, (self.population_size, self.dim)) * (ub - lb) / 2\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand() + quantum_component\n            \n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 52, "feedback": "The algorithm QuantumInspiredAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01468 with standard deviation 0.01259.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.0065770999220000625, 0.032460090774435124]}}
{"id": "f00ce650-961d-4d20-a8d6-e2aaeab3289d", "fitness": 0.05416113063584049, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Self-Adaptive Particle Swarm Optimization with Learning Rate Control introduces adaptive learning rates for velocity and population perturbation strategies to enhance convergence speed and exploration balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        self.learning_rate = 0.5  # New line: Introduce adaptive learning rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() * self.learning_rate \\\n                         + social_component * np.random.rand() * self.learning_rate  # Updated line with learning rate\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1 * self.learning_rate, size=(self.population_size, self.dim))  # Updated line with learning rate\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n            # New block for adaptive learning rate update\n            if iter_count % (self.population_size * 10) == 0:\n                self.learning_rate = max(0.1, self.learning_rate * 0.9)  # Decay learning rate over time\n        \n        return global_best_score, global_best", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05416 with standard deviation 0.02184.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0786771566693254, 0.025630799582068153, 0.05817543565612793]}}
{"id": "153a1c2c-349a-4958-a8eb-83ab03c2c551", "fitness": 0.0552217689117499, "name": "AdaptivePSOWithDiversity", "description": "Adaptive Particle Swarm Optimization with Diversity Preservation integrates adaptive learning rates and a diversity preservation mechanism to enhance exploration without losing promising solutions.", "code": "import numpy as np\n\nclass AdaptivePSOWithDiversity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, 0.9 - 0.5 * (1 - iter_count / self.budget))\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                distances = np.linalg.norm(swarm - global_best, axis=1)\n                if np.max(distances) < 0.1 * (ub - lb).mean():\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 54, "feedback": "The algorithm AdaptivePSOWithDiversity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05522 with standard deviation 0.02729.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.04373493029787834, 0.02905687878291885, 0.09287349765445252]}}
{"id": "bba76181-fb45-4c75-b689-d2e8a078826d", "fitness": -Infinity, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Dynamic Adaptive Inertia and Population Scaling refines the balance between exploration and exploitation with a novel inertia adjustment and population scaling approach.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 1.2  # New line\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = np.clip(inertia_weight - 0.01, min_inertia, max_inertia)  # Updated line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 2, self.budget // 8)  # Updated line\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05, size=(self.population_size, self.dim))  # Updated line\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 55, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (22,2) (20,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (22,2) (20,2) ')", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {}}
{"id": "40bae513-67a8-4339-afb7-c4fb965096bf", "fitness": 0.05141119290965893, "name": "DynamicSwarmAdaptationWithMemory", "description": "Dynamic Swarm Adaptation with Historical Memory introduces a memory mechanism to learn from past iterations, dynamically adjusts both inertia and population size based on convergence rates, and employs adaptive perturbation for improved exploration and exploitation.", "code": "import numpy as np\n\nclass DynamicSwarmAdaptationWithMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        self.convergence_rate = []\n        self.max_population_increment = 5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, 0.9 - 0.005 * len(self.convergence_rate))\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            self.convergence_rate.append(np.abs(global_best_score - np.min(scores)))\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n                \n                if len(self.convergence_rate) > 5:\n                    recent_rates = self.convergence_rate[-5:]\n                    avg_rate = np.mean(recent_rates)\n                    if avg_rate < 0.01:\n                        self.population_size = min(self.population_size + self.max_population_increment, self.budget // 10)\n\n        return global_best_score, global_best", "configspace": "", "generation": 56, "feedback": "The algorithm DynamicSwarmAdaptationWithMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05141 with standard deviation 0.02764.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.04825501248003472, 0.019245348814349805, 0.08673321743459228]}}
{"id": "c97e8590-4aad-4f00-8219-a8bb2835c5ea", "fitness": 0.018740984420214324, "name": "AdvancedDynamicSwarmAdaptation", "description": "Advanced Dynamic Swarm Adaptation optimizes search by incorporating adaptive scaling of velocity and dynamic regrouping, improving convergence and exploration balance.", "code": "import numpy as np\n\nclass AdvancedDynamicSwarmAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        self.scale_factor = 0.5\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.5\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)\n            local_search_strength = np.random.uniform(0.1, 0.3)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            velocities *= self.scale_factor  # Adaptive scaling of velocity\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic regrouping adapts population diversity\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Perturbation if convergence is stagnant\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, local_search_strength, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 57, "feedback": "The algorithm AdvancedDynamicSwarmAdaptation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01874 with standard deviation 0.01128.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.018604557039240133, 0.0050000000000000044, 0.032618396221402834]}}
{"id": "fe8c1192-8c69-41aa-b0d0-22075b4f8c38", "fitness": 0.07858296858400908, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation introduces self-adapting velocity components and dynamic population size adjustment to improve exploration and exploitation balance with an additional random perturbation to diversify search.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "5ce918f7-32e7-436f-92ac-d6d4dde948a5", "fitness": 0.03926385813725616, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Hybrid Swarm Optimization with Dynamic Neighborhood and Adaptive Velocity introduces adaptive neighborhood size and velocity scaling for enhanced performance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        self.neighborhood_size = 5  # New line for dynamic neighborhood\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            # Updated line: Adaptive velocity scaling\n            velocity_scaling = 1.0 - (iter_count / self.budget)\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() * velocity_scaling + social_component * np.random.rand() * velocity_scaling  \n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    # New line: Dynamic Neighborhood Perturbation\n                    neighborhood = np.random.choice(self.population_size, size=self.neighborhood_size, replace=False)\n                    perturbation = np.random.normal(0, 0.1, size=(self.neighborhood_size, self.dim))\n                    swarm[neighborhood] += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03926 with standard deviation 0.02423.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.051634892044600256, 0.0054036506872735535, 0.060753031679894653]}}
{"id": "83e2673c-065a-4c28-86c1-95a38d8e861a", "fitness": 0.052161651138492394, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Novel Perturbation and Adaptive Inertia introduces a novel perturbation mechanism and adaptive inertia weight adjustment to improve convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Adaptive inertia weight adjustment\n            inertia_weight = max(min_inertia, 0.5 + 0.4 * np.abs(np.sin(0.1 * iter_count)))  # Changed line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10) \n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    # Novel perturbation mechanism\n                    perturbation = np.random.uniform(-0.05, 0.05, size=(self.population_size, self.dim))  # Changed\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05216 with standard deviation 0.03734.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.047178657274878355, 0.009130264011397493, 0.10017603212920134]}}
{"id": "9a1a4659-2147-41a4-b5fc-1cff04d2c078", "fitness": 0.04476052260643663, "name": "QuantumInfluencedSwarmOptimization", "description": "The Quantum-Influenced Swarm Optimization (QISO) introduces a quantum probability approach to enhance global search potential, allowing particles to explore non-contiguous regions effectively, balancing exploration and exploitation in black-box optimization.", "code": "import numpy as np\n\nclass QuantumInfluencedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        quantum_factor = 0.05\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Quantum probability influenced exploration\n            quantum_motion = quantum_factor * (np.random.uniform(size=(self.population_size, self.dim)) - 0.5) * (ub - lb)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand() + quantum_motion\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 61, "feedback": "The algorithm QuantumInfluencedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04476 with standard deviation 0.01118.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03738135722477054, 0.03633494380089797, 0.06056526679364138]}}
{"id": "0699631d-d699-42fb-a907-a90d264c8c7b", "fitness": 0.06968571941914699, "name": "EnhancedSwarmPerturbationWithClustering", "description": "Enhanced Swarm Perturbation with Adaptive Memory and Divisive Clustering utilizes adaptive memory to enhance diversity and divisive clustering to refine exploration, improving convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedSwarmPerturbationWithClustering:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        self.memory = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.memory.append(swarm.copy())\n\n                # Divisive Clustering\n                cluster_centers = self.divisive_clustering(swarm)\n                perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                for i in range(len(cluster_centers)):\n                    swarm[i] = cluster_centers[i] + perturbation[i]\n                \n                self.history.append(global_best_score)\n\n        return global_best_score, global_best\n\n    def divisive_clustering(self, swarm):\n        # A simple divisive clustering approach by bisecting the current swarm\n        center = np.mean(swarm, axis=0)\n        left_cluster = swarm[swarm[:, 0] < center[0]]\n        right_cluster = swarm[swarm[:, 0] >= center[0]]\n        cluster_centers = [np.mean(left_cluster, axis=0), np.mean(right_cluster, axis=0)]\n        return cluster_centers", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedSwarmPerturbationWithClustering got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06969 with standard deviation 0.03339.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10489904116317117, 0.024827687756969308, 0.0793304293373005]}}
{"id": "5c441603-16cf-43e7-8d7e-bbe717069a38", "fitness": 0.04971181987703954, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Introducing a dynamic learning factor adjustment to further enhance the balance between exploration and exploitation in the swarm perturbation mechanism.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        learning_factor_base = 2.0\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            learning_factor = learning_factor_base * (1 - iter_count / self.budget)  # Updated line\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + learning_factor * (cognitive_component * np.random.rand() + social_component * np.random.rand())  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04971 with standard deviation 0.02331.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.07681053026290241, 0.01990830614495498, 0.05241662322326124]}}
{"id": "7fe02869-9fcf-4c70-b715-57acc53f62bd", "fitness": 0.07450529281735137, "name": "EnhancedExploratoryPerturbation", "description": "Enhanced Exploratory Perturbation integrates adaptive velocity scaling and periodic random diversification to sharpen global convergence in dynamic environments.", "code": "import numpy as np\n\nclass EnhancedExploratoryPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight * 0.99)  # Adaptive inertia scaling\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.2, size=(self.population_size, self.dim))  # Increased perturbation\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedExploratoryPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07451 with standard deviation 0.03470.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.09016412641534133, 0.026399052476310247, 0.10695269956040254]}}
{"id": "a22a1db0-10e4-4a54-9116-818de631e69a", "fitness": 0.045686686355371396, "name": "EnhancedAdaptiveSwarmQuantumTunneling", "description": "Enhanced Adaptive Swarm with Quantum Tunneling incorporates quantum behavior to escape local optima and improve global exploration through probabilistic tunneling.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmQuantumTunneling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        quantum_threshold = 0.1  # Probability threshold for quantum tunneling\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Quantum tunneling\n            for i in range(self.population_size):\n                if np.random.rand() < quantum_threshold:\n                    swarm[i] = np.random.uniform(lb, ub, self.dim)\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedAdaptiveSwarmQuantumTunneling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04569 with standard deviation 0.03838.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.034910944744362626, 0.09714911432175155]}}
{"id": "d79beca5-391d-41f3-985a-2a3a06cbcee1", "fitness": -Infinity, "name": "AdaptiveSwarmPerturbationDynamicNeighborhood", "description": "Adaptive Swarm Perturbation with Dynamic Neighborhood introduces neighborhood-based exploration and self-adjusting perturbation influenced by convergence trends to enhance convergence speed and robustness.", "code": "import numpy as np\n\nclass AdaptiveSwarmPerturbationDynamicNeighborhood:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        \n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Define dynamic neighborhood radius\n            neighborhood_radius = (ub - lb) * (1 - iter_count / self.budget)\n            \n            for i in range(self.population_size):\n                distances = np.linalg.norm(swarm - swarm[i], axis=1)\n                neighbors = np.where(distances < neighborhood_radius)[0]\n                if len(neighbors) > 1:\n                    local_best = personal_best[neighbors[np.argmin(personal_best_scores[neighbors])]]\n                else:\n                    local_best = personal_best[i]\n                \n                cognitive_component = np.random.uniform(size=self.dim) * (personal_best[i] - swarm[i])\n                social_component = np.random.uniform(size=self.dim) * (local_best - swarm[i])\n                \n                velocities[i] = inertia_weight * velocities[i] + cognitive_component * np.random.rand() + social_component * np.random.rand()\n                \n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                perturbation = np.random.normal(0, 0.1 * (1 - iter_count / self.budget), size=(self.population_size, self.dim))\n                swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 66, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (20,) (2,) ').", "error": "ValueError('operands could not be broadcast together with shapes (20,) (2,) ')", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {}}
{"id": "8c392750-ccfd-4181-8937-eff698c8da51", "fitness": 0.0056240539316334175, "name": "QuantumEnhancedAdaptiveSwarm", "description": "The Quantum-Enhanced Adaptive Swarm introduces quantum-inspired initialization and dynamic inertia adjustment to enhance convergence speed and solution quality.", "code": "import numpy as np\n\nclass QuantumEnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        \n        # Quantum-inspired initialization\n        swarm = lb + (ub - lb) * np.random.rand(self.population_size, self.dim)**2\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 0.9\n\n        while iter_count < self.budget - self.population_size:\n            # Dynamic inertia based on convergence\n            if len(self.history) > 1:\n                progress = (self.history[-2] - self.history[-1]) / self.history[-2]\n                inertia_weight = max(min_inertia, min(max_inertia, inertia_weight + 0.05*(0.5 - progress)))\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 67, "feedback": "The algorithm QuantumEnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00562 with standard deviation 0.00088.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0068721617949002445, 0.0050000000000000044, 0.0050000000000000044]}}
{"id": "ea735119-7446-43cb-a6df-97a887c0ccd0", "fitness": 0.022940673402884082, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Swarm Perturbation with Adaptive Learning Rate integrates adaptive learning rate scheduling and neighborhood influence to refine exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        self.learning_rate = 0.5  # Added line\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            neighborhood_influence = np.mean(swarm, axis=0)  # Added line\n            velocities = (inertia_weight * velocities + self.learning_rate * cognitive_component * np.random.rand() + \n                          self.learning_rate * social_component * np.random.rand() + \n                          0.1 * np.random.uniform(size=(self.population_size, self.dim)) * (neighborhood_influence - swarm))  # Modified line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n            \n            self.learning_rate = max(0.1, self.learning_rate * 0.99)  # Added line\n        \n        return global_best_score, global_best", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02294 with standard deviation 0.00996.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.014976046360163475, 0.016860103796058734, 0.03698587005243004]}}
{"id": "d3d4dddb-73c2-4a5c-b55e-fa7ea827f61f", "fitness": 0.04803080261930585, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "The Enhanced Adaptive Swarm Perturbation with Inertia Weight Annealing introduces an exponential decay factor for inertia weight, improves randomization in velocity updates, and dynamically adapts exploration strategies based on convergence trends to enhance optimization performance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Exponential decay for inertia weight\n            inertia_weight *= 0.99  \n            inertia_weight = max(min_inertia, inertia_weight)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = (inertia_weight * velocities + \n                          cognitive_component * np.random.rand(self.population_size, 1) + \n                          social_component * np.random.rand(self.population_size, 1))\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Dynamic exploration strategy\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1 * (1 - iter_count / self.budget), size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04803 with standard deviation 0.01606.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.04795867750100502, 0.028393131047279363, 0.06774059930963316]}}
{"id": "a9b4e495-4dcd-43ce-9800-67e257c2cf3a", "fitness": 0.014153363591478377, "name": "QuantumInspiredAdaptiveSwarm", "description": "Quantum-Inspired Adaptive Swarm Optimization incorporates quantum-inspired mechanisms and adaptive mutation to enhance swarm exploration and convergence in multi-dimensional search spaces.", "code": "import numpy as np\n\nclass QuantumInspiredAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            # Quantum-inspired velocity update\n            velocities = inertia_weight * velocities + np.sin(cognitive_component) * np.random.rand() + np.cos(social_component) * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Adaptive mutation for stagnation\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.2, size=(self.population_size, self.dim))  # Adjusted value\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 70, "feedback": "The algorithm QuantumInspiredAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01415 with standard deviation 0.01294.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.0050000000000000044, 0.032460090774435124]}}
{"id": "8f90d0bc-e903-4012-8b1c-6f4b2af75701", "fitness": 0.06475375389253457, "name": "QuantumEnhancedSwarmOptimization", "description": "Quantum-Inspired Particle Swarm Optimization with Adaptive Quantum Potential utilizes quantum behavior to explore search spaces more effectively and adjusts potential wells for adaptive convergence.", "code": "import numpy as np\n\nclass QuantumEnhancedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n        self.quantum_potential = 1.0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Quantum behavior: random movement influenced by quantum potential\n            quantum_component = np.random.uniform(size=(self.population_size, self.dim)) * self.quantum_potential * (global_best - swarm)\n            \n            # Update positions with quantum influence\n            swarm += inertia_weight * quantum_component\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Adjust quantum potential based on convergence\n            if iter_count % (self.population_size * 5) == 0:\n                self.quantum_potential = max(0.1, self.quantum_potential * 0.9) if len(self.history) > 2 and self.history[-1] >= self.history[-2] else min(1.5, self.quantum_potential * 1.1)\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 71, "feedback": "The algorithm QuantumEnhancedSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06475 with standard deviation 0.02105.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03548167284538328, 0.07470143336486135, 0.08407815546735908]}}
{"id": "d876b80e-b091-477d-92e9-28b569d095ce", "fitness": 0.07858296858400908, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Introduce dynamic adaptive inertia weight scaling for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01 * (global_best_score < np.mean(personal_best_scores)))  # Updated line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "0f26462c-ebbe-4b9f-8391-cc845feb29bd", "fitness": -Infinity, "name": "HybridEnhancedSwarmOptimization", "description": "Hybrid Enhanced Swarm Optimization introduces evolutionary inspiration with mutation and crossover to the adaptive swarm approach, improving both diversity and convergence efficiency.", "code": "import numpy as np\n\nclass HybridEnhancedSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            # Mutation and crossover to introduce diversity\n            mutation_rate = 0.1\n            for i in range(self.population_size):\n                if np.random.rand() < mutation_rate:\n                    mutation_vector = np.random.normal(0, 0.1, self.dim)\n                    swarm[i] = np.clip(swarm[i] + mutation_vector, lb, ub)\n                if np.random.rand() < 0.5:\n                    parent1, parent2 = np.random.choice(self.population_size, 2, replace=False)\n                    crossover_point = np.random.randint(1, self.dim - 1)\n                    swarm[i][:crossover_point] = swarm[parent1][:crossover_point]\n                    swarm[i][crossover_point:] = swarm[parent2][crossover_point:]\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 73, "feedback": "An exception occurred: ValueError('low >= high').", "error": "ValueError('low >= high')", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {}}
{"id": "58dbddf3-7d96-4fce-970f-b909bae0a530", "fitness": 0.056443307516405104, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Adaptive Mutation introduces adaptive mutation strategies and learning factors to improve convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        learning_factor_cognitive = 1.5  # New line\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * learning_factor_cognitive * (personal_best - swarm)  # Updated line\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component + social_component * np.random.rand()  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1 * inertia_weight, size=(self.population_size, self.dim))  # Updated line\n                    swarm += perturbation\n                self.history.append(global_best_score)\n                \n            # Adaptive mutation strategy\n            if iter_count % (self.population_size * 10) == 0:  # New line\n                mutation_rate = np.random.rand() * 0.05  # New line\n                mutation_indices = np.random.choice(self.population_size, size=int(self.population_size * mutation_rate), replace=False)  # New line\n                mutation_values = np.random.uniform(lb, ub, (len(mutation_indices), self.dim))  # New line\n                swarm[mutation_indices] = mutation_values  # New line\n        \n        return global_best_score, global_best", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05644 with standard deviation 0.02053.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.02808955214533937, 0.06519641210960192, 0.07604395829427402]}}
{"id": "067e63ca-686d-48c4-bbeb-e3edb8be1d82", "fitness": 0.028837487758817965, "name": "DynamicPerturbationSwarmOptimizer", "description": "Dynamic Perturbation Swarm Optimizer (DPSO) enhances exploration and exploitation by incorporating dynamically adaptive velocity scaling and periodic swarm diversification.", "code": "import numpy as np\n\nclass DynamicPerturbationSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        velocity_scale = 0.5\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            velocity_scale = max(0.1, velocity_scale - 0.005)  # Gradually reduce velocity scaling for exploitation\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + velocity_scale * (cognitive_component + social_component)\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)  # Updated line\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation_stddev = max(0.05, 0.1 * (1.0 - (global_best_score - np.min(personal_best_scores)) / (np.max(personal_best_scores) - np.min(personal_best_scores) + 1e-10)))\n                    perturbation = np.random.normal(0, perturbation_stddev, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 75, "feedback": "The algorithm DynamicPerturbationSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02884 with standard deviation 0.01857.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.021440544787898252, 0.010717470699194154, 0.05435444778936149]}}
{"id": "aaffedd4-82a8-470d-9bf4-be475eb10a21", "fitness": 0.0664124042930817, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation and Adaptive Cognitive Component Weight Refinement.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component_weight = 2.0  # New line\n            cognitive_component = cognitive_component_weight * np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 76, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06641 with standard deviation 0.03264.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.06984669259052267]}}
{"id": "9be36940-0570-48aa-bc70-f62419276fed", "fitness": 0.05776828494364261, "name": "MultiStrategyAdaptiveSwarm", "description": "Multi-Strategy Adaptive Swarm Optimization (MSASO) applies a multi-strategy approach combining adaptive inertia reduction, dynamic subpopulation exploitation, and strategic perturbation to enhance convergence efficiency and solution accuracy.", "code": "import numpy as np\n\nclass MultiStrategyAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)  # Slower reduction for finer exploration-exploitation balance\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment with subpopulation strategy\n            if iter_count % (self.initial_population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                if np.random.rand() > 0.5:  # Randomly decide to exploit a subpopulation\n                    subpop_indices = np.random.choice(self.population_size, size=int(self.population_size * 0.5), replace=False)\n                    perturbation = np.random.normal(0, 0.05, size=(len(subpop_indices), self.dim))\n                    swarm[subpop_indices] += perturbation\n\n            # Strategic perturbation to escape local minima\n            if iter_count % (self.initial_population_size * 8) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 77, "feedback": "The algorithm MultiStrategyAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05777 with standard deviation 0.02222.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.05790450746954756, 0.030481025144114104, 0.08491932221726617]}}
{"id": "5531d085-595b-4111-a3c0-efc3447a5cef", "fitness": 0.05416113063584049, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Improved Velocity Update introduces an adaptive scaling factor for social and cognitive components to improve convergence speed and solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        scaling_factor = 0.5  # New line\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + scaling_factor * (cognitive_component * np.random.rand() + social_component * np.random.rand())  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)  # Updated line\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05416 with standard deviation 0.02184.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0786771566693254, 0.025630799582068153, 0.05817543565612793]}}
{"id": "0194241b-2e0a-4f90-b1ae-2e79c9d28d28", "fitness": 0.037085334015653504, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Particle Swarm Optimization with Adaptive Velocity Clamping introduces adaptive velocity clamping and a dynamic perturbation mechanism to improve convergence stability and exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Changed line\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        velocity_clamp = 0.1 * (ub - lb)  # Added line\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            velocities = np.clip(velocities, -velocity_clamp, velocity_clamp)  # Changed line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05, size=(self.population_size, self.dim))  # Changed line\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03709 with standard deviation 0.00856.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.039646025152566544, 0.025556289653466013, 0.046053687240927954]}}
{"id": "9665a3ba-c0e1-46eb-b074-d3f9f1ee38fb", "fitness": 0.04286512338888667, "name": "EnhancedAdaptiveSwarmPerturbationWithDiversity", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation and Diversity Preservation introduces dynamic velocity scaling and diversity-driven perturbations to balance exploration and exploitation while preventing premature convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbationWithDiversity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n\n            # Dynamic velocity scaling\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            velocities *= 0.5 * (1 + np.random.rand(self.population_size, self.dim))\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    # Diversity-driven perturbation\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    diverse_indices = np.random.rand(self.population_size) < 0.5  # 50% chance to perturb\n                    swarm[diverse_indices] += perturbation[diverse_indices]\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbationWithDiversity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04287 with standard deviation 0.02910.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.019276083987872283, 0.02545321874151374, 0.08386606743727398]}}
{"id": "58b012ff-fca2-4b2b-b667-f8a7220bc181", "fitness": 0.02936385753997132, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation introduces adaptive learning rates and a novel exploration strategy to improve convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        adaptive_lr = 0.5  # New line\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            # Updated line with adaptive learning rate\n            velocities = inertia_weight * velocities + adaptive_lr * (cognitive_component + social_component * np.random.rand())  \n            swarm += velocities\n\n            # Exploration strategy update\n            exploration_factor = np.random.normal(0, 0.1, size=(self.population_size, self.dim))  \n            swarm += exploration_factor * 0.01  \n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02936 with standard deviation 0.02457.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.020090372069676565, 0.0050000000000000044, 0.06300120055023739]}}
{"id": "f6ecfa7c-1ea2-4fac-91a5-26351b469c92", "fitness": 0.04872267350726348, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Momentum-Based Self-Adaptation improves convergence by incorporating momentum in velocity update, optimizing balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        momentum = 0.5  # New momentum term\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = (momentum * velocities \n                          + inertia_weight * (cognitive_component * np.random.rand() + social_component * np.random.rand()))  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)  # Updated line\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04872 with standard deviation 0.03311.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.08936789379160626, 0.008258558724082543, 0.048541568006101654]}}
{"id": "9f0f5fcf-1a88-44e7-bf4b-6f426923b4ef", "fitness": 0.04395733083558998, "name": "ModifiedEnhancedAdaptiveSwarm", "description": "Modified Enhanced Adaptive Swarm with Dynamic Learning and Local Search introduces adaptive learning factors and local search operations to further balance exploration and exploitation in optimization.", "code": "import numpy as np\n\nclass ModifiedEnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            # Adaptive learning factors\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            cognitive_factor = 2.5 - (2.0 * iter_count) / self.budget  # New line\n            social_factor = 0.5 + (2.0 * iter_count) / self.budget  # New line\n            \n            velocities = inertia_weight * velocities + \\\n                         cognitive_component * cognitive_factor + \\\n                         social_component * social_factor  # Modified line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n            # Local search operation\n            if iter_count % (self.population_size * 10) == 0:  # New line\n                local_search_idx = np.random.randint(self.population_size)  # New line\n                local_search_ind = swarm[local_search_idx] + np.random.uniform(-0.05, 0.05, self.dim)  # New line\n                local_search_score = func(np.clip(local_search_ind, lb, ub))  # New line\n                if local_search_score < personal_best_scores[local_search_idx]:  # New line\n                    personal_best[local_search_idx] = local_search_ind  # New line\n                    personal_best_scores[local_search_idx] = local_search_score  # New line\n        \n        return global_best_score, global_best", "configspace": "", "generation": 83, "feedback": "The algorithm ModifiedEnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04396 with standard deviation 0.01620.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.030611650543839297, 0.034510226209613415, 0.06675011575331724]}}
{"id": "39c7cd34-6cf8-45e5-92d5-93dee9e3f127", "fitness": 0.07858296858400908, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation and Improved Perturbation introduces small dynamic perturbation to further balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05, size=(self.population_size, self.dim))  # Updated line\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 84, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "6de07ff6-ec7e-4938-9a9e-49dca2d74e43", "fitness": 0.048788358027047986, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Dynamic Adaptation incorporates adaptive mutation and variable population size scaling to enhance convergence speed and solution precision.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            # Adaptive mutation\n            if np.random.rand() < 0.1:\n                mutation_strength = 0.1 * (ub - lb) * (1 - iter_count / self.budget)\n                mutation = np.random.normal(0, mutation_strength, swarm.shape)\n                swarm += mutation\n                swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size scaling\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04879 with standard deviation 0.02617.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.01727287363775165, 0.08134860889878948, 0.04774359154460284]}}
{"id": "ed6a459c-b00b-48a7-9916-5926c10a64d2", "fitness": 0.05782889410621087, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Improved Self-Adaptive Swarm Perturbation includes optimized inertia weight decay and adaptive perturbation scaling for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)  # Changed line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05, size=(self.population_size, self.dim))  # Changed line\n                    swarm += perturbation\n                self.history.append(global_best_score)  # Changed line\n        \n        return global_best_score, global_best", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05783 with standard deviation 0.02230.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.05790450746954756, 0.030481025144114104, 0.08510114970497096]}}
{"id": "d341ea2d-b2fc-4196-bf27-27a441f1dcac", "fitness": 0.022897774712078472, "name": "MultiSwarmEnhancedPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Multi-Swarm Strategy introduces multiple swarms with periodical merging and split to diversify search space exploration and improve convergence rate.", "code": "import numpy as np\n\nclass MultiSwarmEnhancedPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.num_swarms = 3  # New line\n        self.history = []\n    \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarms = [np.random.uniform(lb, ub, (self.initial_population_size, self.dim)) for _ in range(self.num_swarms)]  # Modified line\n        velocities = [np.zeros((self.initial_population_size, self.dim)) for _ in range(self.num_swarms)]  # Modified line\n        \n        personal_bests, personal_best_scores, global_best, global_best_score = [], [], None, float('inf')  # Modified line\n        \n        for swarm in swarms:  # New block\n            p_best = swarm.copy()\n            p_best_scores = np.array([func(ind) for ind in swarm])\n            personal_bests.append(p_best)\n            personal_best_scores.append(p_best_scores)\n        \n            best_index = np.argmin(p_best_scores)\n            if p_best_scores[best_index] < global_best_score:\n                global_best = p_best[best_index]\n                global_best_score = p_best_scores[best_index]\n        \n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        \n        while iter_count < self.budget - self.initial_population_size * self.num_swarms:  # Modified line\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            for i, swarm in enumerate(swarms):\n                cognitive_component = np.random.uniform(size=(self.initial_population_size, self.dim)) * (personal_bests[i] - swarm)\n                social_component = np.random.uniform(size=(self.initial_population_size, self.dim)) * (global_best - swarm)\n                \n                velocities[i] = inertia_weight * velocities[i] + cognitive_component * np.random.rand() + social_component * np.random.rand()\n                swarm += velocities[i]\n\n                swarm = np.clip(swarm, lb, ub)\n\n                scores = np.array([func(ind) for ind in swarm])\n                iter_count += self.initial_population_size\n\n                better_indices = scores < personal_best_scores[i]\n                personal_bests[i][better_indices] = swarm[better_indices]\n                personal_best_scores[i][better_indices] = scores[better_indices]\n\n                min_index = np.argmin(personal_best_scores[i])\n                if personal_best_scores[i][min_index] < global_best_score:\n                    global_best = personal_bests[i][min_index]\n                    global_best_score = personal_best_scores[i][min_index]\n\n            if iter_count % (self.initial_population_size * self.num_swarms * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.initial_population_size, self.dim))\n                    for swarm in swarms:\n                        swarm += perturbation\n                self.history.append(global_best_score)\n\n            if iter_count % (self.initial_population_size * self.num_swarms * 10) == 0:  # New line\n                swarms.append(np.random.uniform(lb, ub, (self.initial_population_size, self.dim)))  # New line\n\n        return global_best_score, global_best", "configspace": "", "generation": 87, "feedback": "The algorithm MultiSwarmEnhancedPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02290 with standard deviation 0.01922.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.014132054990501408, 0.049561269145734]}}
{"id": "339fb0d2-ae44-4459-aba3-5dcb5a97abfa", "fitness": 0.020356590537277192, "name": "DynamicSwarmPerturbation", "description": "Dynamic Swarm Perturbation integrates adaptive inertia reduction, velocity oscillation, and learning-based swarm guidance to enhance convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass DynamicSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)  # Smoother inertia reduction\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            # Oscillating velocities to enhance exploration\n            oscillation_factor = np.sin(iter_count / self.budget * np.pi)\n            velocities = (inertia_weight * velocities + \n                          cognitive_component * np.random.rand() + \n                          social_component * np.random.rand() * oscillation_factor)\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Introducing learning-based swarm guidance\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 88, "feedback": "The algorithm DynamicSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02036 with standard deviation 0.00963.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.01243417045885531, 0.014725493042103133, 0.03391010811087314]}}
{"id": "1b87e2a1-0c77-4d0a-821f-44908971101d", "fitness": 0.01944508332340511, "name": "GradientBoostedSwarmPerturbation", "description": "Gradient Boosted Swarm Perturbation introduces gradient estimation to improve local search around promising areas, enhancing the balance between exploration and exploitation.", "code": "import numpy as np\n\nclass GradientBoostedSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n            # Gradient-boosted local search\n            if iter_count % (self.population_size * 2) == 0:\n                for i in range(self.population_size):\n                    gradient = self.estimate_gradient(func, swarm[i], lb, ub)\n                    swarm[i] -= 0.01 * gradient  # Small step towards negative gradient direction\n                    swarm[i] = np.clip(swarm[i], lb, ub)\n\n        return global_best_score, global_best\n\n    def estimate_gradient(self, func, x, lb, ub, epsilon=1e-5):\n        gradient = np.zeros(self.dim)\n        fx = func(x)\n        for i in range(self.dim):\n            x_epsilon = np.copy(x)\n            x_epsilon[i] += epsilon\n            x_epsilon[i] = np.clip(x_epsilon[i], lb[i], ub[i])\n            gradient[i] = (func(x_epsilon) - fx) / epsilon\n        return gradient", "configspace": "", "generation": 89, "feedback": "The algorithm GradientBoostedSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01945 with standard deviation 0.02043.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.0050000000000000044, 0.04833524997021532]}}
{"id": "97a41e3e-6553-4814-a687-be39d0b2fcd1", "fitness": 0.04730820303504024, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Introduced a dynamic inertia weight adaptation based on the improvement of the global best to balance exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Updated line: Dynamic inertia weight adaptation\n            inertia_weight = max(min_inertia, 0.9 * (1 - (global_best_score - min(personal_best_scores)) / max(1e-10, global_best_score))) \n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04731 with standard deviation 0.02204.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03899182054653072, 0.02544986164152807, 0.07748292691706193]}}
{"id": "95a08c83-1336-480a-ac07-c32b54232dc1", "fitness": 0.056808142662560845, "name": "DynamicSwarmPerturbation", "description": "Dynamic Swarm Perturbation with Adaptive Inertia introduces adaptive inertia and enhanced perturbation mechanisms to optimize convergence in varying landscapes.", "code": "import numpy as np\n\nclass DynamicSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        max_inertia = 0.9\n        perturbation_frequency = 10  # New parameter\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Enhanced perturbation mechanism\n            if iter_count % perturbation_frequency == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.05, size=(self.population_size, self.dim))  # Reduced perturbation scale\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 91, "feedback": "The algorithm DynamicSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05681 with standard deviation 0.02526.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.061835112367411016, 0.02366999340300535, 0.08491932221726617]}}
{"id": "e3f7d217-f725-4ed5-acbb-ae60333c57b8", "fitness": 0.04182031219566703, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with improved dynamic inertia weight adjustment for accelerated convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Modified line: Adjust inertia weight dynamically based on improvement rate\n            inertia_weight = max(min_inertia, inertia_weight * (0.9 if len(self.history) > 1 and self.history[-1] < self.history[-2] else 1.1))\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04182 with standard deviation 0.03453.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.08800084581256595, 0.0050000000000000044, 0.032460090774435124]}}
{"id": "58365bab-b977-46f5-8d06-7328453c6fbb", "fitness": 0.07527147020960272, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Dynamic Strategy Switching introduces strategy switching based on performance trends and utilizes adaptive neighborhood size to improve convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        strategy_switch_threshold = self.budget // 4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            # Strategy Switching and Adaptive Neighborhood\n            if iter_count > strategy_switch_threshold:\n                if global_best_score >= np.mean(self.history[-3:]):\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation * np.clip(1.0 / (1.0 + np.std(self.history[-3:])), 0.1, 1.0)\n                else:\n                    velocities *= 0.5\n                    inertia_weight *= 0.5\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07527 with standard deviation 0.03833.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10477974402045609, 0.021140471074098555, 0.0998941955342535]}}
{"id": "1e84ca7e-ca04-4522-8eb4-8b3c15a3842b", "fitness": 0.07858296858400908, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Self-Adaptive Swarm Optimization with Diversity Preservation integrates adaptive inertia with diversity measures to maintain exploration capabilities and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = 20\n        self.population_size = self.initial_population_size\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            # Adjust inertia weight dynamically\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size and diversity preservation\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n                # Diversity preservation mechanism\n                diversity = np.std(swarm, axis=0).mean()\n                if diversity < 0.1:  # Threshold for diversity\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n\n        return global_best_score, global_best", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07858 with standard deviation 0.03802.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.10456283253175314, 0.024827687756969308, 0.10635838546330478]}}
{"id": "6f455245-260b-4e68-843d-5900254ad81b", "fitness": 0.02067251073352631, "name": "HybridParticleSwarmDifferentialEvolution", "description": "Hybrid Particle Swarm and Differential Evolution enhances adaptive swarm perturbation with DE-inspired mutation strategies to diversify exploration and intensify exploitation.", "code": "import numpy as np\n\nclass HybridParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        F = 0.8  # DE mutation factor\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n\n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n\n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            # Apply DE mutation strategy\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x1, x2, x3 = swarm[indices]\n                mutant = x1 + F * (x2 - x3)\n                trial = np.where(np.random.rand(self.dim) < 0.5, mutant, swarm[i])\n                trial = np.clip(trial, lb, ub)\n                if func(trial) < personal_best_scores[i]:\n                    swarm[i] = trial\n                    personal_best[i] = trial\n                    personal_best_scores[i] = func(trial)\n            \n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 95, "feedback": "The algorithm HybridParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02067 with standard deviation 0.00980.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.02108705708980496, 0.008470384336338843, 0.032460090774435124]}}
{"id": "1c9fd742-7177-4c88-b5eb-8006b62769b2", "fitness": 0.06947064329567698, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation introduces self-adapting velocity components and individual-based inertia adjustment for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = max(min_inertia, inertia_weight - 0.01)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = (inertia_weight + np.random.uniform(0, 0.1)) * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()  # Updated line\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)  # Updated line\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06947 with standard deviation 0.04266.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.11804090208234885, 0.01419514444006087, 0.07617588336462122]}}
{"id": "71b7d5ac-5ccd-46e3-bfd2-29adccf90d4d", "fitness": 0.06917816265304637, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Adaptive Swarm Perturbation with Self-Adaptation and Dynamic Inertia implements a linearly decreasing inertia weight for improved convergence over iterations.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n\n        while iter_count < self.budget - self.population_size:\n            inertia_weight = min_inertia + (0.9 - min_inertia) * ((self.budget - iter_count) / self.budget)  # Updated line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Dynamic population size adjustment\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06918 with standard deviation 0.04092.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.05853529400198765, 0.025237955159879033, 0.12376123879727241]}}
{"id": "bca8db1d-e605-4aa1-b597-df63e53e0222", "fitness": 0.050141036107788785, "name": "EnhancedAdaptiveSwarmPerturbation", "description": "Enhanced Swarm Perturbation with Multi-Phase Inertia Weight and Adaptive Perturbation adds phased inertia weight decay and dynamically adjusts perturbations for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmPerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.zeros((self.population_size, self.dim))\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        decay_phases = 3  # New line\n        decay_rate = (inertia_weight - min_inertia) / decay_phases  # New line\n\n        while iter_count < self.budget - self.population_size:\n            phase = iter_count // (self.budget // decay_phases)  # New line\n            inertia_weight = max(min_inertia, 0.9 - phase * decay_rate)  # Updated line\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component * np.random.rand() + social_component * np.random.rand()\n            swarm += velocities\n\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n            if iter_count % (self.population_size * 5) == 0:\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation_magnitude = 0.05 if np.random.rand() > 0.5 else 0.1  # Updated line\n                    perturbation = np.random.normal(0, perturbation_magnitude, size=(self.population_size, self.dim))  # Updated line\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedAdaptiveSwarmPerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05014 with standard deviation 0.02457.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.03932360893824938, 0.02695362832598447, 0.08414587105913252]}}
{"id": "1d7c873e-ef0e-4f5c-b3a0-c85e320c7a52", "fitness": 0.01952656827000121, "name": "DynamicSwarmAdaptiveVelocity", "description": "Dynamic Swarm with Adaptive Velocity Control introduces adaptive inertia weights and a multi-phase exploration-exploitation strategy to improve convergence efficiency.", "code": "import numpy as np\n\nclass DynamicSwarmAdaptiveVelocity:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.history = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))  # Initialize with random velocities\n        personal_best = swarm.copy()\n        personal_best_scores = np.array([func(ind) for ind in swarm])\n        global_best = personal_best[np.argmin(personal_best_scores)]\n        global_best_score = np.min(personal_best_scores)\n        self.history.append(global_best_score)\n\n        iter_count = 0\n        inertia_weight = 0.9\n        min_inertia = 0.4\n        phase_change_iter = self.budget // 4\n\n        while iter_count < self.budget - self.population_size:\n            # Dynamic inertia weight adaptation\n            inertia_weight = max(min_inertia, inertia_weight - 0.005)\n            \n            cognitive_component = np.random.uniform(size=(self.population_size, self.dim)) * (personal_best - swarm)\n            social_component = np.random.uniform(size=(self.population_size, self.dim)) * (global_best - swarm)\n            \n            velocities = inertia_weight * velocities + cognitive_component + social_component\n            swarm += velocities\n            swarm = np.clip(swarm, lb, ub)\n\n            scores = np.array([func(ind) for ind in swarm])\n            iter_count += self.population_size\n\n            better_indices = scores < personal_best_scores\n            personal_best[better_indices] = swarm[better_indices]\n            personal_best_scores[better_indices] = scores[better_indices]\n\n            min_index = np.argmin(personal_best_scores)\n            if personal_best_scores[min_index] < global_best_score:\n                global_best = personal_best[min_index]\n                global_best_score = personal_best_scores[min_index]\n\n            # Multi-phase exploration-exploitation strategy\n            if iter_count % phase_change_iter == 0:\n                phase_factor = np.random.uniform(0.5, 1.5)\n                velocities *= phase_factor  # Adjust velocity magnitude\n\n            if iter_count % (self.population_size * 5) == 0:\n                self.population_size = min(self.population_size + 1, self.budget // 10)\n\n                if len(self.history) > 2 and self.history[-1] >= self.history[-2]:\n                    perturbation = np.random.normal(0, 0.1, size=(self.population_size, self.dim))\n                    swarm += perturbation\n                self.history.append(global_best_score)\n        \n        return global_best_score, global_best", "configspace": "", "generation": 99, "feedback": "The algorithm DynamicSwarmAdaptiveVelocity got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01953 with standard deviation 0.01016.", "error": "", "parent_ids": ["76decbf8-269e-4a17-8d58-99e18da07cad"], "operator": null, "metadata": {"aucs": [0.0076921809744150416, 0.01838277881416217, 0.03250474502142642]}}
