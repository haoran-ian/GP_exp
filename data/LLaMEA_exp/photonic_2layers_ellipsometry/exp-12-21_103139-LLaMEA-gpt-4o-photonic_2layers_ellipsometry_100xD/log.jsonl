{"id": "42297bb9-933c-4144-b8c1-ce2fab4c48bc", "fitness": 0.022432124201916204, "name": "AdaptiveSwarmHybridization", "description": "Adaptive Swarm Hybridization (ASH) blending swarm intelligence and local search for dynamic exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                self.inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                candidate = self.best_global_position + np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 0, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02243 with standard deviation 0.02465.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.0572963726057486, 0.0050000000000000044, 0.0050000000000000044]}}
{"id": "6f741dac-0642-43d2-8e34-d89529c0d504", "fitness": 0.0050000000000000044, "name": "AdaptiveSwarmHybridization", "description": "Adaptive Swarm Hybridization (ASH) with velocity scaling to enhance exploration-exploitation balance. ", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.inertia_weight = 0.7\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                0.5 * self.inertia_weight * velocities +  # Changed line 1\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < 0.05:  # Changed line 2\n                candidate = self.best_global_position + np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 1, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00500 with standard deviation 0.00000.", "error": "", "parent_ids": ["42297bb9-933c-4144-b8c1-ce2fab4c48bc"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.0050000000000000044, 0.0050000000000000044]}}
{"id": "8225e109-fa9c-4aec-a4ef-659ddf0e9390", "fitness": 0.03567519017052471, "name": "AdaptiveSwarmHybridization", "description": "Improved Adaptive Swarm Hybridization (IASH) with enhanced exploration through dynamic inertia weight adjustment.", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.inertia_weight = 0.9  # Change made here for better exploration in early iterations\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                self.inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                candidate = self.best_global_position + np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 2, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03568 with standard deviation 0.02170.", "error": "", "parent_ids": ["42297bb9-933c-4144-b8c1-ce2fab4c48bc"], "operator": null, "metadata": {"aucs": [0.05010583371580679, 0.051919736795767335, 0.0050000000000000044]}}
{"id": "6def7f19-3ad8-4cb6-a3a6-50151bc36170", "fitness": 0.022067763227233732, "name": "AdaptiveSwarmHybridization", "description": "Enhanced Adaptive Swarm Hybridization with dynamic local search rate for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.inertia_weight = 0.9  # Change made here for better exploration in early iterations\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        while evals < self.budget:\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                self.inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Adjusted local search rate for better convergence\n            self.local_search_rate = 0.1 + 0.1 * (1 - evals / self.budget)\n            if np.random.rand() < self.local_search_rate:\n                candidate = self.best_global_position + np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 3, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02207 with standard deviation 0.01694.", "error": "", "parent_ids": ["8225e109-fa9c-4aec-a4ef-659ddf0e9390"], "operator": null, "metadata": {"aucs": [0.04515427061570365, 0.0050000000000000044, 0.01604901906599754]}}
{"id": "946e01e6-213d-41ec-a7da-3abccb15ffcc", "fitness": 0.06384414524011572, "name": "AdaptiveSwarmHybridization", "description": "AdaptiveSwarmHybridization with enhanced exploration via chaotic inertia weight and dynamic neighborhood search.", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        # Chaotic map for inertia weight\n        chaos_parameter = np.random.rand()\n        \n        while evals < self.budget:\n            # Dynamic inertia weight\n            chaos_parameter = 3.9 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.1\n                candidate = self.best_global_position + np.random.uniform(-dynamic_radius, dynamic_radius, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06384 with standard deviation 0.03033.", "error": "", "parent_ids": ["8225e109-fa9c-4aec-a4ef-659ddf0e9390"], "operator": null, "metadata": {"aucs": [0.043681928353835664, 0.04113262693473718, 0.10671788043177433]}}
{"id": "426b5e3f-9b56-4187-89d2-326f2eabe852", "fitness": 0.05995430115701602, "name": "AdaptiveSwarmHybridization", "description": "Refined AdaptiveSwarmHybridization using chaotic mutation strategy for local search enhancement.", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        # Chaotic map for inertia weight\n        chaos_parameter = np.random.rand()\n        \n        while evals < self.budget:\n            # Dynamic inertia weight\n            chaos_parameter = 3.9 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                # Introduce chaotic mutation strategy\n                dynamic_radius = (ub - lb) * 0.1 * chaos_parameter \n                candidate = self.best_global_position + np.random.uniform(-dynamic_radius, dynamic_radius, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 5, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05995 with standard deviation 0.02484.", "error": "", "parent_ids": ["946e01e6-213d-41ec-a7da-3abccb15ffcc"], "operator": null, "metadata": {"aucs": [0.043681928353835664, 0.04113262693473718, 0.0950483481824752]}}
{"id": "f06f5f5c-5fb2-43fd-bb6b-ff28f91eea49", "fitness": 0.05157131232592475, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Enhanced AdaptiveSwarmHybridization utilizing Lévy flights for improved exploration and opposition-based learning to escape local optima.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.levy_alpha = 1.5\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def levy_flight(self, step_size):\n        u = np.random.normal(0, 1, self.dim) * step_size\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1/self.levy_alpha)\n        return step\n\n    def opposition_based_learning(self, population, lb, ub):\n        return lb + ub - population\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.9 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.1\n                candidate = self.best_global_position + np.random.uniform(-dynamic_radius, dynamic_radius, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Lévy flight for enhanced exploration\n            for i in range(self.population_size):\n                step_size = 0.01 * (ub - lb)\n                levy_step = self.levy_flight(step_size)\n                new_position = population[i] + levy_step\n                new_position = np.clip(new_position, lb, ub)\n                new_value = func(new_position)\n                evals += 1\n\n                if new_value < local_best_values[i]:\n                    local_best_positions[i] = new_position\n                    local_best_values[i] = new_value\n\n                    if new_value < self.best_global_value:\n                        self.best_global_value = new_value\n                        self.best_global_position = new_position\n\n            # Opposition-based learning\n            if np.random.rand() < 0.1:\n                opposite_population = self.opposition_based_learning(population, lb, ub)\n                opposite_values = np.array([func(ind) for ind in opposite_population])\n                evals += self.population_size\n                combined = np.concatenate((population, opposite_population))\n                combined_values = np.concatenate((values, opposite_values))\n                best_indices = np.argsort(combined_values)[:self.population_size]\n                population = combined[best_indices]\n                local_best_positions = population.copy()\n                local_best_values = combined_values[best_indices]\n\n        return self.best_global_position", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05157 with standard deviation 0.03042.", "error": "", "parent_ids": ["946e01e6-213d-41ec-a7da-3abccb15ffcc"], "operator": null, "metadata": {"aucs": [0.0726340546964298, 0.008554041773194743, 0.0735258405081497]}}
{"id": "4d39f4e5-dacd-44cf-bc6b-11cb9f449380", "fitness": -Infinity, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Enhanced AdaptiveSwarmHybridization with Lévy flight local search and adaptive parameter tuning for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        # Chaotic map for inertia weight\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            # Dynamic inertia weight\n            chaos_parameter = 3.9 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            # Adaptive parameters\n            self.cognitive_param = 1.5 + 0.5 * np.random.rand()\n            self.social_param = 1.5 + 0.5 * np.random.rand()\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                # Lévy flight for local search\n                levy_step = self.levy_flight(self.dim, 0.1)\n                candidate = self.best_global_position + levy_step * (ub - lb) * (1 - evals / self.budget)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position\n\n    def levy_flight(self, dim, beta):\n        sigma_u = np.power((gamma(1 + beta) * np.sin(np.pi * beta / 2) / (gamma((1 + beta) / 2) * beta * np.power(2, (beta - 1) / 2))), 1 / beta)\n        u = np.random.normal(0, sigma_u, dim)\n        v = np.random.normal(0, 1, dim)\n        step = u / np.power(np.abs(v), 1 / beta)\n        return step", "configspace": "", "generation": 7, "feedback": "An exception occurred: NameError(\"name 'gamma' is not defined\").", "error": "NameError(\"name 'gamma' is not defined\")", "parent_ids": ["946e01e6-213d-41ec-a7da-3abccb15ffcc"], "operator": null, "metadata": {}}
{"id": "8a3962e2-8756-4039-afce-0ef6b562db96", "fitness": 0.0625359550071913, "name": "AdaptiveSwarmHybridization", "description": "Enhanced AdaptiveSwarmHybridization by integrating nonlinear cognitive and social parameters for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        # Chaotic map for inertia weight\n        chaos_parameter = np.random.rand()\n        \n        while evals < self.budget:\n            # Dynamic inertia weight\n            chaos_parameter = 3.9 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            # Nonlinear cognitive and social parameters\n            cognitive_param = self.cognitive_param * (1 - np.exp(-evals / self.budget))\n            social_param = self.social_param * (1 - np.exp(-evals / self.budget))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.1\n                candidate = self.best_global_position + np.random.uniform(-dynamic_radius, dynamic_radius, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 8, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06254 with standard deviation 0.04073.", "error": "", "parent_ids": ["946e01e6-213d-41ec-a7da-3abccb15ffcc"], "operator": null, "metadata": {"aucs": [0.08892042884125162, 0.0050000000000000044, 0.09368743618032227]}}
{"id": "fc3e3ef5-78de-4bc5-a100-703dc2866ef8", "fitness": 0.07317324282344069, "name": "AdaptiveSwarmHybridization", "description": "Enhanced AdaptiveSwarmHybridization with improved dynamic neighborhood search and exploitation phase.", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.15  # Increased local search rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        # Chaotic map for inertia weight\n        chaos_parameter = np.random.rand()\n        \n        while evals < self.budget:\n            # Dynamic inertia weight\n            chaos_parameter = 3.9 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.15  # Adjusted dynamic radius factor\n                candidate = self.best_global_position + np.random.uniform(-dynamic_radius, dynamic_radius, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 9, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07317 with standard deviation 0.02626.", "error": "", "parent_ids": ["946e01e6-213d-41ec-a7da-3abccb15ffcc"], "operator": null, "metadata": {"aucs": [0.07294217196746855, 0.04113262693473718, 0.10544492956811635]}}
{"id": "0a198da7-d95a-4994-8861-80bcdf5fb4d2", "fitness": 0.05499123874312036, "name": "AdaptiveSwarmHybridization", "description": "Improved exploration with Lévy flight mechanism for better convergence in high-dimensional spaces.", "code": "import numpy as np\n\nclass AdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.15  # Increased local search rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        # Chaotic map for inertia weight\n        chaos_parameter = np.random.rand()\n        \n        while evals < self.budget:\n            # Dynamic inertia weight\n            chaos_parameter = 3.9 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                # Use Lévy flight for exploration\n                levy_flight = np.random.standard_cauchy(self.dim) * 0.01  # Lévy flight step size\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 10, "feedback": "The algorithm AdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05499 with standard deviation 0.04049.", "error": "", "parent_ids": ["fc3e3ef5-78de-4bc5-a100-703dc2866ef8"], "operator": null, "metadata": {"aucs": [0.01724738146813709, 0.03656868637329136, 0.11115764838793263]}}
{"id": "fedc1dac-7663-484a-b271-789925b93702", "fitness": 0.07817644688961096, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Integrating multi-phase exploration and exploitation balance with chaotic perturbations for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.2  # Further increased local search rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.9 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2  # Adjusted dynamic radius factor\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07818 with standard deviation 0.01912.", "error": "", "parent_ids": ["fc3e3ef5-78de-4bc5-a100-703dc2866ef8"], "operator": null, "metadata": {"aucs": [0.07274602201807523, 0.057952430193117355, 0.10383088845764032]}}
{"id": "db34f3d2-6731-4268-ab5b-f3cc9cbb9934", "fitness": 0.0793848753080153, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Enhanced adaptive swarm optimization with a refined chaotic perturbation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.2  # Further increased local search rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)  # Adjusted chaotic map parameter\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2  # Adjusted dynamic radius factor\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07938 with standard deviation 0.05322.", "error": "", "parent_ids": ["fedc1dac-7663-484a-b271-789925b93702"], "operator": null, "metadata": {"aucs": [0.06736826451167177, 0.02104773966758655, 0.14973862174478758]}}
{"id": "b9384ccf-d07e-4b5b-bf01-166e03561964", "fitness": 0.05444470290555151, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Adaptive chaotic swarm optimization with multi-strategy perturbation and inertia weight tuning for enhanced convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.3  # Increased local search rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            # Iterate chaotic parameter\n            chaos_parameter = 3.99 * chaos_parameter * (1 - chaos_parameter)  # Refined chaotic map parameter\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.3  # Refined dynamic radius factor\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05444 with standard deviation 0.02553.", "error": "", "parent_ids": ["db34f3d2-6731-4268-ab5b-f3cc9cbb9934"], "operator": null, "metadata": {"aucs": [0.0595764972632441, 0.020923796635056835, 0.08283381481835361]}}
{"id": "7a36c2e9-2c01-493b-a2e6-387b590eb21f", "fitness": 0.03133872624830336, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Improved swarm hybridization with adaptive dynamic radii and random leader selection to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.7  # Increased social influence\n        self.local_search_rate = 0.3  # Further increased local search rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            random_leader = population[np.random.randint(self.population_size)]  # Random leader selection\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (random_leader - population)  # Changed global best to random leader\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * np.random.rand()  # Adaptive dynamic radius\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03134 with standard deviation 0.02301.", "error": "", "parent_ids": ["db34f3d2-6731-4268-ab5b-f3cc9cbb9934"], "operator": null, "metadata": {"aucs": [0.027967907972420103, 0.0050000000000000044, 0.061048270772489976]}}
{"id": "6d626bd6-a317-44f3-bcd1-27d1579d4f46", "fitness": 0.08423663767305496, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Enhanced adaptive swarm optimization with refined chaotic perturbation for improved convergence, now featuring dynamic cognitive and social parameters.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.2  # Further increased local search rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)  # Adjusted chaotic map parameter\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            # Updated line: Dynamic adjustment of cognitive and social parameters\n            self.cognitive_param = 1.5 * chaos_parameter; self.social_param = 2.0 - self.cognitive_param\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2  # Adjusted dynamic radius factor\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08424 with standard deviation 0.03206.", "error": "", "parent_ids": ["db34f3d2-6731-4268-ab5b-f3cc9cbb9934"], "operator": null, "metadata": {"aucs": [0.12027217654136246, 0.04238663653212105, 0.09005109994568139]}}
{"id": "79fb4f08-9398-4499-8367-386162198e7b", "fitness": 0.06446461422523102, "name": "QuantumAdaptiveSwarmHybridization", "description": "Adaptive Swarm Hybridization with Quantum-inspired Chaotic Perturbation and Dynamic Leader Strategy to enhance global exploration and exploitation.", "code": "import numpy as np\n\nclass QuantumAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.25  # Increased local search rate for more frequent local optimizations\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)  # Chaotic map parameter\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            # Dynamic adjustment of cognitive and social parameters with quantum-inspired influence\n            self.cognitive_param = 1.5 * (0.5 + chaos_parameter)\n            self.social_param = 2.5 - self.cognitive_param\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Introduce a dynamic leader strategy\n            if evals % (self.population_size * 5) == 0:\n                leader_idx = np.random.choice(self.population_size)\n                self.best_global_position = local_best_positions[leader_idx]\n                self.best_global_value = local_best_values[leader_idx]\n\n        return self.best_global_position", "configspace": "", "generation": 16, "feedback": "The algorithm QuantumAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06446 with standard deviation 0.01877.", "error": "", "parent_ids": ["6d626bd6-a317-44f3-bcd1-27d1579d4f46"], "operator": null, "metadata": {"aucs": [0.044116021644628245, 0.05987188980909952, 0.08940593122196527]}}
{"id": "edd10596-2a7f-4039-a19c-541bb2e815d0", "fitness": 0.07671913443590135, "name": "AdaptiveDynamicSwarmOptimization", "description": "Adaptive dynamic swarm optimization with multi-layered chaotic enhancement and strategic memory reset for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveDynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.3  # Further increased local search rate\n        self.memory_reset_interval = 0.1 * budget  # New parameter for memory reset\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.98 * chaos_parameter * (1 - chaos_parameter)  # Further tuned chaotic map parameter\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            # Updated line: Dynamic adjustment of cognitive and social parameters based on chaos\n            self.cognitive_param = 1.5 * chaos_parameter; self.social_param = 2.5 - self.cognitive_param\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Strategic memory reset to escape local optima\n            if evals % self.memory_reset_interval < self.population_size:\n                random_indices = np.random.choice(self.population_size, size=int(0.1 * self.population_size), replace=False)\n                population[random_indices] = np.random.uniform(lb, ub, (random_indices.size, self.dim))\n                local_best_positions[random_indices] = population[random_indices]\n                local_best_values[random_indices] = np.array([func(ind) for ind in population[random_indices]])\n                evals += random_indices.size\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.1  # Further adjusted dynamic radius factor\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 17, "feedback": "The algorithm AdaptiveDynamicSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07672 with standard deviation 0.02528.", "error": "", "parent_ids": ["6d626bd6-a317-44f3-bcd1-27d1579d4f46"], "operator": null, "metadata": {"aucs": [0.060710540666482626, 0.11240514614993102, 0.05704171649129042]}}
{"id": "04778f7a-90c5-4a1c-8c9c-6aea48053741", "fitness": 0.005257323339024622, "name": "AdaptiveDynamicSwarmOptimization", "description": "Adaptive Dynamic Swarm Optimization with Multi-level Chaotic Maps incorporating Self-adaptive Local Search for enhanced convergence and exploration.", "code": "import numpy as np\n\nclass AdaptiveDynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 2.0\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter1 = np.random.rand()\n        chaos_parameter2 = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter1 = 3.95 * chaos_parameter1 * (1 - chaos_parameter1)\n            chaos_parameter2 = 3.8 * chaos_parameter2 * (1 - chaos_parameter2) * chaos_parameter1\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter2\n            self.cognitive_param = self.cognitive_param_base * chaos_parameter2\n            self.social_param = self.social_param_base - self.cognitive_param\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.1\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 18, "feedback": "The algorithm AdaptiveDynamicSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00526 with standard deviation 0.00036.", "error": "", "parent_ids": ["6d626bd6-a317-44f3-bcd1-27d1579d4f46"], "operator": null, "metadata": {"aucs": [0.0057719700170738575, 0.0050000000000000044, 0.0050000000000000044]}}
{"id": "7f200bd2-4a44-4d00-bb10-c307f10846fc", "fitness": 0.06650826041266944, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Enhanced adaptive swarm with refined chaotic perturbation and a local search mechanism for improved convergence using dynamic perturbation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            self.cognitive_param = 1.5 * chaos_parameter; self.social_param = 2.0 - self.cognitive_param\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Updated line: More frequent local search with a smaller, dynamic perturbation factor\n            if np.random.rand() < (self.local_search_rate + 0.1):\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.1\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 19, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06651 with standard deviation 0.04614.", "error": "", "parent_ids": ["6d626bd6-a317-44f3-bcd1-27d1579d4f46"], "operator": null, "metadata": {"aucs": [0.11647693060219277, 0.005182487517704337, 0.07786536311811121]}}
{"id": "55d536ed-deec-4f01-9e59-da014f99e3ea", "fitness": 0.08626056419898513, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Enhanced swarm-based optimization incorporating a modified Lévy flight mechanism for exploratory dispersion and improved convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            self.cognitive_param = 1.5 * chaos_parameter\n            self.social_param = 2.0 - self.cognitive_param\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Implementing Lévy flight mechanism\n            if np.random.rand() < 0.1:  # 10% chance to perform Lévy flight\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 20, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08626 with standard deviation 0.03168.", "error": "", "parent_ids": ["6d626bd6-a317-44f3-bcd1-27d1579d4f46"], "operator": null, "metadata": {"aucs": [0.04625032084474312, 0.08881682693892434, 0.12371454481328792]}}
{"id": "a87adf74-a04c-400c-a0ce-02a6ab32c00d", "fitness": 0.01751924580878254, "name": "EnhancedAdaptiveSwarmHybridization", "description": "Enhanced swarm optimization using a dynamic inertia weight strategy, adaptive mutation, and local search intensification for accelerated convergence.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarmHybridization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 2.0\n        self.social_param = 2.0\n        self.local_search_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        while evals < self.budget:\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (\n                (self.budget - evals) / self.budget\n            )\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.1\n                perturbation = np.random.normal(0, dynamic_radius, self.dim)\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:  # 10% chance to perform enhanced Lévy flight\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedAdaptiveSwarmHybridization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01752 with standard deviation 0.01394.", "error": "", "parent_ids": ["55d536ed-deec-4f01-9e59-da014f99e3ea"], "operator": null, "metadata": {"aucs": [0.010591692582163192, 0.03696604484418442, 0.0050000000000000044]}}
{"id": "39e80a98-7e11-4db0-a1f3-7eabaa62982e", "fitness": 0.078644351957551, "name": "AdaptiveChaosDrivenSwarm", "description": "Adaptive Chaos-Driven Swarm Optimization with Enhanced Lévy Flight for diverse exploration and precise convergence.", "code": "import numpy as np\n\nclass AdaptiveChaosDrivenSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param = 1.5\n        self.social_param = 1.5\n        self.local_search_rate = 0.2\n        self.levy_rate = 0.15\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - chaos_parameter)\n\n            self.cognitive_param = 1.5 * (1 + chaos_parameter * 0.1)\n            self.social_param = 2.0 - self.cognitive_param\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                self.cognitive_param * r1 * (local_best_positions - population) +\n                self.social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * 0.1\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < self.levy_rate:\n                alpha = 1.5\n                beta = 0.3\n                levy_flight = np.random.standard_cauchy(size=self.dim) * \\\n                              np.random.uniform(size=self.dim) ** (-1 / beta)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 22, "feedback": "The algorithm AdaptiveChaosDrivenSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07864 with standard deviation 0.05460.", "error": "", "parent_ids": ["55d536ed-deec-4f01-9e59-da014f99e3ea"], "operator": null, "metadata": {"aucs": [0.0570485407008815, 0.025243729251885116, 0.1536407859198864]}}
{"id": "e4372447-2dcd-4508-a286-74784c0f6756", "fitness": 0.09747855670181926, "name": "DynamicAdaptiveSwarm", "description": "Improved swarm optimization with a dynamic adaptive parameter mechanism and chaotic convergence enhancement for better exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 23, "feedback": "The algorithm DynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09748 with standard deviation 0.05743.", "error": "", "parent_ids": ["55d536ed-deec-4f01-9e59-da014f99e3ea"], "operator": null, "metadata": {"aucs": [0.05021084510070328, 0.06391634573597271, 0.1783084792687818]}}
{"id": "60d5fe06-cdf1-4a74-810d-ed55d113d5b3", "fitness": 0.08118442129410575, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced DynamicAdaptiveSwarm with adaptive chaos parameter adjustments for improved convergence and supplementary Levy flight exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.99 * chaos_parameter * (1 - chaos_parameter)  # Adjusted chaos parameter multiplier\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                perturbation = levy_flight * (ub - lb) * 0.1  # Scaled Levy flight step\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 24, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08118 with standard deviation 0.03828.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.09800162357538555, 0.028215640610509962, 0.11733599969642172]}}
{"id": "aaad1838-1788-4d0c-acfb-e655c41c80da", "fitness": -Infinity, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced swarm optimization using an adaptive memory mechanism and diversified local search strategies for improved convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.memory = []\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Adaptive memory mechanism\n            self.memory.append(self.best_global_position.copy())\n            if len(self.memory) > 10:\n                self.memory.pop(0)\n\n            # Diversified local search\n            if np.random.rand() < 0.2:\n                historical_best = np.random.choice(self.memory)\n                candidate = historical_best + np.random.uniform(-0.1, 0.1, self.dim) * (ub - lb)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 25, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {}}
{"id": "76445f9c-01a2-4bd9-83a8-01814300c1a7", "fitness": 0.02436658358588939, "name": "DynamicAdaptiveSwarm", "description": "Enhanced swarm optimization with adaptive inertia and Levy flights for improved exploration.", "code": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - evals / self.budget)\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 26, "feedback": "The algorithm DynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02437 with standard deviation 0.01377.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.035769550636159164, 0.032330200121509]}}
{"id": "9b16ddf6-305a-4c50-8842-13fa7a7631f8", "fitness": 0.07060293690444559, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Particle Swarm Optimization incorporating adaptive inertia weights and self-adaptive local search with Lévy flights to improve convergence speed and precision in black-box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:  # Increased probability for Lévy flight exploration\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07060 with standard deviation 0.02950.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.10197078210172617, 0.031092237999776673, 0.07874579061183395]}}
{"id": "08391ab4-f6b7-4658-87ad-ca549aaf433d", "fitness": 0.08798256409378098, "name": "DynamicAdaptiveSwarm", "description": "Enhanced swarm optimization with chaos-based inertia weight adjustment and occasional Levy flights to improve exploration.", "code": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * 0.01  # Slightly reduce the impact of Levy flights\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 28, "feedback": "The algorithm DynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08798 with standard deviation 0.06415.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.05021084510070328, 0.03542836791185788, 0.1783084792687818]}}
{"id": "e8f093af-7347-4aba-a10e-bcb55a2b560e", "fitness": 0.08874493149858946, "name": "EnhancedDynamicSwarm", "description": "Enhanced Dynamic Swarm Optimization with Adaptive Inertia, Contextual Parameter Adjustment, and Hybrid Exploration Techniques for Robust Search and Convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.levy_search_rate = 0.1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            # Adaptive parameter adjustment based on search progress\n            progress_factor = evals / self.budget\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(progress_factor * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(progress_factor * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Dynamic local search\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - progress_factor) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Hybrid exploration using Lévy flights\n            if np.random.rand() < self.levy_search_rate:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 29, "feedback": "The algorithm EnhancedDynamicSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08874 with standard deviation 0.04518.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.05021084510070328, 0.06387110469737178, 0.1521528446976933]}}
{"id": "69ece0b2-b0ef-4a98-a9a8-2974bf7cabdf", "fitness": 0.08011227204604532, "name": "DynamicAdaptiveSwarm", "description": "Enhanced swarm algorithm with adaptive chaos and perturbation for improved global exploration and rapid convergence.", "code": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25  # Adjusted from 0.2 to 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 4.0 * chaos_parameter * (1 - chaos_parameter)  # Adjusted from 3.95 to 4.0\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 30, "feedback": "The algorithm DynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08011 with standard deviation 0.02628.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.0969959705350516, 0.04299140054237327, 0.10034944506071108]}}
{"id": "75eb83a5-e4be-491e-815f-0b9075b9702b", "fitness": 0.011130135564404639, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Adaptive Swarm Optimization utilizing stochastic adaptive parameters and Levy flight for improved convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.inertia_weight_max = 0.9\n        self.inertia_weight_min = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.exploration_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        while evals < self.budget:\n            inertia_weight = self.inertia_weight_max - ((self.inertia_weight_max - self.inertia_weight_min) * evals / self.budget)\n            cognitive_param = self.cognitive_param_base + 0.5 * np.random.rand()\n            social_param = self.social_param_base + 0.5 * np.random.rand()\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.exploration_rate:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight * (ub - lb) * 0.1\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 31, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01113 with standard deviation 0.00660.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.008102124263628996, 0.020288282429584914, 0.0050000000000000044]}}
{"id": "a6dc8308-476e-475d-95f0-8d627255bf48", "fitness": 0.07060293690444559, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced swarm optimization with adaptive inertia and Levy flight for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                # Increased probability for Levy flights\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07060 with standard deviation 0.02950.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.10197078210172617, 0.031092237999776673, 0.07874579061183395]}}
{"id": "93614db3-fcea-4dca-a7f8-866d0ca53f44", "fitness": 0.050286549898738264, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced swarm optimization using a hybrid adaptive chaos-fusion strategy with Levy flights and random forest-based local exploitation for improved convergence and diversity.", "code": "import numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.7\n        self.social_param_base = 1.7\n        self.local_search_rate = 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.rf_model = RandomForestRegressor(n_estimators=10)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = (self.final_inertia_weight + \n                              (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter)\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals > self.population_size * 2 and np.random.rand() < 0.15:\n                self.rf_model.fit(population, values)\n                for i in range(self.population_size):\n                    pred_value = self.rf_model.predict(population[i][None, :])\n                    if pred_value < local_best_values[i]:\n                        local_best_positions[i] = population[i]\n                        local_best_values[i] = pred_value\n\n        return self.best_global_position", "configspace": "", "generation": 33, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05029 with standard deviation 0.03549.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.04944803115337093, 0.007244671840283101, 0.09416694670256076]}}
{"id": "c83ea04c-8e70-43f3-ac53-ce3a28b10ff0", "fitness": 0.0792535264244653, "name": "DynamicAdaptiveSwarm", "description": "Enhanced swarm optimization with adaptive chaos-induced inertia and elite-based mutation for improved exploitation and convergence.", "code": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 4.0 * chaos_parameter * (1 - chaos_parameter)  # Change 1: Increase chaos influence\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                elite_individual = local_best_positions[np.argmin(local_best_values)]  # Change 2: Elite-based mutation\n                candidate = elite_individual + levy_flight  # Change 3: Use elite for mutation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 34, "feedback": "The algorithm DynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07925 with standard deviation 0.03911.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.0969959705350516, 0.025009511690791353, 0.11575509704755294]}}
{"id": "6a7b62ef-bb93-4e09-bc31-d921cc92d918", "fitness": 0.04077923041902287, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced swarm optimization using dynamic parameter adaptation with Levy Flights and chaotic perturbation for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Additional chaotic perturbation\n            if np.random.rand() < 0.05:\n                chaos_perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = self.best_global_position + chaos_perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 35, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04078 with standard deviation 0.02011.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.06568587834055384, 0.016429206244429118, 0.04022260667208566]}}
{"id": "85d391f3-9e0f-45c9-bd2d-7b238a0a9dd3", "fitness": 0.039139141994578686, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced swarm optimization with chaotic inertia and stochastic adaptive parameters for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n        \n        while evals < self.budget:\n            chaos_parameter = 4.0 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + np.random.normal(0, 0.1)\n            social_param = self.social_param_base + np.random.normal(0, 0.1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < 0.2:\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 36, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.03914 with standard deviation 0.02413.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.0608560563865872, 0.005479013433057678, 0.05108235616409118]}}
{"id": "66e3046b-67fe-4f52-a8ff-9a4a116def38", "fitness": 0.07037813416944176, "name": "QuantumDynamicAdaptiveSwarm", "description": "Hybrid swarm optimization integrating dynamic adaptive parameters with quantum-inspired search for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass QuantumDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.quantum_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.quantum_rate:\n                quantum_radius = (ub - lb) * (1 - evals / self.budget) * 0.3\n                quantum_perturbation = np.random.normal(0, quantum_radius, self.dim)\n                candidate = self.best_global_position + quantum_perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 37, "feedback": "The algorithm QuantumDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07038 with standard deviation 0.00980.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.056567359671708006, 0.07621680844906153, 0.07835023438755573]}}
{"id": "815833c9-9129-4d97-a1dc-7987a09aa08c", "fitness": 0.057251606642073814, "name": "DynamicAdaptiveSwarm", "description": "Improved swarm optimization with adaptive learning rates and enhanced local search using Lévy flights for better convergence.", "code": "import numpy as np\n\nclass DynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25  # changed from 0.2 to 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.3  # changed from 0.2 to 0.3\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * 0.1  # multiplication added for scaling\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 38, "feedback": "The algorithm DynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05725 with standard deviation 0.00877.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.05021084510070328, 0.051927964170105145, 0.06961601065541301]}}
{"id": "8eaa1d12-754c-4bec-9f7e-011b49bbc1ad", "fitness": 0.06000178148113219, "name": "EnhancedDynamicSwarm", "description": "Enhanced Particle Swarm Optimization using variable neighborhood search and adaptive parameter tuning for improved convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Variable Neighborhood Search\n            if np.random.rand() < 0.05:\n                for _ in range(3):  # attempt 3 local variations\n                    radius = (ub - lb) * 0.1 * np.random.rand()\n                    perturbation = np.random.uniform(-radius, radius, self.dim)\n                    candidate = self.best_global_position + perturbation\n                    candidate = np.clip(candidate, lb, ub)\n                    candidate_value = func(candidate)\n                    evals += 1\n\n                    if candidate_value < self.best_global_value:\n                        self.best_global_value = candidate_value\n                        self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 39, "feedback": "The algorithm EnhancedDynamicSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06000 with standard deviation 0.03093.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.08508476982368152, 0.016429206244429118, 0.07849136837528592]}}
{"id": "f57e4ca5-9e4b-426b-8ebd-a52239c7b53f", "fitness": 0.06072609646475258, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced Dynamic Adaptive Swarm Optimization with Hybrid Chaos-Levy Exploration and Adaptive Mutation Strategy for Improved Convergence Efficiency and Robustness.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n        \n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.05:  # Adaptive mutation enhancement\n                mutation_vector = np.random.normal(0, 0.1 * (ub - lb), self.dim)\n                candidate = self.best_global_position + mutation_vector\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n                \n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06073 with standard deviation 0.04684.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.12552647647774295, 0.016429206244429118, 0.04022260667208566]}}
{"id": "b8a91050-180e-491f-ac5a-d00239fe6f87", "fitness": 0.08808816865873081, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced swarm optimization with adaptive chaotic inertia and random perturbations for improved convergence and diversification balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:  # Increased probability for Levy flights\n                levy_flight = np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 41, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08809 with standard deviation 0.06995.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.06526667096961147, 0.016136910259890946, 0.18286092474669002]}}
{"id": "02c48b22-e757-4432-b1ad-cb88810593a1", "fitness": 0.07934630258183233, "name": "EnhancedAdaptiveSwarm", "description": "Enhanced swarm optimization leveraging variable Lévy flight and adaptive inertia modulation for superior convergence control and solution refinement.", "code": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.8 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - (evals / self.budget)) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * np.sin(evals / self.budget * np.pi)\n            social_param = self.social_param_base - 0.5 * np.cos(evals / self.budget * np.pi)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.1:\n                levy_scale = 0.01 * (1 - evals / self.budget)\n                levy_flight = levy_scale * np.random.standard_cauchy(size=self.dim)\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07935 with standard deviation 0.01119.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.06439443653204269, 0.08232634382033877, 0.09131812739311551]}}
{"id": "0cf7a9b2-c0a1-4083-8ead-4d9690e398e6", "fitness": 0.10170404116046505, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced swarm optimization integrating adaptive chaos-driven dynamic parameters and Lévy flights for improved exploration and convergence balance.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 43, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10170 with standard deviation 0.05711.", "error": "", "parent_ids": ["e4372447-2dcd-4508-a286-74784c0f6756"], "operator": null, "metadata": {"aucs": [0.06526667096961147, 0.05749522175711175, 0.18235023075467194]}}
{"id": "22b64a3f-4b7e-46fa-9361-2a8595563dc4", "fitness": 0.10170404116046505, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced swarm optimization with adaptive chaos-driven parameters, Lévy flights, and dynamic exploration through dimension-wise scaling.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10170 with standard deviation 0.05711.", "error": "", "parent_ids": ["0cf7a9b2-c0a1-4083-8ead-4d9690e398e6"], "operator": null, "metadata": {"aucs": [0.06526667096961147, 0.05749522175711175, 0.18235023075467194]}}
{"id": "a5e23fef-cbda-4fd8-bbbf-816460318eb4", "fitness": 0.08277117564118952, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced swarm optimization with improved convergence by increasing local search rate.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3  # Increased from 0.2 to 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08277 with standard deviation 0.03810.", "error": "", "parent_ids": ["0cf7a9b2-c0a1-4083-8ead-4d9690e398e6"], "operator": null, "metadata": {"aucs": [0.10197078210172617, 0.02956987967189051, 0.11677286514995189]}}
{"id": "3d75bb56-6522-467a-a7c9-4dc51153ca93", "fitness": 0.09341099392762253, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced swarm optimization with adaptive chaos and Lévy flights, incorporating a minor increase in local search rate for improved exploration.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25  # Increased from 0.2 to 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09341 with standard deviation 0.06468.", "error": "", "parent_ids": ["0cf7a9b2-c0a1-4083-8ead-4d9690e398e6"], "operator": null, "metadata": {"aucs": [0.06526667096961147, 0.0321053860665661, 0.18286092474669002]}}
{"id": "1896d4a6-624b-417e-a30a-2c27d0f7cdf5", "fitness": 0.04300017440615015, "name": "OptimizedAdaptiveSwarm", "description": "Optimized chaos-driven adaptive swarm with dynamic inertia, enhanced local search strategies, and Lévy flight adjustments for robust exploration-exploitation trade-offs.", "code": "import numpy as np\n\nclass OptimizedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base * (1 + 0.5 * np.cos(evals / self.budget * np.pi))\n            social_param = self.social_param_base * (1 + 0.5 * np.sin(evals / self.budget * np.pi))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < 0.25:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.3\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.015\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 47, "feedback": "The algorithm OptimizedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04300 with standard deviation 0.02421.", "error": "", "parent_ids": ["0cf7a9b2-c0a1-4083-8ead-4d9690e398e6"], "operator": null, "metadata": {"aucs": [0.02482804285409923, 0.02696191324099928, 0.07721056712335195]}}
{"id": "ec0d33c6-c8b6-4421-a8e6-3bbf05eb45e1", "fitness": 0.06555219967472077, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Introduce adaptive mutation based on sinusoidal oscillation for enhanced exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # New adaptive mutation step based on sinusoidal oscillation\n            if np.random.rand() < 0.1:\n                mutation_strength = np.sin(np.pi * evals / self.budget) * (ub - lb) * 0.05\n                candidate = self.best_global_position + np.random.normal(0, mutation_strength, self.dim)\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 48, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06555 with standard deviation 0.02524.", "error": "", "parent_ids": ["0cf7a9b2-c0a1-4083-8ead-4d9690e398e6"], "operator": null, "metadata": {"aucs": [0.05974014426799101, 0.037958746121832254, 0.09895770863433906]}}
{"id": "d3bf5105-8b51-45a5-85bb-60a0af36433e", "fitness": 0.06573833707509498, "name": "EnhancedDynamicAdaptiveSwarm", "description": "Enhanced swarm optimization with improved chaos parameter dynamics and stochastic local search adjustments.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = 0.5  # Adjusted initial value\n\n        while evals < self.budget:\n            chaos_parameter = 3.57 * chaos_parameter * (1 - chaos_parameter)  # Adjusted logistic map coefficient\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06574 with standard deviation 0.03790.", "error": "", "parent_ids": ["0cf7a9b2-c0a1-4083-8ead-4d9690e398e6"], "operator": null, "metadata": {"aucs": [0.07299496980558462, 0.016118706075176403, 0.10810133534452393]}}
{"id": "b9db8f40-42f1-4ab7-a0d8-ca5f32d6d93b", "fitness": 0.10170407013632639, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "An enhanced swarm optimization integrating adaptive chaos-driven dynamic parameters, Lévy flights, and dynamic diversity preservation for robust exploration and balanced exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon))\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 50, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10170 with standard deviation 0.05711.", "error": "", "parent_ids": ["0cf7a9b2-c0a1-4083-8ead-4d9690e398e6"], "operator": null, "metadata": {"aucs": [0.06526664705625251, 0.057495233116603206, 0.18235033023612346]}}
{"id": "f3c8dba2-5946-477d-bcd6-d91113060879", "fitness": 0.08809257556911865, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Optimize velocity update strategy by slightly increasing random influence for enhanced exploration.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            ) * 1.01  # Increased random influence\n\n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon))\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08809 with standard deviation 0.03656.", "error": "", "parent_ids": ["b9db8f40-42f1-4ab7-a0d8-ca5f32d6d93b"], "operator": null, "metadata": {"aucs": [0.09892396203836074, 0.0388937482613021, 0.1264600164076931]}}
{"id": "d99c850f-d5ce-40e3-ae61-b94ae424c5a3", "fitness": 0.048281279453517754, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Integrating adaptive chaos-enhanced inertia weight for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            # Changed line: Adjusted the range of inertia weight using chaos_parameter\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (0.5 + 0.5 * chaos_parameter)\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon))\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04828 with standard deviation 0.02061.", "error": "", "parent_ids": ["b9db8f40-42f1-4ab7-a0d8-ca5f32d6d93b"], "operator": null, "metadata": {"aucs": [0.06676273294817703, 0.01952465116339752, 0.05855645424897871]}}
{"id": "0c337dff-f751-4dc9-9ea9-36172e97c824", "fitness": 0.07037150233251455, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Introduce a small mutation mechanism in velocities to enhance exploration and prevent early convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon))\n            \n            # Small Mutation Mechanism\n            velocities += np.random.normal(0, 0.01, velocities.shape)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07037 with standard deviation 0.02570.", "error": "", "parent_ids": ["b9db8f40-42f1-4ab7-a0d8-ca5f32d6d93b"], "operator": null, "metadata": {"aucs": [0.10125728547902557, 0.03833274900588479, 0.07152447251263327]}}
{"id": "fa42f65e-ad80-4c2e-be7d-064385e805eb", "fitness": 0.10170413420444564, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Enhanced swarm optimization with adaptive chaos-driven dynamic parameters and improved diversity scaling for robust exploration and balanced exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)  # Slight modification here\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10170 with standard deviation 0.05711.", "error": "", "parent_ids": ["b9db8f40-42f1-4ab7-a0d8-ca5f32d6d93b"], "operator": null, "metadata": {"aucs": [0.06526663942068534, 0.05749524823070129, 0.18235051496195032]}}
{"id": "371c9ba1-9088-4090-ba83-1c9ea5736a8a", "fitness": 0.10170413420444564, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Enhanced swarm optimization with chaotic randomization factor for improved particle exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)  # Slight modification here\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 55, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10170 with standard deviation 0.05711.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.06526663942068534, 0.05749524823070129, 0.18235051496195032]}}
{"id": "51d8cf38-4cec-4d63-aa43-5215ab9e1b08", "fitness": 0.08775654909709359, "name": "EnhancedDynamicAdaptiveSwarmV3", "description": "Augmented swarm optimization with chaotic inertia balancing and adaptive local exploratory perturbations for refined exploration-exploitation dynamics.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.99 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.3\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08776 with standard deviation 0.02041.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.09806380332194864, 0.059255946702321594, 0.10594989726701054]}}
{"id": "e1acaf53-e715-4064-9721-283099d1aeb3", "fitness": 0.07429857769408084, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Enhanced swarm optimization with improved chaotic inertia adjustment and adaptive local search for superior convergence and exploration balance.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25  # Change 1\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.97 * chaos_parameter * (1 - chaos_parameter)  # Change 2\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.25  # Change 3\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07430 with standard deviation 0.01923.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.07445378653215518, 0.05067039468508239, 0.09777155186500497]}}
{"id": "a97c9351-8ef8-44bc-8198-dc235f82694f", "fitness": -Infinity, "name": "AdvancedDynamicSwarmOptimization", "description": "Advanced exploration-exploitation dynamic swarm optimization with adaptive chaos, levy flights, and fitness influence for superior convergence.", "code": "import numpy as np\n\nclass AdvancedDynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n\n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n            velocities *= (1 + (self.best_global_value - local_best_values) / (np.abs(self.best_global_value) + self.epsilon))\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 58, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (5,2) (5,) (5,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (5,2) (5,) (5,2) ')", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {}}
{"id": "b195baf4-80a9-427d-baa1-90757632935e", "fitness": 0.014633036823521461, "name": "EnhancedDynamicAdaptiveSwarmV3", "description": "Enhanced Dynamic Adaptive Swarm V3 introduces a non-linear inertia decay, adaptive learning rate scaling, and stochastic population regrouping to enhance global convergence and local refinement.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - (evals / self.budget) ** 2)\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)  # Slight modification here\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Stochastic Population Regrouping\n            if np.random.rand() < 0.1:\n                new_positions = np.random.uniform(lb, ub, (self.population_size // 5, self.dim))\n                new_values = np.array([func(ind) for ind in new_positions])\n                evals += len(new_positions)\n\n                for i, value in enumerate(new_values):\n                    if value < np.max(local_best_values):\n                        worst_idx = np.argmax(local_best_values)\n                        local_best_positions[worst_idx] = new_positions[i]\n                        local_best_values[worst_idx] = value\n                        if value < self.best_global_value:\n                            self.best_global_value = value\n                            self.best_global_position = new_positions[i].copy()\n\n        return self.best_global_position", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.01463 with standard deviation 0.01226.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.03193018128793823, 0.006968929182626149, 0.0050000000000000044]}}
{"id": "71a54ac0-74a5-4fde-b064-e14aa4a665fb", "fitness": 0.05665721803683229, "name": "AdaptiveChaosEnhancedPSO", "description": "Adaptive Chaos-Enhanced Particle Swarm Optimization with Multi-Scale Perturbation for improved convergence and diversity maintenance.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5) * 1.1  # Enhanced scaling factor\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.02  # Slightly increased scale\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 60, "feedback": "The algorithm AdaptiveChaosEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05666 with standard deviation 0.03301.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.08566530852100329, 0.010472834131362019, 0.07383351145813155]}}
{"id": "37be17cf-36dc-4595-bf8f-5f760f680a47", "fitness": 0.07037149261916793, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Enhanced swarm optimization with adaptive chaos-driven dynamic parameters, improved diversity scaling, and refined velocity update for robust exploration and balanced exploitation.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population) +\n                0.01 * np.random.normal(size=(self.population_size, self.dim))  # Refined velocity update\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07037 with standard deviation 0.02570.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.1012572624904462, 0.03833275730046881, 0.0715244580665888]}}
{"id": "7fa8db09-9d17-4962-b415-2fdca6d54f97", "fitness": 0.08760102160660195, "name": "EnhancedDynamicAdaptiveSwarmV3", "description": "Introducing a novel Dynamic Adaptive Swarm with Hybrid Perturbation, combining chaos-driven parameters and Lévy flights for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Hybrid Perturbation for refined exploration\n            if np.random.rand() < 0.1:\n                hybrid_perturbation = np.random.uniform(-1, 1, size=self.dim) * (ub - lb) * 0.005\n                candidate = self.best_global_position + hybrid_perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08760 with standard deviation 0.03630.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.09419668705778539, 0.04020943655818454, 0.12839694120383593]}}
{"id": "90f3b8a9-8004-4afd-9488-04f31d4a3d81", "fitness": 0.0553758427149188, "name": "RefinedAdaptiveSwarm", "description": "Adaptive swarm optimization with iterative chaos-driven inertia and adaptive strategy diversification through Lévy flights and local chaotic perturbations for enhanced convergence.  ", "code": "import numpy as np\n\nclass RefinedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.3\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.2:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.02\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 63, "feedback": "The algorithm RefinedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05538 with standard deviation 0.02212.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.06316545458695666, 0.025245350042153558, 0.07771672351564618]}}
{"id": "c8d3513c-e8de-4da6-b2fb-addce09ea32d", "fitness": 0.08653319846916548, "name": "RefinedDynamicAdaptiveSwarm", "description": "Improved swarm optimization using adaptive chaos-driven parameters, dynamic levy flights, and local search intensification for enhanced convergence and diversity management.", "code": "import numpy as np\n\nclass RefinedDynamicAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.2:\n                alpha = 1.5  # Levy flight parameter\n                levy_flight = (np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01) * (self.epsilon + np.abs(velocities[np.argmin(values)]))**alpha\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 64, "feedback": "The algorithm RefinedDynamicAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08653 with standard deviation 0.07461.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.03930822746296447, 0.028433252537278686, 0.19185811540725328]}}
{"id": "8a8e146c-2559-45f7-9f9b-777ce56b93d5", "fitness": 0.08215891583171005, "name": "ImprovedAdaptiveSwarmHybrid", "description": "Improved swarm optimization using adaptive inertia blending and hybrid perturbation strategies for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedAdaptiveSwarmHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = (\n                self.final_inertia_weight +\n                (self.initial_inertia_weight - self.final_inertia_weight) *\n                (0.5 * (1 + np.cos(np.pi * evals / self.budget)) * chaos_parameter)\n            )\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.standard_normal(self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 65, "feedback": "The algorithm ImprovedAdaptiveSwarmHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08216 with standard deviation 0.03153.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.1129227549466415, 0.03883155554826023, 0.09472243700022842]}}
{"id": "1d72c69d-107f-4664-98d0-396234b04b6d", "fitness": 0.07631818521300944, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Improves swarm convergence speed by dynamically adjusting the social parameter more aggressively during exploration phase.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.8 * (np.cos(evals / self.budget * np.pi) + 1)  # Change here\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)  # Slight modification here\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07632 with standard deviation 0.02781.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.07056066748874668, 0.0455039809503438, 0.11288990719993786]}}
{"id": "21100d78-66f2-4f56-a6d6-13cc86a91c05", "fitness": 0.07377189305677338, "name": "EnhancedDynamicAdaptiveSwarmV3", "description": "Implement an EnhancedDynamicAdaptiveSwarmV3 with multilevel chaotic sequences for better trajectory diversity and adaptive mutation strategies to improve convergence rates.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter1, chaos_parameter2 = np.random.rand(), np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter1 = 3.99 * chaos_parameter1 * (1 - chaos_parameter1)\n            chaos_parameter2 = 3.99 * chaos_parameter2 * (1 - chaos_parameter2)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (chaos_parameter1 + chaos_parameter2) / 2\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Advanced Diversity Adjustment\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07377 with standard deviation 0.03045.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.03131075494310043, 0.08877928444156646, 0.10122563978565324]}}
{"id": "ce2d98ae-2f9e-4b15-8610-254a17e6a273", "fitness": 0.0672931852430431, "name": "EnhancedDynamicAdaptiveSwarmV3", "description": "An enhanced adaptive swarm algorithm utilizing a self-regulating chaos factor and a dynamic cognitive-social balance for improved convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV3:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            # Dynamic balancing of cognitive and social parameters\n            cognitive_param = self.cognitive_param_base * (1 + 0.5 * np.sin(evals * np.pi / self.budget))\n            social_param = self.social_param_base * (1 - 0.5 * np.cos(evals * np.pi / self.budget))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced dynamic diversity preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocity_adjustment_factor = (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n            velocities *= velocity_adjustment_factor\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Local search enhancement with adaptive perturbation\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.1\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Employ adaptive Lévy flights for escaping local minima\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01 * velocity_adjustment_factor\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 68, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV3 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06729 with standard deviation 0.04466.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.04638255727338636, 0.026137017787229988, 0.12935998066851295]}}
{"id": "96d95395-2880-4341-b207-d3374a8b600c", "fitness": 0.08209511201151627, "name": "HybridChaosAdaptiveSwarm", "description": "Hybrid Chaos-Enhanced Adaptive Swarm with Multi-Phase Exploration and Exploitation for Improved Convergence.", "code": "import numpy as np\n\nclass HybridChaosAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.dynamic_exploration_rate = 0.3\n        self.epsilon = 1e-8\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.99 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.dynamic_exploration_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.3\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.2:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.02\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 69, "feedback": "The algorithm HybridChaosAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08210 with standard deviation 0.06363.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.0595362953255405, 0.017934560078650796, 0.16881448063035753]}}
{"id": "5e4ec9b4-d65e-45dd-9d31-b523da2e1b74", "fitness": 0.08139759502838732, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Minor enhancements in the inertia weight and exploration mechanisms to slightly improve convergence without altering the overall structure.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.95  # Adjusted for better exploration\n        self.final_inertia_weight = 0.3     # Adjusted for better exploitation\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon / (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08140 with standard deviation 0.04444.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.08862065996967827, 0.02371856417096796, 0.13185356094451572]}}
{"id": "2546233a-7077-4960-9d38-4be02b2809f9", "fitness": 0.10170482884245602, "name": "EnhancedDynamicAdaptiveSwarmV2", "description": "Enhanced swarm optimization with refined dynamic diversity scaling to improve global search balance.", "code": "import numpy as np\n\nclass EnhancedDynamicAdaptiveSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  # Slight modification here\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedDynamicAdaptiveSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10170 with standard deviation 0.05711.", "error": "", "parent_ids": ["fa42f65e-ad80-4c2e-be7d-064385e805eb"], "operator": null, "metadata": {"aucs": [0.06526655876034537, 0.057495384213294365, 0.18235254355372832]}}
{"id": "a51ba100-47d6-4571-9c34-e59ead91d7a9", "fitness": 0.11944018595961954, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introducing an adaptive multi-phase chaos-enhanced exploration strategy to improve convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 72, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11944 with standard deviation 0.05499.", "error": "", "parent_ids": ["2546233a-7077-4960-9d38-4be02b2809f9"], "operator": null, "metadata": {"aucs": [0.10404255048782995, 0.061126962142667995, 0.1931510452483607]}}
{"id": "1308287a-c8c5-4179-925d-1203bb2888dc", "fitness": 0.07029217025646373, "name": "AdaptiveChaosEnhancedSwarm", "description": "Enhanced chaos-based dynamic adjustment with proactive exploration using a blended crossover mechanism.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.97 * chaos_parameter * (1 - chaos_parameter)  # Modified chaos parameter\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.6 * (np.sin(evals / self.budget * np.pi) + 1)  # Adjusted factor\n            social_param = self.social_param_base - 0.6 * (np.cos(evals / self.budget * np.pi) + 1)  # Adjusted factor\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n            \n            # New crossover mechanism\n            for i in range(self.population_size):\n                if np.random.rand() < 0.2:\n                    partner = np.random.randint(self.population_size)\n                    alpha = np.random.rand(self.dim)\n                    offspring = alpha * population[i] + (1 - alpha) * population[partner]\n                    if func(offspring) < local_best_values[i]:\n                        local_best_positions[i] = offspring\n                        local_best_values[i] = func(offspring)\n                        evals += 1\n\n        return self.best_global_position", "configspace": "", "generation": 73, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07029 with standard deviation 0.02443.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.03838655177687089, 0.09772322461496197, 0.07476673437755832]}}
{"id": "a2096507-e897-4651-ba35-0deb5e7febab", "fitness": 0.07891574911544168, "name": "EnhancedAdaptiveChaosSwarm", "description": "Combine adaptive chaotic dynamics, dynamic learning strategies, and a hybrid search process to improve exploration and convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaosSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            # Chaotic dynamics\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Hybrid local search with dynamic radius\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.25\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Levy flight based exploration\n            if evals < self.budget * 0.5 and np.random.rand() < 0.2:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.015\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedAdaptiveChaosSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07892 with standard deviation 0.03276.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.08276689085543243, 0.037010232426685885, 0.1169701240642067]}}
{"id": "fca28f78-2d48-48ab-aa2e-6771cc97d294", "fitness": 0.11944018595961954, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introducing a dynamic inertia and parameter modulation strategy combined with Lévy flight and adaptive chaos-driven exploration to enhance convergence and solution quality.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n\n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 75, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11944 with standard deviation 0.05499.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.10404255048782995, 0.061126962142667995, 0.1931510452483607]}}
{"id": "3fe98ef4-1d31-4206-b75d-0118854ee362", "fitness": 0.09135492821383447, "name": "RefinedAdaptiveChaosSwarm", "description": "A refined chaotic adaptive swarm algorithm incorporating dynamic cognitive-social balancing and adaptive perturbation for robust performance across diverse optimization landscapes.", "code": "import numpy as np\n\nclass RefinedAdaptiveChaosSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.99 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 76, "feedback": "The algorithm RefinedAdaptiveChaosSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09135 with standard deviation 0.07994.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.05003603987199756, 0.020887835328625926, 0.20314090944087992]}}
{"id": "c0723ea3-c3b8-4f81-afba-c4a7ee6e9671", "fitness": 0.09266657884344842, "name": "EnhancedChaosHyperSphereSwarm", "description": "Incorporating adaptive multi-phase chaos-enhanced exploration with a novel dynamic hyper-sphere contraction strategy for improved convergence and exploration balance.", "code": "import numpy as np\n\nclass EnhancedChaosHyperSphereSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.hyper_sphere_contraction_rate = 0.95\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n        sphere_radius = np.linalg.norm(ub - lb)\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = sphere_radius * self.hyper_sphere_contraction_rate\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            sphere_radius *= self.hyper_sphere_contraction_rate\n\n        return self.best_global_position", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedChaosHyperSphereSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09267 with standard deviation 0.02259.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.10404255048782995, 0.061126962142667995, 0.11283022389984732]}}
{"id": "21803cca-2695-4e37-9f12-e50099c98be6", "fitness": 0.06812451180106782, "name": "AdaptiveChaosEnhancedSwarm", "description": "Integrating a time-varying chaotic inertia weight with stochastic perturbation for adaptive balance between exploration and exploitation in swarm optimization.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.99 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n\n            # Enhanced Dynamic Diversity Preservation with Stochastic Perturbation\n            diversity = np.mean(np.std(population, axis=0))\n            stochastic_factor = np.random.uniform(-0.1, 0.1, self.dim)\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5 + stochastic_factor)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 78, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06812 with standard deviation 0.02367.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.03550747144617372, 0.07789773712874282, 0.09096832682828693]}}
{"id": "d6d6e989-f636-4f3a-9a83-94cd63f3d077", "fitness": 0.07510966410801034, "name": "AdaptiveSynergySwarm", "description": "Introducing multi-agent adaptive velocity scaling and a synergy-driven social component to improve convergence and solution exploration.", "code": "import numpy as np\n\nclass AdaptiveSynergySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2, r3 = np.random.rand(3, self.population_size, self.dim)\n            synergy_factor = np.mean(local_best_positions, axis=0)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population) +\n                0.5 * r3 * (synergy_factor - population)\n            )\n            \n            # Multi-Agent Adaptive Velocity Scaling\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Synergy-Driven Exploration\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                synergy_shift = np.random.standard_normal(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + synergy_shift\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 79, "feedback": "The algorithm AdaptiveSynergySwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07511 with standard deviation 0.05626.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.15466844445220285, 0.03640904136438616, 0.03425150650744202]}}
{"id": "8200704f-9045-492b-a653-89838e9d8de9", "fitness": 0.02222945505290112, "name": "AdaptiveChaosEnhancedSwarmV2", "description": "Introducing stochastic chaotic perturbations and adaptive variance-strategy for enhanced exploration-exploitation balance in swarm optimization.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarmV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation with Adaptive Variance Strategy\n            diversity = np.mean(np.std(population, axis=0))\n            variance_factor = np.var(local_best_values) / (np.var(local_best_values) + 1e-8)\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5) * (1 + variance_factor)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 80, "feedback": "The algorithm AdaptiveChaosEnhancedSwarmV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02223 with standard deviation 0.02437.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.05668836515870335, 0.0050000000000000044]}}
{"id": "a29c2ff0-1e97-4738-a79c-bea50172005d", "fitness": -Infinity, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introduce a gradient-based local search for improved exploitation in chaotic swarm optimization.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Gradient-based local search\n            if np.random.rand() < self.local_search_rate:\n                candidate = self.best_global_position.copy()\n                gradient = np.gradient(func(candidate))\n                candidate -= 0.01 * gradient\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 81, "feedback": "An exception occurred: TypeError(\"can't multiply sequence by non-int of type 'float'\").", "error": "TypeError(\"can't multiply sequence by non-int of type 'float'\")", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {}}
{"id": "c98139e8-e899-474a-ad9a-b9c988a4866b", "fitness": 0.07595083730670948, "name": "AdaptiveChaosEnhancedSwarm", "description": "Improved adaptive chaos-enhanced exploration by dynamically adjusting the local search rate.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Dynamically adjust local search rate based on evaluations\n            self.local_search_rate = 0.2 + 0.3 * (1 - evals / self.budget)  \n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 82, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07595 with standard deviation 0.02017.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.08113497430271532, 0.04906817625431015, 0.09764936136310298]}}
{"id": "de0bb3e0-3b13-4780-86fa-7970f47168de", "fitness": 0.07371322477135582, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introducing a dynamic inertia weight strategy with adaptive chaos and Levy flights for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * np.sin(np.pi * chaos_parameter)\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if evals < self.budget * 0.5 and np.random.rand() < self.local_search_rate:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 83, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.07371 with standard deviation 0.03305.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.1140891500245218, 0.03313423705697527, 0.07391628723257038]}}
{"id": "5b8f1cf5-f5c5-42ff-8e66-f57824d8b98d", "fitness": 0.0653103501543267, "name": "AdaptiveChaosEnhancedSwarm", "description": "Refining chaos dynamics and diversity preservation with adaptive feedback for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3  # Adjusted to increase local search probability\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            feedback = min(evals / self.budget, 0.5)\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5 * feedback)  # Introduced feedback factor\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.15  # Adjusted dynamic range\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 84, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06531 with standard deviation 0.04363.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.08417729662181328, 0.0050000000000000044, 0.10675375384116681]}}
{"id": "d9b5b2bc-568c-4cb7-ac7c-155e36c6dbbe", "fitness": 0.05733142969222149, "name": "RefinedAdaptiveChaosSwarm", "description": "Refinement of AdaptiveChaosEnhancedSwarm using phase-dependent parameters and adaptive perturbation for enhanced global and local exploration.  ", "code": "import numpy as np\n\nclass RefinedAdaptiveChaosSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            phase_ratio = evals / self.budget\n            inertia_weight = (1 - phase_ratio) * self.initial_inertia_weight + phase_ratio * self.final_inertia_weight\n            cognitive_param = self.cognitive_param_base * (1 + 0.5 * np.sin(phase_ratio * np.pi))\n            social_param = self.social_param_base * (1 - 0.5 * np.cos(phase_ratio * np.pi))\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - phase_ratio) * 0.1\n                perturbation = np.random.uniform(-dynamic_radius, dynamic_radius, self.dim)\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.6 and np.random.rand() < 0.2:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.005\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 85, "feedback": "The algorithm RefinedAdaptiveChaosSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05733 with standard deviation 0.01462.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.07439446994664978, 0.03869181575625735, 0.058908003373757345]}}
{"id": "da27d4df-0acc-4faa-a862-2c9b774dfa82", "fitness": 0.09967216458439376, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introduce a dynamic local search rate adjustment to enhance convergence.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n            \n            self.local_search_rate = 0.2 * (1 - evals / self.budget)  # Dynamic adjustment\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 86, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09967 with standard deviation 0.06215.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.08725295649341658, 0.030522861602694573, 0.18124067565707014]}}
{"id": "57050648-b0f2-4dfb-bd5f-de2204a77065", "fitness": 0.025762412800716488, "name": "AdaptiveChaosEnhancedSwarm", "description": "Implementing a multi-strategy diversity preservation with adaptive perturbation and chaotic attractor to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n\n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n\n            # Adaptive perturbation mechanism\n            adaptive_perturbation = np.random.uniform(-chaos_parameter, chaos_parameter, (self.population_size, self.dim))\n            velocities += adaptive_perturbation\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 87, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.02576 with standard deviation 0.02500.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.005556985008421389, 0.01074307053163781, 0.06098718286209026]}}
{"id": "c544f6b9-9009-4c03-94a8-608028762c8d", "fitness": 0.0050000000000000044, "name": "DualChaosAdaptiveSwarm", "description": "Introducing a dual-chaos mechanism for enhanced global exploration and fine-tuned local search optimization.", "code": "import numpy as np\n\nclass DualChaosAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameters = [np.random.rand(), np.random.rand()]\n\n        while evals < self.budget:\n            for i in range(len(chaos_parameters)):\n                chaos_parameters[i] = 3.95 * chaos_parameters[i] * (1 - chaos_parameters[i])\n            \n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameters[0]\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation with Dual Chaos\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5 + chaos_parameters[1])\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 88, "feedback": "The algorithm DualChaosAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.00500 with standard deviation 0.00000.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.0050000000000000044, 0.0050000000000000044, 0.0050000000000000044]}}
{"id": "68ffbae3-ce3f-436a-aad1-6f50fc83422e", "fitness": 0.09291574905388855, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introducing a slight adjustment to the cognitive and social parameter dynamics for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.6 * (np.cos(evals / self.budget * np.pi) + 1)  # Slight change here\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 89, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09292 with standard deviation 0.04183.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.09199221664175217, 0.04215855716428196, 0.14459647335563153]}}
{"id": "a0887464-c35e-4f99-9355-60ab96196fda", "fitness": 0.06640995503663845, "name": "HybridAdaptiveMomentumSwarm", "description": "Introducing a hybrid adaptive momentum strategy with multi-peak chaotic perturbations to enhance convergence and solution diversity.", "code": "import numpy as np\n\nclass HybridAdaptiveMomentumSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            # Multi-peak chaotic perturbation\n            chaos_parameter = 3.8 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Refined local search strategy\n            if np.random.rand() < self.local_search_rate * (1 - evals / self.budget):\n                dynamic_radius = (ub - lb) * 0.1 * (1 - evals / self.budget)\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            # Randomized Levy Flight for exploration\n            if np.random.rand() < 0.1:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.05\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 90, "feedback": "The algorithm HybridAdaptiveMomentumSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06641 with standard deviation 0.04416.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.03566922697572639, 0.03470077416618611, 0.12885986396800286]}}
{"id": "0a551f8a-5209-418b-8226-e76afb598c4e", "fitness": 0.0545232653667073, "name": "AdaptiveChaosEnhancedSwarm", "description": "Enhance exploration by dynamically incorporating Levy flights based on chaos parameter.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if np.random.rand() < 0.15 * chaos_parameter:  # Only this line is modified\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 91, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05452 with standard deviation 0.02720.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.05036484435220401, 0.023485737465639867, 0.08971921428227803]}}
{"id": "d096f315-c166-4f15-9fee-74c0279a4651", "fitness": 0.11033520530105534, "name": "AdaptiveChaosEnhancedSwarm", "description": "Modifying the neighborhood exploration factor to enhance adaptive exploitation during the optimization process.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (0.9 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 92, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11034 with standard deviation 0.04298.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.10404255048782995, 0.061126962142667995, 0.16583610327266807]}}
{"id": "77b2f5c8-b120-4a9d-b6d5-c42c37587f0a", "fitness": 0.0676660828050234, "name": "AdaptiveChaosEnhancedSwarm", "description": "Integrate adaptive mutation with chaos-driven parameter tuning to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n        mutation_strength = 0.1\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n            \n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n            population += velocities\n            population = np.clip(population, lb, ub)\n            \n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius * mutation_strength\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01 * mutation_strength\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 93, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06767 with standard deviation 0.04752.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.07799256702829926, 0.0050000000000000044, 0.12000568138677092]}}
{"id": "b967436e-04a1-41ad-84d6-4c330728f779", "fitness": 0.04095738216967337, "name": "AdaptiveChaosEnhancedSwarm", "description": "Enhanced exploration through oscillating inertia and modified chaos factor to boost convergence and solution accuracy.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.7  # Change 1\n        self.social_param_base = 1.3  # Change 2\n        self.local_search_rate = 0.25  # Change 3\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.7 * chaos_parameter * (1 - chaos_parameter)  # Change 4\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * np.abs(np.cos(chaos_parameter * np.pi))  # Change 5\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:  # Change 6\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.25  # Change 7\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 94, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04096 with standard deviation 0.02033.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.05501868110027042, 0.012213753516833958, 0.055639711891915744]}}
{"id": "84429eac-ba18-4cad-bb9d-f66ed5c3a207", "fitness": 0.11944018595961954, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introducing a dynamic inertia weight adjustment based on fitness improvement to enhance convergence speed.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                inertia_weight *= 0.95  # Change: Adjusting the inertia weight based on fitness improvement\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 95, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11944 with standard deviation 0.05499.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.10404255048782995, 0.061126962142667995, 0.1931510452483607]}}
{"id": "a5e85c5d-ff1f-4d3a-a998-422eb6e73624", "fitness": 0.06760305851032884, "name": "AdaptiveChaosEnhancedSwarm", "description": "Enhanced adaptive chaos with dynamic feedback and improved local search to refine convergence.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.25  # Increased local search rate\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.15  # Adjusted dynamic radius factor\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 96, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06760 with standard deviation 0.04611.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.08276689085543243, 0.005090950217671142, 0.11495133445788297]}}
{"id": "a6112788-0bb1-40b7-9283-3e65dd5f18e9", "fitness": 0.04613145115623988, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introduce nonlinear inertia weight decay for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            # Nonlinear inertia weight decay\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * (1 - evals / self.budget) ** 2\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.5 and np.random.rand() < 0.15:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 97, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04613 with standard deviation 0.03452.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.043922941834383056, 0.0050000000000000044, 0.08947141163433658]}}
{"id": "4fd2c5dd-b52b-4d8b-b507-3fbe36cc14fa", "fitness": 0.08762320009242668, "name": "EnhancedAdaptiveChaosSwarm", "description": "Enhancing swarm intelligence with adaptive chaos, dynamic diversity, and Levy flights for superior convergence and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedAdaptiveChaosSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.99 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Enhanced Dynamic Diversity Preservation\n            diversity = np.mean(np.std(population, axis=0))\n            velocities *= (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            if np.random.rand() < self.local_search_rate:\n                dynamic_radius = (ub - lb) * (1 - evals / self.budget) * 0.2\n                perturbation = np.random.uniform(-1, 1, self.dim) * dynamic_radius\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n            if evals < self.budget * 0.7 and np.random.rand() < 0.2:\n                levy_flight = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.01\n                candidate = self.best_global_position + levy_flight\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedAdaptiveChaosSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08762 with standard deviation 0.02419.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.08922718419223175, 0.057228852812868936, 0.11641356327217933]}}
{"id": "f31abf03-3e47-41a5-86ea-1242e8c04d6f", "fitness": 0.06512554353547555, "name": "AdaptiveChaosEnhancedSwarm", "description": "Introducing a dynamic adaptive diversity control mechanism and multi-scale perturbation strategies to enhance exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveChaosEnhancedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 2)\n        self.initial_inertia_weight = 0.9\n        self.final_inertia_weight = 0.4\n        self.cognitive_param_base = 1.5\n        self.social_param_base = 1.5\n        self.local_search_rate = 0.2\n        self.best_global_position = None\n        self.best_global_value = np.inf\n        self.epsilon = 1e-8\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        population = np.random.uniform(lb, ub, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        local_best_positions = population.copy()\n        local_best_values = np.array([func(ind) for ind in population])\n        self.best_global_value = np.min(local_best_values)\n        self.best_global_position = population[np.argmin(local_best_values)].copy()\n        evals = self.population_size\n\n        chaos_parameter = np.random.rand()\n\n        while evals < self.budget:\n            chaos_parameter = 3.95 * chaos_parameter * (1 - chaos_parameter)\n            inertia_weight = self.final_inertia_weight + (self.initial_inertia_weight - self.final_inertia_weight) * chaos_parameter\n\n            cognitive_param = self.cognitive_param_base + 0.5 * (np.sin(evals / self.budget * np.pi) + 1)\n            social_param = self.social_param_base - 0.5 * (np.cos(evals / self.budget * np.pi) + 1)\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (\n                inertia_weight * velocities +\n                cognitive_param * r1 * (local_best_positions - population) +\n                social_param * r2 * (self.best_global_position - population)\n            )\n            \n            # Dynamic Adaptive Diversity Control\n            diversity = np.mean(np.std(population, axis=0))\n            diversity_factor = (1 + self.epsilon * (diversity + self.epsilon) ** 0.5)\n            velocities *= diversity_factor  \n\n            population += velocities\n            population = np.clip(population, lb, ub)\n\n            values = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            better_mask = values < local_best_values\n            local_best_positions[better_mask] = population[better_mask]\n            local_best_values[better_mask] = values[better_mask]\n\n            if np.min(values) < self.best_global_value:\n                self.best_global_value = np.min(values)\n                self.best_global_position = population[np.argmin(values)].copy()\n\n            # Multi-scale Perturbation Strategy\n            if np.random.rand() < self.local_search_rate:\n                scale = 1 - evals / self.budget\n                small_perturbation = np.random.uniform(-1, 1, self.dim) * (ub - lb) * 0.01 * scale\n                large_perturbation = np.random.standard_cauchy(size=self.dim) * (ub - lb) * 0.05 * scale\n                perturbation = small_perturbation if np.random.rand() > 0.5 else large_perturbation\n                candidate = self.best_global_position + perturbation\n                candidate = np.clip(candidate, lb, ub)\n                candidate_value = func(candidate)\n                evals += 1\n\n                if candidate_value < self.best_global_value:\n                    self.best_global_value = candidate_value\n                    self.best_global_position = candidate\n\n        return self.best_global_position", "configspace": "", "generation": 99, "feedback": "The algorithm AdaptiveChaosEnhancedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06513 with standard deviation 0.03017.", "error": "", "parent_ids": ["a51ba100-47d6-4571-9c34-e59ead91d7a9"], "operator": null, "metadata": {"aucs": [0.07402540752038178, 0.024535587625894695, 0.09681563546015015]}}
