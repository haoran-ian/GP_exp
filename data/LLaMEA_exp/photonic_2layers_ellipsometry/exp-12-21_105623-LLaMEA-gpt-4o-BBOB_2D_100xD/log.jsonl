{"id": "a4bfa98a-520d-43e9-9f02-dd38d3055f2d", "fitness": 0.35162573861856017, "name": "HybridPSODE", "description": "A hybrid Particle Swarm Optimization and Differential Evolution algorithm that adapts dynamically to the search landscape by leveraging swarm intelligence for exploration and mutation-driven exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35163 with standard deviation 0.34598.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.8612367579141997, 0.8802410634954195, 0.7605631762180061, 0.0050000000000000044, 0.058386651837985304, 0.1129233293237405, 0.16066456774355042, 0.15712959023795547, 0.1684865107961846]}}
{"id": "4f82c326-ac87-485f-8596-da15a1dbca84", "fitness": 0.23352399649238492, "name": "HybridQPSODE", "description": "An adaptive swarm-based algorithm that combines Quantum Particle Swarm Optimization (QPSO) and Differential Evolution (DE) for enhanced exploration and exploitation balance in black-box optimization.", "code": "import numpy as np\n\nclass HybridQPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.beta = 0.5  # contraction-expansion coefficient for QPSO\n        self.global_best_value = np.inf\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        self.global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            mean_best = np.mean(personal_best, axis=0)\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                phi = np.random.uniform(-1, 1, self.dim)\n                u = np.random.rand(self.dim)\n                \n                # QPSO update\n                p = (personal_best[i] + global_best) / 2\n                L = self.beta * np.log(1 / u)\n                new_position = p + phi * np.abs(mean_best - swarm[i]) * L\n                new_position = np.clip(new_position, lb, ub)\n\n                # DE mutation and crossover\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            new_position[j] = swarm[np.random.randint(self.pop_size)][j]\n                \n                new_position_value = func(new_position)\n                eval_count += 1\n                \n                if new_position_value < personal_best_values[i]:\n                    personal_best[i] = new_position\n                    personal_best_values[i] = new_position_value\n                    if new_position_value < self.global_best_value:\n                        global_best = new_position\n                        self.global_best_value = new_position_value\n        \n        return global_best", "configspace": "", "generation": 1, "feedback": "The algorithm HybridQPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23352 with standard deviation 0.24381.", "error": "", "parent_ids": ["a4bfa98a-520d-43e9-9f02-dd38d3055f2d"], "operator": null, "metadata": {"aucs": [0.6070788485652417, 0.7150003946509575, 0.30179446407550903, 0.02842196394165053, 0.009243586608778553, 0.045341888654903184, 0.12674472459950592, 0.13293556573839393, 0.13515453159652435]}}
{"id": "f4945dee-e87a-400c-9f7e-58242b302a46", "fitness": 0.3667163194748213, "name": "HybridPSODE", "description": "A hybrid PSO with enhanced cognitive parameter tuning dynamically based on iteration count for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36672 with standard deviation 0.33649.", "error": "", "parent_ids": ["a4bfa98a-520d-43e9-9f02-dd38d3055f2d"], "operator": null, "metadata": {"aucs": [0.8612367579141997, 0.8802410634954195, 0.7605631762180061, 0.017882554316890342, 0.10135433631050295, 0.10277048485796936, 0.2003124035685867, 0.15395038836531583, 0.2221357102265018]}}
{"id": "21ee6d44-129e-4518-a387-79eb7b50bfc4", "fitness": 0.3667163194748213, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive mutation factor based on current solution diversity for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))  # Updated line\n            self.mutation_factor = 0.8 + 0.2 * np.var(swarm)  # Adaptively modify mutation factor based on solution diversity\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 3, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36672 with standard deviation 0.33649.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.8612367579141997, 0.8802410634954195, 0.7605631762180061, 0.017882554316890342, 0.10135433631050295, 0.10277048485796936, 0.2003124035685867, 0.15395038836531583, 0.2221357102265018]}}
{"id": "f4480b94-3f79-4d01-a221-c14f61b67cc7", "fitness": 0.34817099385256134, "name": "AdaptiveHybridPSODE", "description": "An Adaptive Hybrid PSODE with dynamic adjustment of inertia and social parameters for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Starting inertia\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)  # Dynamic inertia adjustment\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))  # Dynamic social adjustment\n\n            self.velocity = (self.inertia * self.velocity +\n                             self.cognitive * r1 * (personal_best - swarm) +\n                             self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 4, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "aa44085d-2f06-4bb5-9781-4f8f34d06454", "fitness": 0.36045296448249986, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive social parameter tuning based on iteration count for enhanced exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 - (0.5 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 5, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36045 with standard deviation 0.33758.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.8611136979925516, 0.8840743838965062, 0.7359785050912189, 0.01190438761563739, 0.05977775513992667, 0.12465265455048102, 0.20815978575702188, 0.13804011068301092, 0.22037539961614427]}}
{"id": "5a87cc9c-c083-415a-b662-b1c6cb611d5a", "fitness": 0.3531755194604369, "name": "HybridPSODE", "description": "A hybrid PSO with enhanced cognitive and dynamically adjusted inertia for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))  # Updated line\n            self.inertia = 0.5 - (0.3 * (eval_count / self.budget))  # Dynamically adjust inertia\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 6, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35318 with standard deviation 0.33885.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.8612059835770988, 0.8801891960092777, 0.7375294667992951, 0.08130912799085488, 0.04505112393028243, 0.0848290202713351, 0.17488631106445007, 0.15945726593965037, 0.15412217956168772]}}
{"id": "44dd361f-864a-4d4b-a170-a5ef1f4f415b", "fitness": 0.3667163194748213, "name": "HybridPSODE", "description": "A hybrid PSO with dynamically adaptive mutation factor based on the iteration count for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))  # Updated line\n            self.mutation_factor = 0.8 + (0.2 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36672 with standard deviation 0.33649.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.8612367579141997, 0.8802410634954195, 0.7605631762180061, 0.017882554316890342, 0.10135433631050295, 0.10277048485796936, 0.2003124035685867, 0.15395038836531583, 0.2221357102265018]}}
{"id": "3e3f4580-0402-4f49-8207-7ad8e0bd189f", "fitness": 0.3251489758678985, "name": "EnhancedHybridPSODE", "description": "Introducing adaptive velocity and dynamically controlled mutation strategies in HybridPSODE to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            adaptive_inertia = 0.4 + 0.5 * (1 - eval_count / self.budget)\n            self.velocity = adaptive_inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < (1 - eval_count / self.budget):\n                    mutate_indices = np.random.choice(self.dim, max(1, self.dim // 5), replace=False)\n                    trial[mutate_indices] = np.random.uniform(lb[mutate_indices], ub[mutate_indices])\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 8, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32515 with standard deviation 0.34062.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.7753893513587623, 0.8388968660043977, 0.7867417385152062, 0.030184246538130677, 0.023522826558230125, 0.013666596815623544, 0.1432953169994814, 0.15162634546301978, 0.16301749455823478]}}
{"id": "022a5fbb-3bb5-40b2-a4e5-9195e341cab3", "fitness": 0.338758171513453, "name": "EnhancedHybridPSODE", "description": "Introducing random restarts and adaptive inertia weight adjustment to enhance exploration and convergence in PSO.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.min_inertia = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        self.global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            if eval_count % (self.budget // 5) == 0:  # Random restarts\n                swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n            \n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.inertia = self.min_inertia + (0.5 * (1 - eval_count / self.budget))  # Adaptive inertia\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < self.global_best_value:\n                        global_best = trial\n                        self.global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 9, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33876 with standard deviation 0.36900.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.8419419839844474, 0.8863263410285982, 0.8325857378156212, 0.0050000000000000044, 0.023526201076559117, 0.0050000000000000044, 0.13253914758690433, 0.14285226491574865, 0.179051867213198]}}
{"id": "e13d11cb-4ec7-4332-993b-66fe08399803", "fitness": 0.34343023055359795, "name": "EnhancedHybridPSODE", "description": "A hybrid PSO enhanced with adaptive inertia and self-adjusting crossover mechanisms for improved diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.init_crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Adaptive inertia weight\n            inertia_weight = 0.4 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = inertia_weight\n            \n            # Update velocity\n            self.velocity = (self.inertia * self.velocity +\n                             self.cognitive * r1 * (personal_best - swarm) +\n                             self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            # Self-adjusting crossover rate\n            crossover_rate = self.init_crossover_rate - (eval_count / self.budget) * 0.5\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 10, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34343 with standard deviation 0.36611.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.8423773823434023, 0.8863263410285982, 0.8325857378156212, 0.015260107421724567, 0.011002175186152208, 0.017233752363700505, 0.1687035789268827, 0.16010663183202323, 0.15727636806427692]}}
{"id": "f8266d15-c025-4c1f-9e50-7547c322c6f2", "fitness": 0.3494774905618895, "name": "AdaptiveHybridPSODE", "description": "An Adaptive Hybrid PSODE with a dynamically weighted velocity and mutation balance for better exploration-exploitation trade-off.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            adapt_factor = 1 - (eval_count / self.budget)\n            self.inertia = 0.5 + 0.4 * adapt_factor  # Adjust inertia dynamically\n            self.cognitive = 1.5 + (0.5 * adapt_factor)\n            self.social = 1.5 + (0.5 * (1 - adapt_factor))\n            \n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 11, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34948 with standard deviation 0.36547.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.8619539501487743, 0.8873656556527869, 0.8331481940125773, 0.010028006392306277, 0.04579147210684553, 0.03915042516233769, 0.15503005600877018, 0.16364867862499244, 0.14918097694761512]}}
{"id": "2f200a7b-5554-48ca-9fd4-71bc4c97d010", "fitness": 0.36822059018171216, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive social parameter enhancement based on iteration count for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 12, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36822 with standard deviation 0.35434.", "error": "", "parent_ids": ["f4945dee-e87a-400c-9f7e-58242b302a46"], "operator": null, "metadata": {"aucs": [0.861965582254754, 0.9322223327517526, 0.7967549927776763, 0.0250540113563672, 0.08425880356419357, 0.16107999231155834, 0.14631063339920347, 0.12604297453629953, 0.18029598868360486]}}
{"id": "b20bdff6-ef57-43b5-9d2f-3d7288c4bc05", "fitness": 0.34817099385256134, "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE with dynamic inertia weight and adaptive crossover to balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.4 + (0.5 * (1 - eval_count / self.budget))  # Dynamic inertia weight\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 13, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "dd42be71-1b9f-4b16-93d9-5e456ac64038", "fitness": 0.3459196108271488, "name": "RefinedHybridPSODE", "description": "A hybrid PSO with nonlinear dynamic adjustment of inertia and adaptive mutation to enhance exploration-exploitation balance.", "code": "import numpy as np\n\nclass RefinedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia_start = 0.9\n        self.inertia_end = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Nonlinear inertia decay\n            inertia = self.inertia_end + (self.inertia_start - self.inertia_end) * (1 - (eval_count / self.budget))**2\n            \n            # Adaptive social parameter\n            self.social = 1.5 + (0.5 * np.sin(np.pi * eval_count / self.budget))\n            \n            self.velocity = inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                \n                # Adaptive mutation probability\n                mutation_prob = 0.1 + 0.9 * (eval_count / self.budget)\n                \n                if np.random.rand() < mutation_prob:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 14, "feedback": "The algorithm RefinedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34592 with standard deviation 0.36368.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8410342886720181, 0.8887307437016931, 0.8338739934017405, 0.025269787229863394, 0.010348439486636773, 0.05338539423105748, 0.1425362825315627, 0.14675379398781385, 0.17134377420195301]}}
{"id": "6a0efa23-fb85-4721-8142-0a1f3252809a", "fitness": 0.3525069854793049, "name": "EnhancedHybridPSODE", "description": "Introducing variable inertia weighting and adaptive mutation to enhance the exploration and exploitation dynamics of the hybrid PSO.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            inertia = self.inertia_min + (self.inertia_max - self.inertia_min) * (1 - (eval_count / self.budget))\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                if np.random.rand() < 0.1:  # Adaptive mutation probability\n                    mutation_vector = np.random.uniform(-1, 1, self.dim) * self.mutation_factor\n                    trial = np.clip(trial + mutation_vector, lb, ub)\n                    \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 15, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35251 with standard deviation 0.38527.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8875897087576823, 0.9368626829286343, 0.8437595057975239, 0.010460525853014713, 0.018512287184714205, 0.0050000000000000044, 0.19526742390507024, 0.12404427212532898, 0.1510664627617757]}}
{"id": "dec3abf7-787b-4248-ba96-3d027d6c534d", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive inertia weight to balance exploration and exploitation for enhanced convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 16, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "12260251-4da6-4c8a-8ce0-d7a38ee1f22d", "fitness": 0.35624287945870686, "name": "DynamicHybridPSODE", "description": "A dynamic hybrid PSO with adaptive inertia, cognitive, and social parameters, incorporating differential evolution mutation for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass DynamicHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 2.0\n        self.social = 2.0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))\n            self.cognitive = 2.0 - (0.5 * (eval_count / self.budget))\n            self.social = 2.0 + (0.5 * (eval_count / self.budget))\n            \n            self.velocity = (\n                self.inertia * self.velocity\n                + self.cognitive * r1 * (personal_best - swarm)\n                + self.social * r2 * (global_best - swarm)\n            )\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                \n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                else:  # Apply differential evolution mutation\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    a, b, c = swarm[indices[0]], swarm[indices[1]], swarm[indices[2]]\n                    trial = a + self.mutation_factor * (b - c)\n                    trial = np.clip(trial, lb, ub)\n                    \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 17, "feedback": "The algorithm DynamicHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35624 with standard deviation 0.34600.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8387867092282251, 0.8831995141919597, 0.7884446838876131, 0.0050000000000000044, 0.029869604438540476, 0.2094662308097639, 0.17947223759425457, 0.12243453313539365, 0.14951240184261083]}}
{"id": "8ac30956-c6a6-4d69-b9e5-d09bfc4eb9fb", "fitness": 0.34809548253616485, "name": "HybridPSODE_Improved", "description": "Introduce adaptive inertia reduction and dynamic crossover rate adjustment in Hybrid PSO with DE to improve convergence speed and accuracy.", "code": "import numpy as np\n\nclass HybridPSODE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate_max = 0.9\n        self.crossover_rate_min = 0.6\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            inertia = self.inertia_max - ((self.inertia_max - self.inertia_min) * (eval_count / self.budget))\n            crossover_rate = self.crossover_rate_min + ((self.crossover_rate_max - self.crossover_rate_min) * (1 - eval_count / self.budget))\n            \n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 18, "feedback": "The algorithm HybridPSODE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34810 with standard deviation 0.38058.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0060571759868881525, 0.03127644310436328, 0.14414231562937063, 0.1602539308677723, 0.1477040951334776]}}
{"id": "144eb6b0-2b9c-41c6-afa5-8ff016497492", "fitness": 0.36822059018171216, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive social parameter enhancement and dynamic mutation factor for improved convergence and diversity maintenance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.mutation_factor = 0.9 - 0.4 * (eval_count / self.budget)  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36822 with standard deviation 0.35434.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.861965582254754, 0.9322223327517526, 0.7967549927776763, 0.0250540113563672, 0.08425880356419357, 0.16107999231155834, 0.14631063339920347, 0.12604297453629953, 0.18029598868360486]}}
{"id": "c6fbc103-8ae2-4718-9113-e5dae8be5f20", "fitness": 0.3645294127084076, "name": "HybridPSODE", "description": "Enhanced Hybrid PSO with dynamic inertia adjustment for improved convergence stability.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.7 - (0.5 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 20, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36453 with standard deviation 0.36972.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8621007532660568, 0.9323379612685294, 0.8410124959251603, 0.0050000000000000044, 0.06544908946101824, 0.03964507454505051, 0.233935033966588, 0.13674704317280184, 0.164537262770464]}}
{"id": "e7053dfe-685c-4d3f-9be6-4ee29259cc7c", "fitness": 0.3627756497444893, "name": "EnhancedHybridPSODE", "description": "Enhanced HybridPSODE incorporating dynamic population size and adaptive inertia to improve exploration and convergence balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.initial_pop_size = self.pop_size\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            inertia = self.inertia_max - ((self.inertia_max - self.inertia_min) * (eval_count / self.budget))\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n            \n            # Dynamically adjust population size\n            self.pop_size = self.initial_pop_size + int((self.budget - eval_count) / self.budget * self.initial_pop_size)\n            self.velocity = np.resize(self.velocity, (self.pop_size, self.dim))\n            swarm = np.resize(swarm, (self.pop_size, self.dim))\n            personal_best = np.resize(personal_best, (self.pop_size, self.dim))\n            personal_best_values = np.resize(personal_best_values, self.pop_size)\n        \n        return global_best", "configspace": "", "generation": 21, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36278 with standard deviation 0.36922.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8629683979260533, 0.9325069560599878, 0.8408196747665754, 0.016784250582403737, 0.013452464246651585, 0.15120715735606938, 0.14894548044232236, 0.1418651070899628, 0.15643135923037732]}}
{"id": "13b7ddfe-58ab-4cac-ae74-3ccd1cad3561", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "Enhanced Hybrid PSO with dynamic inertia adjustment and refined exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 22, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "e28ec6d7-a3a4-49a2-93b4-b6177b7dd085", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "An enhanced hybrid PSO that dynamically adjusts the inertia factor based on the evaluation count to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 23, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "2f40750d-3e89-452b-8bf6-0b97ab50240f", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "An adaptive hybrid PSO-DE algorithm with enhanced velocity update by introducing a dynamic inertia weight based on iteration progress.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 24, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "f0babb0f-9249-4ae0-9e15-cbbcdf81d58f", "fitness": 0.36377385217014135, "name": "EnhancedHybridPSO", "description": "Enhanced Hybrid PSO with dynamic learning rates and adaptive mutation for improved global exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget)) ** 2  # Dynamic cognitive\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget)) ** 2  # Dynamic social\n            self.velocity = (self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + \n                             self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                        # Adaptive mutation for exploration\n                        self.mutation_factor = 0.9 - (0.5 * (eval_count / self.budget))\n        \n        return global_best", "configspace": "", "generation": 25, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36377 with standard deviation 0.35784.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.861722366941315, 0.9322223327517526, 0.7889248970060619, 0.0050000000000000044, 0.04783920873613767, 0.10840272515842675, 0.20648800665702627, 0.14739066215219143, 0.17597447012836043]}}
{"id": "782bf32a-1454-4815-a14c-6641e4635821", "fitness": 0.3379410798880428, "name": "EnhancedHybridPSODE", "description": "Enhanced Hybrid PSO with adaptive inertia and diversity-driven mutation for robust convergence across varying landscapes.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with high inertia\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))  # Adaptive inertia\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            # Diversity-driven mutation\n            diversity_factor = np.std(swarm, axis=0)\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                # Apply diversity-driven mutation\n                trial += self.mutation_factor * diversity_factor * np.random.randn(self.dim)\n                trial = np.clip(trial, lb, ub)\n                \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 26, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33794 with standard deviation 0.37196.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8291717162584763, 0.9329059030047413, 0.8091794262791022, 0.0050000000000000044, 0.029256978757500995, 0.014979873714807912, 0.1463716452316871, 0.12781751820234521, 0.14678665754372344]}}
{"id": "aa340c2d-25a3-4d0c-9d54-52b358caba84", "fitness": 0.35676385708874003, "name": "EnhancedHybridPSODE", "description": "Enhanced hybrid PSO with dynamic inertia and adaptive velocity scaling based on iteration feedback for improved search efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))  # Dynamic inertia\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            velocity_scaling = 1 - (eval_count / self.budget)  # Adaptive velocity scaling\n            self.velocity = velocity_scaling * (self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 27, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35676 with standard deviation 0.36740.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8422221228284636, 0.9324584502676361, 0.8374478616116832, 0.02165357845838567, 0.058906019732879455, 0.047981445051103244, 0.143492274702118, 0.16750113023845015, 0.15921183090794078]}}
{"id": "8d2262b7-2286-4396-a1dc-06792a7fc632", "fitness": 0.36205553935653567, "name": "EnhancedHybridPSODE", "description": "Hybrid Particle Swarm Optimization with Differential Evolution-inspired adaptive crossover for enhanced exploration and exploitation balance.  ", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                    while i in indices:\n                        indices = np.random.choice(self.pop_size, 3, replace=False)\n                    mutant = personal_best[indices[0]] + self.mutation_factor * (personal_best[indices[1]] - personal_best[indices[2]])\n                    mutant = np.clip(mutant, lb, ub)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = mutant[j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36206 with standard deviation 0.35969.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8709458546422111, 0.9322223327517526, 0.7842340009298402, 0.036412873368872445, 0.008268148261094677, 0.12422806530061659, 0.14959228385935874, 0.16759160240448467, 0.18500469269058983]}}
{"id": "f162bb31-e644-47b6-84a0-437f05874d4c", "fitness": 0.36822059018171216, "name": "HybridPSODE", "description": "Enhance mutation strategy with adaptive factor based on remaining budget for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                        \n        return global_best", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36822 with standard deviation 0.35434.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.861965582254754, 0.9322223327517526, 0.7967549927776763, 0.0250540113563672, 0.08425880356419357, 0.16107999231155834, 0.14631063339920347, 0.12604297453629953, 0.18029598868360486]}}
{"id": "640dac1c-b238-4561-93a0-03cda794a409", "fitness": 0.36822059018171216, "name": "HybridPSODE", "description": "Enhance the exploration-exploitation balance by dynamically adjusting the mutation factor based on the evaluation count.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.mutation_factor = 0.8 + 0.2 * (eval_count / self.budget)  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 30, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36822 with standard deviation 0.35434.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.861965582254754, 0.9322223327517526, 0.7967549927776763, 0.0250540113563672, 0.08425880356419357, 0.16107999231155834, 0.14631063339920347, 0.12604297453629953, 0.18029598868360486]}}
{"id": "83cd9779-a092-49bf-8bb0-1ba535ca8ecd", "fitness": 0.3549746941001307, "name": "ImprovedHybridPSODE", "description": "An improved Hybrid PSO-DE algorithm using adaptive inertia and dynamic crossover based on swarm diversity for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass ImprovedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            # Calculate diversity\n            swarm_mean = np.mean(swarm, axis=0)\n            diversity = np.sum(np.linalg.norm(swarm - swarm_mean, axis=1)) / self.pop_size\n            \n            # Dynamic inertia weight\n            self.inertia = 0.4 + 0.5 * (1 - (eval_count / self.budget))\n            \n            # Dynamic crossover rate based on diversity\n            self.crossover_rate = 0.6 + 0.3 * (diversity / (ub - lb).sum())\n            \n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 31, "feedback": "The algorithm ImprovedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35497 with standard deviation 0.37170.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8918579163444629, 0.8915029825290711, 0.8397920363707195, 0.0050000000000000044, 0.05351602888296725, 0.03257503591238786, 0.13725435785851092, 0.18480269372579516, 0.1584711952772615]}}
{"id": "5b135b96-bfa5-42e9-b29f-06803956d407", "fitness": 0.33147058749600816, "name": "HybridPSODEPlusPlus", "description": "HybridPSODE++ employs dynamic parameter adaptation, integrating Differential Evolution's mutation strategies with PSO's social-cognitive balance for enhanced convergence and exploration.", "code": "import numpy as np\n\nclass HybridPSODEPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            # Dynamic inertia weight adjustment\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)\n            \n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            # Differential Evolution-inspired mutation\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                idxs = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = swarm[idxs[0]], swarm[idxs[1]], swarm[idxs[2]]\n                mutant_vec = np.clip(x0 + self.mutation_factor * (x1 - x2), lb, ub)\n                trial = np.copy(swarm[i])\n                \n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == j_rand:\n                        trial[j] = mutant_vec[j]\n                \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 32, "feedback": "The algorithm HybridPSODEPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33147 with standard deviation 0.37058.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8286655833411869, 0.9330009393683504, 0.7842354882037897, 0.027971875689648762, 0.008636602995866438, 0.009828870193522299, 0.13337224842747886, 0.11008049529726915, 0.14744318394696065]}}
{"id": "f29d637f-176b-48c8-8ea0-c4aa4d2dd526", "fitness": 0.3419527969856397, "name": "QuantumInspiredPSO", "description": "Introducing Quantum-inspired Particle Dynamics with Adaptive Inertia for enhanced exploration and exploitation balance.", "code": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Adaptive inertia for dynamic balance\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)\n            # Quantum-inspired perturbation\n            quantum_jump = np.random.normal(0, 0.1, (self.pop_size, self.dim))\n            \n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm) + quantum_jump\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n\n        return global_best", "configspace": "", "generation": 33, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34195 with standard deviation 0.36962.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8432970717947166, 0.8947441937387736, 0.8368236097468003, 0.018696386891940753, 0.0050000000000000044, 0.025511526189156752, 0.14738945238824575, 0.1397126111104271, 0.16640032101069668]}}
{"id": "4156f580-08ea-4f6e-9ece-bf248076a951", "fitness": 0.3478643933668083, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive social and inertia parameters incorporating Levy flight for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, size=size)\n        v = np.random.normal(0, 1, size=size)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.4 + 0.3 * (1 - eval_count / self.budget)  # Line Updated\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = (self.inertia * self.velocity + \n                             self.cognitive * r1 * (personal_best - swarm) + \n                             self.social * r2 * (global_best - swarm) + \n                             self.levy_flight((self.pop_size, self.dim)))  # Line Updated\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 34, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34786 with standard deviation 0.38410.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8706043861356948, 0.9337840156237984, 0.8497137342096331, 0.009406700001513002, 0.025038196812113167, 0.0050000000000000044, 0.1610979896010789, 0.12934786037371993, 0.14678665754372344]}}
{"id": "eb37005c-b73d-47c8-b3c9-086610589c1e", "fitness": 0.3465666305616277, "name": "HybridPSODE", "description": "Introducing adaptive inertia and diversity preservation mechanisms to enhance exploration and prevent premature convergence in HybridPSODE.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia_min = 0.4\n        self.inertia_max = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = self.inertia_max - (self.inertia_max - self.inertia_min) * (eval_count / self.budget)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + \\\n                            self.cognitive * r1 * (personal_best - swarm) + \\\n                            self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                else:\n                    # Diversity preservation: perturb solution slightly\n                    swarm[i] = np.clip(swarm[i] + np.random.normal(0, 0.1, self.dim), lb, ub)\n        \n        return global_best", "configspace": "", "generation": 35, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34657 with standard deviation 0.37757.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8420478488178942, 0.9325069560599878, 0.8436434352559654, 0.01343273854599314, 0.018019696040780908, 0.0050000000000000044, 0.13297324991069193, 0.18170069307914072, 0.14977505734419472]}}
{"id": "52222383-4d1d-40b6-8ba8-447381d62ee9", "fitness": 0.3605503533849381, "name": "HybridPSODEAE", "description": "HybridPSODEAE - A hybrid PSO with adaptive inertia and elitism to enhance exploration and exploitation balance for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass HybridPSODEAE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = self.inertia_max - (self.inertia_max - self.inertia_min) * (eval_count / self.budget)\n            self.cognitive = 2.0 - (0.5 * (eval_count / self.budget))\n            self.social = 2.0 + (0.5 * (1 - eval_count / self.budget))\n            \n            self.velocity = (self.inertia * self.velocity +\n                             self.cognitive * r1 * (personal_best - swarm) +\n                             self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n            \n            # Elitism: Keep the best global solution found so far\n            for i in range(self.pop_size):\n                if personal_best_values[i] < global_best_value:\n                    global_best = personal_best[i]\n                    global_best_value = personal_best_values[i]\n        \n        return global_best", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSODEAE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36055 with standard deviation 0.38355.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8627568228690423, 0.9325069560599878, 0.8866907105052244, 0.0050000000000000044, 0.007950191718347766, 0.0246279945389426, 0.20112748678206582, 0.16785640917960376, 0.15643660881122867]}}
{"id": "4e525902-9245-4dbe-995f-ee1e5fe74523", "fitness": 0.3457343851860195, "name": "EnhancedHybridPSODE", "description": "Enhanced HybridPSODE with adaptive inertia and mutation strategies to balance exploration and exploitation for improved convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.initial_inertia = 0.9\n        self.final_inertia = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            # Adaptive inertia weight\n            w = self.initial_inertia - (self.initial_inertia - self.final_inertia) * (eval_count / self.budget)\n            \n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = w * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                \n                # Adaptive mutation factor\n                if np.random.rand() < self.crossover_rate - (eval_count / self.budget):\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 37, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34573 with standard deviation 0.38077.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.840512424975801, 0.0050000000000000044, 0.037203582980825045, 0.013981491463884499, 0.12840188754336135, 0.13087464013670158, 0.16085349272595562]}}
{"id": "dbb88311-c144-4a9d-8e20-2580d7c05a2f", "fitness": 0.34817099385256134, "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO with adaptive dynamic adjustment of velocity components and diversity preservation for robust convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.diversity_threshold = 1e-5  # New parameter for diversity check\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)  # Adaptive inertia\n\n            self.velocity = self.inertia * self.velocity + \\\n                            self.cognitive * r1 * (personal_best - swarm) + \\\n                            self.social * r2 * (global_best - swarm)\n            \n            swarm = np.clip(swarm + self.velocity, lb, ub)\n\n            # Check for diversity and reset if needed\n            if np.std(swarm) < self.diversity_threshold:\n                swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n                self.velocity = np.random.rand(self.pop_size, dim)\n\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n\n        return global_best", "configspace": "", "generation": 38, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "74efd40b-008e-4a14-9afb-9942def4f1ca", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive social parameter and inertia weight dynamic adjustment for enhanced exploration and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 39, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "a09149c7-8a89-4cbe-94b4-16acf7d70c7d", "fitness": 0.3490221535312283, "name": "EnhancedHybridPSODE", "description": "Enhanced Hybrid PSODE with adaptive inertia and diversity preservation for improved convergence and exploitation-exploration balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.4 + 0.5 * (1 - eval_count / self.budget)  # Adaptive inertia\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n            \n            # Diversity preservation mechanism: Restart some worst particles\n            if eval_count < self.budget:\n                worst_indices = np.argsort(personal_best_values)[-int(self.pop_size * 0.1):]\n                for idx in worst_indices:\n                    if eval_count >= self.budget:\n                        break\n                    swarm[idx] = np.random.uniform(lb, ub, self.dim)\n                    self.velocity[idx] = np.random.rand(self.dim)\n                    personal_best[idx] = swarm[idx]\n                    personal_best_values[idx] = func(swarm[idx])\n                    eval_count += 1\n\n        return global_best", "configspace": "", "generation": 40, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34902 with standard deviation 0.37693.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8588584459377249, 0.9325069560599878, 0.8354514171862566, 0.0050000000000000044, 0.02442237122723856, 0.03886117080532092, 0.12010024245337736, 0.17207110614339638, 0.15392767196775214]}}
{"id": "96beacbc-3a3a-4351-886f-ce6bab78bf6b", "fitness": 0.34817099385256134, "name": "HybridPSODE", "description": "An adaptive hybrid PSO with dynamically adjusted inertia weight for enhanced performance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "96bb63e5-9097-4c87-9512-6ae470acb65b", "fitness": 0.3411610118465393, "name": "EnhancedHybridPSO", "description": "An enhanced hybrid PSO with dynamic parameter adaptation and elitist strategy for improved diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        elite_position = global_best\n\n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.4 + 0.5 * (1 - eval_count / self.budget)  # Adaptive inertia\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            # Elitist strategy: include the best solution found so far\n            if eval_count < self.budget:\n                swarm[np.random.randint(self.pop_size)] = elite_position\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                        elite_position = global_best\n        \n        return global_best", "configspace": "", "generation": 42, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34116 with standard deviation 0.37301.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8104933031869115, 0.9325069560599878, 0.8398748418785656, 0.0050000000000000044, 0.025587493966552577, 0.009223643855874264, 0.13885141935431689, 0.1621247907729214, 0.14678665754372344]}}
{"id": "209dbacc-ace2-40cb-8b4e-1cfceb420923", "fitness": 0.36521842788360126, "name": "HybridPSODEPlus", "description": "HybridPSODE+ with enhanced mutation diversity using random dimension scaling for better exploration.", "code": "import numpy as np\n\nclass HybridPSODEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                # Enhanced mutation diversity\n                trial += self.mutation_factor * np.random.uniform(-1, 1, self.dim) * (np.random.rand(self.dim) < 0.1)\n                trial = np.clip(trial, lb, ub)\n                \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 43, "feedback": "The algorithm HybridPSODEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36522 with standard deviation 0.36099.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8415640772855217, 0.9322223327517526, 0.8407745104822193, 0.03440006459088951, 0.07269395797051204, 0.09734787809977563, 0.14775297775549168, 0.15547493875501628, 0.1647351132612327]}}
{"id": "ad997a8f-a682-464b-987a-5129b6d7b481", "fitness": 0.34817099385256134, "name": "HybridPSODE", "description": "Improved Hybrid PSO with dynamic inertia weight adjustment for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 44, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "f60aabc5-318a-4bd1-a161-fb24dde5bbd1", "fitness": 0.34817099385256134, "name": "HybridPSODE", "description": "Enhance convergence by dynamically adjusting the inertia weight over iterations to improve balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 45, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "76225435-a49c-4a2b-8a26-ca2bb5c7d563", "fitness": 0.33371755751618637, "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO using adaptive differential evolution mutation to improve diversity and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            # Update inertia, cognitive, and social factors\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            new_population = np.copy(swarm)\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                # Differential Evolution Mutation\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = swarm[np.random.choice(indices, 3, replace=False)]\n                mutant = np.clip(a + self.mutation_factor * (b - c), lb, ub)\n                \n                # Crossover\n                trial = np.copy(swarm[i])\n                j_rand = np.random.randint(self.dim)\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == j_rand:\n                        trial[j] = mutant[j]\n                \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                new_population[i] = trial if trial_value < func(swarm[i]) else swarm[i]\n            swarm = new_population\n        \n        return global_best", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33372 with standard deviation 0.35495.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.7047366973385881, 0.9286452416576717, 0.8411530168758788, 0.007900073218171433, 0.0050000000000000044, 0.08907662076876444, 0.14200573324391275, 0.12207872929129049, 0.162861905251399]}}
{"id": "619f4669-5856-45e4-9d07-14219fccb1fa", "fitness": 0.34817099385256134, "name": "HybridPSODE", "description": "A hybrid PSO with dynamic inertia adjustment based on evaluation ratio for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 47, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "4163b7ac-1c78-418a-98bd-d171f4a34932", "fitness": 0.3536092499795305, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive cognitive parameter enhancement based on iteration count for improved exploration.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (1 - eval_count / self.budget))  # Updated line\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 48, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35361 with standard deviation 0.36682.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.861965582254754, 0.9322223327517526, 0.7967549927776763, 0.023496312335731018, 0.0050000000000000044, 0.06268374170694557, 0.19887071515617516, 0.15323570463066272, 0.1482538682020773]}}
{"id": "d58ee51d-ba8c-4c96-9e31-d3f38a2ec2d8", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive social parameter enhancement based on iteration count for improved convergence, now with dynamic inertia adjustment.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 49, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "ad1deb01-cbc8-4003-9513-d31a1fbbaa0e", "fitness": 0.3437144470101414, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive cognitive and social parameters enhanced further based on velocity magnitude to guide exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))  # Updated line\n            scale_factor = np.linalg.norm(self.velocity, axis=1, keepdims=True)\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm) * scale_factor\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 50, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34371 with standard deviation 0.37980.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8916916950919037, 0.9015217594813192, 0.8340884968219634, 0.0050000000000000044, 0.0050000000000000044, 0.052932281824008665, 0.14211396122345177, 0.11051588667765311, 0.15056594197097295]}}
{"id": "ed68d952-e715-413a-a786-165fcd568ed5", "fitness": 0.3387123840688964, "name": "EnhancedHybridPSODE", "description": "Enhanced Hybrid PSO with adaptive inertia and elite selection for improved convergence and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.elite_rate = 0.2\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        elite_size = int(self.pop_size * self.elite_rate)\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                for j in range(self.dim):\n                    if np.random.rand() < 0.5:\n                        trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n            \n            elite_indices = personal_best_values.argsort()[:elite_size]\n            global_best_candidates = personal_best[elite_indices]\n            best_candidate_value = np.min([func(x) for x in global_best_candidates])\n            if best_candidate_value < global_best_value:\n                global_best = global_best_candidates[np.argmin([func(x) for x in global_best_candidates])]\n                global_best_value = best_candidate_value\n        \n        return global_best", "configspace": "", "generation": 51, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33871 with standard deviation 0.36154.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8132967683785807, 0.8825228888243799, 0.8215464194531161, 0.0050000000000000044, 0.0050000000000000044, 0.0050000000000000044, 0.227497371060026, 0.13288276510778874, 0.15566524379617608]}}
{"id": "2a411707-ce58-4b79-98af-9900e2d832fc", "fitness": 0.3609946003982694, "name": "EnhancedHybridPSODE", "description": "Enhanced PSO-DE with dynamic parameter tuning using success-based adaptation for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.successful_updates = 0\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            success_rate = self.successful_updates / max(1, eval_count)\n            self.inertia = 0.9 - 0.4 * success_rate\n            self.cognitive = 1.5 + (0.5 * success_rate)\n            self.social = 1.5 + (0.5 * (1 - success_rate))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    self.successful_updates += 1\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n\n        return global_best", "configspace": "", "generation": 52, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36099 with standard deviation 0.37055.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.862126133683538, 0.9325365596072452, 0.84221070797514, 0.01947622403897442, 0.020057370371571293, 0.09159115668474715, 0.16566211012600107, 0.16543089030226665, 0.14986025079494103]}}
{"id": "105ec029-ff00-47ee-a1fc-b35bf90470f2", "fitness": 0.32585753201478457, "name": "HybridPSODE_Improved", "description": "A hybrid PSO with adaptive velocity and periodic local search to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.9 - 0.7 * (eval_count / self.budget)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            \n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                        \n            if eval_count % (self.pop_size * 2) == 0:  # Periodically apply local search\n                for i in range(self.pop_size):\n                    if eval_count >= self.budget:\n                        break\n                    local_trial = np.copy(personal_best[i])\n                    local_trial += np.random.normal(0, 0.1, size=self.dim)\n                    local_trial = np.clip(local_trial, lb, ub)\n                    local_trial_value = func(local_trial)\n                    eval_count += 1\n                    \n                    if local_trial_value < personal_best_values[i]:\n                        personal_best[i] = local_trial\n                        personal_best_values[i] = local_trial_value\n                        if local_trial_value < global_best_value:\n                            global_best = local_trial\n                            global_best_value = local_trial_value\n        \n        return global_best", "configspace": "", "generation": 53, "feedback": "The algorithm HybridPSODE_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32586 with standard deviation 0.34691.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.7403893881953577, 0.9324954813230658, 0.7398706633157868, 0.03314389144705132, 0.01708534160240216, 0.005055139247626794, 0.16722433533484105, 0.15066689012320633, 0.14678665754372344]}}
{"id": "69012d68-93c8-4929-ae7f-004d0ac1ddbf", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive social parameter and dynamic inertia weight for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 54, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "b2f04e74-640a-4589-92cc-cdb91b82aad0", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive inertia weight adjustment based on iteration count for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 55, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "9a0ead0f-ca99-4a97-820f-ee277181303c", "fitness": 0.3419167270815974, "name": "HybridPSODE", "description": "A hybrid PSO with dynamic inertia and adaptive mutation to balance exploration and exploitation for enhanced optimization.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with higher inertia\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            # Dynamic inertia decreases linearly over time\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                if np.random.rand() < self.mutation_factor:\n                    trial += np.random.normal(0, 0.1, self.dim) * (ub - lb) * 0.1  # Scale mutation with bounds\n                trial = np.clip(trial, lb, ub)\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 56, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34192 with standard deviation 0.36365.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8357636495526304, 0.8933300116950131, 0.8243337755314492, 0.033986662168634996, 0.05695891222065763, 0.0050000000000000044, 0.1586113990634227, 0.11996160234190856, 0.14930453116066023]}}
{"id": "8dbef43a-ad47-4184-b4ce-ec1319aec745", "fitness": -Infinity, "name": "EnhancedHybridPSO", "description": "Hybrid PSO with momentum terms and dynamic population size adjustment for enhanced adaptability.", "code": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 + int(2 * np.sqrt(dim))\n        self.max_pop_size = 20 + int(3 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.momentum = 0.9\n        self.velocity = np.random.rand(self.initial_pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        pop_size = self.initial_pop_size\n        swarm = np.random.uniform(lb, ub, (pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(pop_size, self.dim), np.random.rand(pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.momentum * self.velocity + self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < 0.9:  # Fixed crossover_rate\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > 0.9 and j != j_rand:\n                            trial[j] = swarm[np.random.randint(pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n\n            if eval_count < self.budget and pop_size < self.max_pop_size:\n                new_individuals = self.max_pop_size - pop_size\n                additional_swarm = np.random.uniform(lb, ub, (new_individuals, self.dim))\n                eval_count += new_individuals\n                additional_best_values = np.array([func(x) for x in additional_swarm])\n                swarm = np.vstack((swarm, additional_swarm))\n                personal_best = np.vstack((personal_best, additional_swarm))\n                personal_best_values = np.concatenate((personal_best_values, additional_best_values))\n                pop_size = swarm.shape[0]\n        \n        return global_best", "configspace": "", "generation": 57, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (12,2) (24,2) ').", "error": "ValueError('operands could not be broadcast together with shapes (12,2) (24,2) ')", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {}}
{"id": "ec8c3171-d1e4-4dc2-9af1-294a2b8c93cf", "fitness": 0.3509769338725425, "name": "HybridPSODE", "description": "A hybrid PSO with enhanced mutation strategy and adaptive inertia for better exploration and convergence.  ", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Updated line\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.9  # Updated line\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - 0.4 * (eval_count / self.budget)  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 58, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35098 with standard deviation 0.38024.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8682581810335264, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "81366e02-8f2a-4a8e-81a7-88b3be5f03b0", "fitness": 0.34817099385256134, "name": "HybridPSODE", "description": "Improved exploration by dynamic inertia adjustment based on budget utilization to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - 0.5 * (eval_count / self.budget)  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 59, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "86f08397-6c25-4da7-87ca-479d6bd43eda", "fitness": 0.35417705647559666, "name": "HybridPSODE", "description": "Enhanced social parameter adaptation for improved exploration-exploitation balance in PSO-DE hybrid.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (np.sin(np.pi * eval_count / self.budget)))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 60, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35418 with standard deviation 0.35249.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8615050981161811, 0.8874584949187497, 0.7863338039829373, 0.0050000000000000044, 0.026412874761967076, 0.17060504273223132, 0.13765147684029344, 0.1291832886104315, 0.18344342831757843]}}
{"id": "b6389381-9849-4738-93eb-4cb12933129c", "fitness": 0.36524546717197437, "name": "HybridPSODE", "description": "A hybrid PSO with adaptive cognitive and social parameters based on population diversity and convergence speed for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        def population_diversity(swarm):\n            return np.mean([np.linalg.norm(ind - global_best) for ind in swarm])\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            current_diversity = population_diversity(swarm)\n            max_diversity = np.linalg.norm(ub - lb)\n            diversity_ratio = current_diversity / max_diversity\n            self.cognitive = 1.5 + (0.5 * diversity_ratio)\n            self.social = 1.5 + (0.5 * (1 - diversity_ratio))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 61, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36525 with standard deviation 0.35762.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.861974151167374, 0.9322223327517526, 0.792368700038514, 0.0050000000000000044, 0.06164996753796037, 0.09950904355049517, 0.1735632317962842, 0.1432296067904858, 0.21769217091490356]}}
{"id": "a465fbc6-23e1-43e1-b8a1-7608f89b3098", "fitness": 0.3486036623260716, "name": "HybridPSODE", "description": "A hybrid PSO with dynamic cognitive and social parameters tailored to balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.4 * (eval_count / self.budget))  # Updated line\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 62, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34860 with standard deviation 0.36921.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.861965582254754, 0.9322223327517526, 0.7967549927776763, 0.025865156947073586, 0.05981031483045851, 0.007130022317953011, 0.14857145994719856, 0.13266182296349438, 0.17245127614428313]}}
{"id": "af5039db-62db-47d4-a5d4-4ce6b86adc2a", "fitness": 0.3388166544945034, "name": "HybridPSODE", "description": "A hybrid PSO enhanced with adaptive velocity dampening and elitism for better convergence in diverse landscapes.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.7  # Increased inertia for more exploration\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            dampening_factor = 0.5 + 0.5 * np.exp(-10 * eval_count / self.budget)  # Adaptive dampening\n            self.velocity = dampening_factor * (self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n\n            # Elitism: keep the best found solution so far in the swarm\n            worst_idx = np.argmax(personal_best_values)\n            if global_best_value < personal_best_values[worst_idx]:\n                personal_best[worst_idx] = global_best\n                personal_best_values[worst_idx] = global_best_value\n        \n        return global_best", "configspace": "", "generation": 63, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33882 with standard deviation 0.32032.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.7975185628990961, 0.8894818295725799, 0.6231063514057169, 0.04780634930730787, 0.04343484435057343, 0.04248991716161454, 0.2907753009428887, 0.13410675116685444, 0.1806299836438986]}}
{"id": "722dbd43-b921-4532-a995-bc6501fac01a", "fitness": 0.34817099385256134, "name": "HybridPSODE", "description": "A hybrid PSO with dynamic inertia weight adjustment based on iteration count for optimized exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))  # Updated line\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 64, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "8903a89f-ba20-4ab5-82fb-4ef2f0ecdd42", "fitness": 0.34801747297865765, "name": "HybridPSODE", "description": "HybridPSODE with adaptive inertia weight and enhanced exploration through random walks to improve search diversity and convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia_min = 0.3\n        self.inertia_max = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            inertia_weight = self.inertia_max - ((self.inertia_max - self.inertia_min) * eval_count / self.budget)\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = inertia_weight * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            # Introduce random walk for exploration\n            if np.random.rand() < 0.1:\n                random_walk = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n                swarm = np.clip(swarm + random_walk * (ub - lb) * 0.05, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 65, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34802 with standard deviation 0.37597.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8436195489229785, 0.9325011934268177, 0.8434793696429477, 0.0050000000000000044, 0.01971396087214261, 0.037203602123562995, 0.15440611076318367, 0.1471098576332447, 0.1491236134230407]}}
{"id": "34b9bb57-59f9-4ee5-8926-068b192a7458", "fitness": 0.31086874612696724, "name": "RefinedHybridPSO", "description": "A hybrid PSO with adaptive inertia and dynamic learning rates to balance exploration and exploitation for better convergence.", "code": "import numpy as np\n\nclass RefinedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.initial_inertia = 0.9\n        self.final_inertia = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.zeros((self.pop_size, dim))\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            iteration = eval_count / self.pop_size\n            inertia = self.initial_inertia - (self.initial_inertia - self.final_inertia) * (iteration / (self.budget / self.pop_size))\n            self.cognitive = 1.0 + 1.5 * (1 - (iteration / (self.budget / self.pop_size)))  # Adaptive cognitive\n            self.social = 1.0 + 1.5 * (iteration / (self.budget / self.pop_size))  # Adaptive social\n            \n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.velocity = inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 66, "feedback": "The algorithm RefinedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31087 with standard deviation 0.33221.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.7592407800389845, 0.8743863830662447, 0.6797762700688783, 0.030044238047003624, 0.0346697442834214, 0.0050000000000000044, 0.12028704542368929, 0.14717102255030423, 0.14724323166417908]}}
{"id": "241b7b11-d269-496e-860e-e5f15cca135e", "fitness": 0.3666360439832247, "name": "HybridPSODE", "description": "A Hybrid PSO with dynamic crossover rate to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                self.crossover_rate = 0.8 + 0.2 * (1 - eval_count / self.budget)  # Updated line\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 67, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36664 with standard deviation 0.35902.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8456235865905652, 0.8981125528921923, 0.8402352628344244, 0.0050000000000000044, 0.02872678387987604, 0.09700718558127197, 0.30256323868690305, 0.12549161955225796, 0.15696416583153128]}}
{"id": "e8ef4264-4e5e-40a8-b06e-19d894c3fef6", "fitness": 0.350312676851552, "name": "HybridPSODE", "description": "Introduce adaptive inertia based on progress to balance exploration and exploitation effectively.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.9 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 68, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35031 with standard deviation 0.37934.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622798678446123, 0.9325127701245299, 0.8439124175390017, 0.0050000000000000044, 0.013540288852731286, 0.027046920390766283, 0.15963587582033834, 0.16209929354826447, 0.14678665754372344]}}
{"id": "595511eb-162d-4daf-b053-235360fa0c69", "fitness": 0.36484904831486836, "name": "HybridPSODE", "description": "A hybrid PSO with enhanced crossover strategy and adaptive social parameter for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > np.random.rand() and j != j_rand:  # Updated line\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 69, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36485 with standard deviation 0.34803.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8262870788039527, 0.9322223327517526, 0.7976503174675282, 0.10272235305126609, 0.031211047063057107, 0.15653063371665776, 0.14602645869165187, 0.13102021409299314, 0.15997099919495605]}}
{"id": "e05bad6d-f867-4053-b495-522553dbeb2a", "fitness": 0.34456896865486736, "name": "EnhancedHybridPSODE", "description": "An enhanced hybrid PSO-DE algorithm with adaptive inertia, cognitive, and social components, and an improved mutation strategy for better exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))\n            self.cognitive = 1.5 + (0.5 * np.sin(np.pi * eval_count / self.budget))\n            self.social = 1.5 + (0.5 * np.cos(np.pi * eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                # Improved mutation strategy leveraging DE/rand/1\n                a, b, c = swarm[np.random.randint(self.pop_size, size=3)]\n                mutant = a + self.mutation_factor * (b - c)\n                mutant = np.clip(mutant, lb, ub)\n                if np.random.rand() < self.crossover_rate:\n                    trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, trial)\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34457 with standard deviation 0.38491.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8919149268730173, 0.882013293413415, 0.8782391103057318, 0.012778040592272832, 0.0050000000000000044, 0.019739472598802155, 0.13184947469662722, 0.130557357837905, 0.1490290415760347]}}
{"id": "82116279-b520-4254-a549-c7d6de92ce0e", "fitness": 0.3515236919806167, "name": "HybridPSODE", "description": "A hybrid PSO with enhanced social parameter adaptation and dynamic inertia for improved convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.4 + 0.1 * (1 - eval_count / self.budget)  # Updated line\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 71, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35152 with standard deviation 0.36733.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8619621757899544, 0.9322186041077358, 0.7947644168616367, 0.028146957960765162, 0.03069044646622332, 0.030829094433686755, 0.18091497653936062, 0.12785606591020082, 0.17633048975598653]}}
{"id": "41cb4b7b-3f94-4ace-a1ff-8c865150a275", "fitness": 0.3450895269632007, "name": "EnhancedHybridPSODE", "description": "Enhanced Hybrid PSODE with dynamic exploration-exploitation balancing using adaptive inertia weight and local search for improved global convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.inertia = self.inertia_max\n        self.cognitive = 2.0\n        self.social = 2.0\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = self.inertia_max - ((self.inertia_max - self.inertia_min) * (eval_count / self.budget))\n            self.velocity = (self.inertia * self.velocity + \n                             self.cognitive * r1 * (personal_best - swarm) +\n                             self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                \n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                \n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                \n                # Local search enhancement\n                if np.random.rand() < 0.1:  # Small chance of local exploration\n                    local_trial = np.clip(trial + np.random.normal(0, 0.1, self.dim), lb, ub)\n                    local_trial_value = func(local_trial)\n                    eval_count += 1\n                    \n                    if local_trial_value < trial_value:\n                        personal_best[i] = local_trial\n                        personal_best_values[i] = local_trial_value\n                        if local_trial_value < global_best_value:\n                            global_best = local_trial\n                            global_best_value = local_trial_value\n        \n        return global_best", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34509 with standard deviation 0.38312.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8875935958592668, 0.9325069560599878, 0.8236445087902875, 0.03909627750839706, 0.0050000000000000044, 0.013256340387270749, 0.1405666231782593, 0.11437774938831669, 0.1497636914970204]}}
{"id": "fc67d9e1-702d-4beb-80b1-fd327064de75", "fitness": 0.3552560164324846, "name": "EnhancedHybridPSODE", "description": "Enhanced Hybrid PSO-DE with adaptive inertia and elitism strategy for balanced exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with higher inertia for exploration\n        self.cognitive = 2.0\n        self.social = 2.0\n        self.elitism_rate = 0.1\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            # Adaptive inertia decreases over time to favor exploitation\n            self.inertia = 0.9 - (0.5 * (eval_count / self.budget))\n            self.cognitive = 2.0 - (0.5 * (eval_count / self.budget))\n            self.social = 2.0 + (0.5 * (eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            new_personal_best = np.copy(personal_best)\n            new_personal_best_values = np.copy(personal_best_values)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < new_personal_best_values[i]:\n                    new_personal_best[i] = trial\n                    new_personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n            \n            # Elitism: keep a portion of the best solutions\n            sorted_indices = np.argsort(new_personal_best_values)\n            elite_count = int(self.elitism_rate * self.pop_size)\n            for i in range(elite_count):\n                idx = sorted_indices[i]\n                personal_best[idx] = new_personal_best[idx]\n                personal_best_values[idx] = new_personal_best_values[idx]\n        \n        return global_best", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35526 with standard deviation 0.37338.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8627353002225263, 0.9325069560599878, 0.8411264752455423, 0.019376825959590227, 0.024648050293783808, 0.09754844409330876, 0.14041088026913673, 0.1321645582047618, 0.14678665754372344]}}
{"id": "bba2b3ec-0a91-4172-bd95-7e59832c0b00", "fitness": 0.3599184681745732, "name": "HybridPSODE", "description": "Improved exploration through dynamic inertia adjustment for better convergence.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.inertia = 0.7 - (0.4 * (eval_count / self.budget))  # Updated line\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 74, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35992 with standard deviation 0.37053.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.862104771146935, 0.9323424422472087, 0.84109949685781, 0.0050000000000000044, 0.0940125463915169, 0.04752797932070052, 0.16859875354023668, 0.13028241556358466, 0.15829780850316655]}}
{"id": "66e62081-7333-4d66-b781-3dbf046997ad", "fitness": 0.34817099385256134, "name": "HybridPSODE", "description": "Adjust the inertia weight dynamically based on the evaluation count for better balance between exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = 0.4 + (0.5 * (1 - eval_count / self.budget))  # Updated line\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 75, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34817 with standard deviation 0.38091.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622749907876587, 0.9325069560599878, 0.8436434352559654, 0.0050000000000000044, 0.0050000000000000044, 0.022581807553788358, 0.15320976619765003, 0.1625353312742781, 0.14678665754372344]}}
{"id": "e4aea2c5-0133-488c-864d-94c340ee9e91", "fitness": 0.3735659834972777, "name": "AdaptiveHybridPSODE", "description": "An adaptive hybrid PSO-DE algorithm with dynamically adjusted inertia and mutation factor for enhanced global exploration and local convergence.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 76, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37357 with standard deviation 0.36395.", "error": "", "parent_ids": ["2f200a7b-5554-48ca-9fd4-71bc4c97d010"], "operator": null, "metadata": {"aucs": [0.8622783155807461, 0.9325069560599878, 0.8431964130254083, 0.0050000000000000044, 0.12300580696352659, 0.039904367212323044, 0.15715523528614372, 0.2378955596596911, 0.16115119768767217]}}
{"id": "443fcc6a-6dd2-42c7-93e9-573b6f7713ec", "fitness": 0.3735659834972777, "name": "AdaptiveHybridPSODE", "description": "Slightly increase the social component to promote more global influence, improving the balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.55  # Slightly increased for more global influence\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, self.dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 77, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37357 with standard deviation 0.36395.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8622783155807461, 0.9325069560599878, 0.8431964130254083, 0.0050000000000000044, 0.12300580696352659, 0.039904367212323044, 0.15715523528614372, 0.2378955596596911, 0.16115119768767217]}}
{"id": "cc5623ed-a7e1-4293-8361-7dcde758cf55", "fitness": 0.34657945718787875, "name": "EnhancedAdaptiveHybridPSODE", "description": "Introduced a self-adaptive mechanism for parameter tuning and randomized perturbation to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.min_inertia = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.perturbation_rate = 0.1  # Additional perturbation rate for diversity\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Self-adaptive adjustment of inertia and mutation factor\n            dynamic_factor = np.exp(-eval_count / (self.budget / 2))\n            self.inertia = self.min_inertia + (self.inertia - self.min_inertia) * dynamic_factor\n            self.mutation_factor = self.min_mutation_factor + (self.mutation_factor - self.min_mutation_factor) * dynamic_factor\n            \n            # Velocity and position update with perturbation\n            self.velocity = (self.inertia * self.velocity \n                             + self.cognitive * r1 * (personal_best - swarm) \n                             + self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            # Introduce random perturbation to enhance exploration\n            if np.random.rand() < self.perturbation_rate:\n                perturbation = np.random.normal(scale=(ub - lb) / 10, size=(self.pop_size, self.dim))\n                swarm = np.clip(swarm + perturbation, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34658 with standard deviation 0.35874.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8416332453160797, 0.8857894533926127, 0.8130847916966162, 0.025602573388114558, 0.03668571432533396, 0.021070893321609052, 0.18976258957927183, 0.1587744918375137, 0.14681136183375731]}}
{"id": "06e8b149-6838-4a27-8516-4ac52e79b691", "fitness": 0.35781649326546416, "name": "EnhancedAdaptiveHybridPSODE", "description": "An enhanced adaptive hybrid PSO-DE algorithm with dynamic parameter tuning and adaptive population size for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 + int(2 * np.sqrt(dim))\n        self.pop_size = self.initial_pop_size\n        self.inertia = 0.9\n        self.min_inertia = 0.4\n        self.cognitive = 2  # Increased cognitive component for better local search\n        self.social = 1.5\n        self.mutation_factor = 0.9  # Increased mutation factor for better diversity\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 2 - (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n            \n            # Adaptive population size adjustment\n            if eval_count < self.budget * 0.5:\n                self.pop_size = max(self.initial_pop_size, int(self.pop_size * 0.95))\n            else:\n                self.pop_size = min(self.initial_pop_size, int(self.pop_size * 1.05))\n            swarm = swarm[:self.pop_size]\n            self.velocity = self.velocity[:self.pop_size]\n            personal_best = personal_best[:self.pop_size]\n            personal_best_values = personal_best_values[:self.pop_size]\n        \n        return global_best", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35782 with standard deviation 0.37488.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8622783155807461, 0.9325069560599878, 0.8431964130254083, 0.03517781659716168, 0.018852390263063845, 0.0050000000000000044, 0.18333510739521008, 0.1736541787423853, 0.1663472617252144]}}
{"id": "78ac9366-8720-433c-a8a1-78f6db09f20b", "fitness": 0.35842702977227425, "name": "AdaptiveHybridPSODE", "description": "Enhanced AdaptiveHybridPSODE with fine-tuned crossover rate to improve exploration and convergence balance.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.95  # Adjusted crossover rate\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 80, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35843 with standard deviation 0.37294.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8622783155807461, 0.9325069560599878, 0.8431964130254083, 0.0050000000000000044, 0.05885622274683289, 0.04234948066946942, 0.13883312142403637, 0.1882334264666108, 0.1545893319773768]}}
{"id": "e426f8f9-683f-43b4-b226-728fee53b738", "fitness": 0.3735659834972777, "name": "AdaptiveHybridPSODE", "description": "An adaptive hybrid PSO-DE algorithm with improved mutation factor dynamics for better convergence.", "code": "class AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.3  # Reduced minimum mutation factor for more diversity\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 81, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37357 with standard deviation 0.36395.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8622783155807461, 0.9325069560599878, 0.8431964130254083, 0.0050000000000000044, 0.12300580696352659, 0.039904367212323044, 0.15715523528614372, 0.2378955596596911, 0.16115119768767217]}}
{"id": "7e00f548-c445-4be0-9e9d-ea8fa59d9998", "fitness": 0.34587822530864903, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced adaptive hybrid PSO-DE with stochastic perturbation and adaptive learning rates for improved exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.min_inertia = 0.4\n        self.cognitive = 2.0  # Increased cognitive component\n        self.social = 2.0     # Increased social component\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.learning_rate = 0.1  # New adaptive learning rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            # Dynamic adjustment of inertia, mutation factor, and learning rate\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 2.0 - (0.5 * (eval_count / self.budget))\n            self.social = 2.0 + (0.5 * (1 - eval_count / self.budget))\n            \n            # Velocity update with stochastic perturbation\n            perturbation = np.random.normal(0, 1, self.velocity.shape) * self.learning_rate\n            self.velocity = (self.inertia * self.velocity + \n                             self.cognitive * r1 * (personal_best - swarm) + \n                             self.social * r2 * (global_best - swarm) + perturbation)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                        \n            # Adaptive learning rate adjustment\n            self.learning_rate = 0.1 + 0.9 * (eval_count / self.budget)  # Increases over time\n        \n        return global_best", "configspace": "", "generation": 82, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34588 with standard deviation 0.39205.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8665556004782655, 0.9326309959883605, 0.8866503576532715, 0.020992295702316532, 0.0050000000000000044, 0.0050000000000000044, 0.1280264518423686, 0.12126166856953535, 0.14678665754372344]}}
{"id": "e3eed76e-c64e-4243-9454-e30651fdf9ad", "fitness": 0.3534523299796375, "name": "AdaptiveHybridPSODE", "description": "A refined PSO-DE hybrid with adaptive learning rates to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        dynamic_factor = np.linspace(1, 0.5, self.budget)\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * dynamic_factor[eval_count])\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * dynamic_factor[eval_count])\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * (self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm))\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 83, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35345 with standard deviation 0.37167.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8413438216672238, 0.9325215153246438, 0.841390101847924, 0.024301822700446007, 0.025106508780693315, 0.026484378108213358, 0.16601760018386147, 0.17425085417202302, 0.14965436703170865]}}
{"id": "5034723a-3e4f-4bcf-ad02-3a2d653a49b6", "fitness": 0.3568606034535966, "name": "AdaptiveHybridPSODE", "description": "Enhanced AdaptiveHybridPSODE with modified crossover strategy to improve exploration capabilities.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, self.dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    trial = np.where(np.random.rand(self.dim) < 0.5, trial, swarm[np.random.randint(self.pop_size)])\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 84, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35686 with standard deviation 0.36403.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8665099506086016, 0.8921910420613668, 0.843479633381859, 0.036587109046287924, 0.12165359418454724, 0.019511645879225936, 0.17115229290794232, 0.11129829556588522, 0.14936186744665358]}}
{"id": "73454cf5-6306-4e21-9e40-55019efd5d8c", "fitness": 0.370632139635681, "name": "AdaptiveHybridPSODE", "description": "An improved adaptive hybrid PSO-DE algorithm with refined dynamic weight adjustment for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.7 + (0.3 * (eval_count / self.budget))  # changed value\n            self.social = 1.3 + (0.7 * (1 - eval_count / self.budget))  # changed value\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 85, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37063 with standard deviation 0.36315.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8622590034218403, 0.9325069560599878, 0.8430367135584494, 0.01929197091061763, 0.13397607001659262, 0.0666849122661094, 0.14192982297123435, 0.17408470523165098, 0.16191910228464634]}}
{"id": "25efa2e1-435b-42e1-86d1-c4fc932d775b", "fitness": 0.34823631519996656, "name": "AdaptiveHybridPSODE", "description": "An adaptive hybrid PSO-DE algorithm with an improved initial velocity distribution for enhanced exploration.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        # Improved initial velocity distribution for better exploration\n        self.velocity = np.random.uniform(-1, 1, (self.pop_size, dim)) \n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 86, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34824 with standard deviation 0.37912.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8621005924698811, 0.9322125217481588, 0.8410926318220862, 0.0050000000000000044, 0.035208279714045276, 0.023308864917469196, 0.13103191593757568, 0.14479273979038365, 0.1593792904000988]}}
{"id": "50ccd5fc-5ef9-4d29-bbc5-beb4a594dcd6", "fitness": 0.34879475099424984, "name": "EnhancedAdaptiveHybridPSODE", "description": "A hybrid PSO-DE algorithm with adaptive parameters and differential mutation strategies for robust exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.min_inertia = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n\n        eval_count = self.pop_size\n\n        while eval_count < self.budget:\n            r1 = np.random.rand(self.pop_size, self.dim)\n            r2 = np.random.rand(self.pop_size, self.dim)\n            \n            # Adaptive parameter adjustment\n            inertia_dynamic = np.clip(self.inertia - eval_count * (self.inertia - self.min_inertia) / self.budget, self.min_inertia, self.inertia)\n            mutation_factor_dynamic = np.clip(self.mutation_factor - eval_count * (self.mutation_factor - self.min_mutation_factor) / self.budget, self.min_mutation_factor, self.mutation_factor)\n            \n            # Update velocities and positions\n            self.velocity = inertia_dynamic * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                \n                # DE/rand/1 mutation strategy\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[indices[0]][j] + mutation_factor_dynamic * (swarm[indices[1]][j] - swarm[indices[2]][j])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n\n        return global_best", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34879 with standard deviation 0.36184.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8370102405370062, 0.8903763951113874, 0.8368180897428146, 0.038269946693545887, 0.02300493008592175, 0.03514880197095227, 0.16678419354028273, 0.1599962190428843, 0.15174394222345322]}}
{"id": "84ba0420-bc79-4ef2-b071-f08cc40f13d6", "fitness": -Infinity, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced Adaptive Hybrid PSO-DE with dynamic population size and adaptive learning rates for improved exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = min(20 + int(3 * np.sqrt(dim)), budget // 2)\n        self.initial_pop_size = self.pop_size\n        self.inertia = 0.9\n        self.min_inertia = 0.3\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.3\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.pop_size = self.initial_pop_size + int((self.budget - eval_count) / self.budget * self.initial_pop_size)\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 88, "feedback": "An exception occurred: IndexError('index 27 is out of bounds for axis 0 with size 24').", "error": "IndexError('index 27 is out of bounds for axis 0 with size 24')", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {}}
{"id": "984dc8fc-b474-42ad-ade8-7a72ba1347f3", "fitness": 0.3673301531431993, "name": "AdaptiveHybridPSODE", "description": "Enhanced adaptive hybrid PSO-DE with improved velocity update for better convergence.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm) + 0.1 * (np.random.rand(self.pop_size, self.dim) - 0.5)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 89, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36733 with standard deviation 0.37426.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.9022120474764086, 0.9325215525870925, 0.8391139455030804, 0.030676275952490784, 0.030646851251151297, 0.09081398210164848, 0.14327178469725643, 0.1666590139941535, 0.170055924725512]}}
{"id": "9506fb83-2567-434d-bf24-963a177be05e", "fitness": 0.30830324276021925, "name": "EnhancedAdaptiveHybridPSODE", "description": "Incorporating adaptive learning rates and a restart mechanism for improved exploration-exploitation balance in an enhanced PSO-DE hybrid algorithm.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.min_inertia = 0.3\n        self.cognitive_base = 1.5\n        self.social_base = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.3\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.learning_rate_decay = 0.95\n        self.restart_threshold = 0.1 * self.budget\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        restart_count = 0\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia, mutation factor, and learning rates\n            self.inertia = max(self.min_inertia, self.inertia * self.learning_rate_decay)\n            self.mutation_factor = max(self.min_mutation_factor, self.mutation_factor * self.learning_rate_decay)\n            self.cognitive = self.cognitive_base + (0.5 * (eval_count / self.budget))\n            self.social = self.social_base + (0.5 * (1 - eval_count / self.budget))\n            \n            # Update velocities and positions\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n\n            # Evaluate new positions and apply DE crossover\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                # Update personal and global bests\n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n\n            # Restart mechanism if no improvement after a threshold\n            if eval_count - (restart_count * self.restart_threshold) > self.restart_threshold:\n                current_best_value = np.min(personal_best_values)\n                if current_best_value >= global_best_value:  # No improvement\n                    swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n                    personal_best = np.copy(swarm)\n                    personal_best_values = np.array([func(x) for x in swarm])\n                    global_best = personal_best[np.argmin(personal_best_values)]\n                    global_best_value = np.min(personal_best_values)\n                    eval_count += self.pop_size\n                    restart_count += 1\n        \n        return global_best", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30830 with standard deviation 0.35654.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.615792670373561, 0.9324926439443151, 0.8388044574813183, 0.0050000000000000044, 0.0050000000000000044, 0.0050000000000000044, 0.12011940718296199, 0.10573334831609371, 0.14678665754372344]}}
{"id": "3d6b1c93-3b71-4359-8926-ba0d9f8eba00", "fitness": 0.34810582453198385, "name": "AdaptiveHybridPSODE", "description": "Improved exploration by dynamically adjusting the crossover rate based on function evaluations for better diversity.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                # Dynamic adjustment of crossover rate\n                self.crossover_rate = 0.6 + 0.3 * (eval_count / self.budget)\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 91, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34811 with standard deviation 0.36438.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.7934263171653726, 0.9325069560599878, 0.8393043757555664, 0.025661980415346175, 0.031572308992786735, 0.023018774906716444, 0.14412668776008264, 0.17927519203281472, 0.16405982769918126]}}
{"id": "aed4e8ec-85e0-4abb-bcd6-6b93001c79fc", "fitness": 0.18884038382283927, "name": "AdaptiveHybridPSODE", "description": "Introduce adaptive velocity clamping in the PSO algorithm to prevent swarm explosion and enhance convergence stability.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            velocity_clamp = (ub - lb) * 0.1  # Adaptive velocity clamping\n            self.velocity = np.clip(self.velocity, -velocity_clamp, velocity_clamp)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 92, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18884 with standard deviation 0.21391.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.14507953900311965, 0.7804018040717899, 0.14556038726949427, 0.034183726999631237, 0.05497739633092569, 0.08564361559501632, 0.17370526514467566, 0.12247977357150264, 0.15753194641939805]}}
{"id": "854e4f13-8ad7-4ec5-b317-467286bf57d9", "fitness": 0.37340834838367426, "name": "EnhancedAdaptiveHybridPSODE", "description": "An enhanced adaptive PSO-DE algorithm that incorporates a diversity preservation strategy to avoid premature convergence and improve exploration capabilities.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        diversity_threshold = np.var(swarm) * 0.1  # Set diversity threshold\n\n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            # Diversity preservation strategy\n            if np.var(swarm) < diversity_threshold:\n                indices_to_mutate = np.random.choice(self.pop_size, size=self.pop_size // 2, replace=False)\n                mutation_noise = np.random.normal(0, 0.1, (len(indices_to_mutate), self.dim))\n                swarm[indices_to_mutate] += mutation_noise\n                swarm = np.clip(swarm, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 93, "feedback": "The algorithm EnhancedAdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37341 with standard deviation 0.36409.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8622783155807461, 0.9325069560599878, 0.8431964130254083, 0.0050000000000000044, 0.12300580696352659, 0.038485651189892556, 0.15715523528614372, 0.2378955596596911, 0.16115119768767217]}}
{"id": "c5f3fe99-6e8e-4c63-9eed-c0b00caae3a2", "fitness": 0.3468972162199655, "name": "SynergisticAdaptivePSODE", "description": "A synergistic PSO-DE algorithm with adaptive learning rates based on performance feedback to efficiently balance exploration and exploitation.", "code": "import numpy as np\n\nclass SynergisticAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9\n        self.min_inertia = 0.4\n        self.cognitive_base = 1.5\n        self.social_base = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.epsilon = 1e-8  # Small constant to prevent division by zero\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        performance_history = np.zeros(self.pop_size)\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Adaptive inertia and mutation factor based on performance\n            avg_perf = np.mean(personal_best_values)\n            self.inertia = self.min_inertia + (self.inertia - self.min_inertia) * (avg_perf / (avg_perf + self.epsilon))\n            self.mutation_factor = self.min_mutation_factor + (self.mutation_factor - self.min_mutation_factor) * (avg_perf / (avg_perf + self.epsilon))\n            \n            # Dynamic cognitive and social components\n            self.cognitive = self.cognitive_base + (0.5 * (eval_count / self.budget))\n            self.social = self.social_base + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 94, "feedback": "The algorithm SynergisticAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34690 with standard deviation 0.37891.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8445703002056146, 0.9325365596071125, 0.8454574359822067, 0.0050000000000000044, 0.01186391366155548, 0.005023457966577216, 0.1427239636563047, 0.188112657356595, 0.14678665754372344]}}
{"id": "ad993b3a-ee55-4b3f-907b-c9e62b57efd4", "fitness": -Infinity, "name": "EnhancedAdaptiveHybridPSODE", "description": "Enhanced PSODE with adaptive learning rates and leader election strategy to improve search diversity and convergence efficiency.", "code": "import numpy as np\n\nclass EnhancedAdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        leader_election_frequency = max(1, self.budget // (10 * self.pop_size))\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia and mutation factor\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            \n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            # Leader election strategy\n            if eval_count % leader_election_frequency == 0:\n                leader_index = np.random.choice(self.pop_size, p=personal_best_values / personal_best_values.sum())\n                global_best = personal_best[leader_index]\n                global_best_value = personal_best_values[leader_index]\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 95, "feedback": "An exception occurred: ValueError('probabilities are not non-negative').", "error": "ValueError('probabilities are not non-negative')", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {}}
{"id": "7d8d460a-2896-4f93-b02b-2b30ec44cab1", "fitness": 0.3552405653131894, "name": "AdaptiveHybridPSODE", "description": "Enhanced hybrid PSO-DE with dynamic crossover rate adjustment for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.min_crossover_rate = 0.6  # Line modified\n        self.velocity = np.random.rand(self.pop_size, dim)\n        \n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            \n            # Dynamic adjustment of inertia, mutation factor, and crossover rate\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (self.budget - eval_count) / self.budget)\n            self.crossover_rate = self.min_crossover_rate + ((self.crossover_rate - self.min_crossover_rate) * (self.budget - eval_count) / self.budget)  # Line modified\n            \n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:  # Line modified\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = swarm[np.random.randint(self.pop_size)][j]\n                trial_value = func(trial)\n                eval_count += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 96, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35524 with standard deviation 0.37678.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.8674085129291277, 0.9325069560599878, 0.8431964130254083, 0.0050000000000000044, 0.01947322376277083, 0.04671194135259282, 0.1523183834752604, 0.15860014174039383, 0.17194951547316295]}}
{"id": "bb53a240-30ae-4218-a9c0-313113736f76", "fitness": 0.37721200006064537, "name": "AdaptiveHybridPSODE", "description": "Enhanced AdaptiveHybridPSODE by incorporating dynamic adaptive learning rates and enhanced crossover mechanism to improve convergence and exploration.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.learning_rate = np.random.rand(self.pop_size) * 0.1  # Introduce learning rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (\n                    self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (\n                    self.budget - eval_count) / self.budget)\n\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            self.velocity *= (1 + self.learning_rate[:, np.newaxis])  # Use learning rate\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = (swarm[np.random.randint(self.pop_size)][j] + swarm[np.random.randint(self.pop_size)][j]) / 2  # Enhanced crossover\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 97, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37721 with standard deviation 0.38667.", "error": "", "parent_ids": ["e4aea2c5-0133-488c-864d-94c340ee9e91"], "operator": null, "metadata": {"aucs": [0.9029503324469544, 0.9173909307220802, 0.9280174176463633, 0.0628240972532279, 0.0050000000000000044, 0.023121165965816703, 0.20671927084948538, 0.1764870844392371, 0.17239770122264364]}}
{"id": "9b9a5909-b8b4-4fee-8e43-60b18481a999", "fitness": 0.3704910250712128, "name": "AdaptiveHybridPSODE", "description": "Enhanced AdaptiveHybridPSODE by adjusting the cognitive component to prioritize personal experience at early stages, balancing exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass AdaptiveHybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 + int(2 * np.sqrt(dim))\n        self.inertia = 0.9  # Start with a higher inertia for exploration\n        self.min_inertia = 0.4  # Minimum inertia for exploitation\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.mutation_factor = 0.8\n        self.min_mutation_factor = 0.5\n        self.crossover_rate = 0.9\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.learning_rate = np.random.rand(self.pop_size) * 0.1  # Introduce learning rate\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (\n                    self.budget - eval_count) / self.budget)\n            self.mutation_factor = self.min_mutation_factor + ((self.mutation_factor - self.min_mutation_factor) * (\n                    self.budget - eval_count) / self.budget)\n\n            self.cognitive = 1.7 + (0.3 * (eval_count / self.budget))  # Changed for improved exploration-exploitation balance\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            self.velocity *= (1 + self.learning_rate[:, np.newaxis])  # Use learning rate\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n            \n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                if np.random.rand() < self.crossover_rate:\n                    j_rand = np.random.randint(self.dim)\n                    for j in range(self.dim):\n                        if np.random.rand() > self.crossover_rate and j != j_rand:\n                            trial[j] = (swarm[np.random.randint(self.pop_size)][j] + swarm[np.random.randint(self.pop_size)][j]) / 2  # Enhanced crossover\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n        \n        return global_best", "configspace": "", "generation": 98, "feedback": "The algorithm AdaptiveHybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37049 with standard deviation 0.38940.", "error": "", "parent_ids": ["bb53a240-30ae-4218-a9c0-313113736f76"], "operator": null, "metadata": {"aucs": [0.9029503324469544, 0.9173909307220802, 0.9280174176463633, 0.08483765062424187, 0.0050000000000000044, 0.033475816219359134, 0.11719515185754148, 0.18011501138722363, 0.16543691473715172]}}
{"id": "a8cdcc14-bfdf-4513-96a3-101e0f69fb6b", "fitness": 0.3643885094719241, "name": "MemoryAdaptivePSO", "description": "Introduce a memory-based adaptive learning strategy with a dynamic swarm-size adjustment to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass MemoryAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 10 + int(2 * np.sqrt(dim))\n        self.pop_size = self.initial_pop_size\n        self.inertia = 0.9\n        self.min_inertia = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.velocity = np.random.rand(self.pop_size, dim)\n        self.learning_rate = np.random.rand(self.pop_size) * 0.1\n        self.memory = np.zeros((self.initial_pop_size, dim))\n        self.memory_values = np.full(self.initial_pop_size, np.inf)\n\n    def __call__(self, func):\n        lb, ub = func.bounds.lb, func.bounds.ub\n        swarm = np.random.uniform(lb, ub, (self.pop_size, self.dim))\n        personal_best = np.copy(swarm)\n        personal_best_values = np.array([func(x) for x in swarm])\n        global_best = personal_best[np.argmin(personal_best_values)]\n        global_best_value = np.min(personal_best_values)\n        \n        eval_count = self.pop_size\n        \n        while eval_count < self.budget:\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            self.inertia = self.min_inertia + ((self.inertia - self.min_inertia) * (self.budget - eval_count) / self.budget)\n            self.cognitive = 1.5 + (0.5 * (eval_count / self.budget))\n            self.social = 1.5 + (0.5 * (1 - eval_count / self.budget))\n            self.velocity = self.inertia * self.velocity + self.cognitive * r1 * (personal_best - swarm) + self.social * r2 * (global_best - swarm)\n            self.velocity *= (1 + self.learning_rate[:, np.newaxis])\n            swarm = np.clip(swarm + self.velocity, lb, ub)\n\n            for i in range(self.pop_size):\n                if eval_count >= self.budget:\n                    break\n                trial = np.copy(swarm[i])\n                trial_value = func(trial)\n                eval_count += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best[i] = trial\n                    personal_best_values[i] = trial_value\n                    if trial_value < global_best_value:\n                        global_best = trial\n                        global_best_value = trial_value\n                        \n                # Update memory if an improvement is found\n                if trial_value < self.memory_values[i]:\n                    self.memory[i] = trial\n                    self.memory_values[i] = trial_value\n            \n            # Dynamically adjust swarm size\n            if eval_count % (self.budget // 10) == 0:\n                self.pop_size = max(5, int(self.pop_size * (1 - 0.1 * (eval_count / self.budget))))\n                self.velocity = self.velocity[:self.pop_size]\n                swarm = swarm[:self.pop_size]\n                personal_best = personal_best[:self.pop_size]\n                personal_best_values = personal_best_values[:self.pop_size]\n                self.learning_rate = self.learning_rate[:self.pop_size]\n        \n        return global_best", "configspace": "", "generation": 99, "feedback": "The algorithm MemoryAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36439 with standard deviation 0.39419.", "error": "", "parent_ids": ["bb53a240-30ae-4218-a9c0-313113736f76"], "operator": null, "metadata": {"aucs": [0.9051969903882252, 0.9173909307220802, 0.9280174176463633, 0.03498403372621217, 0.008750367714538632, 0.030273951569110835, 0.1447249498496519, 0.15519713105305954, 0.15496081257807515]}}
