{"id": "767f6891-1364-45f3-a606-c29d4410cd14", "fitness": 0.05305457827454333, "name": "HybridPSO_SA", "description": "A hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) for enhanced exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)  # Adjust number of particles based on dimensionality\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10  # Initial temperature for SA\n        self.temp_final = 0.1  # Final temperature for SA\n        self.cooling_rate = 0.95  # Cooling rate for SA\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Simulated annealing for exploration\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 0, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": [], "operator": null, "metadata": {"aucs": [0.009274177211894719, 0.009274177211894719, 0.009274177211894719, 0.07873023672478285, 0.07873023672478285, 0.07873023672478285, 0.07115932088695243, 0.07115932088695243, 0.07115932088695243]}}
{"id": "d7ea8dde-7514-40aa-bffa-8d0257eefde3", "fitness": 0.05305184737991716, "name": "EnhancedHybridPSO_SA", "description": "An enhanced hybrid combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with adaptive inertia weight and dynamic cooling for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w_min, self.w_max = 0.3, 0.9  # Adaptive inertia weight bounds\n        self.c1 = 2.0  # Cognitive coefficient for PSO\n        self.c2 = 2.0  # Social coefficient for PSO\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def adaptive_inertia(self):\n        return self.w_max - (self.w_max - self.w_min) * (self.function_evaluations / self.budget)\n\n    def dynamic_cooling(self):\n        return self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            w = self.adaptive_inertia()\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.dynamic_cooling()\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 1, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009273750775308787, 0.009273750775308787, 0.009273750775308787, 0.07872586388364089, 0.07872586388364089, 0.07872586388364089, 0.0711559274808018, 0.0711559274808018, 0.0711559274808018]}}
{"id": "af25494b-a1c9-4f38-bc76-e04665ba0839", "fitness": 0.053045693354623835, "name": "HybridPSO_SA", "description": "Enhanced the initialization of the inertia weight (w) in HybridPSO_SA based on dimensionality to improve convergence.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)  # Adjust number of particles based on dimensionality\n        self.w = 0.9 - 0.5 * (dim / 100)  # Adjust inertia weight based on dimensionality\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10  # Initial temperature for SA\n        self.temp_final = 0.1  # Final temperature for SA\n        self.cooling_rate = 0.95  # Cooling rate for SA\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Simulated annealing for exploration\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 2, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.00927278361897943, 0.00927278361897943, 0.00927278361897943, 0.07871600895043274, 0.07871600895043274, 0.07871600895043274, 0.07114828749445934, 0.07114828749445934, 0.07114828749445934]}}
{"id": "39cb995e-abcd-4706-8cd7-9b3e237f7d64", "fitness": 0.053045262741504194, "name": "EnhancedHybridPSO_SA", "description": "An enhanced hybrid optimization strategy integrating adaptive inertia and dynamic temperature adjustment for improved convergence in high-dimensional spaces.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w_max = 0.9  # Max inertia weight for PSO\n        self.w_min = 0.4  # Min inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            # Adaptive inertia weight\n            w = self.w_max - (self.w_max - self.w_min) * (self.function_evaluations / self.budget)\n\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Dynamic temperature for SA\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 3, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272716266887637, 0.009272716266887637, 0.009272716266887637, 0.07871532181034935, 0.07871532181034935, 0.07871532181034935, 0.07114775014727559, 0.07114775014727559, 0.07114775014727559]}}
{"id": "d4385484-8f88-490c-a7fe-9743dfc4a8df", "fitness": 0.053045279800735666, "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by integrating dynamic inertia weight adaptation and adaptive cooling rate for improved convergence.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)  \n        self.w_max = 0.9  \n        self.w_min = 0.4  \n        self.c1 = 1.5  \n        self.c2 = 1.5  \n        self.temp_initial = 10 \n        self.temp_final = 0.1  \n        self.cooling_rate_initial = 0.99  \n        self.cooling_rate_final = 0.9  \n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  \n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            w = self.w_max - (self.w_max - self.w_min) * (self.function_evaluations / self.budget)\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            cooling_rate = self.cooling_rate_initial - (self.cooling_rate_initial - self.cooling_rate_final) * (self.function_evaluations / self.budget)\n            temp = self.temp_initial * (cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 4, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272718665443769, 0.009272718665443769, 0.009272718665443769, 0.07871534625417742, 0.07871534625417742, 0.07871534625417742, 0.0711477744825858, 0.0711477744825858, 0.0711477744825858]}}
{"id": "24b37d5f-0036-4326-ae68-7276231c3d86", "fitness": 0.053045262741504194, "name": "ImprovedHybridPSO_SA", "description": "Improved HybridPSO_SA utilizing dynamic velocity adjustment and adaptive cooling for enhanced convergence in black box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w_initial = 0.9  # Starting inertia weight\n        self.w_final = 0.4  # Final inertia weight\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Dynamic inertia weight update\n            w = self.w_final + (self.w_initial - self.w_final) * ((self.budget - self.function_evaluations) / self.budget)\n\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Adaptive Simulated annealing for exploration\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 5, "feedback": "The algorithm ImprovedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272716266887637, 0.009272716266887637, 0.009272716266887637, 0.07871532181034935, 0.07871532181034935, 0.07871532181034935, 0.07114775014727559, 0.07114775014727559, 0.07114775014727559]}}
{"id": "9db38fe8-f21b-47e5-baeb-3d2d6b230795", "fitness": 0.053045262741504194, "name": "EnhancedHybridPSO_SA", "description": "An enhanced hybrid metaheuristic that integrates Dynamic Inertia Weight adaptation in PSO with Adaptive Cooling in SA to improve convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)  # Adjust number of particles based on dimensionality\n        self.w_max = 0.9  # Max inertia weight\n        self.w_min = 0.4  # Min inertia weight\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10  # Initial temperature for SA\n        self.temp_final = 0.1  # Final temperature for SA\n        self.cooling_rate = 0.95  # Initial cooling rate for SA\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Dynamic inertia weight\n            w = self.w_max - ((self.w_max - self.w_min) * (self.function_evaluations / self.budget))\n\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Adaptive cooling for simulated annealing\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 6, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272716266887637, 0.009272716266887637, 0.009272716266887637, 0.07871532181034935, 0.07871532181034935, 0.07871532181034935, 0.07114775014727559, 0.07114775014727559, 0.07114775014727559]}}
{"id": "46ce3883-158b-4607-9f31-8ca503231975", "fitness": 0.05305457811203662, "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA by incorporating dynamic parameter tuning and adaptive exploration strategies to better balance exploration and exploitation.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            inertia_decrease = 0.99 ** (self.function_evaluations / self.budget)  # Dynamic inertia\n            self.w = 0.5 * inertia_decrease\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * inertia_decrease, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 7, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009274177211894719, 0.009274177211894719, 0.009274177211894719, 0.07873023672478285, 0.07873023672478285, 0.07873023672478285, 0.07115932039943229, 0.07115932039943229, 0.07115932039943229]}}
{"id": "2834eff8-350e-405c-ba77-f6707b069fb2", "fitness": 0.053045262741504194, "name": "HybridPSO_SA", "description": "Enhance the hybrid PSO-SA algorithm by improving the inertia weight adaptation for better convergence behavior.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)  # Adjust number of particles based on dimensionality\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10  # Initial temperature for SA\n        self.temp_final = 0.1  # Final temperature for SA\n        self.cooling_rate = 0.95  # Cooling rate for SA\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            self.w = 0.9 - (self.function_evaluations / self.budget) * (0.9 - 0.4)  # Line change: adapt inertia weight\n\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Simulated annealing for exploration\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 8, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272716266887637, 0.009272716266887637, 0.009272716266887637, 0.07871532181034935, 0.07871532181034935, 0.07871532181034935, 0.07114775014727559, 0.07114775014727559, 0.07114775014727559]}}
{"id": "beecace3-a058-4876-9c87-507db93c3d8c", "fitness": 0.05304527110613322, "name": "HybridPSO_SA", "description": "A refined hybrid metaheuristic using adaptive inertia and a dynamic cooling schedule for improved black box optimization performance.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)  # Adjust number of particles based on dimensionality\n        self.w = 0.9  # Start with a higher inertia weight for exploration\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10  # Initial temperature for SA\n        self.temp_final = 0.1  # Final temperature for SA\n        self.cooling_rate = 0.99  # Dynamic cooling rate\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.w = 0.9 - 0.5 * (self.function_evaluations / self.budget)  # Adaptive inertia weight\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Simulated annealing for exploration\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 9, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272717250730977, 0.009272717250730977, 0.009272717250730977, 0.07871533181991919, 0.07871533181991919, 0.07871533181991919, 0.07114776424774949, 0.07114776424774949, 0.07114776424774949]}}
{"id": "3c2069cd-7af5-4caf-9f82-0a23a98b77f4", "fitness": 0.053045283043593315, "name": "HybridPSO_SA_Improved", "description": "A hybrid metaheuristic combining Particle Swarm Optimization (PSO) with a dynamic inertia weight strategy and Simulated Annealing (SA) with adaptive cooling for enhanced exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass HybridPSO_SA_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)  # Adjust number of particles based on dimensionality\n        self.w_max = 0.9  # Maximum inertia weight\n        self.w_min = 0.4  # Minimum inertia weight\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10  # Initial temperature for SA\n        self.temp_final = 0.1  # Final temperature for SA\n        self.cooling_rate = 0.99  # Adaptive cooling rate for SA\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Dynamic inertia weight\n            self.w = self.w_max - (self.w_max - self.w_min) * (self.function_evaluations / self.budget)\n            \n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Simulated annealing for exploration\n            temp = max(self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget)), self.temp_final)\n            for i in range(self.num_particles):\n                candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                candidate_position = np.clip(candidate_position, lb, ub)\n                candidate_score = func(candidate_position)\n                self.function_evaluations += 1\n\n                if candidate_score < self.best_individual_scores[i] or \\\n                   np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                    self.positions[i] = candidate_position\n                    self.best_individual_scores[i] = candidate_score\n                    self.best_individual_positions[i] = candidate_position\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 10, "feedback": "The algorithm HybridPSO_SA_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272719403548235, 0.009272719403548235, 0.009272719403548235, 0.07871535378440697, 0.07871535378440697, 0.07871535378440697, 0.07114777594282473, 0.07114777594282473, 0.07114777594282473]}}
{"id": "d585802c-aca4-49ec-ae6a-5703bb7282ce", "fitness": 0.05304481689445243, "name": "EnhancedHybridPSO_SA", "description": "Enhanced HybridPSO_SA by dynamically adjusting inertia weight and introducing a mutation operator for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w_max = 0.9  # Max inertia weight for PSO\n        self.w_min = 0.4  # Min inertia weight for PSO\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            w = self.w_max - ((self.w_max - self.w_min) * self.function_evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n                # Mutation operator for enhanced exploration\n                if np.random.rand() < 0.1:\n                    mutation_idx = np.random.randint(0, self.dim)\n                    self.positions[i][mutation_idx] = np.random.uniform(lb[mutation_idx], ub[mutation_idx])\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 11, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.0092726457767347, 0.0092726457767347, 0.0092726457767347, 0.07871460830609944, 0.07871460830609944, 0.07871460830609944, 0.07114719660052315, 0.07114719660052315, 0.07114719660052315]}}
{"id": "0ecbb7b7-eca7-4906-a993-9f375fb158c7", "fitness": 0.053045262741504194, "name": "EnhancedHybridPSO_SA", "description": "Enhanced Hybrid PSO and SA with Adaptive Parameters and Diversity Introduction for Improved Convergence in Black Box Optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.9  # Start with a high inertia weight for exploration\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            # Adaptive inertia weight (linearly decreases over time)\n            self.w = 0.9 - (0.5 * self.function_evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Introduce random new positions to increase diversity if stagnant\n            if self.function_evaluations < self.budget and \\\n               np.ptp(self.best_individual_scores) < 1e-6:\n                new_positions = np.random.uniform(lb, ub, (self.num_particles // 2, self.dim))\n                new_scores = np.array([func(pos) for pos in new_positions])\n                self.function_evaluations += len(new_positions)\n                idx = new_scores < self.best_individual_scores[:len(new_positions)]\n                self.best_individual_positions[:len(new_positions)][idx] = new_positions[idx]\n                self.best_individual_scores[:len(new_positions)][idx] = new_scores[idx]\n\n                if np.min(new_scores) < self.global_best_score:\n                    self.global_best_score = np.min(new_scores)\n                    self.global_best_position = new_positions[np.argmin(new_scores)]\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 12, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272716266887637, 0.009272716266887637, 0.009272716266887637, 0.07871532181034935, 0.07871532181034935, 0.07871532181034935, 0.07114775014727559, 0.07114775014727559, 0.07114775014727559]}}
{"id": "372f1713-1b99-4101-a6cd-2d51edb971b3", "fitness": 0.05304493333790176, "name": "HybridPSO_SA", "description": "Enhanced HybridPSO_SA with dynamic inertia weight adjustment for improved convergence.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)  # Adjust number of particles based on dimensionality\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Cognitive coefficient for PSO\n        self.c2 = 1.5  # Social coefficient for PSO\n        self.temp_initial = 10  # Initial temperature for SA\n        self.temp_final = 0.1  # Final temperature for SA\n        self.cooling_rate = 0.95  # Cooling rate for SA\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)  # For reproducibility\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Dynamic Inertia Weight Adjustment\n                self.w = 0.9 - (0.8 * self.function_evaluations / self.budget)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Simulated annealing for exploration\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 13, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009272664601255087, 0.009272664601255087, 0.009272664601255087, 0.07871479486885202, 0.07871479486885202, 0.07871479486885202, 0.07114734054359817, 0.07114734054359817, 0.07114734054359817]}}
{"id": "443cee50-0479-4975-a3a4-d44397e8b39e", "fitness": 0.05305185364712369, "name": "EnhancedHybridAPSO_SA", "description": "An enhanced hybrid metaheuristic that integrates Adaptive Particle Swarm Optimization (APSO) with Simulated Annealing (SA) for improved convergence and diversified exploration in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridAPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w_max = 0.9  # Maximum inertia weight for APSO\n        self.w_min = 0.4  # Minimum inertia weight for APSO\n        self.c1 = 2.0  # Cognitive coefficient for APSO\n        self.c2 = 2.0  # Social coefficient for APSO\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Update inertia weight dynamically\n            w = self.w_max - ((self.w_max - self.w_min) * (self.function_evaluations / self.budget))\n\n            # Update velocities and positions\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Simulated annealing for exploration\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 14, "feedback": "The algorithm EnhancedHybridAPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009273751759343418, 0.009273751759343418, 0.009273751759343418, 0.07872587391307018, 0.07872587391307018, 0.07872587391307018, 0.07115593526895747, 0.07115593526895747, 0.07115593526895747]}}
{"id": "9a4dac5d-4432-417e-9fd7-76beb38106bd", "fitness": 0.05304548343589984, "name": "HybridPSO_SA_Adaptive", "description": "HybridPSO_SA_Adaptive: An enhanced hybrid metaheuristic that dynamically adjusts PSO and SA parameters for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass HybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n        \n        # Initialize particles\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        # Optimization loop\n        while self.function_evaluations < self.budget:\n            # Adjust parameters dynamically\n            self.w = 0.9 - 0.7 * (self.function_evaluations / self.budget)\n            self.c1 = 2.5 - 2.0 * (self.function_evaluations / self.budget)\n            self.c2 = 0.5 + 2.0 * (self.function_evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Evaluate new position\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                # Update personal best\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Simulated annealing with adaptive temperature\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 15, "feedback": "The algorithm HybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.00927275238072367, 0.00927275238072367, 0.00927275238072367, 0.07871567377841071, 0.07871567377841071, 0.07871567377841071, 0.07114802414856514, 0.07114802414856514, 0.07114802414856514]}}
{"id": "b3cd136c-3f0a-4c7d-ac76-102fd4c663c3", "fitness": 0.05305465582803959, "name": "HybridPSO_SA", "description": "An enhanced hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with adaptive parameters for improved convergence in black box optimization.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget  # Adaptively adjust inertia\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 16, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["767f6891-1364-45f3-a606-c29d4410cd14"], "operator": null, "metadata": {"aucs": [0.009274189392174614, 0.009274189392174614, 0.009274189392174614, 0.07873036113560261, 0.07873036113560261, 0.07873036113560261, 0.07115941695634154, 0.07115941695634154, 0.07115941695634154]}}
{"id": "2b6cf12d-fec6-4e04-af7c-6dce283009fe", "fitness": 0.05305465582803959, "name": "HybridPSO_SA", "description": "A refined HybridPSO_SA with improved cooling rate setup for enhanced performance in black box optimization.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.98  # Adjusted cooling rate\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget  # Adaptively adjust inertia\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 17, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.009274189392174614, 0.009274189392174614, 0.009274189392174614, 0.07873036113560261, 0.07873036113560261, 0.07873036113560261, 0.07115941695634154, 0.07115941695634154, 0.07115941695634154]}}
{"id": "44bfabc6-4928-443e-89c6-bdccad7f3343", "fitness": 0.05305465582803959, "name": "RefinedHybridPSO_SA", "description": "A refined hybrid metaheuristic leveraging Particle Swarm Optimization (PSO) with adaptive learning coefficients and Simulated Annealing (SA) for enhanced exploration and exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass RefinedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.adaptive_c1() * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.adaptive_c2() * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget\n\n        return self.global_best_position, self.global_best_score\n\n    def adaptive_c1(self):\n        return self.c1_initial - (self.c1_initial - self.c1_final) * (self.function_evaluations / self.budget)\n\n    def adaptive_c2(self):\n        return self.c2_initial - (self.c2_initial - self.c2_final) * (self.function_evaluations / self.budget)", "configspace": "", "generation": 18, "feedback": "The algorithm RefinedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.009274189392174614, 0.009274189392174614, 0.009274189392174614, 0.07873036113560261, 0.07873036113560261, 0.07873036113560261, 0.07115941695634154, 0.07115941695634154, 0.07115941695634154]}}
{"id": "bd1a3dae-769f-46ce-a2cf-74e6c7fe264b", "fitness": 0.05305465582803959, "name": "HybridPSO_SA", "description": "A refined hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with dynamic cooling and inertia strategies for enhanced black box optimization performance.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.001  # Changed from 0.1 to 0.001 for finer control\n        self.cooling_rate = 0.9  # Adjusted from 0.95 for more gradual cooling\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n            self.w = 0.3 + 0.7 * (self.budget - self.function_evaluations) / self.budget  # Adjusted inertia range\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 19, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.009274189392174614, 0.009274189392174614, 0.009274189392174614, 0.07873036113560261, 0.07873036113560261, 0.07873036113560261, 0.07115941695634154, 0.07115941695634154, 0.07115941695634154]}}
{"id": "6e1f0e6d-45fb-453f-bd1e-b62cb84acf5b", "fitness": 0.05305465582803959, "name": "HybridPSO_SA", "description": "A refined hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with an increased initial temperature for better exploration in black box optimization.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 20  # Increased initial temperature for better exploration\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget  # Adaptively adjust inertia\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 20, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.009274189392174614, 0.009274189392174614, 0.009274189392174614, 0.07873036113560261, 0.07873036113560261, 0.07873036113560261, 0.07115941695634154, 0.07115941695634154, 0.07115941695634154]}}
{"id": "cb63966f-6a86-45be-b39d-db43f80ff0bd", "fitness": 0.05305454514434945, "name": "DynamicHybridPSO_SA", "description": "Dynamic Hybrid PSO_SA with Adaptive Mutation and Exploration Enhancement", "code": "import numpy as np\n\nclass DynamicHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.mutation_rate = 0.1  # New adaptive mutation rate\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive mutation for exploration\n            if np.random.rand() < self.mutation_rate:\n                mutation_index = np.random.randint(0, self.num_particles)\n                mutation_vector = np.random.normal(0, 1, self.dim)\n                self.positions[mutation_index] = np.clip(self.positions[mutation_index] + mutation_vector, lb, ub)\n                mutation_score = func(self.positions[mutation_index])\n                self.function_evaluations += 1\n\n                if mutation_score < self.best_individual_scores[mutation_index]:\n                    self.best_individual_scores[mutation_index] = mutation_score\n                    self.best_individual_positions[mutation_index] = self.positions[mutation_index].copy()\n\n                    if mutation_score < self.global_best_score:\n                        self.global_best_score = mutation_score\n                        self.global_best_position = self.positions[mutation_index].copy()\n\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget  # Adaptively adjust inertia\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 21, "feedback": "The algorithm DynamicHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.009274172044552054, 0.009274172044552054, 0.009274172044552054, 0.07873018394953135, 0.07873018394953135, 0.07873018394953135, 0.07115927943896494, 0.07115927943896494, 0.07115927943896494]}}
{"id": "8f3a5f12-7d84-4a6a-842b-ef1335bdb676", "fitness": -Infinity, "name": "RefinedHybridPSO_SA", "description": "A refined hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with enhanced adaptive parameters and dynamic neighborhood structures for superior convergence in black box optimization.", "code": "import numpy as np\n\nclass RefinedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            neighborhood_radius = 1 + int(0.5 * self.budget / (self.function_evaluations + 1))\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget\n\n            # Dynamic neighborhood adaptation\n            neighborhood_indices = np.random.choice(self.num_particles, neighborhood_radius, replace=False)\n            local_best_index = neighborhood_indices[np.argmin(self.best_individual_scores[neighborhood_indices])]\n            if self.best_individual_scores[local_best_index] < self.global_best_score:\n                self.global_best_score = self.best_individual_scores[local_best_index]\n                self.global_best_position = self.best_individual_positions[local_best_index]\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 22, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {}}
{"id": "8a8beed0-5bb5-4c91-9980-07a1945cf7f7", "fitness": 0.05305455454299183, "name": "ImprovedHybridPSO_SA", "description": "An advanced hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with dynamic learning rates and strategic velocity adjustments for enhanced exploration and exploitation balance in black box optimization.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                \n                # Strategy: Adjust velocity to prioritize global or local exploration\n                self.velocities[i] = np.clip(self.velocities[i], -abs(ub - lb) / 3, abs(ub - lb) / 3)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Dynamic learning rates based on current evaluations\n            self.c1 = 1.5 + 0.5 * (self.budget - self.function_evaluations) / self.budget\n            self.c2 = 1.5 - 0.5 * (self.budget - self.function_evaluations) / self.budget\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 23, "feedback": "The algorithm ImprovedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.009274173520566475, 0.009274173520566475, 0.009274173520566475, 0.07873019898965528, 0.07873019898965528, 0.07873019898965528, 0.07115929111875374, 0.07115929111875374, 0.07115929111875374]}}
{"id": "bdd8c909-03dd-4b51-b86f-8c0808781a96", "fitness": 0.053054575134805194, "name": "HybridPSO_SA", "description": "Introduced inertia weight decay based on iteration count to enhance convergence speed and precision near optimal solutions.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n            self.w *= 0.99  # Line modified to implement inertia weight decay\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 24, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.009274176719766603, 0.009274176719766603, 0.009274176719766603, 0.07873023169854076, 0.07873023169854076, 0.07873023169854076, 0.07115931698610822, 0.07115931698610822, 0.07115931698610822]}}
{"id": "fe32496a-b431-4ddb-af2c-791dc34160ed", "fitness": 0.05305454514434945, "name": "HybridPSO_SA", "description": "An enhanced hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with adaptive parameters and improved diversity for enhanced exploration in black box optimization.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 10\n        self.temp_final = 0.1\n        self.cooling_rate = 0.95\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget  # Adaptively adjust inertia\n\n            # Improved diversity: random reinitialization for stagnating particles\n            if np.random.rand() < 0.1:\n                stagnating_index = np.argmax(self.best_individual_scores)\n                self.positions[stagnating_index] = np.random.uniform(lb, ub, self.dim)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 25, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.009274172044552054, 0.009274172044552054, 0.009274172044552054, 0.07873018394953135, 0.07873018394953135, 0.07873018394953135, 0.07115927943896494, 0.07115927943896494, 0.07115927943896494]}}
{"id": "f5fce32c-4b42-458c-a6c6-bd224e395338", "fitness": 0.053054707735934646, "name": "HybridPSO_SA", "description": "An improved hybrid metaheuristic combining Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with dynamic exploration-exploitation balance and enhanced local search for better convergence.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 1.8  # modified\n        self.c2 = 1.8  # modified\n        self.temp_initial = 15  # modified\n        self.temp_final = 0.1\n        self.cooling_rate = 0.92  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()  # modified inertia adjustment\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 26, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["b3cd136c-3f0a-4c7d-ac76-102fd4c663c3"], "operator": null, "metadata": {"aucs": [0.00927419751119618, 0.00927419751119618, 0.00927419751119618, 0.07873044395471052, 0.07873044395471052, 0.07873044395471052, 0.07115948174189723, 0.07115948174189723, 0.07115948174189723]}}
{"id": "7d84d276-b38f-4504-8960-5705e5dc6d03", "fitness": 0.05304867118925408, "name": "HybridPSO_SA", "description": "Enhanced hybrid metaheuristic with PSO and SA utilizing adaptive mutation and diversity preservation for improved global exploration and robust convergence.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.6  # modified\n        self.c1 = 2.0  # modified\n        self.c2 = 2.0  # modified\n        self.temp_initial = 15\n        self.temp_final = 0.1\n        self.cooling_rate = 0.9  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()  # randomness preserved\n\n            if np.random.rand() < 0.1:  # added mutation\n                for i in range(self.num_particles):\n                    if np.random.rand() < 0.1:  # mutation probability\n                        self.positions[i] = np.random.uniform(lb, ub, self.dim)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 27, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["f5fce32c-4b42-458c-a6c6-bd224e395338"], "operator": null, "metadata": {"aucs": [0.00927325145645852, 0.00927325145645852, 0.00927325145645852, 0.07872077633290364, 0.07872077633290364, 0.07872077633290364, 0.0711519857784001, 0.0711519857784001, 0.0711519857784001]}}
{"id": "ff092819-c271-4c55-8e9b-3c148fa080cb", "fitness": 0.05304782261138571, "name": "EnhancedHybridPSO_SA", "description": "Enhanced hybrid metaheuristic integrating Particle Swarm Optimization (PSO) and Simulated Annealing (SA) with adaptive parameter tuning and stochastic ranking to improve convergence and escape local optima.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim), 30)\n        self.w = 0.5\n        self.c1 = 2.0  # increased cognitive component\n        self.c2 = 2.0  # increased social component\n        self.temp_initial = 10  # modified\n        self.temp_final = 0.01  # more aggressive cooling\n        self.cooling_rate = 0.95  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive inertia weighting\n            self.w = 0.5 * (1 - (self.function_evaluations / self.budget)) + 0.4 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 28, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["f5fce32c-4b42-458c-a6c6-bd224e395338"], "operator": null, "metadata": {"aucs": [0.009273114488011491, 0.009273114488011491, 0.009273114488011491, 0.07871942563092604, 0.07871942563092604, 0.07871942563092604, 0.07115092771521958, 0.07115092771521958, 0.07115092771521958]}}
{"id": "9068531e-39cd-4d97-ac86-e94177cfff7d", "fitness": 0.05305527098700028, "name": "HybridPSO_SA", "description": "Enhanced PSO-SA hybrid with adaptive cooling and dynamic particle count for improved exploration-exploitation.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)  # modified\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20  # modified\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))  # modified\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 29, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["f5fce32c-4b42-458c-a6c6-bd224e395338"], "operator": null, "metadata": {"aucs": [0.00927428584498946, 0.00927428584498946, 0.00927428584498946, 0.0787313458309764, 0.0787313458309764, 0.0787313458309764, 0.07116018128503498, 0.07116018128503498, 0.07116018128503498]}}
{"id": "134ec798-abb8-4985-ae71-ea31a77d5f7d", "fitness": 0.05304755056639332, "name": "EnhancedHybridPSO_SA", "description": "Introduce adaptive inertia weight and adaptive learning rates based on convergence to improve the balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_start = 2.5\n        self.c2_start = 0.5\n        self.c1_end = 0.5\n        self.c2_end = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.9\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            iteration_ratio = self.function_evaluations / self.budget\n            w = self.w_max - (self.w_max - self.w_min) * iteration_ratio\n            c1 = self.c1_start + (self.c1_end - self.c1_start) * iteration_ratio\n            c2 = self.c2_start + (self.c2_end - self.c2_start) * iteration_ratio\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 30, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009273076866749608, 0.009273076866749608, 0.009273076866749608, 0.07871898104744846, 0.07871898104744846, 0.07871898104744846, 0.0711505937849819, 0.0711505937849819, 0.0711505937849819]}}
{"id": "2a5d566b-f95c-4896-8748-67ec40a11e36", "fitness": 0.05304729251371387, "name": "RefinedHybridPSO_SA", "description": "Enhanced PSO-SA hybrid with dynamic inertia weight and stochastic perturbation for improved convergence and diversity.", "code": "import numpy as np\n\nclass RefinedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            inertia_weight = 0.9 - (0.5 * (self.function_evaluations / self.budget))\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 31, "feedback": "The algorithm RefinedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009273034919100365, 0.009273034919100365, 0.009273034919100365, 0.07871857046739461, 0.07871857046739461, 0.07871857046739461, 0.07115027215464664, 0.07115027215464664, 0.07115027215464664]}}
{"id": "ff22437c-23ac-4377-8427-bd4b9377cc1a", "fitness": 0.05305527098700028, "name": "EnhancedHybridPSO_SA_Chaotic", "description": "Incorporating chaotic maps and adaptive learning rates into the Hybrid PSO-SA enhances solution diversity and convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Chaotic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def chaotic_map(self, x):\n        # Using a simple logistic map for chaotic sequence\n        return 4.0 * x * (1 - x)\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        chaotic_value = 0.7  # Initial value for the chaotic map\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                # Incorporate chaotic map into learning coefficients\n                chaotic_value = self.chaotic_map(chaotic_value)\n                adaptive_c1 = self.c1 * chaotic_value\n                adaptive_c2 = self.c2 * chaotic_value\n\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      adaptive_c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      adaptive_c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 32, "feedback": "The algorithm EnhancedHybridPSO_SA_Chaotic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.00927428584498946, 0.00927428584498946, 0.00927428584498946, 0.0787313458309764, 0.0787313458309764, 0.0787313458309764, 0.07116018128503498, 0.07116018128503498, 0.07116018128503498]}}
{"id": "c0c7a791-0ab6-49bc-ba9e-2645d2cb49d4", "fitness": 0.05304590506123811, "name": "ImprovedHybridPSO_SA", "description": "Improved Hybrid PSO-SA with adaptive inertia weight and multi-exploitation strategies for enhanced convergence.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.9\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.temp_initial = 15\n        self.temp_final = 0.1\n        self.cooling_rate = 0.9\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            self.w = 0.4 + 0.5 * (self.budget - self.function_evaluations) / self.budget  # Adaptive inertia weight\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 33, "feedback": "The algorithm ImprovedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.00927281664757773, 0.00927281664757773, 0.00927281664757773, 0.0787163515238728, 0.0787163515238728, 0.0787163515238728, 0.07114854701226381, 0.07114854701226381, 0.07114854701226381]}}
{"id": "93432df8-c731-4fe1-9c46-cf13263f361f", "fitness": 0.05304918511985387, "name": "ImprovedHybridPSO_SA", "description": "Enhanced PSO-SA hybrid with adaptive inertia weight, stochastic cooling schedule, and elitism strategy for robust global convergence.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        best_score_idx = np.argmin(self.best_individual_scores)\n        self.global_best_position = self.best_individual_positions[best_score_idx]\n        self.global_best_score = self.best_individual_scores[best_score_idx]\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.w = self.w_max - (self.w_max - self.w_min) * (self.function_evaluations / self.budget)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 34, "feedback": "The algorithm ImprovedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009273332724155425, 0.009273332724155425, 0.009273332724155425, 0.0787216010734536, 0.0787216010734536, 0.0787216010734536, 0.07115262156195257, 0.07115262156195257, 0.07115262156195257]}}
{"id": "f29d2bae-9fc8-4666-97a8-0dbcd786e3fa", "fitness": 0.05304578896549731, "name": "HybridPSO_SA", "description": "Hybrid PSO-SA with adaptive velocity clamping and stochastic perturbation for enhanced convergence.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                velocity_clamp = (ub - lb) * 0.1  # New velocity clamping strategy\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    perturbation = np.random.normal(0, temp, self.dim) * np.random.rand()  # Modified stochastic perturbation\n                    candidate_position = self.positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 35, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009272796587812437, 0.009272796587812437, 0.009272796587812437, 0.07871615718986147, 0.07871615718986147, 0.07871615718986147, 0.07114841311881803, 0.07114841311881803, 0.07114841311881803]}}
{"id": "0d60c769-0401-4bd0-b3c5-a56d2a504067", "fitness": 0.053050950610721036, "name": "HybridPSO_SA", "description": "Hybrid PSO-SA with variable topology and self-adaptive parameters to balance exploration and exploitation efficiently.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_max = 2.5\n        self.c1_min = 0.5\n        self.c2_max = 2.5\n        self.c2_min = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (self.function_evaluations / self.budget))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * (self.function_evaluations / self.budget))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * (self.function_evaluations / self.budget))\n            \n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (inertia_weight * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 36, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009273611117569192, 0.009273611117569192, 0.009273611117569192, 0.07872442447971184, 0.07872442447971184, 0.07872442447971184, 0.07115481623488207, 0.07115481623488207, 0.07115481623488207]}}
{"id": "e8466253-cde9-40b9-859c-ba8be927fd3a", "fitness": 0.0530551736337234, "name": "HybridPSO_SA", "description": "Enhanced PSO-SA hybrid with adaptive neighborhood search and dynamic cooling for improved exploitation and robustness.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.9  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))  # modified\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    neighborhood_size = (ub - lb) * 0.1  # modified\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim) + np.random.uniform(-neighborhood_size, neighborhood_size, self.dim)  # modified\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 37, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.00927427058866681, 0.00927427058866681, 0.00927427058866681, 0.07873118998091111, 0.07873118998091111, 0.07873118998091111, 0.07116006033159228, 0.07116006033159228, 0.07116006033159228]}}
{"id": "657d81a1-3d22-4d73-b3e6-2ac7fa05e214", "fitness": 0.053054441342637926, "name": "HybridPSO_SA", "description": "Enhanced hybrid PSO-SA with reduced velocity impact for smoother convergence and improved search stability.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)  # modified\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20  # modified\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (0.3 * self.velocities[i] +  # modified\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))  # modified\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 38, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.00927415523289754, 0.00927415523289754, 0.00927415523289754, 0.07873001634107812, 0.07873001634107812, 0.07873001634107812, 0.07115915245393811, 0.07115915245393811, 0.07115915245393811]}}
{"id": "197a43f1-5f63-4845-b586-efdc78d51fb0", "fitness": 0.05305527098700028, "name": "AQPSO_SA", "description": "Adaptive Quantum-inspired PSO-SA hybrid utilizing stochastic tunneling and variable neighborhood search for enhanced global convergence.", "code": "import numpy as np\n\nclass AQPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if (candidate_score < self.best_individual_scores[i] or \n                        np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp)):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            if np.random.rand() < 0.1:  # Stochastic tunneling\n                local_best_idx = np.argmin(self.best_individual_scores)\n                jump = np.random.uniform(-0.5, 0.5, self.dim) * (ub - lb)\n                candidate_position = self.positions[local_best_idx] + jump\n                candidate_position = np.clip(candidate_position, lb, ub)\n                candidate_score = func(candidate_position)\n                self.function_evaluations += 1\n\n                if candidate_score < self.global_best_score:\n                    self.global_best_score = candidate_score\n                    self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 39, "feedback": "The algorithm AQPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.00927428584498946, 0.00927428584498946, 0.00927428584498946, 0.0787313458309764, 0.0787313458309764, 0.0787313458309764, 0.07116018128503498, 0.07116018128503498, 0.07116018128503498]}}
{"id": "0f8a5862-4edf-4893-9d3c-be05c30b9606", "fitness": 0.053042185675208166, "name": "HybridPSO_SA", "description": "Optimized Hybrid PSO-SA with adaptive inertia and enhanced exploration through Levy flights for better convergence.", "code": "import numpy as np\nimport scipy.stats as stats\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)  # modified\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20  # modified\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.w = 0.4 + 0.2 * (self.global_best_score / np.min(self.best_individual_scores))  # modified\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))  # modified\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    step = np.random.normal(0, temp, self.dim) * stats.levy.rvs(size=self.dim)  # modified\n                    candidate_position = self.positions[i] + step\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 40, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03110.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009272231348165128, 0.009272231348165128, 0.009272231348165128, 0.0787103990458321, 0.0787103990458321, 0.0787103990458321, 0.07114392663162727, 0.07114392663162727, 0.07114392663162727]}}
{"id": "8917d2a1-5c8f-4f6d-946d-e8293b9a6724", "fitness": 0.05305527098700028, "name": "HybridPSO_SA", "description": "Improved PSO-SA hybrid by fine-tuning velocity update and adaptive inertia weight for enhanced convergence.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)  # modified\n        self.w = 0.5\n        self.c1 = 1.9  # modified\n        self.c2 = 1.9  # modified\n        self.temp_initial = 20  # modified\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))  # modified\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.3 + 0.4 * np.random.rand()  # modified\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 41, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.00927428584498946, 0.00927428584498946, 0.00927428584498946, 0.0787313458309764, 0.0787313458309764, 0.0787313458309764, 0.07116018128503498, 0.07116018128503498, 0.07116018128503498]}}
{"id": "ca02878a-ea03-47c7-a2c9-e2588d353423", "fitness": 0.0530490808422717, "name": "HybridPSO_SA_Refined", "description": "Hybrid PSO-SA with adaptive inertia, stochastic cooling, and selective candidate acceptance for robust optimization.", "code": "import numpy as np\n\nclass HybridPSO_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + 0.1 * np.random.rand()) ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i]:\n                        accept = True\n                    else:\n                        delta_score = candidate_score - self.best_individual_scores[i]\n                        accept = np.random.rand() < np.exp(-delta_score / temp) and delta_score < 0.1 * (ub - lb).mean()\n\n                    if accept:\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.5 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 42, "feedback": "The algorithm HybridPSO_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009273308614605624, 0.009273308614605624, 0.009273308614605624, 0.07872144075141774, 0.07872144075141774, 0.07872144075141774, 0.07115249316079175, 0.07115249316079175, 0.07115249316079175]}}
{"id": "a95075e8-60cf-4dd8-b575-da84a529ce35", "fitness": 0.05305527098700028, "name": "HybridPSO_SA", "description": "Improved HybridPSO_SA with enhanced velocity update using dynamic inertia weight.", "code": "import numpy as np\n\nclass HybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)  # modified\n        self.w = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.8\n        self.temp_initial = 20  # modified\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85  # modified\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (self.function_evaluations / self.budget))  # modified\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand() * (1 - self.function_evaluations / self.budget)  # modified\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 43, "feedback": "The algorithm HybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.00927428584498946, 0.00927428584498946, 0.00927428584498946, 0.0787313458309764, 0.0787313458309764, 0.0787313458309764, 0.07116018128503498, 0.07116018128503498, 0.07116018128503498]}}
{"id": "9b455e38-3f08-413d-a2dd-71b55ecdd07b", "fitness": 0.05305235897859036, "name": "EnhancedHybridPSO_SA", "description": "Improved PSO-SA hybrid with adaptive inertia, real-time temperature adjustment, and comprehensive local search to enhance convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.temp_initial = 15\n        self.temp_final = 0.01\n        self.cooling_rate = 0.9\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb = bounds.lb\n        ub = bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            w = self.w_max - ((self.w_max - self.w_min) * self.function_evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      self.c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (self.function_evaluations / self.budget))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 44, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009273831097820318, 0.009273831097820318, 0.009273831097820318, 0.07872668260949822, 0.07872668260949822, 0.07872668260949822, 0.07115656322845254, 0.07115656322845254, 0.07115656322845254]}}
{"id": "35bf5cf9-3635-41d1-bc68-1a151354dffb", "fitness": 0.053055296078568924, "name": "EnhancedHybridPSO_SA", "description": "Enhanced hybrid PSO-SA with adaptive learning coefficients and dynamic annealing for improved optimization efficiency.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 45, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["9068531e-39cd-4d97-ac86-e94177cfff7d"], "operator": null, "metadata": {"aucs": [0.009274289781535994, 0.009274289781535994, 0.009274289781535994, 0.07873138599106366, 0.07873138599106366, 0.07873138599106366, 0.07116021246310711, 0.07116021246310711, 0.07116021246310711]}}
{"id": "4ad5dab9-407f-4b73-9040-9dc69f4047cf", "fitness": 0.053055296078568924, "name": "EnhancedHybridPSO_SA", "description": "Introduced dynamic inertia weight with a slight adaptation for improved convergence in the Enhanced Hybrid PSO-SA algorithm.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand() * (1 - t)  # Modified line for dynamic inertia weight\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 46, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009274289781535994, 0.009274289781535994, 0.009274289781535994, 0.07873138599106366, 0.07873138599106366, 0.07873138599106366, 0.07116021246310711, 0.07116021246310711, 0.07116021246310711]}}
{"id": "1215550a-1f6c-4673-a027-7190ed7ffc06", "fitness": 0.053055296078568924, "name": "EnhancedHybridPSO_SA", "description": "Enhanced hybrid PSO-SA with a strategic adjustment to the inertia weight formula for better exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.7 - 0.5 * (self.function_evaluations / self.budget)  # Modified inertia weight formula\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 47, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009274289781535994, 0.009274289781535994, 0.009274289781535994, 0.07873138599106366, 0.07873138599106366, 0.07873138599106366, 0.07116021246310711, 0.07116021246310711, 0.07116021246310711]}}
{"id": "be84e7a2-550b-464a-bc2e-22711f936e2b", "fitness": 0.05305079116218766, "name": "ImprovedHybridPSO_SA", "description": "Improved Hybrid PSO-SA with adaptive inertia weight and velocity clamping for enhanced convergence and exploration-exploitation balance.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.velocity_clamp = 0.1\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n            self.w = self.w_max * (1 - t) + self.w_min * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n\n                self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 48, "feedback": "The algorithm ImprovedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009273580006074256, 0.009273580006074256, 0.009273580006074256, 0.07872417672918941, 0.07872417672918941, 0.07872417672918941, 0.0711546167512993, 0.0711546167512993, 0.0711546167512993]}}
{"id": "4964f8bf-9f4f-4986-a719-9113816a4bee", "fitness": 0.053055296078568924, "name": "EnhancedHybridPSO_SA", "description": "Enhanced hybrid PSO-SA with dynamic topology adaptation and energy-based velocity control for improved convergence and diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w = 0.5\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            self.w = 0.4 + 0.3 * np.random.rand()\n            if self.function_evaluations % 10 == 0:  # Dynamic topology adaptation\n                np.random.shuffle(self.positions)  # Shuffle positions to adapt connectivity\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 49, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009274289781535994, 0.009274289781535994, 0.009274289781535994, 0.07873138599106366, 0.07873138599106366, 0.07873138599106366, 0.07116021246310711, 0.07116021246310711, 0.07116021246310711]}}
{"id": "a2f52f5f-ad6a-4a9c-affa-c8a114872b1b", "fitness": 0.053052305108334474, "name": "AdaptiveInertiaPSO_SA", "description": "Adaptive Inertia PSO-SA with dynamic velocity bounds and enhanced exploration-exploitation balance for improved convergence.", "code": "import numpy as np\n\nclass AdaptiveInertiaPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.1\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 2.5\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n            self.w = self.w_max - (self.w_max - self.w_min) * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                velocity_limit = (ub - lb) * (1 - t)\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_limit, velocity_limit)\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 50, "feedback": "The algorithm AdaptiveInertiaPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009273823106971446, 0.009273823106971446, 0.009273823106971446, 0.07872659583261343, 0.07872659583261343, 0.07872659583261343, 0.07115649638541854, 0.07115649638541854, 0.07115649638541854]}}
{"id": "940d60a4-4af2-46b8-9e72-67ab238103c9", "fitness": 0.0530484424778274, "name": "RefinedHybridPSO_SA", "description": "A refined hybrid PSO-SA algorithm with dynamically adjusted inertia and temperature based on convergence metrics for improved optimization performance.", "code": "import numpy as np\n\nclass RefinedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n            self.w = self.w_max - (self.w_max - self.w_min) * (self.function_evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 51, "feedback": "The algorithm RefinedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.00927321600458031, 0.00927321600458031, 0.00927321600458031, 0.0787204125294072, 0.0787204125294072, 0.0787204125294072, 0.07115169889949469, 0.07115169889949469, 0.07115169889949469]}}
{"id": "417d8e8a-678f-49b9-94f2-aa7730302509", "fitness": 0.0530484424778274, "name": "ImprovedHybridPSO_SA", "description": "Improved Hybrid PSO-SA with adaptive inertia weight, diversity preservation, and enhanced annealing for superior convergence efficiency.", "code": "import numpy as np\n\nclass ImprovedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_init = 0.9\n        self.w_final = 0.4\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n            self.w = self.w_init * (1 - t) + self.w_final * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            if self.function_evaluations % (self.budget // 10) == 0:\n                diversity = np.std(self.positions)\n                if diversity < (ub - lb).mean() * 0.01:\n                    self.positions += np.random.uniform(-0.1, 0.1, self.positions.shape)\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 52, "feedback": "The algorithm ImprovedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.00927321600458031, 0.00927321600458031, 0.00927321600458031, 0.0787204125294072, 0.0787204125294072, 0.0787204125294072, 0.07115169889949469, 0.07115169889949469, 0.07115169889949469]}}
{"id": "1b4c3650-8b77-47e3-88ad-ac67169ffd4c", "fitness": 0.0530552835603868, "name": "EnhancedHybridPSO_SA", "description": "Enhanced Hybrid PSO-SA with adaptive inertia weight and stochastic velocity clamping for diversified exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_initial = 0.9  # Changed\n        self.w_final = 0.4  # Changed\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n            self.w = self.w_initial * (1 - t) + self.w_final * t  # Changed\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                velocity_clamp = 0.2 * (ub - lb)  # Added\n                self.velocities[i] = np.clip(self.velocities[i], -velocity_clamp, velocity_clamp)  # Added\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 53, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009274287690241856, 0.009274287690241856, 0.009274287690241856, 0.07873136465562425, 0.07873136465562425, 0.07873136465562425, 0.0711601983352943, 0.0711601983352943, 0.0711601983352943]}}
{"id": "30a61d5a-0b4d-423e-9a17-ed336b28f279", "fitness": 0.05304764906495296, "name": "EnhancedHybridPSO_SA", "description": "EnhancedHybridPSO_SA with adaptive inertia weight and improved candidate solution exploration using Gaussian perturbations.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_initial = 0.9\n        self.w_final = 0.4\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 0.5\n        self.c2_final = 0.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n            self.w = self.w_initial * (1 - t) + self.w_final * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp / 2, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 54, "feedback": "The algorithm EnhancedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009273091295305291, 0.009273091295305291, 0.009273091295305291, 0.07871914307680472, 0.07871914307680472, 0.07871914307680472, 0.07115071282274887, 0.07115071282274887, 0.07115071282274887]}}
{"id": "96b81d29-e41d-4b3d-b701-9bb51db5afad", "fitness": 0.05304989811776158, "name": "RefinedHybridPSO_SA", "description": "Enhanced hybrid PSO-SA with dynamic inertia weight and temperature-dependent perturbation for refined search accuracy.", "code": "import numpy as np\n\nclass RefinedHybridPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_init = 0.9\n        self.w_final = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 0.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 25\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.zeros((self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            w = self.w_init * (1 - t) + self.w_final * t\n            c1 = self.c1_initial * (1 - t) + self.c1_final * t\n            c2 = self.c2_initial * (1 - t) + self.c2_final * t\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** t)\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 55, "feedback": "The algorithm RefinedHybridPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009273436208281804, 0.009273436208281804, 0.009273436208281804, 0.0787227503092508, 0.0787227503092508, 0.0787227503092508, 0.07115350783575214, 0.07115350783575214, 0.07115350783575214]}}
{"id": "ad5e6552-efe6-4963-838b-d40835abe648", "fitness": 0.056262612803496016, "name": "EnhancedHybridPSO_SA_Refined", "description": "Introduces stochastic adaptive inertia weight and cyclic learning coefficients for enhanced exploration and exploitation balance in PSO-SA optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 56, "feedback": "The algorithm EnhancedHybridPSO_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05626 with standard deviation 0.03311.", "error": "", "parent_ids": ["35bf5cf9-3635-41d1-bc68-1a151354dffb"], "operator": null, "metadata": {"aucs": [0.009725793182216003, 0.009725793182216003, 0.009725793182216003, 0.0839744595539531, 0.0839744595539531, 0.0839744595539531, 0.07508758567431895, 0.07508758567431895, 0.07508758567431895]}}
{"id": "3fc4ba2d-fe94-4ca7-9f0f-b258861cc0e5", "fitness": 0.05305817803054721, "name": "EnhancedHybridPSO_SA_Refined", "description": "Introduces a slight stochasticity in the velocity update to enhance exploration capabilities of PSO in PSO-SA optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]) + \n                                      np.random.normal(0, 0.1, self.dim)) # Added stochasticity\n                \n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 57, "feedback": "The algorithm EnhancedHybridPSO_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["ad5e6552-efe6-4963-838b-d40835abe648"], "operator": null, "metadata": {"aucs": [0.00927474572237752, 0.00927474572237752, 0.00927474572237752, 0.0787359955358462, 0.0787359955358462, 0.0787359955358462, 0.0711637928334179, 0.0711637928334179, 0.0711637928334179]}}
{"id": "f6611e7c-de63-4b7e-8abe-f67936876711", "fitness": 0.053052427686642346, "name": "EnhancedHybridPSO_SA_Refined", "description": "Enhanced balance of exploration and exploitation through dynamic learning coefficients and adaptive temperature control in PSO-SA hybrid optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.2  # Refined for better balance\n        self.w_max = 1.0  # Increased for more exploration\n        self.c1_initial = 2.0  # Reduced for more consistent convergence\n        self.c2_initial = 2.0  # Balanced both for better coordination\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 25  # Higher initial temperature for better exploration\n        self.temp_final = 0.01  # Lower final temperature for precise exploitation\n        self.cooling_rate = 0.9  # Slower cooling for gradual exploration\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.02) ** (t))  # Reduced randomness\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 58, "feedback": "The algorithm EnhancedHybridPSO_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["ad5e6552-efe6-4963-838b-d40835abe648"], "operator": null, "metadata": {"aucs": [0.009273841975389607, 0.009273841975389607, 0.009273841975389607, 0.07872679270258698, 0.07872679270258698, 0.07872679270258698, 0.07115664838195046, 0.07115664838195046, 0.07115664838195046]}}
{"id": "b557f8de-e988-4850-afd6-4e594334cfaf", "fitness": 0.053055617090979945, "name": "EnhancedHybridPSO_SA_Dynamic", "description": "Integrates dynamic neighborhood topology and adaptive temperature scaling in PSO-SA for robust convergence in high-dimensional spaces.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Dynamic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.9\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.neighborhood_size = max(2, self.num_particles // 5)\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                neighborhood_best_position = self._get_neighborhood_best(i)\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (neighborhood_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t * (10.0 / np.sqrt(self.dim))))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp, self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n        return self.global_best_position, self.global_best_score\n\n    def _get_neighborhood_best(self, index):\n        neighbors = np.argsort(np.linalg.norm(self.positions - self.positions[index], axis=1))\n        best_neighbor = neighbors[:self.neighborhood_size].min()\n        return self.best_individual_positions[best_neighbor]", "configspace": "", "generation": 59, "feedback": "The algorithm EnhancedHybridPSO_SA_Dynamic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["ad5e6552-efe6-4963-838b-d40835abe648"], "operator": null, "metadata": {"aucs": [0.009274343053403578, 0.009274343053403578, 0.009274343053403578, 0.07873189584614293, 0.07873189584614293, 0.07873189584614293, 0.07116061237339333, 0.07116061237339333, 0.07116061237339333]}}
{"id": "bac8f56c-fa2a-4d76-baac-566fe8cc1182", "fitness": 0.05795996541433812, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Implements an adaptive mutation strategy in PSO-SA to dynamically adjust exploration based on convergence metrics, improving solution diversity and convergence rate.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 60, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05796 with standard deviation 0.03418.", "error": "", "parent_ids": ["ad5e6552-efe6-4963-838b-d40835abe648"], "operator": null, "metadata": {"aucs": [0.009948742007812927, 0.009948742007812927, 0.009948742007812927, 0.08678265928484064, 0.08678265928484064, 0.08678265928484064, 0.0771484949503608, 0.0771484949503608, 0.0771484949503608]}}
{"id": "308a546a-a13c-4c0b-8016-44d88d7da7eb", "fitness": 0.053058341197025016, "name": "EnhancedHybridPSO_SA_Refined", "description": "Incorporates an adaptive inertia weight strategy alongside improved stochastic update mechanisms for PSO, enhancing convergence speed and solution accuracy.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.2  # Adjusted\n        self.w_max = 0.9\n        self.c1_initial = 2.4  # Adjusted\n        self.c2_initial = 1.7  # Adjusted\n        self.c1_final = 0.6  # Adjusted\n        self.c2_final = 2.4  # Adjusted\n        self.temp_initial = 25  # Adjusted\n        self.temp_final = 0.1\n        self.cooling_rate = 0.9  # Adjusted\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.mutation_rate = 0.08  # Adjusted\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t * np.random.rand())  # Added randomness\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.15 * (1 - np.exp(-5 * t))  # Adjusted\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 61, "feedback": "The algorithm EnhancedHybridPSO_SA_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["bac8f56c-fa2a-4d76-baac-566fe8cc1182"], "operator": null, "metadata": {"aucs": [0.009274771698314366, 0.009274771698314366, 0.009274771698314366, 0.07873625659716965, 0.07873625659716965, 0.07873625659716965, 0.07116399529559103, 0.07116399529559103, 0.07116399529559103]}}
{"id": "22cddb35-e23d-46d8-a8ba-8fe6c1e37dd8", "fitness": 0.05468917812298213, "name": "EnhancedHybridPSO_SA_Entropy", "description": "Integrates an entropy-based perturbation mechanism in PSO-SA to enhance exploration by dynamically adjusting position updates, ensuring better convergence and solution quality.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Entropy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    entropy_factor = np.random.normal(0, 0.05 * np.std(self.positions, axis=0))\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim) + entropy_factor\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 62, "feedback": "The algorithm EnhancedHybridPSO_SA_Entropy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05469 with standard deviation 0.03211.", "error": "", "parent_ids": ["bac8f56c-fa2a-4d76-baac-566fe8cc1182"], "operator": null, "metadata": {"aucs": [0.009521509576147724, 0.009521509576147724, 0.009521509576147724, 0.08136161553060262, 0.08136161553060262, 0.08136161553060262, 0.07318440926219605, 0.07318440926219605, 0.07318440926219605]}}
{"id": "d250efe8-9173-48a7-9327-f5a083b47f2a", "fitness": 0.05795996541433812, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Enhances the adaptive mutation strategy by increasing mutation diversity, boosting exploration capability and convergence accuracy.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.2 * (1 - np.exp(-5 * t))  # Increased mutation diversity\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 63, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05796 with standard deviation 0.03418.", "error": "", "parent_ids": ["bac8f56c-fa2a-4d76-baac-566fe8cc1182"], "operator": null, "metadata": {"aucs": [0.009948742007812927, 0.009948742007812927, 0.009948742007812927, 0.08678265928484064, 0.08678265928484064, 0.08678265928484064, 0.0771484949503608, 0.0771484949503608, 0.0771484949503608]}}
{"id": "89a5f6a0-63ce-4685-9872-0173f454487a", "fitness": 0.08945554628232089, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Refines EnhancedHybridPSO_SA_Adaptive by introducing a dynamic mutation rate based on particle diversity and introducing a boundary reflection mechanism to enhance exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 64, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["bac8f56c-fa2a-4d76-baac-566fe8cc1182"], "operator": null, "metadata": {"aucs": [0.009830695898250918, 0.009830695898250918, 0.009830695898250918, 0.13329318520780387, 0.13329318520780387, 0.13329318520780387, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
{"id": "faed13f8-e9fd-4205-92a8-8b6a9c6a1d78", "fitness": 0.053058175367744854, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduce a minor adjustment to the velocity update formula to enhance exploration in later stages.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]) +\n                                      0.01 * np.random.randn(self.dim))  # Minor change here\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 65, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009274745353554992, 0.009274745353554992, 0.009274745353554992, 0.07873599179449864, 0.07873599179449864, 0.07873599179449864, 0.07116378895518094, 0.07116378895518094, 0.07116378895518094]}}
{"id": "9ed5c5a9-37d4-4f3c-9e1d-30ab544fc1bf", "fitness": 0.0530492683737559, "name": "EnhancedHybridPSO_SA_Adaptive_V2", "description": "Introduces an adaptive learning rate based on convergence speed and implements a stochastic search phase to enhance exploration and solution diversity.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        previous_global_best_score = self.global_best_score\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            # Dynamic learning rate based on convergence speed\n            if self.global_best_score < previous_global_best_score:\n                self.learning_rate = min(self.learning_rate * 1.05, 1.0)\n            else:\n                self.learning_rate = max(self.learning_rate * 0.95, 0.01)\n            previous_global_best_score = self.global_best_score\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i] * self.learning_rate, lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy with Stochastic Search\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                for i in range(self.num_particles):\n                    stochastic_position = np.random.uniform(lb, ub, self.dim)\n                    stochastic_score = func(stochastic_position)\n                    self.function_evaluations += 1\n\n                    if stochastic_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = stochastic_score\n                        self.best_individual_positions[i] = stochastic_position\n\n                        if stochastic_score < self.global_best_score:\n                            self.global_best_score = stochastic_score\n                            self.global_best_position = stochastic_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 66, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009273338570702894, 0.009273338570702894, 0.009273338570702894, 0.07872174081940553, 0.07872174081940553, 0.07872174081940553, 0.07115272573115927, 0.07115272573115927, 0.07115272573115927]}}
{"id": "c927bf4c-aa1b-459d-8cc4-6370ee8c39a2", "fitness": 0.053001995940576564, "name": "EnhancedHybridPSO_SA_Adaptive_v2", "description": "Integrates adaptive neighborhood topology and stochastic gradient-driven perturbations to enhance local search and convergence in EnhancedHybridPSO_SA_Adaptive.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                local_best_position = self.best_individual_positions[np.random.choice(self.num_particles)]\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (local_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n            # Stochastic Gradient-driven Perturbations\n            if np.random.rand() < self.mutation_rate:\n                gradient_perturbation = np.random.uniform(-0.01, 0.01, self.dim)\n                for i in range(self.num_particles):\n                    perturbed_position = self.positions[i] + gradient_perturbation * (self.global_best_position - self.positions[i])\n                    perturbed_position = np.clip(perturbed_position, lb, ub)\n                    perturbed_score = func(perturbed_position)\n                    self.function_evaluations += 1\n\n                    if perturbed_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = perturbed_score\n                        self.best_individual_positions[i] = perturbed_position\n\n                        if perturbed_score < self.global_best_score:\n                            self.global_best_score = perturbed_score\n                            self.global_best_position = perturbed_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 67, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05300 with standard deviation 0.03108.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009265913722836583, 0.009265913722836583, 0.009265913722836583, 0.07864607203046359, 0.07864607203046359, 0.07864607203046359, 0.07109400206842953, 0.07109400206842953, 0.07109400206842953]}}
{"id": "51cd7c6c-29ef-4ff7-949d-8445c93b13e3", "fitness": -Infinity, "name": "EnhancedHybridPSO_Lvy_Adaptive", "description": "Integrate a Lvy flight mechanism to enhance exploration, combined with an adaptive inertia weight strategy for improved balance between exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_Lvy_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / (\n                np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size=self.dim)\n        v = np.random.normal(0, 1, size=self.dim)\n        step = u / (np.abs(v) ** (1 / beta))\n        return 0.01 * step * L\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Levy flight\n            if np.random.rand() < self.mutation_rate:\n                for i in range(self.num_particles):\n                    L = np.linalg.norm(self.velocities[i])\n                    step = self.levy_flight(L)\n                    mutated_position = self.positions[i] + step\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 68, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {}}
{"id": "d3afd6b9-ae93-4d01-8c5a-dafa4d3ed881", "fitness": 0.05303501373617433, "name": "EnhancedHybridPSO_SA_Adaptive_Improved", "description": "Refines EnhancedHybridPSO_SA_Adaptive by introducing a particle swarm hierarchy with leader-follower dynamics and a dynamic inertia weight adaptation based on convergence, along with improved boundary handling via a random reinitialization strategy, to enhance both exploration and exploitation.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            # Introduce hierarchy: assign leader roles\n            leaders_indices = np.argsort(self.best_individual_scores)[:self.num_particles // 2]\n            followers_indices = np.argsort(self.best_individual_scores)[self.num_particles // 2:]\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                leader_position = self.positions[leaders_indices[np.random.randint(0, len(leaders_indices))]]\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (leader_position - self.positions[i]))\n                self.positions[i] = self.positions[i] + self.velocities[i]\n\n                # Improved boundary handling: random reinitialization\n                out_of_bounds = np.logical_or(self.positions[i] < lb, self.positions[i] > ub)\n                self.positions[i][out_of_bounds] = np.random.uniform(lb, ub, self.dim)[out_of_bounds]\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 69, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03110.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009271095924941242, 0.009271095924941242, 0.009271095924941242, 0.07869893189702981, 0.07869893189702981, 0.07869893189702981, 0.07113501338655193, 0.07113501338655193, 0.07113501338655193]}}
{"id": "e6cc8f9f-7080-4ddd-9eda-7b85af5fee04", "fitness": 0.053057785565248906, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduced stochastic inertia weight variation for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t) + np.random.uniform(-0.05, 0.05)  # Stochastic variation\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 70, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009274684593638671, 0.009274684593638671, 0.009274684593638671, 0.0787353671604899, 0.0787353671604899, 0.0787353671604899, 0.07116330494161816, 0.07116330494161816, 0.07116330494161816]}}
{"id": "6f4bd558-f574-4f44-a83c-2729d4ee8030", "fitness": 0.05305778510746847, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduces stochastic inertia weight adjustment by adding a random perturbation, enhancing exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t) + np.random.uniform(-0.1, 0.1)  # Line modified\n\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 71, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009274684470666261, 0.009274684470666261, 0.009274684470666261, 0.07873536591012098, 0.07873536591012098, 0.07873536591012098, 0.07116330494161816, 0.07116330494161816, 0.07116330494161816]}}
{"id": "5c63bcba-e8a7-4794-8a21-582695db36bd", "fitness": 0.05304722826616448, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduces a momentum term in the velocity update to enhance convergence speed.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            momentum = 0.9  # Introduced momentum term in velocity update\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (momentum * self.velocities[i] +  # New momentum term applied here\n                                      self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 72, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009273024345312408, 0.009273024345312408, 0.009273024345312408, 0.07871846886945488, 0.07871846886945488, 0.07871846886945488, 0.07115019158372615, 0.07115019158372615, 0.07115019158372615]}}
{"id": "5f47d34a-22d8-4f7e-b08d-e0345984f94b", "fitness": 0.0530546431673502, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Incorporates a multi-swarm strategy to enhance global exploration and diversity while maintaining convergence precision.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n        self.num_swarms = 3  # Additional line for multi-swarm strategy\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for swarm in range(self.num_swarms):  # Splitting into multiple swarms\n                for i in range(swarm, self.num_particles, self.num_swarms):\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    self.velocities[i] = (self.w * self.velocities[i] +\n                                          c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                          c2 * r2 * (self.global_best_position - self.positions[i]))\n                    self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                    # Boundary reflection\n                    self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                    self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                    score = func(self.positions[i])\n                    self.function_evaluations += 1\n\n                    if score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = score\n                        self.best_individual_positions[i] = self.positions[i].copy()\n\n                    if score < self.global_best_score:\n                        self.global_best_score = score\n                        self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 73, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009274190522827963, 0.009274190522827963, 0.009274190522827963, 0.07873033501621451, 0.07873033501621451, 0.07873033501621451, 0.07115940396300813, 0.07115940396300813, 0.07115940396300813]}}
{"id": "efcf1743-611e-4534-a499-09068789cf76", "fitness": 0.05307177255345904, "name": "EnhancedHybridPSO_SA_Adaptive_Refined", "description": "Introduce an adaptive velocity clamping mechanism and chaotic sequence initialization to improve exploration and diversity in EnhancedHybridPSO_SA_Adaptive.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.vel_clamp_factor = 0.5\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        # Chaotic sequence initialization\n        chaotic_sequence = np.sin(np.arange(1, self.num_particles * self.dim + 1) * np.pi / 2)\n        self.positions = chaotic_sequence.reshape(self.num_particles, self.dim) * (ub - lb) + lb\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n            \n            vel_clamp = self.vel_clamp_factor * (ub - lb)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = np.clip(\n                    self.w * self.velocities[i] +\n                    c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                    c2 * r2 * (self.global_best_position - self.positions[i]),\n                    -vel_clamp, vel_clamp\n                )\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 74, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05307 with standard deviation 0.03112.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009276893743993209, 0.009276893743993209, 0.009276893743993209, 0.07875772643349332, 0.07875772643349332, 0.07875772643349332, 0.07118069748289058, 0.07118069748289058, 0.07118069748289058]}}
{"id": "f5c383c4-49cc-4dc2-b5cb-a330cd3553b0", "fitness": 0.05468917812298213, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduces a dynamic temperature oscillation and variance-based stopping criterion for enhanced exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Dynamic temperature oscillation\n            temp = (self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t)) *\n                    (0.5 + 0.5 * np.sin(2 * np.pi * t)))\n\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n            # Variance-based stopping criterion\n            if np.std(self.best_individual_scores) < 1e-5:\n                break\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 75, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05469 with standard deviation 0.03211.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009521509576147724, 0.009521509576147724, 0.009521509576147724, 0.08136161553060262, 0.08136161553060262, 0.08136161553060262, 0.07318440926219605, 0.07318440926219605, 0.07318440926219605]}}
{"id": "b251950c-9eef-4a59-9caa-9c30d1d3dff9", "fitness": -Infinity, "name": "EnhancedHybridPSO_SA_Adaptive_Crossover", "description": "Introduces a dynamic inertia weight strategy and an adaptive crossover mechanism to balance exploration and exploitation for enhanced convergence in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_Crossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = (self.w_max - t * (self.w_max - self.w_min))\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Crossover Strategy\n            if np.random.rand() < self.mutation_rate:\n                for i in range(self.num_particles):\n                    partner = np.random.randint(self.num_particles)\n                    crossover_point = np.random.randint(1, self.dim - 1)\n                    offspring = np.concatenate((self.positions[i][:crossover_point],\n                                                self.best_individual_positions[partner][crossover_point:]))\n                    offspring = np.clip(offspring, lb, ub)\n                    offspring_score = func(offspring)\n                    self.function_evaluations += 1\n\n                    if offspring_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = offspring_score\n                        self.best_individual_positions[i] = offspring\n\n                        if offspring_score < self.global_best_score:\n                            self.global_best_score = offspring_score\n                            self.global_best_position = offspring\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 76, "feedback": "An exception occurred: ValueError('low >= high').", "error": "ValueError('low >= high')", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {}}
{"id": "4b8041ca-5471-436f-91db-6a958c985e76", "fitness": 0.05305795396233796, "name": "EnhancedMultiSwarmPSO_SA", "description": "Introduces a multi-swarm approach with adaptive inter-swarm communication and a stochastic perturbation mechanism to enhance both exploration and exploitation in high-dimensional search spaces.", "code": "import numpy as np\n\nclass EnhancedMultiSwarmPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = max(2, dim // 10)\n        self.num_particles_per_swarm = min(max(3, dim // 2), 20)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = [None] * self.num_swarms\n        self.velocities = [None] * self.num_swarms\n        self.best_individual_positions = [None] * self.num_swarms\n        self.best_individual_scores = [None] * self.num_swarms\n        self.global_best_position = np.random.rand(self.dim)\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n        self.inter_swarm_rate = np.linspace(0.1, 0.5, self.num_swarms)\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        for s in range(self.num_swarms):\n            self.positions[s] = np.random.uniform(lb, ub, (self.num_particles_per_swarm, self.dim))\n            self.velocities[s] = np.random.uniform(-1, 1, (self.num_particles_per_swarm, self.dim))\n            self.best_individual_positions[s] = self.positions[s].copy()\n            self.best_individual_scores[s] = np.array([func(position) for position in self.positions[s]])\n            self.function_evaluations += self.num_particles_per_swarm\n\n            swarm_best_idx = np.argmin(self.best_individual_scores[s])\n            if self.best_individual_scores[s][swarm_best_idx] < self.global_best_score:\n                self.global_best_score = self.best_individual_scores[s][swarm_best_idx]\n                self.global_best_position = self.positions[s][swarm_best_idx].copy()\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            for s in range(self.num_swarms):\n                # Calculate diversity\n                diversity = np.mean(np.std(self.positions[s], axis=0))\n                self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n                for i in range(self.num_particles_per_swarm):\n                    r1, r2 = np.random.rand(), np.random.rand()\n                    self.velocities[s][i] = (self.w * self.velocities[s][i] +\n                                             c1 * r1 * (self.best_individual_positions[s][i] - self.positions[s][i]) +\n                                             c2 * r2 * (self.global_best_position - self.positions[s][i]))\n                    self.positions[s][i] = np.clip(self.positions[s][i] + self.velocities[s][i], lb, ub)\n\n                    # Boundary reflection\n                    self.positions[s][i] = np.where(self.positions[s][i] < lb, lb + (lb - self.positions[s][i]), self.positions[s][i])\n                    self.positions[s][i] = np.where(self.positions[s][i] > ub, ub - (self.positions[s][i] - ub), self.positions[s][i])\n\n                    score = func(self.positions[s][i])\n                    self.function_evaluations += 1\n\n                    if score < self.best_individual_scores[s][i]:\n                        self.best_individual_scores[s][i] = score\n                        self.best_individual_positions[s][i] = self.positions[s][i].copy()\n\n                    if score < self.global_best_score:\n                        self.global_best_score = score\n                        self.global_best_position = self.positions[s][i].copy()\n\n                temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n                if temp > self.temp_final:\n                    for i in range(self.num_particles_per_swarm):\n                        candidate_position = self.positions[s][i] + np.random.normal(0, temp * (1 - t), self.dim)\n                        candidate_position = np.clip(candidate_position, lb, ub)\n                        candidate_score = func(candidate_position)\n                        self.function_evaluations += 1\n\n                        if candidate_score < self.best_individual_scores[s][i] or \\\n                           np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[s][i]) / temp):\n                            self.positions[s][i] = candidate_position\n                            self.best_individual_scores[s][i] = candidate_score\n                            self.best_individual_positions[s][i] = candidate_position\n\n                            if candidate_score < self.global_best_score:\n                                self.global_best_score = candidate_score\n                                self.global_best_position = candidate_position\n\n                # Adaptive Mutation Strategy\n                if np.random.rand() < self.mutation_rate:\n                    mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                    mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                    for i in range(self.num_particles_per_swarm):\n                        mutated_position = self.positions[s][i] + mutation_vector\n                        mutated_position = np.clip(mutated_position, lb, ub)\n                        mutated_score = func(mutated_position)\n                        self.function_evaluations += 1\n\n                        if mutated_score < self.best_individual_scores[s][i]:\n                            self.best_individual_scores[s][i] = mutated_score\n                            self.best_individual_positions[s][i] = mutated_position\n\n                            if mutated_score < self.global_best_score:\n                                self.global_best_score = mutated_score\n                                self.global_best_position = mutated_position\n\n                # Inter-swarm communication\n                if np.random.rand() < self.inter_swarm_rate[s]:\n                    for other_s in range(self.num_swarms):\n                        if other_s != s:\n                            external_best_idx = np.argmin(self.best_individual_scores[other_s])\n                            external_best_position = self.positions[other_s][external_best_idx].copy()\n                            self.velocities[s] = (self.velocities[s] + \n                                                  np.random.uniform(-0.5, 0.5, self.velocities[s].shape) *\n                                                  (external_best_position - self.positions[s]))\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 77, "feedback": "The algorithm EnhancedMultiSwarmPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009274708898995287, 0.009274708898995287, 0.009274708898995287, 0.07873563881131873, 0.07873563881131873, 0.07873563881131873, 0.07116351417669986, 0.07116351417669986, 0.07116351417669986]}}
{"id": "a306c991-f7e8-4620-8daf-da4f5daf2f54", "fitness": 0.08945553747837387, "name": "EnhancedHybridPSO_SA_Adaptive_Phased", "description": "Introduces a phased adaptive cooling schedule and perturbation technique to dynamically balance exploration and exploitation, enhancing convergence and robustness.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_Phased:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            if t < 0.5:\n                temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.1) ** (t * 2))\n            else:\n                temp = self.temp_initial * ((self.cooling_rate - np.random.rand() * 0.1) ** ((1 - t) * 2))\n\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            if np.random.rand() < self.mutation_rate:\n                mutation_magnitude = 0.1 * (1 - np.exp(-5 * t))\n                perturbation_vector = np.random.uniform(-mutation_magnitude, mutation_magnitude, self.dim)\n                for i in range(self.num_particles):\n                    perturbed_position = self.positions[i] + perturbation_vector\n                    perturbed_position = np.clip(perturbed_position, lb, ub)\n                    perturbed_score = func(perturbed_position)\n                    self.function_evaluations += 1\n\n                    if perturbed_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = perturbed_score\n                        self.best_individual_positions[i] = perturbed_position\n\n                        if perturbed_score < self.global_best_score:\n                            self.global_best_score = perturbed_score\n                            self.global_best_position = perturbed_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 78, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive_Phased got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009830688497621587, 0.009830688497621587, 0.009830688497621587, 0.13329316619659215, 0.13329316619659215, 0.13329316619659215, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
{"id": "0f70440e-a7dd-4561-9820-eb8d61755d77", "fitness": 0.08945554628232089, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduces a dynamic particle count adjustment to balance exploration-exploitation based on function evaluation ratio.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            # Dynamic adjustment of particle count based on evaluation ratio\n            self.num_particles = min(max(5, int((1-t) * self.num_particles)), 50)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 79, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009830695898250918, 0.009830695898250918, 0.009830695898250918, 0.13329318520780387, 0.13329318520780387, 0.13329318520780387, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
{"id": "42b1ff56-1d3a-437f-97c3-17b92cc90974", "fitness": 0.053057785565248906, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduce a small random offset to the inertia weight, `w`, for improved exploration-exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t) + 0.01 * np.random.rand()  # Introduce random offset\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 80, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009274684593638671, 0.009274684593638671, 0.009274684593638671, 0.0787353671604899, 0.0787353671604899, 0.0787353671604899, 0.07116330494161816, 0.07116330494161816, 0.07116330494161816]}}
{"id": "0082301a-54c8-4079-9654-a2276a507d82", "fitness": 0.05303816397532246, "name": "EnhancedHybridPSO_SA_SAM", "description": "Introduces a self-adaptive temperature control mechanism based on function evaluation progress and integrates a diversity-aware mutation strategy to enhance convergence consistency and robustness.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_SAM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 10\n        self.temp_final = 0.3\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.temp_final / self.temp_initial) ** (t))\n            for i in range(self.num_particles):\n                candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                candidate_position = np.clip(candidate_position, lb, ub)\n                candidate_score = func(candidate_position)\n                self.function_evaluations += 1\n\n                if candidate_score < self.best_individual_scores[i] or \\\n                   np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                    self.positions[i] = candidate_position\n                    self.best_individual_scores[i] = candidate_score\n                    self.best_individual_positions[i] = candidate_position\n\n                    if candidate_score < self.global_best_score:\n                        self.global_best_score = candidate_score\n                        self.global_best_position = candidate_position\n\n            # Diversity-aware mutation strategy\n            mutation_factor = 0.1\n            if np.random.rand() < self.mutation_rate:\n                mutation_vector = np.random.uniform(-mutation_factor, mutation_factor, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 81, "feedback": "The algorithm EnhancedHybridPSO_SA_SAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03110.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009271412573850002, 0.009271412573850002, 0.009271412573850002, 0.07870200870998156, 0.07870200870998156, 0.07870200870998156, 0.07114107064213582, 0.07114107064213582, 0.07114107064213582]}}
{"id": "6ef020e2-e47a-4fa9-a2eb-88a86043bce6", "fitness": 0.05304894326238326, "name": "AdvancedMultiScalePSO_SA", "description": "Integrates a novel multi-scale search strategy that dynamically adjusts exploration and exploitation by modifying the inertia weight and mutation rate based on both global and local performance metrics to enhance convergence.", "code": "import numpy as np\n\nclass AdvancedMultiScalePSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.2\n        self.w_max = 0.9\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.temp_initial = 25\n        self.temp_final = 0.01\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial - t * (self.c1_initial - 0.5)\n            c2 = self.c2_initial + t * (2.5 - self.c2_initial)\n            self.w = self.w_max - (self.w_max - self.w_min) * (t**2)\n\n            # Calculate performance-based diversity\n            local_diversity = np.std(self.best_individual_scores)\n            global_effect = np.std(self.positions, axis=0).mean()\n            self.mutation_rate = self.base_mutation_rate + (0.1 * global_effect) + (0.1 * local_diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * np.exp(-t * 5)\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Enhanced Adaptive Mutation\n            if np.random.rand() < self.mutation_rate:\n                mutation_strength = 0.1 * (1 - np.exp(-5 * t))\n                for i in range(self.num_particles):\n                    mutation_vector = np.random.uniform(-mutation_strength, mutation_strength, self.dim)\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 82, "feedback": "The algorithm AdvancedMultiScalePSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009273294659321918, 0.009273294659321918, 0.009273294659321918, 0.07872121359017425, 0.07872121359017425, 0.07872121359017425, 0.0711523215376536, 0.0711523215376536, 0.0711523215376536]}}
{"id": "74df7984-729f-4231-8d87-53a477d78a86", "fitness": 0.05468917812298213, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduces adaptive local search with Lvy flights to enhance global exploration and prevent premature convergence, maintaining diverse solutions.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy with Lvy flight\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                # Lvy flight\n                levy_flight = np.random.standard_cauchy(self.dim) * mutation_percentage\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + levy_flight\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 83, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05469 with standard deviation 0.03211.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009521509576147724, 0.009521509576147724, 0.009521509576147724, 0.08136161553060262, 0.08136161553060262, 0.08136161553060262, 0.07318440926219605, 0.07318440926219605, 0.07318440926219605]}}
{"id": "ae188305-eeda-4eda-997c-80e70958e045", "fitness": -Infinity, "name": "EnhancedHybridPSO_SA_Elite", "description": "Introduces a phased adaptive strategy that transitions from exploration to exploitation by dynamically adjusting inertia weight and interaction coefficients; incorporates elite selection to retain top solutions and prevent premature convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Elite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n        self.elite_fraction = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n            # Elite selection process to maintain promising solutions\n            elite_threshold = int(self.elite_fraction * self.num_particles)\n            elite_indices = np.argsort(self.best_individual_scores)[:elite_threshold]\n            non_elite_indices = np.setdiff1d(np.arange(self.num_particles), elite_indices)\n            for i in non_elite_indices:\n                self.positions[i] = self.positions[np.random.choice(elite_indices)].copy()\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 84, "feedback": "An exception occurred: ValueError(\"'a' cannot be empty unless no samples are taken\").", "error": "ValueError(\"'a' cannot be empty unless no samples are taken\")", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {}}
{"id": "69fa1e63-5a3c-4577-a34d-dd97b6b828a7", "fitness": 0.05468917812298213, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Introduces a hierarchical temperature-adaptive cooling schedule combined with a neighborhood exploration strategy to improve convergence speed and robustness in dynamic environments.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Hierarchical temperature-adaptive cooling\n            hierarchy = int(np.random.choice(3, 1))\n            if hierarchy == 0:\n                temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.1) ** (t))\n            elif hierarchy == 1:\n                temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            else:\n                temp = self.temp_initial * ((self.cooling_rate) ** (t))\n            \n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy with Neighborhood exploration\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                for i in range(self.num_particles):\n                    neighborhood_indices = np.random.choice(self.num_particles, 3, replace=False)\n                    neighbor_position = np.mean(self.positions[neighborhood_indices], axis=0)\n                    mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                    mutated_position = neighbor_position + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 85, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05469 with standard deviation 0.03211.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009521509576147724, 0.009521509576147724, 0.009521509576147724, 0.08136161553060262, 0.08136161553060262, 0.08136161553060262, 0.07318440926219605, 0.07318440926219605, 0.07318440926219605]}}
{"id": "7586566a-e5b8-4685-988e-a77799c2c70c", "fitness": 0.05305507777111843, "name": "EnhancedHybridPSO_SA_Adaptive_Refined", "description": "Introduces a multi-phase adaptive learning rate and an enhanced diversity-influenced mutation strategy to improve convergence and exploration.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.2  # Reduced inertia minimum to enhance exploitation\n        self.w_max = 0.8  # Reduced inertia maximum to control exploration\n        self.c1_initial = 2.0  # Adjusted cognitive component\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 15  # Reduced initial temperature for a quicker convergence\n        self.temp_final = 0.1\n        self.cooling_rate = 0.9  # Adjusted cooling rate for a smoother transition\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.08  # Increased base mutation rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            phase_factor = 0.5 + 0.5 * np.sin(np.pi * t)  # New adaptive phase factor\n            c1 = self.c1_final + phase_factor * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + (1 - phase_factor) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * phase_factor)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.15 * diversity)  # Increased diversity impact\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] += self.velocities[i]\n                mask_lb = self.positions[i] < lb\n                mask_ub = self.positions[i] > ub\n                self.positions[i][mask_lb] = lb[mask_lb] + (lb[mask_lb] - self.positions[i][mask_lb])\n                self.positions[i][mask_ub] = ub[mask_ub] - (self.positions[i][mask_ub] - ub[mask_ub])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy with diversity influence\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-3 * diversity))  # More influenced by diversity\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 86, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009274255398978082, 0.009274255398978082, 0.009274255398978082, 0.07873103529235836, 0.07873103529235836, 0.07873103529235836, 0.07115994262201886, 0.07115994262201886, 0.07115994262201886]}}
{"id": "525718aa-42d1-441b-bc0f-2ffc51da64d0", "fitness": 0.08945554628232089, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Improves boundary reflection to switch between reflection and wrapping based on diversity, enhancing exploration in constrained spaces.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Improved boundary handling based on diversity\n                if diversity > 0.1:  # Switch to wrapping if diversity is high\n                    self.positions[i] = np.where(self.positions[i] < lb, ub - (lb - self.positions[i]), self.positions[i])\n                    self.positions[i] = np.where(self.positions[i] > ub, lb + (self.positions[i] - ub), self.positions[i])\n                else:  # Default to reflection otherwise\n                    self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                    self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 87, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009830695898250918, 0.009830695898250918, 0.009830695898250918, 0.13329318520780387, 0.13329318520780387, 0.13329318520780387, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
{"id": "9f837d9d-0df4-4714-8f5b-cb341cd5ebb3", "fitness": 0.08945554940613694, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Refines EnhancedHybridPSO_SA_Adaptive by adjusting the mutation percentage calculation to enhance exploration and convergence.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-10 * t))  # Changed from 5 to 10\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 88, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["89a5f6a0-63ce-4685-9872-0173f454487a"], "operator": null, "metadata": {"aucs": [0.009830705269699092, 0.009830705269699092, 0.009830705269699092, 0.13329318520780387, 0.13329318520780387, 0.13329318520780387, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
{"id": "9072ed1c-9887-4e3a-9972-e31670f82958", "fitness": 0.053041835204638975, "name": "EnhancedExplorationPSO_SA", "description": "Improved exploration via adaptive boundary reflection and dynamic inertia weight adjustment to enhance convergence.", "code": "import numpy as np\n\nclass EnhancedExplorationPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.4  # Increased for more exploration\n        self.w_max = 0.95  # Increased for more exploration\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Adaptive Boundary Reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + 0.1 * (ub - lb) * np.random.rand(self.dim), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - 0.1 * (ub - lb) * np.random.rand(self.dim), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-10 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 89, "feedback": "The algorithm EnhancedExplorationPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03110.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009272177356562161, 0.009272177356562161, 0.009272177356562161, 0.0787098322705101, 0.0787098322705101, 0.0787098322705101, 0.07114349598684466, 0.07114349598684466, 0.07114349598684466]}}
{"id": "77dccf80-648e-4d46-9373-4119202f9434", "fitness": 0.05468917812298213, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Enhanced convergence by modifying mutation rate based on diversity dynamics.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.15 * diversity)  # Changed 0.1 to 0.15\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-10 * t))  # Changed from 5 to 10\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 90, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05469 with standard deviation 0.03211.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009521509576147724, 0.009521509576147724, 0.009521509576147724, 0.08136161553060262, 0.08136161553060262, 0.08136161553060262, 0.07318440926219605, 0.07318440926219605, 0.07318440926219605]}}
{"id": "8e11d0dd-7201-482b-b702-5d0633c5d07a", "fitness": 0.05304522284386012, "name": "EnhancedHybridPSO_SA_Adaptive_Improved", "description": "Introduce dynamic swarm size adaptation and nonlinear inertia weight decay to enhance exploration and exploitation balance.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.initial_num_particles = self.num_particles\n        self.swarm_growth_rate = 1.05\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t * t)  # Nonlinear inertia weight decay\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            # Adaptively increase swarm size\n            if self.function_evaluations < self.budget / 2:\n                self.num_particles = min(int(self.initial_num_particles * (self.swarm_growth_rate ** t)), 100)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-10 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 91, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05305 with standard deviation 0.03111.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009272709375079846, 0.009272709375079846, 0.009272709375079846, 0.07871525699335791, 0.07871525699335791, 0.07871525699335791, 0.07114770216314259, 0.07114770216314259, 0.07114770216314259]}}
{"id": "129f9e89-53b8-4854-af94-c36b8c0d50a2", "fitness": 0.08945554940613694, "name": "EnhancedHybridPSO_SA_DynamicMutation", "description": "Integrates a dynamic mutation scaling based on convergence speed to adaptively balance exploration and exploitation in the EnhancedHybridPSO_SA_Adaptive algorithm.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_DynamicMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        previous_global_best_score = self.global_best_score\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Calculate convergence speed\n            convergence_speed = previous_global_best_score - self.global_best_score\n            previous_global_best_score = self.global_best_score\n\n            # Dynamic mutation scaling based on convergence speed\n            mutation_scale = np.exp(-convergence_speed * 10)\n            mutation_percentage = 0.1 * (1 - np.exp(-10 * t)) * mutation_scale\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 92, "feedback": "The algorithm EnhancedHybridPSO_SA_DynamicMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009830705269699092, 0.009830705269699092, 0.009830705269699092, 0.13329318520780387, 0.13329318520780387, 0.13329318520780387, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
{"id": "49736797-974b-4fa5-be03-e97b0501f676", "fitness": -Infinity, "name": "EnhancedHybridPSO_SA_Adaptive_Levy", "description": "Introduce adaptive inertia weight adjustment and incorporate Lvy flight for enhanced exploration and convergence control.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_Levy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def levy_flight(self, size):\n        beta = 1.5\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_min + (self.w_max - self.w_min) * (1 - t)  # Adaptive inertia weight\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** t)\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + self.levy_flight(self.dim) * temp * (1 - t)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-10 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 93, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {}}
{"id": "d0dd44be-a711-43ec-beff-59cc17ad617e", "fitness": 0.08945554628232089, "name": "EnhancedHybridPSO_SA_Cooperative", "description": "Introduces dynamic cooperative learning strategy and adaptive mutation for enhanced exploration and exploitation in black box optimization.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Cooperative:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-10 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    cooperative_vector = np.mean(self.positions, axis=0) - self.positions[i]\n                    mutated_position = self.positions[i] + mutation_vector + cooperative_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 94, "feedback": "The algorithm EnhancedHybridPSO_SA_Cooperative got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009830695898250918, 0.009830695898250918, 0.009830695898250918, 0.13329318520780387, 0.13329318520780387, 0.13329318520780387, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
{"id": "f05e31bf-2f25-442d-8143-e09aa5eb5d70", "fitness": 0.05304292841552979, "name": "EnhancedHybridPSO_SA_AdaptiveV2", "description": "Introduces a dynamic inertia weight and temperature adaptation mechanism to balance exploration and exploitation more effectively.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_AdaptiveV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.2\n        self.w_max = 1.0\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 15\n        self.temp_final = 0.01\n        self.cooling_rate = 0.88\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.03\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * (1 - np.exp(-5 * t)))\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.15 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.05 * (1 - np.exp(-10 * t))  # Adjusted mutation percentage strategy\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 95, "feedback": "The algorithm EnhancedHybridPSO_SA_AdaptiveV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03110.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009272349140949099, 0.009272349140949099, 0.009272349140949099, 0.07871158393499156, 0.07871158393499156, 0.07871158393499156, 0.0711448521706487, 0.0711448521706487, 0.0711448521706487]}}
{"id": "31710b39-4640-4859-a793-8d8b50ee839f", "fitness": 0.053055009855622025, "name": "EnhancedHybridPSO_SA_Adaptive_Improved", "description": "Enhances the convergence of EnhancedHybridPSO_SA_Adaptive by utilizing a dynamic inertia weight strategy and integrating an adaptive mutation scaling factor based on convergence history.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        previous_global_best_score = self.global_best_score\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * np.exp(-5 * t))\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            # Dynamic mutation scaling factor based on convergence\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                improvement = 1 if previous_global_best_score - self.global_best_score > 0 else 0\n                mutation_scaling = 0.1 * (1 - np.exp(-10 * t)) * (0.5 + improvement * 0.5)\n                mutation_vector = np.random.uniform(-mutation_scaling, mutation_scaling, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n            previous_global_best_score = self.global_best_score\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 96, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05306 with standard deviation 0.03111.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009274244644522422, 0.009274244644522422, 0.009274244644522422, 0.07873092647008018, 0.07873092647008018, 0.07873092647008018, 0.07115985845226347, 0.07115985845226347, 0.07115985845226347]}}
{"id": "cdf490af-4ba2-4600-90fe-fadee6a1b0f8", "fitness": 0.05303614793366451, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Integrates enhanced adaptive parameters and dynamic learning rates to improve convergence speed and robustness.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.2\n        self.w_max = 0.7\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 2.5\n        self.c2_final = 2.5\n        self.temp_initial = 15\n        self.temp_final = 0.1\n        self.cooling_rate = 0.9\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.02\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_initial + (self.c1_final - self.c1_initial) * (1 - t)\n            c2 = self.c2_initial + (self.c2_final - self.c2_initial) * t\n            self.w = self.w_max - ((self.w_max - self.w_min) * np.sqrt(t))\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * (self.cooling_rate ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.15 * (1 - np.exp(-5 * t))\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 97, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.05304 with standard deviation 0.03110.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.00927128363257268, 0.00927128363257268, 0.00927128363257268, 0.07870073135784439, 0.07870073135784439, 0.07870073135784439, 0.07113642881057647, 0.07113642881057647, 0.07113642881057647]}}
{"id": "11283ebd-2f65-4dd6-b25a-353a572b3bf1", "fitness": 0.08945554789112398, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Enhances the mutation strategy by introducing a diversity-based mutation scaling and adaptive cooling schedule for simulated annealing to improve exploration dynamics.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.08) ** (1.5 * t))  # Modified\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.2 * (1 - np.exp(-8 * diversity * t))  # Modified\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 98, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009830719735871907, 0.009830719735871907, 0.009830719735871907, 0.13329316619659215, 0.13329316619659215, 0.13329316619659215, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
{"id": "1b847e35-a622-42ea-8b7a-6b97e75e7bf1", "fitness": 0.08945554914581826, "name": "EnhancedHybridPSO_SA_Adaptive", "description": "Slightly refine the mutation strategy by modifying the mutation percentage formula for enhanced exploration.", "code": "import numpy as np\n\nclass EnhancedHybridPSO_SA_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = min(max(5, dim // 2), 50)\n        self.w_min = 0.3\n        self.w_max = 0.9\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 0.5\n        self.c2_final = 2.5\n        self.temp_initial = 20\n        self.temp_final = 0.1\n        self.cooling_rate = 0.85\n        self.positions = None\n        self.velocities = None\n        self.best_individual_positions = None\n        self.best_individual_scores = None\n        self.global_best_position = None\n        self.global_best_score = float('inf')\n        self.function_evaluations = 0\n        self.base_mutation_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        bounds = func.bounds\n        lb, ub = bounds.lb, bounds.ub\n\n        self.positions = np.random.uniform(lb, ub, (self.num_particles, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        self.best_individual_positions = self.positions.copy()\n        self.best_individual_scores = np.array([func(position) for position in self.positions])\n        self.function_evaluations += self.num_particles\n\n        self.global_best_position = self.best_individual_positions[np.argmin(self.best_individual_scores)]\n        self.global_best_score = np.min(self.best_individual_scores)\n\n        while self.function_evaluations < self.budget:\n            t = self.function_evaluations / self.budget\n            c1 = self.c1_final + 0.5 * np.sin(2 * np.pi * t) * (self.c1_initial - self.c1_final)\n            c2 = self.c2_final + 0.5 * np.cos(2 * np.pi * t) * (self.c2_initial - self.c2_final)\n            self.w = self.w_max - ((self.w_max - self.w_min) * t)\n\n            # Calculate diversity\n            diversity = np.mean(np.std(self.positions, axis=0))\n            self.mutation_rate = self.base_mutation_rate + (0.1 * diversity)\n\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                self.velocities[i] = (self.w * self.velocities[i] +\n                                      c1 * r1 * (self.best_individual_positions[i] - self.positions[i]) +\n                                      c2 * r2 * (self.global_best_position - self.positions[i]))\n                self.positions[i] = np.clip(self.positions[i] + self.velocities[i], lb, ub)\n\n                # Boundary reflection\n                self.positions[i] = np.where(self.positions[i] < lb, lb + (lb - self.positions[i]), self.positions[i])\n                self.positions[i] = np.where(self.positions[i] > ub, ub - (self.positions[i] - ub), self.positions[i])\n\n                score = func(self.positions[i])\n                self.function_evaluations += 1\n\n                if score < self.best_individual_scores[i]:\n                    self.best_individual_scores[i] = score\n                    self.best_individual_positions[i] = self.positions[i].copy()\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.positions[i].copy()\n\n            temp = self.temp_initial * ((self.cooling_rate + np.random.rand() * 0.05) ** (t))\n            if temp > self.temp_final:\n                for i in range(self.num_particles):\n                    candidate_position = self.positions[i] + np.random.normal(0, temp * (1 - t), self.dim)\n                    candidate_position = np.clip(candidate_position, lb, ub)\n                    candidate_score = func(candidate_position)\n                    self.function_evaluations += 1\n\n                    if candidate_score < self.best_individual_scores[i] or \\\n                       np.random.rand() < np.exp(-(candidate_score - self.best_individual_scores[i]) / temp):\n                        self.positions[i] = candidate_position\n                        self.best_individual_scores[i] = candidate_score\n                        self.best_individual_positions[i] = candidate_position\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_position\n\n            # Adaptive Mutation Strategy\n            if np.random.rand() < self.mutation_rate:\n                mutation_percentage = 0.1 * (1 - np.exp(-8 * t))  # Changed from 10 to 8\n                mutation_vector = np.random.uniform(-mutation_percentage, mutation_percentage, self.dim)\n                for i in range(self.num_particles):\n                    mutated_position = self.positions[i] + mutation_vector\n                    mutated_position = np.clip(mutated_position, lb, ub)\n                    mutated_score = func(mutated_position)\n                    self.function_evaluations += 1\n\n                    if mutated_score < self.best_individual_scores[i]:\n                        self.best_individual_scores[i] = mutated_score\n                        self.best_individual_positions[i] = mutated_position\n\n                        if mutated_score < self.global_best_score:\n                            self.global_best_score = mutated_score\n                            self.global_best_position = mutated_position\n\n        return self.global_best_position, self.global_best_score", "configspace": "", "generation": 99, "feedback": "The algorithm EnhancedHybridPSO_SA_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08946 with standard deviation 0.05640.", "error": "", "parent_ids": ["9f837d9d-0df4-4714-8f5b-cb341cd5ebb3"], "operator": null, "metadata": {"aucs": [0.009830704488743014, 0.009830704488743014, 0.009830704488743014, 0.13329318520780387, 0.13329318520780387, 0.13329318520780387, 0.12524275774090787, 0.12524275774090787, 0.12524275774090787]}}
